{"meta":{"title":"南阳向北","subtitle":"业精于勤荒于嬉，行成于思毁于随","description":"","author":"MQRoad","url":"https://hbroad.github.io","root":"/"},"pages":[{"title":"","date":"2023-04-07T11:42:45.586Z","updated":"2023-04-07T11:42:45.586Z","comments":true,"path":"thx/index.html","permalink":"https://hbroad.github.io/thx/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-07T02:23:10.435Z","updated":"2023-04-07T02:23:10.435Z","comments":true,"path":"categories/index.html","permalink":"https://hbroad.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-04-07T08:46:05.000Z","updated":"2023-04-07T08:47:06.406Z","comments":false,"path":"about/index.html","permalink":"https://hbroad.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-07T02:22:42.000Z","updated":"2023-04-07T02:49:31.441Z","comments":true,"path":"link/index.html","permalink":"https://hbroad.github.io/link/index.html","excerpt":"","text":""},{"title":"essay","date":"2023-04-07T14:06:41.000Z","updated":"2023-04-07T14:07:37.495Z","comments":true,"path":"essay/index.html","permalink":"https://hbroad.github.io/essay/index.html","excerpt":"","text":""},{"title":"大佬们","date":"2020-04-20T08:38:53.572Z","updated":"2020-04-04T11:21:13.453Z","comments":true,"path":"friends/index.html","permalink":"https://hbroad.github.io/friends/index.html","excerpt":"虽然我很菜，但好在这里有大佬","text":"虽然我很菜，但好在这里有大佬 友链规范1234567name: # 博客名avatar: # 头像链接url: # 博客链接backgroundColor: &#x27;#3E74C9&#x27; # 卡片背景颜色textColor: &#x27;#fff&#x27; # 卡片文字颜色tags: [标签1, 标签2] # 标签desc: 描述文字"},{"title":"所有标签","date":"2023-04-07T13:39:16.202Z","updated":"2023-04-07T13:39:16.202Z","comments":true,"path":"tags/index.html","permalink":"https://hbroad.github.io/tags/index.html","excerpt":"","text":""},{"title":"建站小记","date":"2023-04-09T12:25:01.000Z","updated":"2023-04-17T12:11:03.890Z","comments":true,"path":"timeline/index.html","permalink":"https://hbroad.github.io/timeline/index.html","excerpt":"","text":"2023 04-06 神奇之旅继续，更换主题为AnZhiYu，开启新纪元 2022 08-02 神奇之旅继续，部署到 Gitee，便于国内访问 2020 04-04 神奇之旅开启，Hexo + Github Pages，使用了Volantis主题 2019 01-13 Deployed"}],"posts":[{"title":"ChatGPT 类产品","slug":"AI资讯/chatgpt类产品","date":"2023-04-28T01:53:21.000Z","updated":"2023-05-05T13:36:47.324Z","comments":true,"path":"chatgptlike/","link":"","permalink":"https://hbroad.github.io/chatgptlike/","excerpt":"","text":"OpenAI 的 ChatGPT 问世以来让低迷的 AI 一下进入了寻常百姓家，但正如老马所说，OpenAI 不再 Open，逐渐走上了闭源盈利，目前，诸多类 ChatGPT 产品层出不穷，此处对可用产品做一分享。 商用模型 POE POE由海外知乎Quora开发，其集成了市面上诸多的 AI 对话机器人(最新的 ChatGPT4 依旧需要付费订阅)，但值得一提的是，该平台的生成速度惊人，一般的使用已经足够。 forefront forefront集成了 GPT3.5 和 GPT4，目前可免费使用，但后者使用人数较多时会有限制，该平台的亮点是内置了众多的“角色”，如爱因斯坦、乔布斯以及诸多动漫角色，你可以选择和他们进行对话；当然也有一个通用的角色 Help Assistant。此外，用户也可自行创建角色。也可以通过 #imagine prompts 的形式生成图片，但效果一般 开源模型 GPT4free GPT4free是一个逆向工程项目，对市面上现有的诸多产品进行了逆向，该项目在Github上的星标已达 13.1k，作者也开发了一个在线体验的端口，无需登录，可切换 GPT3.5 和 GPT4。 HuggingChat HuggingChat由Hugging Face基于 OpenAssistant 开发，目前完全开源且免费，与 ChatGPT 形成了对抗。 国产大模型 文心一言 国产大模型，但文生图的效果不是很好，希望国产迎头赶上 通义千问 暂未拿到内测资格 讯飞星火 暂未拿到内测资格 2023年5月5日拿到内测资格 星火大模型支持 语音输入，生成的文字也可朗读（有多个发音人可选），更多功能正在探索…… 天工AI 暂未拿到内测资格 2023年5月4日拿到测试，更多功能正在探索……","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"资讯","slug":"资讯","permalink":"https://hbroad.github.io/tags/%E8%B5%84%E8%AE%AF/"}]},{"title":"Python 从入门到放弃","slug":"Python/Python-从入门到放弃","date":"2023-04-19T13:07:56.000Z","updated":"2023-04-28T14:20:10.474Z","comments":true,"path":"Python_start2end/","link":"","permalink":"https://hbroad.github.io/Python_start2end/","excerpt":"","text":"课程：北理嵩天《Python语言程序设计》 turtle 库1234567891011121314151617import turtleturtle.setup(100, 200) # 设置屏幕显示坐标turtle.goto(100,100) #在窗体中坐标行走turtle.fd()turtle.bk()turtle.circle()# 角度坐标系turtle.seth(45) # 设置朝向为 45°，此时为绝对角度turtle.left(45) # 设置朝向为 45°，此时为海龟自身角度turtle.right()# RGB # 默认使用0~1表示颜色，可切换为 0~255turtle.mode(1.0) #255 1234567891011121314151617181920212223242526import turtle# from turtle import* # 此时可直接省略库名，直接使用函数名，容易导致函数与用户自定义函数重名# import turtle as t # 为防止函数重名，起个别名# 各参数单位均为像素turtle.setup(650,650,200,200)turtle.penup() # 画笔升起，即不绘制图案 = turtle.pu()turtle.fd(-250)turtle.pendown() # 画笔落下，即绘制图案 = turtle.pd()turtle.pensize(25) # 画笔宽度，= turtle.width()# 画笔颜色# 支持三种参数形式：# 颜色字符串 &quot;blue&quot;# RGB 小数值 0.1,0.2,0.3# RGB 元组值 (0.1,0.2,0.3)turtle.pencolor(&quot;blue&quot;)turtle.seth(-45)for i in range(4): # range 函数可接受1或2个参数，range(2,5) 即 2,3,4，不包括最后一个 turtle.circle(40, 80) # 绘制半径为 r, extent 角度的圆弧，默认圆心在海龟左侧 turtle.circle(-40, 80)turtle.circle(40, 80/2)turtle.fd(40)turtle.circle(16,180)turtle.fd(40 * 2/3)turtle.done() # 运行后程序不会自动结束，需手动退出 Python 数据类型基本类型 整型 浮点数 浮点数存在不确定尾数，正常，如 0.1 + 0.2 = 0.3， 但计算机中可能为 0.3000000000000004 这是由计算机数学计算实现决定的 可通过 round 函数辅助，round(x[,d])：对 x 四舍五入，d 是小数截取位数(可省略) Python 复数类型（独有） .img和.real 获取实部和虚部 数值计算 x / y 结果是浮点型，如 10/3 = 3.333333333333333 x // y 则是整数除，即 10 // 3 = 3 x ** y，幂运算，即x^y，但当 y 为小数时，则为开方运算，如 10 ** 0.5，表示根号10 数值运算函数：divmod(x,y) 输出商和余数，如 divmod(10,3) -&gt; (3,1) 1234567891011121314# 天天向上的力量def dayUp(du): day = 1.0 for i in range(365): if i % 7 in [6,0]: day *= 1 - 0.01 else: day *= 1 + du return daydayfactor = 0.001while dayUp(dayfactor) &lt; 37.68: dayfactor += 0.001print(&quot;dayup: &#123;:.05f&#125;&quot;.format(dayfactor)) 字符串类型及操作字符串表示 单行字符串：一对单引号或双引号 1&quot;请输入&quot; &#x27;C&#x27; 多行字符串：一对三单引号或三双引号(未赋值给任何变量时作为注释使用) 1234&#x27;&#x27;&#x27;Python Hello &#x27;&#x27;&#x27; 输出中显示单引号或双引号 12&quot;输出单引号(&#x27;)&quot;&#x27;输出双引号(&quot;)&#x27; 既输出单引号又输出双引号 1&#x27;&#x27;&#x27;输出单引号(&#x27;)和双引号(&quot;)&#x27;&#x27;&#x27; 字符串序号 正向递增序号 和 反向递减序号 字符串操作 索引：使用[]获取字符串中的一个或多个字符，返回字串中的单个字符，&lt;字串&gt;[M] 12&quot;输入字串：&quot;[0]str[-1] 切片：返回字串中的一段字符子串，str[0:-1] 12&quot;输入字串：&quot;[1:3]str[0:-1] 切片高级用法 &lt;str&gt;[M:N]，M 缺省表示至开头，N 缺省表示至结尾 “零一二三四五六七八九十” [:3]，结果为 “零一二” &lt;str&gt;[M: N: K]，根据步长对字符串切片 “零一二三四五六七八九十” [1: 8: 2]，结果为 “一三五七” 字符串逆序：[::-1]，M、N 缺省，表示从头至尾，步长 -1 表示从尾部逐一读取 1234Weeknum = eval(input(&quot;input the nummber(1-7):&quot;))Weekstr = &quot;星期一星期二星期三星期四星期五星期六星期日&quot;pos = (str - 1) * 3print(&quot;Today is:&quot;, Weekstr[pos: pos+3]) # 切片操作 eval 函数可将字符串两侧的引号去掉，使其变成可执行的语句 转义符：\\，表达特定字符的本意 “这里是个引号(\\“)” 结果为 “这里是个引号(“)” 常见：”\\n” “\\r” 操作符 x + y：字符串连接 n * x 或 x * n：将字串 x 复制 n 次 x in s：若 x 是 s 的子串，返回 True，否则为 False 123WeekNum = eval(input(&quot;input the num(1-7):&quot;))WeekStr = &quot;一二三四五六日&quot;print(&quot;星期&quot; + WeekStr[WeekNum - 1]) # 字符串的连接 字符串处理函数 len(x)：返回字串 x 的长度 1len(&quot;一二三456&quot;) # 6 str(x)：任意类型 x 转为字串形式（和 eval 相反） 12str(1.23) # &quot;1.23&quot;str([1,2]) # &quot;[1,2]&quot; hex(x)/oct(x)：整数 x 的十六进制 或 八进制小写形式字串 12hex(425) # &quot;0x1a9&quot;oct(425) # &quot;0o651&quot; 字符编码 chr(u)：u 为 Unicode 编码，返回其对应的字符 ord(x)：x 为 字符，返回其对应的 Unicode 编码 Python 使用 Unicode 编码 字符串处理方法 str.lower() / str.upper()：全部小写 或 全部大写 12str = &quot;A,B,C&quot;print(str.lower()) # a,b,c str.split(sep = None)：根据 sep 分割字串 12str = &quot;A,B,C&quot;print(str.split(&quot;,&quot;)) # [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] str.count(sub)：返回字串 sub 在 str 中出现的次数 12str = &quot;abcdefaads&quot;print(str.count(&quot;a&quot;)) # 3 str.replace(old, new)：old 字串被替换为 new 12str = &quot;abcdefaads&quot;print(str.replace(&quot;a&quot;, &quot;m&quot;)) # mbcdefmmds str.center(width[,fillchar])：str 根据 width 居中，多余部分用 fillchar 填充 12str = &quot;abcdefaads&quot;print(str.center(20, &quot;-&quot;)) # -----abcdefaads----- str.strip(chars)：从 str 中去掉 chars 中列出的在其左右侧的字符 12str = &quot; -----abcdefaads----- &quot;print(str.strip(&quot; -as&quot;)) # bcdefaad str.join(iter)：在 iter 变量每个元素后增加一个 str，最后一个元素除外 123str = &quot;abcdefaads&quot;str_seg = &quot;,&quot;print(str_seg.join(str)) # a,b,c,d,e,f,a,a,d,s 字符串格式化 &lt;模板字串&gt;.format(&lt;逗号分割的参数&gt;) 槽机制 字符串中的槽 {} 的默认顺序是 0 ，1，2，这与 format 函数中参数的顺序一致（0,1,2），但也可以直接指定槽中的顺序 12345678print(&quot;&#123;&#125;:当前&#123;&#125;占用内存为&#123;&#125;%&quot;.format(&quot;2023-04-20&quot;, &quot;Python&quot;, &quot;5&quot;))# 相当于print(&quot;&#123;0&#125;:当前&#123;1&#125;占用内存为&#123;2&#125;%&quot;.format(&quot;2023-04-20&quot;, &quot;Python&quot;, &quot;5&quot;)) ## 2023-04-20:当前Python占用内存为5%# 指定槽中数据print(&quot;&#123;1&#125;:当前&#123;0&#125;占用内存为&#123;2&#125;%&quot;.format(&quot;2023-04-20&quot;, &quot;Python&quot;, &quot;5&quot;))## Python:当前2023-04-20占用内存为5% format() 格式控制：{&lt;参数序号&gt;} : &lt;格式控制标记符&gt; 1234567891011# 填充、对齐、宽度# 输出长度为 20，居中对齐，空余部分使用 * 填充print(&quot;&#123;0:*^20&#125;&quot;.format(&quot;str&quot;)) # ********str*********print(&quot;&#123;0:*&lt;20&#125;&quot;.format(&quot;str&quot;)) # str*****************print(&quot;&#123;0:*&gt;20&#125;&quot;.format(&quot;str&quot;)) # *****************strprint(&quot;&#123;:10&#125;&quot;.format(&quot;str&quot;)) # 默认以空格填充 # 分位符、精度、类型print(&quot;&#123;0:,.2f&#125;&quot;.format(12356.7852)) # 12,356.79print(&quot;&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;&quot;.format(456)) # 110101001,Ʃ,425,651,1a9,1A9（二进制、字符、十进制、八进制、十六进制小写、十六进制大写）print(&quot;&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;&quot;.format(3.14)) # 3.140000e+00,3.140000E+00,3.140000,314.000000% （科学计数大小写、浮点、百分数） time 库Python 中处理时间的标准库 计算机时间的表达 获取系统时间并格式化输出 系统级精确计时功能，用于分析程序性能 123# time 库的使用import timetime.&lt;b&gt;() 时间获取 time()：获取当前时间戳，即计算机内部时间值，浮点数 1print(time.time()) # 1681981125.892314 (表示从 1970.01.01,00:00 开始至当下的时间，以 s 为单位) ctime()：获取当前时间并以可读形式表示，返回字串 1print(time.ctime()) # Thu Apr 20 16:58:45 2023 gmtime()：获取当前时间，表示为计算机可处理的时间格式 1print(time.gmtime()) # time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=9, tm_min=0, tm_sec=50, tm_wday=3, tm_yday=110, tm_isdst=0) 时间格式化 将时间以合理的方式展示 strftime(tpl, ts)：tpl 是格式化模板字串，定义输出效果；ts 是计算机内部时间类型变量（由时间获取得到） 12t = time.gmtime()time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, t) # 2023-04-20 09:07:34 ​ 具体格式化字串见Python strftime cheatsheet 将给定字串输出为指定格式的时间 strptime(str, tpl)：str 是字串形式的时间；tpl 是格式化模板字串 12timestr = &quot;2023-04-20 09:07:34&quot;print(time.strptime(timestr, &quot;%Y-%m-%d %H:%M:%S&quot;)) # time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=9, tm_min=7, tm_sec=34, tm_wday=3, tm_yday=110, tm_isdst=-1) 程序计时 测量时间 perf_counter()：返回一个 CPU 级别的精确时间计算值，单位为 s，需连续调用计算差值才有意义 1234start = time.perf_counter()Fun_execu…end = time.perf_counter()print(&quot;Loss time&quot;, end - start) 产生时间 sleep(s)：s 是拟休眠时间，单位为 s，可为浮点数 123def wait(): time.sleep(3.3)wait() # 程序等待 3.3s 后退出 文本进度条案例123456789101112import timescale = 50 # 总宽度print(&quot;执行开始&quot;.center(scale//2, &quot;-&quot;)) # 居中显示，空余以 - 填充start = time.perf_counter() # 开始计时for i in range(scale + 1): # 0~scale 循环 a = &quot;*&quot; * i # 输出 i 个 * b = &quot;.&quot; * (scale - i) # 输出 (scale - i) 个 . (总共 sclae, i个*，则剩余的.为(scale-i)) c = (i/scale) * 100 # 计算百分比 dur = time.perf_counter() - start # 计算耗时 print(&quot;\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c, a, b, dur), end = &quot;&quot;) # 格式化输出，end=&quot;&quot; 表示不换行 time.sleep(0.1)print(&quot;\\n&quot; + &quot;执行结束&quot;.center(scale//2, &quot;-&quot;)) 程序控制结构单分支结构12if &lt;条件&gt;: &lt;语句块&gt; 二分支1234if &lt;条件&gt;； &lt;语句块 1&gt;else: &lt;语句块 2&gt; 二分支可用紧凑形式表达，适用于简单表达式 1&lt;表达式 1&gt; if &lt;条件&gt; else &lt;表达式 2&gt; # 满足条件返回 表达式 1 多分支结构123456if &lt;条件&gt;: &lt;语句块 1&gt;elif: &lt;语句块 2&gt;else: &lt;语句块 3&gt; 条件判断 比较：&gt;、&lt;、&lt;=、&gt;=、==、!= 逻辑：and、or、not 异常处理1234try : # 非异常执行 &lt;语句块 1&gt;except &lt;异常类型[可选项]&gt; : # 抛出异常（注意 异常类型 的名字是系统定义的，不是变量，执行该类型时，只抛出该类型的异常 &lt;语句块 2&gt; 此外，Python 也提供了高级用法 12345678try : # 非异常执行 &lt;语句块 1&gt;except &lt;异常类型&gt; : &lt;语句块 2&gt;else: &lt;语句块 3&gt; # 无异常时执行finally： &lt;语句块 4&gt; # 一定被执行 程序循环结构遍历循环将遍历的结果获得的元素放入循环变量，并执行一次语句块 12for &lt;循环变量&gt; in &lt;遍历结构&gt;: &lt;语句块&gt; 计数循环12for i in range(n): # range 产生 0~n-1 之间的数 print(i) 123456789for i in range(M,N,K): # range 产生数字序列 [M,N)，以 K 为步长 &lt;语句块&gt; ## 实例 for i in range(1,6): print(i) # 1 2 3 4 5 for i in range(1,6,2): print(i) # 1 3 5 字串遍历循环123456for c in s: # s 为字串，c 为字串中的字符 &lt;语句块&gt; ## 实例for c in &quot;PythonHello&quot;: print(c, end =&quot;,&quot;) # P,y,t,h,o,n,H,e,l,l,o, 列表循环遍历123456for i in ls: &lt;语句块&gt; ## 实例for i in [123, &quot;phy&quot;, &#x27;H&#x27;]: print(i, end = &quot;,&quot;) # 123,phy,H, 文件遍历循环12for line in fi: # fi 是文件标识符，遍历文件每行 &lt;语句块&gt; 无限循环12while &lt;条件&gt;: &lt;语句块&gt; 结合 continue 和break使用 高级循环循环可与 else 保留字结合，扩展循环结构 当循环未遇到 break 时，执行 else 语句块，类似异常处理中的 else，即通过该扩展可判断主体中是否执行了 break，一旦使用了 break，将退出当前循环，else 语句块也不会执行 123456789101112131415161718192021# for 循环for &lt;循环变量&gt; in &lt;遍历结构&gt;: &lt;语句块 1&gt;else: &lt;语句块 2&gt;# while 循环while &lt;条件&gt;: &lt;语句块 1&gt;else: &lt;语句块 2&gt; ## 实例for i in &quot;Python&quot;: if i == &quot;t&quot;: continue # break print(i, end = &quot;&quot;)else: print(&quot;程序正常结束&quot;) # Pyhon程序正常结束 # Py（使用 break 时不执行） random 库 使用随机数的标准库，主要用于生成随机数 伪随机数：采用梅森旋转算法生成的伪随机序列中的元素 import random random 库函数基本随机数函数 随机数种子：给定随机数种子，经过梅森旋转算法，将会产生一系列随机序列，随机序列中的每个数即为随机数 ​ 下图为随机数种子为 10 时产生的随机序列（部分） seed(a=None)：初始化给定的随机种子，默认为当前系统时间 random()：生成一个 [0.0, 1.0) 之间的随机小数 123import randomrandom.seed(10) # 可选项，不设置随机种子时，默认为系统时间print(random.random()) # 以 10 为随机种子，产生的随机序列的第一个随机数一定是 0.5714025946899135，多次调用可依次产生 值得注意的是，若设置了随机数种子，则每次产生的随机序列是相同的，即该过程是可复现的；而若采用系统时间，则很难再次复现 扩展随机数函数常用的扩展随机函数如下表所示。 函数 描述 random.uniform(a,b) 生成一个指定范围 [a,b] 内的随机浮点数 random.randint(a, b) 生成一个 [a, b] 内的随机整数 random.randrange(m, n[,k]) 从指定区间 [m, n) 内，按指定的步长 k 序列递增的方式生成一个随机数 random.choice(seq) 从给定序列 seq 中随机选取一个元素 random.shuffle(seq) 随机打乱序列 seq，返回打乱后的序列 random.getrandbits(k) 生成一个 k 比特长的随机整数 1234567891011# 以下运行每次结果不一致print(random.getrandbits(16))print(random.uniform(10,15))print(random.randint(10,15))print(random.randrange(10,15))print(random.choice([1,3,5,7,9,13]))# random.shuffle(s) 函数返回的是 None，因其是原位打乱s = [1,2,3,4,5,6,7,8,9]random.shuffle(s)print(s) 实例123456789101112131415#蒙特卡罗法求解圆周率import randomimport timedarts = 1000 * 1000hits = 0.0start = time.perf_counter()for i in range(1, darts + 1): x, y = random.random(), random.random() r = pow(x ** 2 + y ** 2, 0.5) if r &lt;= 1.0: hits += 1 # 圆的面积pi = 4 * (hits/darts) print(&quot;计算时间：&#123;:.5f&#125;s&quot;.format(time.perf_counter() - start))print(&quot;圆周率为：&#123;&#125;&quot;.format(pi)) 函数和代码复用函数的定义与使用函数的定义 某种功能的抽象，用于表达特点功能 作用是降低编程难度及代码复用 123def &lt;函数名&gt;(参数（0个或多个）): &lt;函数体&gt; return &lt;返回值&gt; 函数的参数传递函数的参数 无参 含默认参数：默认参数在用户调用时是可选的，若用户指定，则使用其值，否则使用默认参数。Python 中规定所有的默认参数都放在必选参数的之后（即默认参数总是放在最后） 12345678def fact(n, m = 2): sum = 1 for i in range(1, n + 1): sum *= i return sum // ma = fact(10)print(a) # 1814400 可变参数：函数定义时可以设置可变数量的参数，即不确定参数的总数量 12345678910111213141516def &lt;函数名&gt;(&lt;参数&gt;, *b): # b 为变量名，可任意设置 &lt;函数体&gt; return &lt;返回值&gt;## 实例def fact_unknow(n, *b): sum = 1 for i in range(1, n + 1): sum *= i for j in b: sum *= j # sum 与用户传入的 b 中的多个值相乘 return sumprint(fact(10, 2)) # 7257600print(fact(10, 2, 3, 4)) # 87091200 函数参数传递方式 位置传递：按函数参数指定的位置传递 名称传递：按函数参数的名臣传递 123## 对前述函数 fact() 的两种参数传递方式fact(10, 2) # 位置传递fact(m = 2, n = 10) # 名称传递 函数的返回值 可以有 return，也可以没有 可以返回 0 个或任意多个 1234return s//m, n, m # 返回值是元组类型，显示为：(1200, 10, 5)# 接收时也可以用变量a, b, c = fact(10, 2) # 则将前述的元组中的每个数赋值给 a, b, c 全局、局部变量 可在函数内部通过 global 声明变量是全局的 若局部变量为组合数据类型，且之前未创建，则其等同于全局变量（如列表类型） 123456789ls = [&quot;A&quot;, &quot;C&quot;]def fun(a): # ls = [] # 若在内部真实创建，则为局部变量 ls.append(a) # 未用 global 声明，但在函数中未真实创建，又和全局变量重名，故作为全局变量 returnfun(&quot;D&quot;)print(ls) # [&#x27;A&#x27;, &#x27;C&#x27;, &#x27;D&#x27;] lambda 函数 匿名函数，没有名字 返回函数名 用于定义简单的，能在一行内表示的函数 12345678910&lt;函数名&gt; = lambda &lt;参数&gt;: &lt;表达式&gt;## 等同于 def……return 定义的函数## 定义了有两个参数 x, y 的函数 f，用于求解两数之和f = lambda x, y: x + yprint(f(10,20)) # 30## 定义无参 lambda 函数，用于输出给定的字串f = lambda : &quot;Hello Python&quot;print(f()) # Hello Python 需谨慎使用 lambda 函数 主要用作一些特定函数或方法的参数 有一些固定的使用方式 一般建议使用 def 定义的普通函数 代码复用与函数递归代码复用 函数 对象：属性 + 方法 模块化设计：模块内部紧耦合，模块之间松耦合（两个部分之间交流较少，可以独立存在），即希望各函数之间相互影响越小 函数递归 链条：数学归纳法，递归链条 基例：有一个值特例用于结束 12345678910# 字串符反转## 思想：将给定字串的第一个字符搬到最后，剩余字符重复上述操作def reversestr(str): if str == &quot;&quot;: return str else: return reversestr(str[1:]) + str[0] str = &quot;abcf&quot;print(reversestr(str)) # fcba PyInstaller 库 第三方库 将 .py 源代码转换成无需源代码的可执行文件，如 windows 下的 .exe 文件 123456789# cmd 指令pyinstaller -F &lt;文件名&gt;.py## 常见参数-h # 查看帮助--clean # 清理打包过程中的临时文件-D, --onedir # 默认值，生成 dist 文件夹-F, --onefile # 在 dist 文件夹中只生成独立的打包文件-i &lt;图标文件名.ico&gt; # 指定打包程序使用的图标（.ico）文件 组合数据类型集合 多个元素的无序组合 元素之间无序但唯一，不存在相同元素 集合元素不可更改，即不能是可变数据类型 —为什么要求是不可变数据类型？ —集合要求元素是唯一的，若其中的元素是可变的，则修改之后元素之间可能会重复，显然是不行的 集合类型的定义 必须用 {} 表示，元素之间用逗号分割 建立集合类型用 {} 或 set() 函数 建立空集合类型，必须使用 set() 函数 12345678A = &#123;&quot;python&quot;, &quot;hello&quot;, (&quot;World&quot;, 123)&#125;print(A) # &#123;(&#x27;World&#x27;, 123), &#x27;python&#x27;, &#x27;hello&#x27;&#125;B = set(&quot;ppytthon&quot;)print(B) # &#123;&#x27;t&#x27;, &#x27;o&#x27;, &#x27;y&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;p&#x27;&#125; ## 去重且无序C = &#123;&quot;Python&quot;, &quot;123&quot;, &quot;Python&quot;, &quot;123&quot;&#125;print(C) # &#123;&#x27;Python&#x27;, &#x27;123&#x27;&#125; ## 去重且无序 集合操作符 基本操作符 操作符及应用 描述 S &#124; T 返回一个新集合，包括在集合 S 和 T 中的所有元素（并集） S - T 返回一个新集合，包括在集合 S 但不在 T 中的元素（差集） S &amp; T 返回一个新集合，包括同时在集合 S 和 T 中的元素（交集） S ^ T 返回一个新集合，包括集合 S 和 T 中的非相同元素（补集） S &lt;= T 或 S &lt; T 返回 True/False，判断 S和 T 的子集关系 S &gt;= T 或 S &gt; T 返回 True/False，判断 S和 T 的包含关系 增强操作符 如 S |= T 等与 = 结合的操作符 集合的处理方法 操作函数或方法 描述 S.add(x) 如果 x 不在集合 S 中，将 x 增加到 S S.discard(x) 移除 S 中元素 x，如果 x 不在集合 S 中，不报错 S.remove(x) 移除 S 中元素 x，如果 x 不在集合 S 中，产生 KeyError 异常 S.clear() 移除 S 中所有元素 S.pop() 随机返回 S 的一个元素，更新 S，若 S 为空产生 KeyError 异常（取出的值在集合中被删掉） S.copy() 返回集合 S 的一个副本 len(S) 返回集合 S 的元素个数 x in S 判断 S 中元素 x，x 在集合 S 中，返回 True，否则返回 False x not in S 判断 S 中元素 x，x 不在集合 S 中，返回True，否则返回 False set(x) 将其他类型变量 x 转变为集合类型 集合类型应用场景 包含关系比较 1&quot;p&quot; in &#123;&quot;p&quot;, &quot;y&quot;, &quot;hello&quot;&#125; 数据去重 利用集合元素唯一性的特性 12345ls = [&quot;p&quot;, &quot;p&quot;, &quot;y&quot;, &quot;y&quot;, 123]s = set(ls) # 将列表转为集合，集合会自动去重lt = list(s) # 再将集合转为列表print(s) # &#123;123, &#x27;p&#x27;, &#x27;y&#x27;&#125;print(lt) # [123, &#x27;p&#x27;, &#x27;y&#x27;] 序列类型 序列 具有先后关系的一组元素 一维元素向量，元素类型可以不同 元素间由序列引导，可通过下标访问序列的特定元素 是基类类型，一般使用其衍生类型，如字串、元组、列表 序列类型通用操作符 操作符及应用 描述 x in s 如果 x 是序列 s 的元素，返回 True，否则返回 False x not in s 如果 x 是序列 s 的元素，返回 False，否则返回 True s + t 连接两个序列 s 和 t s * n 或 n * s 将序列 s 复制 n 次 s[i] 索引，返回 s 中的第 i 个元素，i 是序列的序号 s[i: j] 或 s[i: j: k] 切片，返回序列 s 中第 i 到 j 以 k 为步长的元素子序列 通用函数和方法 函数和方法 描述 len(s) 返回序列 s 的长度 min(s) 返回序列 s 的最小元素，s 中元素需要可比较 max(s) 返回序列 s 的最大元素，s 中元素需要可比较 s.index(x) 或 s.index(x, i, j) 返回序列 s 从 i 开始到位置中第一次出现元素 x 的位置 s.count(x) 返回序列 s 中出现 x 的总次数 元组 一旦创建就不能被修改 使用 () 或 tuple() 创建，元素间用逗号分割 可使用或不使用 () 12a = &quot;hello&quot;, &quot;python&quot;, &quot;整点语法&quot;print(a) # (&#x27;hello&#x27;, &#x27;python&#x27;, &#x27;整点语法&#x27;) 列表 创建后可随意修改 使用 [] 或 list() 创建，元素间用逗号分割 各元素类型可不同，无长度限制 1234ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;lazy&quot;, 123]print(ls) # [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;lazy&#x27;, 123]lt = ls # 赋值时仅传递，并未新建一个列表，只有 [] 是新建列表print(lt) # [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;lazy&#x27;, 123] 列表的操作和方法 函数或方法 描述 ls[i] = x 替换列表 ls 第 i 元素为 x ls[i: j: k] = It 用列表 lt 替换 ls 切片后所对应元素子列表 del ls[i] 删除列表 ls 中第 i 元素 del ls[i: j: k] 删除列表 ls 中第 i 到第 j 以 k 为步长的元素 ls += lt 更新列表 ls，将列表 lt 元素增加到列表 ls 中 ls *= n 更新列表 ls，其元素重复 n 次 函数或方法 描述 ls.append(x) 在列表 ls 最后增加一个元素 x ls.clear() 删除列表 ls 中所有元素 ls.copy() 生成一个新列表，赋值 ls 中所有元素 ls.insert(i,x) 在列表 ls 的第i位置增加元素 x ls.pop(i) 将列表 ls 中第 i 位置元素取出并删除该元素 ls.remove(x) 将列表 ls中 出现的第一个元素 x 删除 ls.reverse() 将列表 ls 中的元素反转 序列应用场景 元组用于元素不改变的场景，更多用于固定搭配场景 列表更加灵活，最常用 数据遍历、 数据保护：将列表转为元组，起到保护作用 字典类型字典定义 映射：一种键（索引）和值（数据）的对应，由用户定义数据的索引 字典类型是映射的体现 键值对 键是数据索引的扩展 字典是键值对的集合，键值对之间无序 采用大括号 {} 和 dict() 创建，键值对用冒号表示 字典用法 通过键获得值 通过键赋值 123&lt;字典变量&gt; = &#123;&lt;键 1&gt;:&lt;值 1&gt;, &lt;键 2&gt;:&lt;值 2&gt;, &lt;键 3&gt;:&lt;值 3&gt;, …, &lt;键 n&gt;:&lt;值 n&gt;&#125;&lt;值&gt; = &lt;字典变量&gt;[键]&lt;字典变量&gt;[键] = &lt;值&gt; 可通过 d = {} 的方式生成空字典，故不能用该方式生成空集合（通过 set() 生成） 字典操作 函数或方法 描述 del d[k] 删除字典 d 中键 k 对应的数据值 k in d 判断键 k 是否在字典 d 中，如果在返回 True，否则 False d.keys() 返回字典 d 中所有的键信息 d.values() 返回字典 d 中所有的值信息 d.items() 返回字典 d 中所有的键值对信息 函数或方法 描述 d.get(k, &lt;default&gt;) 键 k 存在，则返回相应值，不在则返回 &lt;default&gt; 值 d.pop(k, &lt;default&gt;) 键 k 存在，则取出相应值，不在则返回 &lt;default&gt; 值 d.popitem() 随机从字典 d 中取出一个键值对，以元组形式返回 d.clear() 删除所有的键值对 len(d) 返回字典 d 中元素的个数 字典应用 映射表达：表达键值对数据并操作它们，如统计数据（键）出现次数（值） 元素遍历 jieba 库jieba 库简介jieba 优秀的中文分词第三方库 依赖于中文字库，确定汉字之间的关联概率，概率大的组成词组 主要提供三种分词模式： 精确模式：精确切分文本，不存在冗余单词 全模式：文本中所有可能的词语都扫描出来，有冗余 搜索引擎模式：在精确模式的基础上，对长词再次切分 jiaba 库函数 函数 描述 jieba.lcut(s) 精确模式，返回一个列表类型的分词结果 jieba.lcut(s, cut_all = True) 全模式，返回一个列表类型的分词结果，存在冗余 jieba.lcut_for_search(s) 搜索引擎模式，返回一个列表类型的分词结果，存在冗余 jieba.add_word(w) 向分词词典增加新词 w 文件和数据格式化 文件：数据的抽象和集合 数据格式化：使用、存储 文件的类型 文本文件 由单一特定编码组成的文件，如 UTF-8 编码 可看做是存储着的长字符串 适用于 .txt、.py 文件等 二进制文件（存储本质） 直接由 0 和 1 组成，没有统一字符编码 一般存在二进制 0 和 1 的组织结构，即文本格式 适用于 .png、.avi 文件等 文件打开关闭 文件打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回 FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回 FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 + 与 r/w/x/a 一同使用，在原功能基础上增加同时读写功能 123s = open(&quot;file.txt&quot;, &quot;rt&quot;)print(s.readlines())s.close() 文件内容读取 操作方法 描述 &lt;f&gt;.read(size=-1) 读入全部内容，若给出参数，读入前 size 长度 &lt;f&gt;.readline(size=-1) 读入一行内容，若给出参数，读入该行前 size 长度 &lt;f&gt;.readlines(hint=-1) 读入文件所有行，以每行为元素形成列表；若给出参数，读入前 hint 行 文件文本操作 遍历全文本：一次读入，统一处理；若文件较大，将耗时严重，故可采用按数量读入，逐步处理 一次读入，逐行处理 12345filename = input(&quot;请输入文件路径：&quot;)fo = open(filename, &quot;r&quot;)for lines in fo.readlines(): # 一次性读入 print(lines)fo.close() 分行读入，逐步处理 12345filename = input(&quot;请输入文件路径：&quot;)fo = open(filename, &quot;r&quot;)for lines in fo: # 逐行读入 print(lines)fo.close() 文件写入 操作方法 描述 f.write(s) 向文件写入一个字符串或字节流 f.writelines(lines) 将一个元素全为字符串的列表写入文件，直接拼接后写入 f.seek(offset) 改变当前文件操作指针的位置，0-文件开头；1-当前位置；2-文件末尾 若打开文件先写入，紧接着遍历输出问见内容，此时不会输出任何内容，因为文件的指针在写入内容的下一行，故需要通过 seek(0) 函数将文件指针设置到文件开头方可遍历 一维数据 由对等关系的有序或无序数据构成，采用线性方式组织 对应列表、数组、集合等 二维数据：由多个一维数据组成 高维数据：仅利用最基本的二元关系展示数据间的复杂结构 操作周期：存储、表示、操作 一维数据的表示 数据有序：使用列表类型，使用 for 循环遍历处理数据 数据无序：使用集合类型，使用 for 循环遍历处理数据 一维数据的存储 空格分隔：使用一个或多个空格分割，不换行；缺点是数据中不能存在空格 逗号分隔：使用英文半角逗号分隔，不换行；缺点是数据中不能有英文逗号 其他方式：使用其他符号或符号组合分隔，建议特殊符号；缺点同理 一维数据的处理 通过 split(&quot;分隔符&quot;)读取 123txt = open(&quot;file.txt&quot;).read()ls = txt.split(&quot; &quot;)print(ls) 通过&quot;分隔符&quot;.joint()分隔数据以存储 1234f = open(&quot;file.txt&quot;, &#x27;w&#x27;)ls = [&quot;Python&quot;,&quot;is&quot;, &quot;great&quot;]f.write(&quot;$&quot;.join(ls)) # 以 $ 符号分隔f.close #Python$is$great 二维数据二维数据表示 二维列表：一维列表内部也是一维列表 通过两层 for 循环遍历二维列表：ls[row][column]，一般遵循先行后列 CSV格式与数据存储逗号分隔表示一维，行分隔表示二维 读取至列表 1234567891011fo = open(&quot;file.csv&quot;, &quot;r&quot;)ls = [] # 定义一个空列表存储读入的数据for line in fo: # 按行读取 line = line.replace(&quot;\\n&quot;, &quot;&quot;) # 将每行末尾的换行符替换为空 ls.append(line.split(&quot;,&quot;)) # 以逗号分隔的数据添加到列表中fo.close()print(ls) # [[&#x27;A&#x27;, &#x27;300&#x27;, &#x27;100&#x27;], [&#x27;B&#x27;, &#x27;500&#x27;, &#x27;500&#x27;], [&#x27;C&#x27;, &#x27;100&#x27;, &#x27;800&#x27;]]for row in ls: for col in row: print(col) # 逐个打印 列表写至csv 12345ls = [[&quot;A&quot;, &quot;100&quot;, &quot;200&quot;], [&quot;B&quot;, &quot;800&quot;, &quot;700&quot;], [&quot;C&quot;, &quot;500&quot;, &quot;400&quot;]]fw = open(&quot;file.csv&quot;, &quot;w&quot;)for item in ls: fw.write(&quot;,&quot;.join(item) + \\n) # 对列表中的元素，用 , 分隔，每行末加换行符fw.close() 面向对象类类的定义及使用123456789class 类名: # 类的属性（成员变量） # 类的行为（成员方法） def 方法名(self, 形参1, 形参2……): 方法体## 创建对象对象名 = 类名() 方法定义中的 self 必须有，且在方法内部访问成员变量时必须使用，类似 C++ 中的 this 指针 123456789101112131415161718class Student: name = None age = None def get_ifo(self): print(&quot;Hi &#123;&#125;&quot;.format(self.name)) print(f&quot;Hi &#123;self.name&#125;&quot;) print(&quot;Hi&quot;, self.name) def get_ifo2(self, msg): print(&quot;Hi &#123;&#125; &#123;&#125;&quot;.format(self.name, msg)) print(f&quot;Hi &#123;self.name&#125; &#123;msg&#125;&quot;) print(&quot;Hi&quot;, self.name, msg)stu = Student()stu.name = &quot;LI&quot;stu.age = 20stu.get_ifo() # Hi LI\\n Hi LI\\n Hi LIstu.get_ifo2(&quot;GREAT&quot;) # Hi LI GREAT\\n Hi LI GREAT\\n Hi LI GREAT 类的构造方法 构造方法：__init__ 创建类对象时，会自动执行；或将传入参数自动传递给该方法使用 12345678910111213141516171819class Student: name = None # 可不写，若不写，会在 __init__ 中构造；若写，则构造方法中为赋值 age = None def __init__(self, name, age): self.name = name self.age = age print(&quot;Initial constru&quot;) def get_ifo(self): print(&quot;Hi &#123;&#125;&quot;.format(self.name)) print(f&quot;Your age is &#123;self.age&#125;&quot;) # print(&quot;Hi&quot;, self.name)stu = Student(&quot;Li&quot;, 20) stu.get_ifo()## 输出结果# Initial constru# Hi Li# Your age is 20 类内置方法类似函数重载 字符串方法：__str__ 控制类转换为字串的行为 默认是输出对象的内存地址 可自定义为想输出的内容 1234567891011121314151617class Student: name = None age = None def __init__(self, name, age): self.name = name self.age = age def __str__(self): return &quot;Hi &#123;&#125;, your age is &#123;&#125;&quot;.format(self.name, self.age)stu = Student(&quot;Li&quot;, 20)print(str(stu)) # 未自定义字串方法：&lt;__main__.Student object at 0x7f849c43d1f0&gt; # 自定义字串方法后：Hi Li, your age is 20 小于比较方法：__lt__ 直接比较两个对象是不行的 可以在类中自定义小于或大于比较方法 小于等于比较方法：__le__ 小于等于或大于等于 等于比较方法：__eq__ 不自定义默认比较两对象的地址 123456789101112131415161718192021222324252627class Student: name = None age = None def __init__(self, name, age): self.name = name self.age = age def __lt__(self, other): # self 和 other 是传入的两个对象 return self.age &lt; other.age def __le__(self, other): return self.age &lt;= other.age def __eq__(self, other): return self.age == other.age stu1 = Student(&quot;Li1&quot;, 28)stu2 = Student(&quot;Li2&quot;, 22)stu3 = Student(&quot;Li3&quot;, 22)print(stu1 &lt; stu2) # Falseprint(stu1 &gt; stu2) # Trueprint(stu2 &lt;= stu3) # Trueprint(stu2 &gt;= stu3) # Trueprint(stu2 == stu3) # True 封装 私有成员：只需在变量名或方法名前加 __ 即可 类对象无法访问私有成员 类中其他成员可以访问 继承 在已有的类中添加新功能，若不想添加新功能，可直接使用 pass 关键字作为占位符，保证方法或类定义的完整性，表示无内容或空 单继承 12class 子类名(父类名): # 新增功能 多继承 若成员属性或方法重名，则优先级取决于继承的顺序 123class 子类名(父类名1, 父类名2, ……): # 新增功能 pass 复写 子类中重新定义父类中同名的属性或方法 一旦复写，类对象就会调用子类中复写的属性或方法；若需使用被复写的父类，需要特殊的调用方式： 父类名.成员变量/方法(self) super().成员变量/方法 类型注解 类型注解有助于 IDE 进行类型推断，协助做代码提示 帮助开发者自身对变量进行类型解释 支持变量类型、函数/方法形参列表和返回值的类型注解 基础语法：变量名: 类型 一般只有在无法直接看出变量类型时会添加类型注解 注解只是建议，并非强制性语法 变量类型注解1234567891011121314151617181920# 基础类型a: int = 10b: float = 3.14# 类对象class Student: passstu: Student = Student()# 容器类型简易注解my_list: list = [1, 2, 3]my_tuple: tuple = (1, 2, 3)# 容器类型详细注解my_list2: list[int] = [1, 2, 3]my_tuple2: tuple[str, int, bool] = [&quot;python&quot;, 1, True] # 必须每个单独指定# 直接在注释中注解a = 10 # type: intb = 3.14 # type: float 函数／方法类型注解1234567# 形参注解def func(x: int, y: float): pass# 返回值注解def add(x: int, y: int) -&gt; int: return x + y Union类型及注解 主要用于混合数据类型的注解 123456from typing import Unionmy_list: list[Union[str, int]] = [1, 2, &quot;python&quot;]my_dict: dict[str, Union[str, int]] = &#123;&quot;name&quot;: &quot;python&quot;, &quot;age&quot;: 20&#125;def func(data: Union[str, int]) -&gt; Union[str, int]: pass","categories":[{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/tags/Python/"}]},{"title":"机器人手眼标定（OpenCV)","slug":"Vrep/机器人手眼标定（OpenCV","date":"2023-04-17T09:12:29.000Z","updated":"2023-04-28T08:20:43.434Z","comments":true,"path":"hec_opencv/","link":"","permalink":"https://hbroad.github.io/hec_opencv/","excerpt":"","text":"机器人手眼标定机器人手眼标定是机器人加工、抓取等的关键，视觉系统的安装方式主要可分为两种：一类是将视觉系统直接安装在机器人末端法兰盘上，构成“眼在手上（eye-in-hand）”的配置方式，该类配置下，视觉系统随着机器人移动，视觉系统与机器人末端工具坐标系之间的位姿固定不变；另一类则与之相反，即视觉系统固定在机器人外部，构成“眼在手外（eye-to-hand）”的配置，此配置下，视觉系统与机器人基坐标系之间的位姿保持不变。 手眼标定模型AX=XB利用机器人的相对位姿求解，如采集 20 个位姿，实际可用于求解有 19 组位姿 AX=ZB利用机器人的绝对位姿求解，如采集 20 个位姿，全部参与求解 手眼标定算法实现OpenCV4 已经实现了部分经典手眼标定算法，但其说明文档实在是一言难尽，经过论文对比和测试，本文对相关参数做一解释! AX=XB123456789void cv::calibrateHandEye( InputArrayOfArrays R_gripper2base, InputArrayOfArrays t_gripper2base, InputArrayOfArrays R_target2cam, InputArrayOfArrays t_target2cam, OutputArray R_cam2gripper, OutputArray t_cam2gripper, HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI ) 参数解释：[输入] R_gripper2base vector&lt;Mat&gt; 类型，机器人位姿旋转部分，可传入 3x3 旋转矩阵或 3x1 旋转向量[输入] t_gripper2base vector&lt;Mat&gt; 类型，机器人位姿平移部分，3x1 平移向量[输入] R_target2cam vector&lt;Mat&gt; 类型，每个位姿相机外参旋转部分，可传入 3x3 旋转矩阵或 3x1 旋转向量[输入] t_target2cam vector&lt;Mat&gt; 类型，每个位姿相机外参平移部分，3x1 平移向量[输出] R_cam2gripper 手眼矩阵旋转部分，3x3 旋转矩阵[输出] t_cam2gripper 手眼矩阵平移部分，3x1 平移向量[输入] method 手眼标定算法，详见cv::HandEyeCalibrationMethod 经测试，上述标定算法中，CALIB_HAND_EYE_HORAUD的精度最高 按照 OpenCV 官方文档解释，机器人末端与基坐标系之间的转换关系为： \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{b}\\textrm{R}_g & _{}^{b}\\textrm{t}_g \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix}可见该转换矩阵将末端位姿转换到了机器人基坐标系下（等号左边是转换后结果，右边是转换前），所以该部分输入可直接采用从上位机获取的机器人位姿。 机器人上相机与标定板之间的转换关系为： \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{c}\\textrm{R}_t & _{}^{c}\\textrm{t}_t \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_t\\\\ Y_t\\\\ Z_t\\\\ 1 \\end{bmatrix}该转换矩阵将标定板坐标转换到了相机坐标系下，故该部分可直接传入每个位姿的相机外参。 最终手眼矩阵输出的结果为： \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{g}\\textrm{R}_c & _{}^{g}\\textrm{t}_c \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix}可见输出的转换矩阵即为机器人末端与相机坐标系之间的位姿关系，无需求逆。 OpenCV 的示意图误导性严重，没有遵循坐标转换关系的标准写法（具体可参考《机器人学导论》）。 AX=ZB1234567891011void cv::calibrateRobotWorldHandEye( InputArrayOfArrays R_world2cam, InputArrayOfArrays t_world2cam, InputArrayOfArrays R_base2gripper, InputArrayOfArrays t_base2gripper, OutputArray R_base2world, OutputArray t_base2world, OutputArray R_gripper2cam, OutputArray t_gripper2cam, RobotWorldHandEyeCalibrationMethod method = CALIB_ROBOT_WORLD_HAND_EYE_SHAH ) 该部分实现了两种算法，分步法和同步法各一种，经测试，两者精度几乎无差别。 参数解释同前，OpenCV官方解释同样具有强烈误导性！！ 首先是传入的机器人位姿，文档给出的转换矩阵为： \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{g}\\textrm{R}_b & _{}^{g}\\textrm{t}_b \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix}可见其将基坐标系转到了末端法兰盘坐标系，而我们上位机直接获取的位姿是在机器人基坐标系下的，故这部分在传入时需求逆矩阵，对转换矩阵而言，其逆矩阵为： T^{-1}= \\begin{bmatrix} R^T & -R^Tt \\\\ 0^T & 1 \\end{bmatrix}对每个位姿的相机外参，从其转换矩阵可知无需求逆： \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{c}\\textrm{R}_w & _{}^{c}\\textrm{t}_w \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix}最坑的地方来了，从下式可知，最终求解的手眼矩阵是以相机坐标系为参考系的，而基坐标系与世界坐标系之间的关系是以后者为参考系的，但实际中我们需要的恰好是其逆矩阵。 \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{w}\\textrm{R}_b & _{}^{w}\\textrm{t}_b \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{c}\\textrm{R}_g & _{}^{c}\\textrm{t}_g \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix}综上，对于部分输入输出参数必须求逆，否则计算结果完全错误，重投影误差显著增大！！！","categories":[{"name":"Robot","slug":"Robot","permalink":"https://hbroad.github.io/categories/Robot/"}],"tags":[{"name":"UR5","slug":"UR5","permalink":"https://hbroad.github.io/tags/UR5/"},{"name":"HEC","slug":"HEC","permalink":"https://hbroad.github.io/tags/HEC/"}]},{"title":"C++ 指针","slug":"CPP/C++ 指针","date":"2023-03-29T16:00:00.000Z","updated":"2023-04-17T14:36:44.400Z","comments":true,"path":"cpp_pointer/","link":"","permalink":"https://hbroad.github.io/cpp_pointer/","excerpt":"","text":"重温指针，参考油管大神，13年的视频，经典经久不衰！ 内存结构内存结构可大致分为四块，各司其职，具体可参考 Code(Text)区：该区域存储程序代码，相关文本 Static/Global区：存储静态变量及全局变量 Static区：栈区，存储局部变量，负责程序运行过程中状态存取（函数调用执行信息） 该区域由 main 函数开始存储，遇到函数调用时，会在内部重新开辟一块内存，在新的内存中执行子函数（可认为是入栈），执行完毕后子函数生命周期结束，内存被释放（可认为是出栈），返回主函数继续执行 由编译器自动分配，自动清理 Heap区：堆区，动态内存 该区并不等同于数据结构中的堆，而是一块动态内存，所有动态内存的分配均在此区域进行，如 C 中的 malloc + free，C++ 中的 new + delete 由程序员自己负责释放，如不释放，在程序结束后由系统自动回收 动态内存分配C malloc：void* malloc(size_t size) 该函数接受一个参数，该参数告知需要分配内存的具体大小，并返回通用指针类型 void*，因而在实际使用中还需类型转换 该函数只会分配指定大小的内存，并不会初始化其中的值 12int* p = (int*)malloc(sizeof(int));//sizeof(int) 获取了基本类型 int 的单位大小，如若需要更大的尺寸，可直接用元素数量整数相乘即可，如 20*sizeof(int) calloc：void* calloc(size_t num, size_t size) 与 malloc 不同的是，该函数接受两个参数，一个元素数量，另一个和 malloc 一致；即将 malloc 中整数相乘的部分作为参数 该函数会初始化内存中的值为 0 1int* p = (int*)calloc(20, sizeof(int)); realloc：void* realloc(void* ptr, size_t size) 若已动态分配了内存，需要更改内存的大小（或重新分配），可通过该函数 第一个参数指向现有内存块的首地址，第二个参数是需新分配的大小 如果需要扩充现有内存，该函数会将现有内存中的全部内容复制到新的内存中 在现有内存上扩展的前提是系统能在现有内存后找到可扩展的连续空间，否则会直接分配一块新的内存 1int* p_ = (int*)realloc(p, n*sizeof(int)); free：所有分配的内存必须通过 free 释放，如若不释放，则分配的内存依然被占用，假若每次都不释放，内存终究会被消耗完 即使释放后，内存可是可访问和修改的，但其中的值是随机的，所以使用内存之前一定要申请内存 c++new + delete 内存泄漏正常情况下，函数的调用均在栈区进行，每调用一次，被调函数生命周期结束返回到主函数时，被调函数的内存被释放，等到下一次调用时重新分配，这个过程由编译器自动进行。 但若我们从堆区动态申请内存，而不手动释放，且由于编译器并不会自动释放，程序运行一段时间后最终会导致内存耗完，而这些未释放的内存不能被别的程序使用，成为了“垃圾”，这种垃圾的不断增加就是内存泄漏。 如若申请使用后释放，效果就和栈区一样。 Java 和 C# 中会自动释放堆区内存，但 C/C++ 不会。 指针与函数指针作为函数返回值假设我们需要通过调用函数实现两数之和，最简单的场景是： 12345678910111213#include &lt;iostream&gt;using namespace std;int Add(int a, int b)&#123; int c = a + b; return c;&#125;int main()&#123; int a = 2, b = 4; int c = Add(a, b); cout &lt;&lt; c;&#125; 若通过指针作为参数来实现上述过程： 12345678910111213#include &lt;iostream&gt;using namespace std;int Add(int* a, int* b)&#123; int c = *a + *b; return c;&#125;int main()&#123; int a = 2, b = 4; int c = Add(&amp;a, &amp;b); cout &lt;&lt; c;&#125; 假若我们将函数的返回值通过指针带回，可以写为： 1234567891011121314#include &lt;iostream&gt;using namespace std;int* Add(int* a, int* b)&#123; int c = *a + *b; return &amp;c;&#125;int main()&#123; int a = 2, b = 4; int* ptr = Add(&amp;a, &amp;b); cout &lt;&lt; &quot;sum&quot; &lt;&lt; *ptr;&#125; 运行该代码完全看运气，或许偶尔能得到正确的值，这是一个典型的逻辑错误，分析如下： 程序从主函数开始，在栈区开辟一段内存，并存储三个局部变量 函数执行到12行时，在栈顶开辟一块新内存存储 Add 函数及其局部变量，由于 Add 函数中的 a、b 指针分别指向 main 函数中的 a、b，故其中存储主函数中局部变量的地址，求和后存储在变量 c 中 Add 函数最终返回了 c 的地址，由主函数中的指针 ptr 接受，Add 函数结束，其内存被自动释放（若有其他函数，则会被其他函数占用），此时在主函数中输出返回值，结果自然是错误的，因为 ptr 指向的内存已被抹去，指针为 NULL了 如何解决呢？ 既然栈区是编译器自动分配与释放，那自然想到堆区（或静态/全局区），由程序员自己申请和释放，只要自己不释放，在程序周期内一直存在 123456789101112131415#include &lt;iostream&gt;using namespace std;int* Add(int* a, int* b)&#123; int* c = new int; //动态申请，不释放，存在直到程序结束 *c = *a + *b; return c;&#125;int main()&#123; int a = 2, b = 4; int* ptr = Add(&amp;a, &amp;b); cout &lt;&lt; *ptr;&#125; 如下图所示，在栈区存储的 Add 函数中，向堆区动态申请了一块内存，也就是栈区的 c 指向了堆区，求和的结果存储在堆区，Add 函数返回了堆区的地址，由于堆区需要手动释放，所以主函数可通过返回的地址获取求和的结果。 函数指针核心含义 顾名思义，指针指向函数 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int Add(int a, int b)&#123; int c = a + b; return c;&#125;int main()&#123; int a = 2, b = 4; int (*p)(int, int); //声明一个指针，该指针指向一个带有两个 int 型参数的函数// p = &amp;Add; //和下述同义// int c = (*p)(a, b); p = Add; int c = p(a, b); cout &lt;&lt; c;&#125; 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void print()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;&#125;void print_name(char* name)&#123; cout &lt;&lt; &quot;Hello &quot; &lt;&lt; name;&#125;int main()&#123; void (*p)(); p = print; p(); //函数指针调用其指向的函数（可直接作为函数名进行调用） void (*pn)(char*); pn = print_name; pn(&quot;Duke&quot;); //可接受函数参数&#125; 注意和 int* p(int, int) 的区别，这是定义了一个函数 p，其返回值为指向 int 的指针 函数指针与回调函数函数指针是可以作为函数参数的 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void print()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;&#125;void print2(void (*p)())&#123; p();&#125;int main()&#123; void (*p)() = print; print2(p); // 等价于下面的 print2(print);&#125; 这段代码中通过函数指针，实现了对另一个函数的回调，但这种显然没有实际意义。 考虑这样一个场景，我们需要对用户输入的一组数进行排序，但升序和降序由用户决定，简单的做法是写升序和降序两段代码，但显然不利于代码的维护，此时便可通过函数指针作为函数参数，通过由用户定义的回调函数，判断升降排序。以冒泡排序为例： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;//回调函数，控制比较的机制int compare(int a, int b)&#123; if(a &gt; b) return 1; //定义规则，此时为升序，改为 -1 即为降序 else return -1;&#125;void bubbleSort(int* A, int n, int (*compare)(int, int))&#123; int i, j, tmp; for (i = 0; i &lt; n; ++i) for (j = 0; j &lt; n-1; ++j)&#123;// if(A[j] &gt; A[j + 1]) if (compare(A[j], A[j+1]) &gt; 0)&#123; //若为 true，则交换，否则保持原顺序 tmp = A[j]; A[j] = A[j + 1]; A[j + 1] = tmp; &#125; &#125;&#125;int main()&#123; int A[] = &#123;2,5,1,4,3,6&#125;;// bubbleSort(A, 6); bubbleSort(A,6,compare); for(auto a : A) cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125; 该程序定义了回调函数 compare()，其对输入序列中的相邻两个值进行比较，实现升降排序，通过这种方式可完全隐藏函数内部实现，由用户定义自己的排序机制。 这在 C/C++ 标准库中有诸多体现，如快排 qsort，该函数可以对任意类似的数组进行排序，故其需要定义排序的逻辑： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdlib&gt; //qsortusing namespace std;//回调函数，控制比较的机制int compare(const void* a, const void* b)&#123;// int A = *(int*)a; //强制类型转换// int B = *(int*)b;// return A - B; return (*(int*)a - *(int*)b); //也可用 if 语句&#125;int main()&#123; int A[] = &#123;2,5,1,4,3,6&#125;; qsort(A, 6, sizeof(int), compare); for(auto a : A) cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125; 由于 qsort 是通用的排序方法，故其回调函数是通用指针 void*，在该函数内部，首先转为所需类型的指针，再解引用参与计算。 此外，回调函数另一常见的使用场景是 事件处理（MFC、OpenCV 等中的按钮事件）。","categories":[{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"}]},{"title":"C++ 小知识点","slug":"CPP/C++常用","date":"2023-03-12T16:00:00.000Z","updated":"2023-04-17T14:37:33.779Z","comments":true,"path":"cpp_useful_sugar/","link":"","permalink":"https://hbroad.github.io/cpp_useful_sugar/","excerpt":"旨在记录一些常见、易错点","text":"旨在记录一些常见、易错点 浮点数的比较 如何比较两个浮点数是否相等 FLT_EPSILON 表示计算机能表示的最小的浮点数 不能直接使用 a==b 判断浮点数是否相等 1234if (fabs(a - b) &lt; FLT_EPSILON) &#123; // a 和 b 被认为是相等的&#125;// double DBL_EPSILON","categories":[{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"}]},{"title":"UR5_Vrep 仿真","slug":"Vrep/UR5_VREP仿真","date":"2022-11-17T16:00:00.000Z","updated":"2023-04-28T07:58:40.799Z","comments":true,"path":"ur5_vrep_simu/","link":"","permalink":"https://hbroad.github.io/ur5_vrep_simu/","excerpt":"UR5 结合 Coppeliasim（旧Vrep） 的仿真相关操作记录","text":"UR5 结合 Coppeliasim（旧Vrep） 的仿真相关操作记录 逆运动学dummy dummy 解释 参考 dummy 的添加 添加一个dummy，dummy在V-REP 中是最简单的模型。然后调整其位置到（-3.7658e-1，+0e+0，+1.0013e+0），注意此时我们假设你的UR的坐标是（+0e+0，+0e+0，+1.4650e-2）。如果你调整的UR的位置，那么这个dummy的位置也需要左相应的调整。当然也没有这么死板，只要将其放在你认为的夹持器工作中心即可。然后将其重命名为 UR5_tip。 所以demo 中的 UR5_Tip 在夹爪中心的原因是其平移过去而非直接与夹爪相连 逆运动学计算方法：伪逆（不稳定但快速）、DLS（稳定但慢） vrep 中编辑 path 时可能出现部分视角看不到完整路径的情况，可新建一场景，编辑后再导入，注意不要更改其位置 Vrep 仿真小问题 仿真开始时部分位置会显示一个紫色球体，这是由于添加了 Blob to 3D position 相机的原因，紫色球体即为相机在场景中检测到的物体(参考)，可在脚本中将 addDrawingObject 注释 编辑路径时，路径上控制点过大，导致编辑看不清，可在属性中设置大小 Geomagic 提取模型合模线 分别选择两个平面拟合平面特征（也可直接选择探测特征，但效果一般） 选择 特征-平面-两平面平均 创建合模线所在平面 选择 曲线-从截面创建，创建平面所经过的曲线，即为合模线 选择 曲线-创建点，合模线离散为点，后续用于路径规划 2023年2月21日19:08:34 导入模型后，首先将CAD模型的坐标系移动到合适的位置，这个过程使用 对象移动器，通过主矢可直接对齐坐标系 在选择选项卡下，更改选择为矩形 选择两平面拟合 Geomagic 点云数据导出 不同的格式对应不同的单位 pcd 文件对应的单位：m obj 文件对应的单位：mm（导出到该格式的点可能和源文件的有差异，下图左为导出后顺序，右为原点云顺序） asc文件格式数据和原点云一致，只需更换点云描述头 Geomagic 与 Vrep 数据转换 Vrep 模型导入（图源） 由 Vrep 导出后，导入到 Geomagic 中时选择单位必须为 m，否则轨迹不正确 关于模型的缩放（当下不需要了，直接在导入时选择单位） 先将扫描得到的 CAD 模型直接导入到 Vrep，可以观察到大小完全不是一个等级，这时候就要缩放，缩放因子设置为 $0.5^n$，这里需要不断调节直到合适的大小 缩放的验证：比如设置缩放因子为 $0.5^8$，此即为将原模型缩放了 256 $(1/0.5^8)$倍， 选取轨迹上两点并测量其距离，距离的缩放应满足该倍数关系 关于最终轨迹的生成 首先将原模型导入，通过设置位置坐标将其移动到机器人基坐标系下（这里可直接输入机器人的基坐标系位置） 设置缩放因子缩放到合适的大小，并旋转到合适的位置 导出上述缩放后的模型（记住导出的轴哪个向上），并重新导入（注意选择与导出时相同的向上轴），再次导出作为最终的模型，此时的模型重新导入时坐标方向是一致的（原因未知） 导入 Geomagic，选择并拟合两个平面，通过拟合的两平面建立中间的平面（即合模线所在平面），通过截面创建曲线，生成点，删除多余的点 拟合两个平面： 取合模线所在平面： 截面创建轨迹： 轨迹线转为点： 导出的点是无序的，可以将数据在 Origin 中画出来，按顺序排好后再导入到 Vrep，此时的轨迹和前述的模型应当是匹配的，在 Vrep 中可以将其设置为模型的从属 无序点（显示的标签为行号）： 排序结果： Geomagic 模型切半 将点集封装成多边形 点击裁剪，按平面，选择好平面 点击下面的平面截面，选择要删除的选区，删除即可 模型轨迹在实际机器人基坐标系下的位姿 按前述将模型导入 Vrep 后，Vrep 自动生成该模型在基坐标系下的位姿 将该模型导出，再导入，再导出作为最终模型使用 提取导出模型的合模线，按前述创建轨迹（该轨迹是和模型同处于机器人基坐标系下的） ，导入到 Vrep 指定每个控制点的方向后导出得到最终的轨迹 注意此时导出的轨迹是 $x,y,z,\\alpha,\\beta,\\gamma$，单位是 $m$ 和 $°$ 测量点云与导出模型（作为CAD模型）配准，得到转换矩阵 轨迹点位姿与转换矩阵相乘，得到转换到实际机器人基坐标系下的轨迹，该轨迹包含位姿 在轨迹点与转换矩阵相乘前，需要将其转换为矩阵的形式，转换顺序为：原始轨迹点——单位转换为mm——欧拉角转旋转矩阵——合并为转换矩阵 vrep 导出模型时单位为 m，需乘 1000 转为 mm，导出的模型作为 CAD 与测量点云配准","categories":[{"name":"Robot","slug":"Robot","permalink":"https://hbroad.github.io/categories/Robot/"}],"tags":[{"name":"UR5","slug":"UR5","permalink":"https://hbroad.github.io/tags/UR5/"},{"name":"Simulation","slug":"Simulation","permalink":"https://hbroad.github.io/tags/Simulation/"},{"name":"Coppeliasim/Vrep","slug":"Coppeliasim-Vrep","permalink":"https://hbroad.github.io/tags/Coppeliasim-Vrep/"}]},{"title":"C++ 学习笔记","slug":"CPP/C++","date":"2022-08-22T16:00:00.000Z","updated":"2023-04-17T14:35:13.146Z","comments":true,"path":"cpp_learning/","link":"","permalink":"https://hbroad.github.io/cpp_learning/","excerpt":"C++ 学习笔记上传（研） 原链接","text":"C++ 学习笔记上传（研） 原链接 小概念集锦 外存储器的容量大， 大部分可移动，便于在不同计算机之间进行信息交流。其只有被读入内存储器后才可被CPU读取，即CPU不能直接访问外存储器 进程是可以并发执行的程序的执行过程 循环队列是顺序存储结构 拷贝构造函数： 程序中需要新建立一个对象，并用另一个对象去初始化 函数的参数为类的对象 函数的返回值是类的对象 类外同名的变量赋值，不能改变类内的静态变量值 程序中的 typename 都可以替换为 class NULL 与 nullptr NULL 在 C 中表示 void，即指向任意类型的指针，C 中会完成隐式类型转换，但 C++ 中是强制类型转换，导致 void 不能隐式转换为其他类型 起初 C++ 用 0 代替空指针，但其在函数重载时发生二义性，后续直接用 nullptr，而 NULL 表示 0 CPP小概念基本框架结构化程序设计框架 函数是程序的基本单元 面向对象程序设计框架 类是程序的基本组成单元 数据类型 单精度不能超过 7 位有效数字，双精度不能超过 15 位 一个字符串常量在存储时在给定的字符序列后再加一个空字符（‘\\0’），而字符常量不加 任一种进制的整数，可添加后缀字母 U 或 L，表示无符号整型（usigned int）和长整型（long int），也可同时添加两者，无排序要求，如：55L，100LU 变量 变量的存储类属性 auto（自动变量）：默认存储类别，占用空间的分配和释放由系统自动完成 register（寄存器变量）：寄存器虽然快，但其数量有限，当其不够时，仍然按照 auto 处理 static（静态变量）：任何静态变量的生存期将延续到整个程序的终止；编译器为其分配的空间在整个程序运行期间不会释放；若未赋初值，系统自动赋值为 0 extern（外部变量）：声明为外部变量后，该变量可被其他文件引用，可避免为其重复分配内存 typedef 类型 给现有的数据类型起一个别名 符号常量 概念：用 const 修饰的标识符 原则：先声明，后使用 声明：const int i = 1； 用 const 声明的常量只能被读取，故在声明时需初始化，且其值在程序中无法改变 可用预处理命令 #define 定义符号常量：#define PI 3.14 运算符和表达式运算符 单目 双目 三目：?:（C++只此一个） 运算类型 赋值运算：可一次性给多变量赋值：x=y=z=1; 其从右往左依次赋值，即 z=1，接着将 z=1 赋给 y，得 y=z=1，最后得 x=y=z=1 自增运算 a++：先参与运算，运算后再 +1 ++a：先 +1，再参与到运算中 逻辑运算符 ！ &amp;&amp; || 优先级依次递减 其他运算符 条件运算符：?: a&gt;b ? 1:0；若a&gt;b，返回1 ，否则0 逗号运算符：返回最后表达式的值 (a = 3 * 5, a * 4), a + 5; // a = 15，表达式结果为 20 sizeof运算符：取得任何变量和类型在内存中占用的字节数 sizeof(int); //4 #include &lt;cmath&gt; // C++ 数学函数 指针指针和地址 指针：变量的地址就是该变量的指针 指针变量：存放地址的变量 指针运算 指针变量和整型量加减 = 指向下一元素 相同的指针变量类型之间可以赋值 两个指向同一类型的指针变量进行逻辑运算，实质是地址的比较 两指向同一数组成员的指针变量可减运算，结果为两指针之间相差的元素个数 指针和数组 数组名即为该数组首元素的地址，即指针 数组名是常量指针，而指针是指针变量 1234567891011int a[10];int *p;//首元素的地址给指针p = &amp;a[0];p = a;//取首元素a[0];*p;*a; 字符串常量可以赋给指针变量，会将前者第一个字符的指针给后者 引用 引用即为变量起别名 既然是起别名，在定义时就要初始化，即指定给谁起别名 既然是别名，那么对引用的操作就是对变量本身的操作 引用就是两个变量使用的是同一块内存单元 12int i = 1;int &amp;j = i; // 给 i 起别名为 j &amp;只是标识符，非取地址符 一旦引用被初始化，不可更改为另一变量的引用 动态存储分配 静态存储分配是在编译阶段确定变量占据的空间，而部分程序只有在运行时才能确定，即为动态内存分配 new 申请，delete 释放 1234567891011121314151617//对某种数据类型分配空间，赋初值10int *a;a = new int(10);//或int *a = new int;*a = 10;//释放delete a;// 对数组int *b;b = new int[10]; // 元素个数可以是变量，这是与一般的数组声明最大的区别//释放delete[] a; 动态内存分配是在堆内存或自由存储区，数量有限，当耗尽时再申请会返回空指针 NULL，故在分配空间后，可做判断如下： 12if (a == NULL) exit(0); //正常结束程序 动态分配后的内存需显式的释放，由 new 申请，则必须由 delete 释放 函数函数及声明 函数不能嵌套，即函数内部不能定义其他函数 函数原型声明的两种形式（注意是声明不是定义） 123double sort(int a[], int b);//或省略形参变量名double sort(int [], int); 函数参数参数的传递方式 值传递 实参不变，将实参复制一份给形参 虽不会改变实参的值，但当传递参数的大型的类对象时，空间和时间开销过大 传地址 传地址之后将改变实参的值 引用传递 隐式的传地址 参数声明为引用时，调用时编译器将自动传递实参的地址给被调用函数 一般情况下，当传递大型的数组或类对象时，采取传递指针的方式，因为任意类型的指针大小是一样的（32位下为 4 字节，64 位下为 8 字节），相比复制传递的方式，空间开销小很多。 建议传地址时使用引用代替指针 指针和引用的区别 定义和性质的不同 指针是地址，引用只是变量的别名，与原变量共用一块地址 函数传参时的区别 指针传参可以直接操作实参的地址，对实参进行改变 引用传参是直接传递实参本身，节约时间空间 默认参数 默认参数 缺省的实参只能用于替换函数调用中缺少的尾部实参，即函数调用是按位置依次赋值的，不是按照参数的类型匹配的，即实参的类型要和形参的顺序一致 12345int default_n(int a = 1, int b = 2, char c = &#x27; &#x27;);//调用default_n(, , &#x27;&lt;&lt;&#x27;); // 该调用并不等价于 default_n(1, 2, &#x27;&lt;&lt;&#x27;);defaulr_n(&#x27;&lt;&lt;&#x27;); //同上 函数重载参数个数/参数类型不同 内联函数 为取代预处理宏函数 inline 关键字放在函数定义中的函数类型之前 内联函数和宏函数 宏函数由预处理器进行替换，而内联函数由编译器实现，是真正的函数 但内联函数调用时像宏一样展开，执行效率更高 内联函数和普通函数 普通函数的调用将控制转移给被调用函数，从而调用有一定的时间和空间开销 内联函数直接将被调用函数复制一份到调用的地方，效率更高 但该优点也是缺点，即内联函数的函数体不能太大，结构也不能太复杂，否则编译器将放弃内联方式转而采用普通方式调用 递归函数类和对象类 数据成员：属性 类中数据成员的类型任意，包括另一个类的对象 虽自身类的对象不能作为数据成员（因为类还没定义完成，该类型没法分配存储空间），但自身类的指针或引用可以（任意类型的指针大小是确定的） 类体内不能对数据初始化，初始化由构造函数完成 成员函数：行为 在类内定义的成员函数皆为内联函数 类外也可定义函数，通过类名+作用域运算符::来表明函数属于哪个类 成员函数可重载，参数可设置默认值 类成员的访问控制 私有成员只能被自己所属类中的成员函数及友元函数访问 对象 对象的定义 可定义一般类对象、对象数组、对象指针、对象引用 1234class c1;class c2[10];class *c3;class &amp;c4 = c1; 对象的成员及其访问 . 运算符：访问一般对象的成员（数据成员或成员函数），也可访问对象引用或对象数组的成员，方法一致 123456789class Time&#123; public: int hour; void settime();&#125;;Time T1;T1.hour;T1.settime(); -&gt;运算符：访问一个指针变量所指向的对象成员，等价于 (*对象指针名).成员 12345678Time T1;Time* T2 = T1;//对象指针变量 T2 的成员访问T2 -&gt; hour;T2 -&gt; settime();//或(*T2).hour;(*T2).settime; 构造函数和析构函数 构造函数的作用：用于新建对象的初始化工作 析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等 每当创建对象，需要对该对象完成初始化时，则需要定义自己的构造函数；而对象撤销，需要自己添加清理工作代码时，则需要定义自己的析构函数 共同特点： 类体中说明的两种成员函数 没有返回值，void也不行 构造函数可带参数，可重载；析构函数都不能 构造函数 函数名与类名相同 函数体可在体内/体外 一般声明为公有函数 在定义对象时被系统直接调用，用户不能直接调用构造函数 构造函数初始化对象：类名 对象名 (参数表)，如：class c1 (1,2,3); 运算符 new + 构造函数： class * c2 = new class () 定义对象数组时只能调用没有参数或所有参数都有默认值的参数 定义对象指针时不会调用构造函数，因为指针变量还未实例化 析构函数 ~ 类名 函数体可在体内/外 在对象生存期即将结束时由系统自动调用，之后对象消失，内存空间被释放 一个类只能定义一个析构函数 delete 运算符和析构函数一起使用 默认构造/析构函数 不带参数 函数与类名相同 参数为空或所有参数带默认值 用户未定义时系统自动建立 拷贝构造函数 只有一个参数，类型是本类对象的引用 每个类必须要有，若没有则编译系统自动生成一个公有的 被调用的 3 种情况： 用类的已知的对象去初始化另一对象 对象作为函数的实参传递给函数形参 对象作为函数的返回值 形式： Copy_ConsFun_Name(const class_name &amp;obj_name) 自由存储对象 由堆运算符 new 和 delete 建立和删除 new 创建单个对象：根据参数调用构造函数 new 创建对象数组：调用默认构造函数 delete 删除对象：调用析构函数 new 或 delete 是显式的调用构造函数，调用的顺序取决于 new 和 delete 的顺序，析构的顺序不一定与构造的顺序相反，但对象数组中各个元素的构造和析构仍然是相反的 delete 删除对象和对象数组时各调用一次析构函数 this 指针 对象创建后，对象的每个成员函数都含有一个系统自动生成的隐含指针，用于保存该对象的地址 “指向本对象的指针” 成员函数所属的对象指针，指向类对象的地址 成员函数可以通过该指针知道自己属于哪个类 this -&gt; 成员变量 可用于区分形参变量和对象成员变量（形参变量和成员变量标识符一致时更加明显） 一般不写，系统默认设置，但要注意： 只能在类的成员函数中使用，指向该函数被调用的对象，一般用于返回当前对象本身 静态成员函数没有 this 指针 编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。 友元函数没有 this 指针 （因为友元函数不属于任何类） 静态成员类中的非静态成员，每个类对象都有一个拷贝（副本），相互独立；而静态成员便是解决同一类的不同对象之间的数据和函数共享问题的，即不管该类拥有多少对象，其静态成员都只有一个副本，该副本被所有对象共享。 表示整个类范围的信息，以 static声明 静态数据成员 静态数据成员的值对所有对象都是一样的，但每个对象可以更新其值 必须初始化，格式为：数据类型 类名 :: 静态数据成员名 = 值 初始化在类体外进行，且前面不加 static，以免与一般静态变量或对象相混淆 初始化时使用作用域运算符来表明所属的类，因静态数据成员是类的成员 初始化时不加该成员的访问权限控制符 若静态数据成员为 public，可在程序中引用该成员：类名 :: 静态数据成员，此时若未初始化，编译系统会自动赋值 0 也即：静态成员变量既可以通过对象名引用（obj.static_memb），也可通过类名引用（class_name::static_memb） 静态成员函数 用于访问类中保护或私有成员的公有接口 以 static 声明，属于类，由所有对象共享 可在类内/外定义，类外定义时不加 static 对对象的访问： 可直接访问类中说明的静态成员，但不能是非静态成员 非静态成员需通过参数传递的方式得到对象后再通过对象访问 main() 函数中对静态函数的调用：类名 :: 静态成员函数名 (参数可选)或 对象名.静态成员函数名 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 常成员对于既需要共享，又不希望其值被改变的数据，可定义为常成员进行保护，保证其在整个程序运行期间不可改变，用 const修饰符定义 常对象使用 const 关键字修饰的对象 类名 const 对象名 或 const 类名 对象名 常对象必须有初值，且不能被更新 常对象只能调用类中的常成员函数 常成员函数使用 const 关键字说明的成员函数 返回类型 成员函数名 (参数) const 函数实现部分也要带有 const 关键字：type class_name :: memb_fun(argu) const 不能更新对象的数据成员，也不能调用类中没有用 const 修饰的函数 const 关键字可用于对重载函数的区分 常数据成员使用 const 关键字修饰的数据成员 const type name 定义必须出现在类体中 必须通过构造函数的成员初始化列表进行初始化（唯一的方法），且不能被更新，格式： 类名 :: 类名(形参) ：常数据成员 (赋值) 123456789101112class VLA&#123;private: const int m_len; int *m_arr;public: VLA(int len);&#125;;//必须使用初始化列表来初始化 m_lenVLA::VLA(int len): m_len(len)&#123; m_arr = new int[len];&#125; 友元 解决类外访问类的私有和保护成员 友元机制允许一个类授权其他的函数访问其非公有成员，减小开销，提高程序运行效率 友元声明 关键字： friend 只能在类的声明中出现 友元函数 在类体中以 friend 声明，独立于当前类的外部函数 可以是不属于任何类的非成员函数，也可以是其他类的成员函数，可访问该类中的私有成员 friend 数据类型 友元函数名 (形参) 在类定义时声明，一般在类外定义友元函数（类中声明，类外定义） 普通友元函数（即类的非成员函数）引用类的私有成员时，需通过对象，即对象名.的形式，因普通友元函数不是类的成员函数 一个函数可被多个类声明为友元函数 友元类类B为A的友元类，则： B 中的所有成员函数都是 A 的友元函数，可访问 A 的所有成员 friend 类名 友元类不具有对称性：B是A的友元类，但A不是B的 友元类不具有传递性：A是B的友元类，B是C的友元类，不代表A是C的友元类 对象数组 数组元素是对象，且每个元素是同一个类的对象 定义：类名 数组名 (元素个数可选) 访问：数组名[下标可选].成员名 创建类的对象数组的条件： 没有给出构造函数，调用系统默认构造函数 有一个不带参数的构造函数 一个构造函数的参数全是默认参数 对象数组的生命周期结束时，默认给每个元素调用一次析构函数，也可通过 delete 强制调用,，构造同理 若定义对象数组时没有使用初始化列表进行初始化，则会为每个对象调用默认构造函数 若初始化项少于数组中的对象，则对剩余的对象调用默认构造函数 成员对象 一个类的成员是另一个类的对象 class c &#123; c1 obj1; c2 obj2; &#125;; 类中有成员对象时，该类的构造函数要调用这些成员对象所在类的构造函数，并采用初始化列表进行初始化 构造函数的调用顺序取决于类中的说明顺序，析构的调用相反 只能调用成员对象的公有函数或变量 继承与派生基本概念 继承：在现有类的基础上创建新类，新类得到已有类已经具备的特性 派生：从已有类（基类）产生一个子类（派生类） 单继承、多继承 基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样 派生类将基类的所有成员全部接收过来，除了构造和析构函数 派生类可对基类初始化 派生类对基类的访问 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 基类中的私有成员在派生类中不可访问，只能在基类访问 派生类中可访问基类中的公有和保护成员 派生类的析构和构造函数基类的构造和析构不能被继承，故派生类的构造函数须调用基类的构造函数以初始化，同理，对派生对象的清理也需要新的析构函数 派生类的构造函数 问题： 考虑新增成员的初始化 考虑基类成员的初始化 解决： 执行派生类的构造函数时，调用基类的构造，注意是调用基类的构造函数，不是声明 执行顺序： 调用基类的构造函数：按照定义派生类时基类的声明顺序进行，而与派生类构造函数的成员初始化列表给出的顺序无关 12class son_class:public dad_class1(x), dad_class2(x1) &#123;&#125;//调用构造函数时先调用基类 dad_class1 的构造，接着调用 dad_class2 的 调用成员对象的构造函数：派生类中有多个成员对象时，按照派生类中声明成员对象的顺序进行，同样与初始化列表无关 1234567class son_class:public dad_class1(x), dad_class2(x1) &#123; dad_class2 c2; dad_class1 c1; …&#125;//调用构造函数时先调用基类 dad_class2 的构造，接着调用 dad_class1 的 执行派生类构造函数体中的内容，完成对派生类的初始化 派生类中既有对基类的声明，又有成员对象时，先调用基类的构造函数，再调用成员对象所属类的构造函数，最后调用派生类自己的构造 1234567class son_class:public dad_class1(x)&#123; dad_class2 c2; son_class(……) &#123;……&#125; …&#125;//先调用基类 dad_class1 的构造，接着调用 dad_class2 的，最后调用自身的 派生类的析构函数调用过程与构造相反 对派生类普通成员清理 调用成员对象的析构，对派生类新增的成员对象清理 调用基类析构，对基类清理 多继承与虚基类多继承中的二义性 一个派生类有两个或多个基类 在派生类中对基类的访问应该是唯一的 在多继承情况下，派生类对基类中某个成员的访问出现不唯一的情况，即产生二义性 产生二义性问题的两种情况： 多继承中，有两个或两个以上的基类存在同名成员，采用对象名.函数名直接调用时无法判断属于哪个类 解决方法有二： 通过作用域运算符进行限定，指定是哪个基类的函数 对象名.基类名 :: 成员函数名() 在派生类中定义同名成员以屏蔽基类中二义性的成员，但此时仍然可通过 :: 指定访问 一个派生类从多个基类派生，且这些基类有一个共同的基类时，派生类访问该共同基类的成员时产生二义性 解决方法同上，但更优的方法是虚基类 虚基类（虚继承）http://c.biancheng.net/view/2280.html 解决二义性问题，将共同基类定义为虚基类，方式如下 定义 class c_name : virtual 继承方式 基类名 class c_name : 继承方式 virtual 基类名 注意 虚基类是在声明派生类时，指定继承方式时声明的 虚基类派生的类，只产生一个虚基类子对象 （可以理解为在派生类中只保留了一份共同基类的成员，这样就不会产生歧义了） 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 虚基类的构造函数 虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。 直接或间接继承虚基类的派生类，其构造函数的成员初始化列表中，都列出了对虚基类构造函数的调用，而在最后的派生类中，除了对直接基类的初始化，还要对虚基类初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;//虚基类Aclass A&#123;public: A(int a);protected: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;//直接派生类Bclass B: virtual public A&#123;public: B(int a, int b);public: void display();protected: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125; // B 的直接继承中调用了A 的构造void B::display()&#123; cout&lt;&lt;&quot;m_a=&quot;&lt;&lt;m_a&lt;&lt;&quot;, m_b=&quot;&lt;&lt;m_b&lt;&lt;endl;&#125;//直接派生类Cclass C: virtual public A&#123;public: C(int a, int c);public: void display();protected: int m_c;&#125;;C::C(int a, int c): A(a), m_c(c)&#123; &#125; // C 的直接继承中调用了A 的构造void C::display()&#123; cout&lt;&lt;&quot;m_a=&quot;&lt;&lt;m_a&lt;&lt;&quot;, m_c=&quot;&lt;&lt;m_c&lt;&lt;endl;&#125;//间接派生类Dclass D: public B, public C&#123;public: D(int a, int b, int c, int d);public: void display();private: int m_d;&#125;;// D 的间接继承中调用了直接继承 B、C 的构造，以及间接继承 A 的构造D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d)&#123; &#125;void D::display()&#123; cout&lt;&lt;&quot;m_a=&quot;&lt;&lt;m_a&lt;&lt;&quot;, m_b=&quot;&lt;&lt;m_b&lt;&lt;&quot;, m_c=&quot;&lt;&lt;m_c&lt;&lt;&quot;, m_d=&quot;&lt;&lt;m_d&lt;&lt;endl;&#125;int main()&#123; B b(10, 20); b.display(); C c(30, 40); c.display(); D d(50, 60, 70, 80); d.display(); return 0;&#125; 子类型关系（向上转型）类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。 虚函数与多态性多态 同一接口为不同的对象服务 分类 编译时的多态：通过函数重载和模板实现，在编译阶段确定调用哪个函数，实现机制称为“静态绑定” 运行时的多态：只有在运行时才知道是哪个函数，“动态绑定” 多态是通过虚函数实现的 虚函数 指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数 通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数 而虚函数允许在派生类中定义与基类同名的函数，且可用基类的指针或引用访问基/派生类中的同名函数 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism） C++中虚函数的唯一用处就是构成多态，有了多态，只需要一个指针变量就可以调用所有派生类的虚函数 虚函数可以是另一个类的友元函数，但不能是静态成员函数、内联函数、构造函数 派生类中可以重新定义从基类继承下来的虚函数，也可以不需要。但在派生类中重新定义虚函数时，函数名、形参表、返回值类型必须保持不变 换句话说，虚函数使得派生类可以更改（其实是覆盖）基类中的同名函数 若基类声明了虚函数，则在派生类中凡与该函数同名，同类型，同参数个数的均为虚函数 虚析构函数 一般情况下，清理派生类的对象时先调用派生类的析构，再调用基类的析构 但若用 new 建立了临时对象，如果基类中有析构，且定义了一个指向基类的指针变量，那么程序在用带指针参数的 delete 撤销对象时，系统只调用基类的析构 故若要调用派生类的析构函数，就要将其声明为虚函数，即虚析构函数 纯虚函数 在基类中给派生类预留一个虚函数的名，但基类不知道拿这个函数干嘛，留给派生类补充函数体 即基类无法确定一个虚函数的具体操作方式或者内容，只能靠派生类提供该虚函数的具体实现方式，即为纯虚函数 virtual 类型 函数名 (参数表) = 0； 纯虚函数没有函数体 “=0” 并不是返回值为 0，只是告诉编译系统这是纯虚函数 是声明语句，所以句尾要有分号 将一函数声明为纯虚函数，仍可以有函数体，即纯虚函数的标志是 “=0”，而不是有无函数体 纯虚函数不得声明为内联函数 抽象类 拥有纯虚函数的类称为抽象类（一般为基类） 抽象类不能用来定义对象 若抽象类的派生类没有重新定义来自基类的纯虚函数，则该函数在派生类中亦是纯虚函数，派生类也为抽象类，而派生类可将重定义纯虚函数的任务转交给自己的派生类 几点说明： 只要基类包含一个或多个纯虚函数，就是抽象类，抽象类不能用于定义对象 在类的层次结构中，顶层或上面几层皆可为抽象基类，抽象基类是各类的共性 抽象基类是本类族的公共接口 抽象类可以实现多态，道理同虚函数 只有类中的虚函数才能声明为纯虚函数，普通的函数不能 12345678//顶层函数不能被声明为纯虚函数void fun() = 0; //compile errorclass base&#123;public : //普通成员函数不能被声明为纯虚函数 void display() = 0; //compile error&#125;; 运算符重载概念 运算符重载是多态的体现 C++ 把重载的运算符看做特殊的函数，称为运算符函数，故运算符重载就是函数重载的一种 运算符重载是对现有运算符的重载，不能利用重载创造新的运算符 不能重载的运算符：. 、·* 、-&gt;* 、:: 、?: 不得为运算符函数设置默认值，故在调用时不能省略实参 任何运算符在作为成员函数重载时不得重载为静态成员函数，new 和 delete 除外 只能作为成员函数重载：=、[]、()、-&gt;以及所有的类型转换运算符 关键字：operator 返回类型 operator 运算符 (参数表) &#123;&#125; 返回类型不能是 void 运算符重载函数也是函数，满足函数的一切性质 运算符重载的两种形式成员函数形式和友元函数形式，都可以访问类的私有成员 成员函数形式 定义：返回类型 operator 运算符 (参数表) 可将 operator 运算符部分看做是一个函数名 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class complex&#123;public: complex(); complex(double real, double imag);public: //声明运算符重载 complex operator+(const complex &amp;A) const; void display() const;private: double m_real; //实部 double m_imag; //虚部&#125;;complex::complex(): m_real(0.0), m_imag(0.0)&#123; &#125;complex::complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;//实现运算符重载complex complex::operator+(const complex &amp;A) const&#123; complex B; B.m_real = this-&gt;m_real + A.m_real; B.m_imag = this-&gt;m_imag + A.m_imag; return B;&#125;void complex::display() const&#123; cout&lt;&lt;m_real&lt;&lt;&quot; + &quot;&lt;&lt;m_imag&lt;&lt;&quot;i&quot;&lt;&lt;endl;&#125;int main()&#123; complex c1(4.3, 5.8); complex c2(2.4, 3.7); complex c3; c3 = c1 + c2; c3.display(); return 0;&#125;//结果 6.7 + 9.5i 执行 c3 = c1 + c2时，编译器检测到 +左边是一个 complex 的对象，故会调用成员函数 operator +()，将该式转换为 c3 = c1.operator(c2)，即对象 c3 调用重载的成员函数，该函数的参数是 c2。 所以说，重载为成员函数时，由于具有隐含的 this 指针，一般参数只有一个。对双目运算符如上述的 + 运算符，一般参数是第二个操作数；而对单目运算符，参数表为空。 友元函数形式 定义：friend 返回类型 operator 运算符 (参数表) 注意： 友元函数没有 this 指针，故对双目运算符，友元函数有两个参数；对单目运算符有一个参数 典型运算符的重载重载负运算符 “-” 一元运算符，作为成员函数重载时，参数为空，存在默认的 this 指针；以友元函数重载时，参数为1个。 重载加运算符 “+” 同前例子 重载自增/减运算符 “++/- - ” 作为类的成员函数重载 前缀运算：返回类型 operator ++ () 后缀运算：返回类型 operator ++ (int) 作为类的友元函数重载 前缀运算：friend 返回类型 operator ++ (参数 1) 后缀运算：friend 返回类型 operator ++ (参数 1，int) 为了与前缀运算符区别，c++ 编译器设定在后缀运算符重载函数中增加一个实际并不使用的整形参数，以示区别 以自增为例，前缀自增是先增1，用增 1 后的值参与运算，故返回的是增1之后运算的值，内部也增 1；后缀自增是先参与运算，运算完毕之后再增 1，故返回的是对象本身，内部依然增 1 重载类型转换运算符 “long” 必须作为成员函数重载 类型名就是返回值类型，故不需要声明返回值类型 operator long（参数表） 重载赋值运算符 “=” 必须作为成员函数重载 类中出现指向动态空间的指针时重载 注意： 返回值应声明为引用，但在函数体中通常使用return * this；语句返回 若参数被声明为指针或引用，一般应加上 const 修饰 一般拷贝函数也会同时出现 重载复合赋值运算符 “+/-/*=” 两种重载形式均可 当重载为友元函数时，需要两个参数，且第一个参数应声明为引用 重载关系运算符 “&gt;、&lt;、==” 返回逻辑值，即返回类型为 bool 重载下标访问运算符 “[]” 只能重载为成员函数 返回类型 operator [] (下标形参，一般为整型) 重载 C++ 流运算符 “&gt;&gt; / &lt;&lt;” 只能重载为非成员函数，一般为友元函数 friend istream&amp; operator &gt;&gt; (istream&amp;, 类名&amp;) friend ostream&amp; operator &lt;&lt; (ostream&amp;, 类名&amp;) 之所以返回 i/ostream 类对象的引用，是为了能够连续读取/输出 模板函数模板概念 一系列相关函数的模型或样板，这些函数的源代码相同，只是针对不同的数据类型 对函数模板而言，数据类型是其参数，故是一种参数化 类型 的函数 格式：template &lt;模板形参表声明&gt; 函数声明 模板形参表声明可以是多个，中间用逗号隔开 模板形参的形式： typename 参数名 class 参数名 类型修饰 参数名 关键字 typename 与 class 完全等价，两者声明的参数为 虚拟类型参数，即指定这个参数名是一种类型，而这种类型只有实例化时才知道是什么类型，其即可做函数的返回值，也可做形参的类型，还可做函数体内变量的类型；而 类型修饰 声明的参数为常规参数，形式上与普通函数的声明相同。 123456template&lt;typename T&gt; //此处可换行，但不能有分号void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125; 模板函数的实例化 函数模板中声明的函数称为 模板函数 编译系统生成函数模板的某个具体版本的过程称为函数模板的实例化 模板实参的省略 模板函数的调用格式：模板函数名 &lt;模板实参表&gt;（函数实参表） 调用一个模板函数时，编译系统需要足够的信息判断每个虚拟类型参数对应的实际参数，主要从 模板实参表 和 函数实参表 中获取信息，且后者优先于前者，如从后者获取的信息足够判断虚拟类型的具体参数，而它们恰好是参数表中最后的若干参数，则模板实参中的那几个参数可以省略，若都被省略，则 &lt;&gt; 为空，也可省略 12345//如上例，调用可分几种：Swap&lt;int, int&gt;(&amp;a, &amp;b);Swap&lt;int&gt;(&amp;a, &amp;b);Swap&lt;&gt;(&amp;a, &amp;b);Swap(&amp;a, &amp;b); 不能省略模板实参的情况： 从模板实参表获得的信息有矛盾 若一个函数实参中获得的是 int，另一个则是 float，显然 T 不能同时为 int 和 float，为此，可将其中一个显示的给出 T 的类型 123int a = 10;float b = 1;Swap&lt;int&gt;(&amp;a, &amp;b); //将 float 强制转为 int 需要获得特定的返回值，而不管参数的类型如何 123int a = 10;float b = 1;Swap&lt;double&gt;(&amp;a, &amp;b); //将 int，float 强制转为 double 虚拟参数类型没有出现在模板函数的形参表中 函数模板含有常规实参 类模板概念 类模板就一系列相关类的模板，只是类型不同 模板类的声明：template &lt;模板参数表声明&gt; 类声明 类模板的成员函数可在类体内或类体外定义，在类外定义模板类（需要带上模板头）： template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; 返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表) &#123;函数体&#125; 类模板的实例化 两种方式： 类名 &lt;模板实参表&gt; 对象名 类名 &lt;模板实参名&gt; 对象名(构造函数实参表) 注意： 使用类模板定义对象时，实参不能省略，即类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。 123Point&lt;int, int&gt; p1(10, 20);Point&lt;int, float&gt; p2(10, 15.5);Point&lt;float, char*&gt; p3(12.4, &quot;东经180度&quot;); 除了对象变量，我们也可以使用对象指针的方式来实例化 12Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3);Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;(&quot;东经180度&quot;, &quot;北纬210度&quot;); 需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的： 1234//赋值号两边的数据类型不一致Point&lt;float, float&gt; *p = new Point&lt;float, int&gt;(10.6, 109);//赋值号右边没有指明数据类型Point&lt;float, float&gt; *p = new Point(10.6, 109); C++流12const int p = 1; // 应在声明时初始化，否则变量的值不确定且无法修改const int * pt;//指向常量的指针，即指针 *pt 是指向 const int 的，即 *pt 是 const的，不能修改","categories":[{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"}]},{"title":"力扣专题刷题","slug":"力扣刷题/专题刷题","date":"2022-08-19T16:00:00.000Z","updated":"2023-04-17T12:18:51.679Z","comments":true,"path":"Leetcode_group/","link":"","permalink":"https://hbroad.github.io/Leetcode_group/","excerpt":"","text":"发现菜的不行，按专题来吧，学一点是一点 参考 参考 链表203. 移除链表元素 思路一：若头结点已经是要删除的值，直接让头结点指向下一个即为删除头结点；若头结点非目标，则定义一个临时指针遍历链表，若该指针的下一节点是目标，则直接让其指向下下个节点 123456789101112131415161718192021222324252627282930class SolutionQ &#123;public: ListNodeQ* removeElements(ListNodeQ* head, int val) &#123; while(head-&gt;next != nullptr &amp;&amp; head-&gt;val == val) //头结点即相等的特殊情况 &#123; ListNodeQ *tmp = head; head = head-&gt;next; delete tmp; //C++不会自动释放内存，力扣不会报错 &#125; //头结点非相等情况 ListNodeQ *p; p = head; while(p != nullptr &amp;&amp; p-&gt;next != nullptr) &#123; if (p-&gt;next-&gt;val == val) &#123; ListNodeQ *tmp = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; delete p; &#125; else &#123; p = p-&gt;next; &#125; &#125; return head; &#125;&#125;; 思路二：创建一个节点作为虚拟头结点，让其指向头结点，那包括头结点在内的所有节点的删除方式就都一致了 1234567891011121314151617class SolutionQ2 &#123;public: ListNodeQ* removeElements(ListNodeQ* head, int val) &#123; ListNodeQ *dummy_head = new ListNodeQ; //new出来的是虚拟的头节点 dummy_head-&gt;next = head;//让虚拟头结点指向头结点 ListNodeQ *cur = dummy_head; while(cur-&gt;next) &#123; if (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; &#125; return dummy_head-&gt;next; &#125;&#125;; 707. 设计链表 包含了链表的增删改查等常见操作，采用虚拟头结点的方式，统一操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//// Created by MQRoad on 2022/08/21.//#include &lt;iostream&gt;using namespace std;class MyLinkedList&#123;public: struct LinkNode &#123; int val; LinkNode *next; LinkNode(): val(0), next(nullptr) &#123;&#125; //默认构造函数 LinkNode(int x): val(x), next(nullptr) &#123;&#125; //带单参数的构造函数 LinkNode(int x, LinkNode *next): val(x), next(next) &#123;&#125; //双参数构造 &#125;; MyLinkedList() //链表的初始化 &#123; dummyhead = new LinkNode; size = 0; //链表的长度 &#125; int get(int index) &#123; LinkNode *cur = dummyhead-&gt;next; if (index &lt; 0 || index &gt; size - 1)//本题头结点是第0个 return -1; while(index) //查找第i个值，也就是让临时指针移动i次， &#123; cur = cur-&gt;next; index--; &#125; return cur-&gt;val; &#125; //头插法 void addAtHead(int val) &#123; LinkNode *p = new LinkNode; p-&gt;val = val; //赋值 p-&gt;next = dummyhead-&gt;next;//新节点的后继是旧的头结点 dummyhead-&gt;next = p; //新节点的前驱是虚拟节点 size++; //链表长度+1 &#125; //尾插法 void addAtTail(int val) &#123; LinkNode *p = new LinkNode(val); //需要遍历得到最后一个节点的位置 LinkNode *cur = dummyhead; //临时指针用于遍历链表 while(cur-&gt;next) &#123; cur = cur-&gt;next; &#125;//循环结束cur指向最后一个节点 cur-&gt;next = p;// p-&gt;next = nullptr; //new节点的时候已经初始化了没必要再写 size++; &#125; //任意位置插入 void addAtIndex(int index, int val) &#123; LinkNode *p = new LinkNode(val); LinkNode *cur = dummyhead; if (index &lt; 0 || index &gt; size) return; while(index--) &#123; cur = cur-&gt;next; &#125; p-&gt;next = cur-&gt;next; //该程序也满足头部插入，如 n=0 位置前插入，循环不执行，其他亦满足条件 cur-&gt;next = p; size++; &#125; //删除节点 void deleteAtIndex(int index) &#123; LinkNode *cur = dummyhead; if (index &lt; 0 || index &gt;= size) return; while(index--) cur = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; size--; &#125; //打印链表 void printLinkedList() &#123; LinkNode *cur = dummyhead; while (cur-&gt;next) &#123; cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; &quot; &quot;; cur = cur-&gt;next; &#125; &#125;private: LinkNode *dummyhead; //虚拟头结点 int size; //链表长度&#125;;int main()&#123; MyLinkedList *obj = new MyLinkedList; for (int i = 0; i &lt; 10; i += 2) &#123; obj-&gt;addAtTail(i); &#125;// obj-&gt;addAtIndex(-1,2); obj-&gt;printLinkedList(); int param = obj-&gt;get(2);// cout &lt;&lt; param;&#125; 206. 反转链表 反转链表并不是说将数据 5 移动到 2 的位置，而是将链表本身反转，可参考 思路一：双指针法：利用两个指针交替完成 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *pre = nullptr; ListNode *cur = head; while(cur) &#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by MQRoad on 2022/08/21.//#include &lt;iostream&gt;using namespace std;struct mynode&#123; int val; mynode *next; mynode(int x): val(x), next(nullptr) &#123;&#125;&#125;;mynode* ini()&#123; mynode *node = new mynode(0); mynode *head = node; for (int i = 1; i &lt;= 5; ++i) &#123; node-&gt;next = new mynode(i); node = node-&gt;next;// newnode = nullptr; //构造函数已赋值 &#125; return head;&#125;//反转链表mynode* reverseLL(mynode *head)&#123; mynode *pre = nullptr; mynode *cur = head; mynode *tmp; while(cur) &#123; tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre;&#125;void printmynode(mynode *head)&#123; mynode *cur = head; while (cur) &#123; cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;; //无虚拟头结点 cur = cur-&gt;next; &#125;&#125;int main()&#123; mynode *head = ini(); printmynode(head); cout &lt;&lt; endl; mynode *newhead = reverseLL(head); printmynode(newhead);&#125; 24. 两两交换链表中的节点 思路：链表题，老老实实画图吧 为方便操作，仍然定义一个虚拟头结点 总体流程：为了让 1 2 两节点交换，先让节点 2 成为头结点的后驱，再让节点 1 成为节点 2 的后驱，最后让节点 3 成为节点 1 的后驱，后续节点依次重复，如下图： 要注意的是，在完成第一步后，cur 的指向已经变化，所以无法进行第 2-3步，因而需要在操作前保存 cur 原来的指向 1-2 完成的情况如下图： 即第三步是在前两步基础上的 cur-&gt;next-&gt;next-&gt;next 最后将 cur 后移两位，进行下一轮的交换 代码： 1234567891011121314151617181920212223242526272829303132333435//// Created by MQRoad on 2022/08/22.//#include &lt;iostream&gt;using namespace std;struct ListNode204&#123; int val; ListNode204 *next; ListNode204(int x): val(x), next(nullptr) &#123;&#125;&#125;;class sol204&#123;public: ListNode204* swappairs(ListNode204 *head) &#123; ListNode204 *dummynode = new ListNode204(0); dummynode-&gt;next = head; ListNode204 *cur = dummynode; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123; ListNode204 *tmp1 = cur-&gt;next; ListNode204 *tmp2 = cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; //步骤一 cur-&gt;next-&gt;next = tmp1; //步骤二 cur-&gt;next-&gt;next-&gt;next = tmp2; //步骤三 cur = cur-&gt;next-&gt;next; //指针后移 &#125; return dummynode-&gt;next; &#125;&#125;; 19. 删除链表的倒数第 N 个结点 思路：利用快慢指针。首先，要删除一个结点，就需要知道其前一个结点，让前一个结点指向待删除结点的下一个结点即可。如何定位到待删除结点的前一位置呢？ 同样利用虚拟头结点，并定义快慢两个指针，初始时同时指向虚拟头结点，如我们要删除倒数第二个结点： 快指针用于遍历，慢指针最终指向待删除结点的前一个结点。因此，要删掉第 n 个结点，需快指针移动 n + 1 位 然后两者同时移动直至快指针指向为空: 代码 1234567891011121314151617181920212223class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy_node = new ListNode(0); dummy_node-&gt;next = head; ListNode* slow = dummy_node; ListNode* fast = dummy_node; while(n-- &amp;&amp; fast-&gt;next) fast = fast-&gt;next; fast = fast-&gt;next; while(fast) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy_node-&gt;next; &#125;&#125;; 哈希表242. 有效的字母异位词 思路一：字母异位词指的是两个字串中每个字符出现的次数相同，那么两个字串的长度肯定相等，其次，若将字串排序，那么两字串必定相等 代码 123456789101112131415161718192021//// Created by MQRoad on 2022/09/02.//#include &lt;bits/stdc++.h&gt;using namespace std;class Solution&#123;public: bool isAnagram(string s, string t) &#123; if (s.size() != t.size()) return false; sort(s.begin(), t.end()); sort(t.begin(), t.end()); return s == t; &#125;&#125;; 思路二：哈希表：维护一个哈希表，先遍历 s 中的字符，将 s 中字符出现的次数纳入其中（因为字符只有26 个字母，故让出现的字母相对于字母 a 的位置作为哈希函数），接着遍历 t，如有相同的字符出现，减去其次数，最后哈希表为空，说明满足；否则不是。 代码： 123456789101112131415161718192021222324class Solutionana&#123;public: bool isAnagram(string s, string t) &#123; char hashtable[26] = &#123;&#125;; for (int i = 0; i &lt; s.size() ; ++i) &#123; hashtable[s[i] - &#x27;a&#x27;]++; &#125; for (int j = 0; j &lt; t.size(); ++j) &#123; hashtable[t[j] - &#x27;a&#x27;]--; &#125; for(auto k : hashtable) &#123; if(k) return false; &#125; return true; &#125;&#125;; 349. 两个数组的交集 思路：两个数组中有相同的元素，异或结果为 0，那就依次异或，但相同的元素导致输出重复，再调 STL 去重 代码： 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; num; // int tmp; for(int i = 0; i &lt; nums1.size(); i++) &#123; for(int j = 0; j &lt; nums2.size(); j++) &#123; if((nums1[i] ^ nums2[j]) == 0) num.push_back(nums1[i]); &#125; &#125; set&lt;int&gt; s(num.begin(), num.end()); num.assign(s.begin(), s.end()); return num; &#125;&#125;; 代码优化： 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; // vector&lt;int&gt; num; // int tmp; set&lt;int&gt; num; for(int i = 0; i &lt; nums1.size(); i++) &#123; for(int j = 0; j &lt; nums2.size(); j++) &#123; if((nums1[i] ^ nums2[j]) == 0) num.insert(nums1[i]); &#125; &#125; return vector&lt;int&gt; result(num.begin(), num.end()); &#125;&#125;; 思路：哈希表。同样的逻辑，数据模拟哈希表，让两个输入数组的值作为哈希表的下标，遍历完第一个数组，再去遍历第二个数组，只要查到有数组1中的值，说明是两者公有的。 代码： 1234567891011121314151617181920class Solution&#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt;&amp; nums2) &#123; int a[1001] = &#123;&#125;; set&lt;int&gt; num; for(int i = 0; i &lt; nums1.size(); i++) &#123; a[nums1[i]] = 1; &#125; for (int i = 0; i &lt; nums2.size(); ++i) &#123; if (a[nums2[i]] == 1) num.insert(nums2[i]); &#125; return vector&lt;int&gt;(num.begin(), num.end()); &#125;&#125;; 202. 快乐数 思路：哈希表，快乐数的计算过程中，各位数的平方和可能一直循环而无法收敛到 1，无序查找的问题，使用无序集合，如果本次求和的结果已经存在了，就无需再计算了，因其已经进入了循环。 代码： 1234567891011121314151617181920212223242526272829303132class Solutionidhappy&#123;public: int getSum(int n) //各位数求和 &#123; int sum = 0; while(n) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; unordered_set&lt;int&gt; setn; while(true) &#123; int sum = getSum(n); if(sum == 1) return true; if(setn.find(sum) != setn.end()) // find函数找到时返回位置，找不到返回end() return false; else setn.insert(sum); //平方和结果保存 n = sum; &#125; &#125;&#125;; 1. 两数之和 思路：暴力，遍历数组，两两相加，找到与目标值相等的保存其位置，并结束遍历（找到就不要遍历后续了） 代码 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; a; for(int i = 0; i &lt; nums.size(); i++) &#123; for(int j = i + 1; j &lt; nums.size(); j++) &#123; if(nums[i] + nums[j] == target) &#123; a.push_back(i); a.push_back(j); break; &#125; &#125; &#125; return a; &#125;&#125;; 思路：既然数组中的两数之和为目标值，则 target - i 的值一定在数组中，找到该值即可，相同的数异或为 0 代码： 12345678910111213141516171819202122class Solutionsum&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; a; for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = i + 1; j &lt; nums.size(); ++j) &#123; if (((target - nums[i]) ^ nums[j]) == 0) &#123; a.push_back(i); a.push_back(j); break; &#125; &#125; &#125; return a;&#125;; 思路：哈希表。本题不仅需要知道元素是否存在，还需要知道该元素对应的下标。set 没法存储下标，选择 map 结构，又无需有序，选择效率更高的 unordered_map，具体过程如下（图源见水印） 代码 1234567891011121314151617Class Solution&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; map; for(int i = 0; i &lt; nums.size(); i++) &#123; auto k = map.find(target - nums[i]); if(k != map.end()) return &#123;k-&gt;second, i&#125;; // map.insert(pair&lt;int, int&gt;(nums[i], i)); key 存储数组的值，value存储数组的下标 map[nums[i]] = i; &#125; return &#123;&#125;; &#125; &#125;; 454. 四数相加 II 思路：哈希法。和两数之和类似，首先进行分块，将前两个数组求和并记录和出现的次数。然后另外两个数组求和，由于总和为 0，则 0 - 该和的结果一定在哈希表中，如果查找到了，计数即可。值得注意的是，由于前两个数组求和时已经有相应的计数了，所以后续的计数是直接在前者的基础上进行迭代而非每次加 1。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by MQRoad on 2022/09/05.////#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;class Solution4sum &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; unmap; int count = 0; for(int a : nums1) for(int b : nums2) unmap[a + b]++; //该操作会查找unmap 中是否存在 (a+b),存在则对应的value++，否则 insert (a+b) for(int c : nums3) &#123; for (int d: nums4) &#123; auto k = unmap.find(0 - (c+d)); if ( k != unmap.end()) &#123; count += k-&gt;second; &#125; &#125; &#125; return count; &#125;&#125;;int main()&#123; Solution4sum sum4nums; vector&lt;int&gt; nums1 = &#123;1,2&#125;; vector&lt;int&gt; nums2 = &#123;-2,-1&#125;; vector&lt;int&gt; nums3 = &#123;-1,2&#125;; vector&lt;int&gt; nums4 = &#123;0, 2&#125;; int k = sum4nums.fourSumCount(nums1, nums2, nums3, nums4); cout &lt;&lt; k; return 0;&#125; 383. 赎金信 思路：暴力。遍历两个字串，如果 rans 中的字符和 mag 中有相等的，删掉该字符，再判断下一个是否存在。直至 rans 为空 代码： 123456789101112131415161718192021class Solution&#123;public: bool canConstruct(string ransomNote, string magazine) &#123; for (int i = 0; i &lt; magazine.size(); ++i) &#123; for (int j = 0; j &lt; ransomNote.size(); ++j) &#123; if (ransomNote[j] == magazine[i]) &#123; ransomNote.erase(ransomNote.begin() + j); break; &#125; &#125; &#125; if (ransomNote.size() == 0) return true; return false; &#125;&#125;; 思路：哈希法。字母的个数是有限的，用数组模拟哈希比较划算。统计 mag 中各字符出现的次数，再遍历 rans，次数递减，次数 &lt;0 即为失败。此外，当 rans 的长度大于 mag 时，显然是不满足的 代码： 12345678910111213141516171819202122class Solution&#123;public: bool canConstruct(string ransomNote, string magazine) &#123; int hash[26] = &#123;&#125;; if (ransomNote.size() &gt; magazine.size()) return false; for(char m : magazine) hash[m - &#x27;a&#x27;]++; for(char r : ransomNote) &#123; hash[r - &#x27;a&#x27;]--; if (hash[r - &#x27;a&#x27;] &lt; 0) return false; &#125; return true; &#125;&#125;; 字符串344. 反转字符串 思路：双指针原地反转 代码： 123456789101112131415161718192021class SolutionreverseString &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; //reverse(s.begin(),s.end()); reverse() int left = 0; int right = s.size() - 1; while (left &lt; right) &#123; char tmp; tmp = s[left]; s[left] = s[right]; s[right] = tmp; //swap(s[left],s[right]); left++; right--; &#125; &#125;&#125;; 541. 反转字符串 II 思路：按题目要求模拟 代码： 123456789101112131415class Solution &#123;public: string reverseStr(string s, int k) &#123; for(int i = 0; i &lt; s.size(); i += 2*k) &#123; if(i + k &lt;= s.size()) reverse(s.begin() + i, s.begin() + i + k); //注意 该函数反转区间是左闭右开，即不包括右边上限 else reverse(s.begin() + i, s.end()); &#125; return s; &#125;&#125;; 剑指 Offer 05. 替换空格 思路：定位空格，替换 代码： 1234567891011121314151617181920class Solution &#123;public: string replaceSpace(string s) &#123; // string str = &quot;%20&quot;; // while(1) // &#123; // if(s.find(&quot; &quot;) == string::npos) // break; // auto k = s.find(&quot; &quot;); // s.erase(k,1); // s.insert(k, str); // &#125; // return s; while(s.find(&quot; &quot;) != string::npos) s.replace(s.find(&quot; &quot;), 1, &quot;%20&quot;); //位置，长度，要替换的字串 return s; &#125;&#125;; 思路：双指针法，原地替换。两点注意：一是替换为 “%20” 后新的字串长度，二是从后往前遍历，这样就是不用考虑元素平移的问题。（因为从前面遍历替换后，后续位置的元素需全部往后移，效率低） ​ 图源及详解 代码： 1234567891011121314151617181920212223242526272829303132class Solutionreplace &#123;public: string replaceSpace(string s) &#123; int count = 0; int len = s.size(); for (int i = 0; i &lt; len; ++i) //确定空格的数量 &#123; if(s[i] == &#x27; &#x27;) count++; &#125; //确定新的数组长度 s.resize(len + 2 * count); //定义双指针，一个指向旧的数组尾部，一个指向新的数组尾部 int i = len - 1; int j = s.size() - 1; for (; i != j; i--, j--) &#123; if (s[i] != &#x27; &#x27;) s[j] = s[i]; else &#123; s[j - 2] = &#x27;%&#x27;; s[j - 1] = &#x27;2&#x27;; s[j] = &#x27;0&#x27;; j -= 2; &#125; &#125; return s; &#125;&#125;; 151. 反转字符串中的单词 思路：暴力？先找空格，按空格提取出单词放入容器，再反向遍历 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by MQRoad on 2022/09/09.//#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;using namespace std;class Solutionreverse &#123;public: string reverseWords(string s) &#123; vector&lt;string&gt; str_vec; while(1) &#123; if(s.find(&quot; &quot;) == string::npos)//找不到空格 &#123; if (s == &quot;&quot;) //特殊情况，最后一个是空格，分割后不能当做单词放入 break; else &#123; str_vec.push_back(s);//最后一个单词也要保存 break; &#125; &#125; string tmp = s.substr(0, s.find(&quot; &quot;)); if(tmp != &quot;&quot;) //单个单词 str_vec.push_back(tmp); s = s.substr(s.find(&quot; &quot;) + 1); &#125; string result; for (int i = str_vec.size() - 1; i &gt;= 0 ; i--) &#123; if (i == 0) result += str_vec[i]; else result += str_vec[i] + &quot; &quot;; &#125; return result; &#125;&#125;;int main()&#123; string s = &quot; hello world &quot;; Solutionreverse obj; cout &lt;&lt; obj.reverseWords(s); return 0;&#125; 思路：先去掉空格，再整体反转，反转后单词也被反转，故再反转单词即可 代码： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void reverse(string&amp; s, int start, int end)&#123; //翻转，区间写法：左闭又闭 [] for (int i = start, j = end; i &lt; j; i++, j--) &#123; swap(s[i], s[j]); &#125; &#125; void removeExtraSpaces(string&amp; s) &#123;//去除所有空格并在相邻单词之间添加空格, 快慢指针。 int slow = 0; //整体思想参考https://programmercarl.com/0027.移除元素.html for (int i = 0; i &lt; s.size(); ++i) &#123; // if (s[i] != &#x27; &#x27;) &#123; //遇到非空格就处理，即删除所有空格。 if (slow != 0) s[slow++] = &#x27; &#x27;; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格(第一个单词前面无需空格) while (i &lt; s.size() &amp;&amp; s[i] != &#x27; &#x27;) &#123; //补上该单词，遇到空格说明单词结束（这里是分割出单个单词的循环 s[slow++] = s[i++]; &#125; &#125; &#125; s.resize(slow); //slow的大小即为去除多余空格后的大小。 &#125; string reverseWords(string s) &#123; removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。 reverse(s, 0, s.size() - 1); int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。 for (int i = 0; i &lt;= s.size(); ++i) &#123; if (i == s.size() || s[i] == &#x27; &#x27;) &#123; //到达空格或者串尾，说明一个单词结束。进行翻转。 reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。 start = i + 1; //更新下一个单词的开始下标start &#125; &#125; return s; &#125;&#125;; 参考","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"力扣Top100","slug":"力扣刷题/力扣Top100","date":"2022-08-13T16:00:00.000Z","updated":"2023-04-17T12:18:47.047Z","comments":true,"path":"leetcode_top_100/","link":"","permalink":"https://hbroad.github.io/leetcode_top_100/","excerpt":"Leetcode Top 100","text":"Leetcode Top 100 ……","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"力扣每日一题","slug":"力扣刷题/力扣每日一题","date":"2022-08-03T16:00:00.000Z","updated":"2023-04-17T12:18:42.295Z","comments":true,"path":"Leetcode_once_day/","link":"","permalink":"https://hbroad.github.io/Leetcode_once_day/","excerpt":"刷的太少，思路只局限在暴力","text":"刷的太少，思路只局限在暴力 1422. 分割字符串的最大得分 思路：（暴力）对输入的字串分割成左右两个非空字串，再遍历左字串中字符 0 个数，由字串中字符 1 的个数；依次循环分割输入的字串，将对应的个数存入左右两个容器，遍历完所有的可能后，求和，再求最大值 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: int maxScore(string s) &#123; string strl, strr; vector&lt;int&gt; l, r; int l_tmp = 0, r_tmp = 0; for(int i = 1; i &lt; s.size(); i++) &#123; strl = s.substr(0, i); strr = s.substr(i); for(int j = 0; j &lt; strl.size(); j++) &#123; if(strl[j] == &#x27;0&#x27;) l_tmp++; &#125; l.push_back(l_tmp); l_tmp = 0; //注意累加器置0 for(int k = 0; k &lt; strr.size(); k++) &#123; if(strr[k] == &#x27;1&#x27;) r_tmp++; &#125; r.push_back(r_tmp); r_tmp = 0; &#125; vector&lt;int&gt; maxsum; for(int n = 0; n &lt; l.size(); n++) &#123; int a = l[n] + r[n]; maxsum.push_back(a); &#125; return *max_element(maxsum.begin(), maxsum.end()); //取最大值 &#125;&#125;;int main()&#123; Solution sol; string s = &quot;1111&quot;; cout &lt;&lt; sol.maxScore(s);&#125; 540. 有序数组中的单一元素 思路，根据异或运算的性质，两个相同的数异或为0，让数组元素依次异或，结果一定是只出现一次的数（代码中是依次一个一个异或，便于理解，推导过程中利用结合律、交换律，相同的数字先异或结果为0） 代码 123456789101112131415161718192021222324252627//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution3 &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = 0; int sum = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; sum ^= nums[i]; &#125; return sum; &#125;&#125;;int main()&#123; Solution3 sol3; vector&lt;int&gt; nums = &#123;1,1,2,3,3,4,4,8,8&#125;; cout &lt;&lt; sol3.singleNonDuplicate(nums); return 0;&#125; 268. 丢失的数字 思路：给定的范围是[0,n]，可求得该范围内所有数的和，用和减去现有数组中的数，结果即为缺失的数 代码 123456789101112131415161718192021222324252627282930//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int n = nums.size(); sum = (0 + n) * (n + 1)/2; //求和 for(int i = 0; i &lt; n; i++) &#123; sum -= nums[i]; //将现有元素全部减掉 &#125; return sum; &#125;&#125;;int main()&#123; Solution sol; vector&lt;int&gt; nums = &#123;9,6,4,2,3,5,7,0,1&#125;; cout &lt;&lt; sol.missingNumber(nums); return 0;&#125; https://flamsteed.github.io/tags/#HUAWEI 第一阶段: 练习字符串、数组、链表的基本操作，熟悉语言和编码手感 参考题目： 字符串，简单 1154，125，344，20，392，409，859，14，1694，551 数组，简单 1，169，53，1502，88，594，643，463， 链表，简单 234，21，141，83 第二阶段: 练习较为复杂的字符串，数组的处理 字符串，中等 468，692，151，686，1764 数组，中等56，229，347 第三阶段: 算法练习 字符串，中等，回溯93 数组，中等，回溯 39，90，46，78 数组，中等，深度优先，广度优先，417，994，385 数组，中等，滑动窗口，713 字符串，中等，滑动窗口424 动态规划，简单70 动态规划，中等64 数组，中等，双指针 16 字符串，中等，双指针15， 数组，中等，栈150","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"华为机试（牛客）","slug":"华为机试/华为机试","date":"2022-07-30T16:00:00.000Z","updated":"2023-04-17T12:31:54.861Z","comments":true,"path":"HuaWei_no_way/","link":"","permalink":"https://hbroad.github.io/HuaWei_no_way/","excerpt":"放弃啦，简历都过不了 华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了 （知道自己菜，没想到这么菜）","text":"放弃啦，简历都过不了 华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了 （知道自己菜，没想到这么菜） 参考1 参考2 https://oi-wiki.org/ HJ1 题目：查找输入字符串最后一个单词的长度 思路：字符串由空格分隔，找到最后一个空格，用整体的长度减去空格及空格前的长度，剩余的即为所求 代码： 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; getline(cin,str); // size_t len = str.size(); //总长度 // size_t found = str.rfind(&quot; &quot;); //最后空格的位置 // size_t found = str.find_last_of(&quot; &quot;); cout &lt;&lt; str.size() - str.rfind(&quot; &quot;) - 1;&#125; 分析：关键有二： 字符串的获取 cin：遇空格或制表符即停，显然无法满足 getline：可连续读取输入并存入字符串 1istream&amp; getline (istream&amp; is, string&amp; str); 最后空格的定位 find_last_of()：给定待查找的字符，从后开始查找并返回其位置 123size_t find_last_of (const char* s, size_t pos = npos) const;//可以指定从何处开始查找，即指定第二个参数//注意字符串从0开始编号 find 家族辨析：参考 1234567891011//搜索指定位置开始的第一个完全匹配的字符（串），即与指定字串完全匹配时才返回，且是第一个size_t find (const string&amp; str, size_t pos = 0); //从前往后找size_t rfind (const string&amp; str, size_t pos = npos); //从后往前找//搜索指定位置开始的第一个匹配的字符（串），只需有一个字符满足即可size_t find_first_of (const string&amp; str, size_t pos = 0); //从前往后找size_t find_last_of (const string&amp; str, size_t pos = npos); //从后往前找 //查找与指定字串不匹配的字符（串）size_t find_first_not_of (const string&amp; str, size_t pos = 0) ;size_t find_last_not_of (const string&amp; str, size_t pos = npos) ; HJ2 题目：计算某字符出现的次数 思路：读入到两个变量中，遍历字串，是否和目标字符相等，若相等则 count 增1，再判断大小写的问题，大写和小写分别判断 代码：（低质量代码） 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str,str2; //读入两行内容 getline(cin, str); getline(cin, str2); //如相等则计数器k自增1 int k = 0; for(int i = 0; i &lt; str.size(); i++) &#123; if(str[i] == str2[0]) &#123; k++; //考虑大小写一致 for(int i = 0; i &lt; str.size(); i++) &#123; if(str2[0] &lt;= &#x27;Z&#x27; &amp;&amp; str2[0] &gt;= &#x27;A&#x27;) //如目标字符是大写，则再判断其对应的小写是否有相等的 &#123; if(str[i]+0 == str2[0] + 32) k++; &#125; else if (str2[0] &lt;= &#x27;z&#x27; &amp;&amp; str2[0] &gt;= &#x27;a&#x27;) //如目标字符是小写，则再判断其对应的大写是否有相等的 &#123; if(str[i]+0 == str2[0] - 32) k++; &#125; &#125; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl;&#125; 分析： 新手，想法简单粗暴 HJ3 题目：输入随机数个数及随机数，去重排序后按行输出 思路一：（排名第一的思路，非本人想法）先确定随机数的个数（直接cin），定义一个数组，然后每次将读入的数作为数组的下标，值填充为1，然后输出数组值不为0的下标 核心：只要有重复值，对应到数组的下标还是同一个，达到既降重又排序的目的；转换思路，输入的值是下标而非数组的值 缺点：一是必须指定数组的大小是题目给定的范围，而不能动态的设置为输入随机数的个数；二是数组必须初始化，否则其中的垃圾数据会造成输入错误 代码： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int N, n; while (cin &gt;&gt; N) &#123; int a[1001] = &#123; 0 &#125;; while (N--) &#123; cin &gt;&gt; n; a[n] = 1; &#125; for (int i = 0; i &lt; 1001; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 123456789101112131415161718192021//按上述思路重写了一下，比较容易理解和看懂#include &lt;iostream&gt;using namespace std;int main()&#123; int N, n; cin &gt;&gt; N; //读入数组的大小 int a[1001] = &#123;0&#125;; //指定大小并初始化（不管数组多小，都开辟了这么多空间） for(int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; n; a[n] = 1; //以读入的数作为下标，有多少重复都无所谓（填充值非零均可） &#125; for(int i = 0; i &lt; 1001; i++) &#123; if(a[i]) cout &lt;&lt; i &lt;&lt; endl; //输出数组值非零的下标 &#125; return 0;&#125; 思路二：调用 STL，去重排序一步到位 12345678910111213141516171819#include&lt;iostream&gt;#include &lt;set&gt; //包含集合setusing namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; set&lt;int&gt; s;//自动实现去重和排序 for(int i=0;i&lt;n;i++) &#123; int x; cin&gt;&gt;x; s.insert(x); &#125; for(auto i:s) cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 分析： STL 中的 set（集合）自动将插入元素放入合适的位置（排序），同时对重复元素忽略，可以插入删除但不能更改 HJ4 题目：字符串的分割，以8为长度分割输入的字符串 思路：考虑 ==8 、8 三种情况，利用容器，把分割后的字串存入其中，最后遍历容器输出，主要利用 substr 进行字串的分割 复盘：既然以 8 为单位分割，那只要不为 8 的倍数就要补 0，用余数判断一下需要补 0 的个数，利用 append 插入，再分割输出（另外本题没有给出输出的格式，我以为是空格，结果提交发现是换行） 代码：初次写的代码，重复代码太多了，自愧不如，简单问题复杂化了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;string&gt; str; string str_tmp; cin &gt;&gt; str_tmp; int n = str_tmp.size(); if(n % 8 == 0) &#123; //按8分割 for(int i = 0; i &lt; str_tmp.size();) &#123; str.push_back(str_tmp.substr(i, 8)); i += 8; &#125; &#125; else if(n &lt; 8) &#123; for(int j = 0; j &lt; 8-n; j++) &#123; str_tmp.push_back(&#x27;0&#x27;); //小于8时判断补 0 的个数 &#125; str.push_back(str_tmp); &#125; else(n &gt; 8) &#123; int k = n / 8; //有几段以 8 为长度的 //需要补几个0 for(int j = 0; j &lt; 8 - n % 8; j++) &#123; str_tmp.push_back(&#x27;0&#x27;); &#125; //按8分割 for(int i = 0; i &lt; str_tmp.size();) &#123; str.push_back(str_tmp.substr(i, 8)); i += 8; &#125; &#125;//遍历输出 for(int i = 0; i &lt; str.size(); i++) //注意这里是补 0 后新的大小 &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125;&#125; 复盘后改进的代码：简便多了 12345678910111213141516171819202122#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; int n = str.size(); if(n % 8 != 0) &#123; str.append(8 - n % 8, &#x27;0&#x27;); //不足8位的补0 &#125; //按8分割 for(int i = 0; i &lt; str.size();) //注意这里的 size 是补 0 后新的大小 &#123; cout &lt;&lt; str.substr(i, 8) &lt;&lt; endl; i += 8; &#125;&#125; 分析： substr 的用法 单参数：从该位置开始取到末尾 双参数：从该位置开始取到指定的长度 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; string s = &quot;time&quot;; cout &lt;&lt; &quot;单参数：&quot; &lt;&lt; s.substr(2) &lt;&lt; endl; //返回 me（从位置 2 截取到尾） cout &lt;&lt; &quot;双参数：&quot; &lt;&lt; s.substr(1, 3) &lt;&lt; endl; //返回 ime（从位置1开始，截取长度3）&#125; append 的用法 向 string 后面追加字符或字符串 1234str.append(4, &#x27;0&#x27;); //在 str 后追加 4 个字符 0str.append(c); //追加 char 类型字串 cstr.append(str_tmp); //追加 string 字串str.append(str_tmp, 5, 3); //追加从位置 5 开始的长度为 3 的字串（包括位置 5） HJ5 题目：输入十六进制字串，将其转为十进制数输出（华为肯定不会考这种题） 思路：（笨人笨方法啊）先把输入的前缀0x截掉，剩下的部分依次遍历，如是字符0-9，则转为数字0-9；如是字母A-F，则转为10~15 代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; //截掉前缀 string str_tmp; str_tmp = str.substr(2); //进制转换 int n = 0; int j = (str_tmp.size() - 1); //控制幂次 for (int i = 0; i &lt; str_tmp.size(); i++) &#123; //遍历每一位 if (str_tmp[i] &gt;= &#x27;0&#x27; &amp;&amp; str_tmp[i] &lt;= &#x27;9&#x27;) //判断是否是数字 &#123; n += int(str_tmp[i] - &#x27;0&#x27;)*pow(16, j); //转为0~9 &#125; else if (str_tmp[i] &gt;= &#x27;A&#x27; &amp;&amp; str_tmp[i] &lt;= &#x27;F&#x27;)//判断是否是字母 &#123; n += (str_tmp[i] - 55)*pow(16, j); //A是65，减55是转为10~15 &#125; j--; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 其实可以直接调库的 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; int main()&#123; string str; while(cin&gt;&gt;str) &#123; cout &lt;&lt; stoi(str,0,16) &lt;&lt; endl; // 将str从位置 0 开始到末尾的 16 进制转为 十进制 &#125;&#125; HJ6 题目：质数因子，给定一个整数，输出该数的所有质数因子，包括重复值 思路：质数从 2 开始，让给定值从 2 开始遍历，能整除则继续，否则 +1 后再判断是否能整除，这样提交后内存超限 看了题解，一个数至少有一个质数因子不会超过其平方根，这样就可以从 2 遍历到其平方根，再判断是否是因子。需要注意该值本身就是质数的情况 代码： 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; long n; cin &gt;&gt; n; for(long i = 2; i &lt;= sqrt(n) &amp;&amp; i &lt;= n; i++)&#123; //从小到大的质因子，质因子不会超过它的平方根 while(n % i == 0)&#123; //所有的质数前面全部除掉，后续就不会有合因子 cout &lt;&lt; i &lt;&lt; &quot; &quot;; n /= i; //除掉质因子 &#125; &#125; if(n - 1) //前面已经除掉了所有因子，故在此判断该值是否是 1 ，不是就说明自己本身就是质数 cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;&#125; HJ7 输入浮点数，四舍五入 思路：都说了入门题了 代码： 1234567891011121314#include &lt;iostream&gt;//#include &lt;cmath&gt;using namespace std;int main()&#123; float a; cin &gt;&gt; a; // cout &lt;&lt; round(a); if(a - int(a) &gt;= 0.5) cout &lt;&lt; int(a) + 1; else cout &lt;&lt; int(a);&#125; HJ8 题目：合并表记录：给定索引及对应的值，将相同索引的值求和，并按索引升序排序输出 思路一：（题目本意是考察哈希表，这里直接暴力解决）首先读入键值对数，再将键值对存入个vector，接着遍历并判断索引号是否相等，如若相等则加到第一个上，同时将另一个清除；新建一个vector，将不为空的复制进去，调用 sort 排序再输出 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int a, b, c; vector&lt;vector&lt;int&gt;&gt; v; vector&lt;vector&lt;int&gt;&gt; v_F; vector&lt;int&gt; v_tmp; cin &gt;&gt; a; for(int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; b &gt;&gt; c; v_tmp.push_back(b); v_tmp.push_back(c); v.push_back(v_tmp); v_tmp.clear(); //注意清空 &#125; for(int i = 0; i &lt; v.size(); i++) &#123; for(int j = i+1; j &lt; v.size(); j++) &#123; if(v[i][0] == v[j][0]) &#123; v[i][1] += v[j][1]; // v[j].clear(); v[j].erase(v[j].begin(), v[j].end()); //清除元素 &#125; &#125; if(v[i].empty() == false) v_F.push_back(v[i]); //非空存入新的容器 &#125; sort(v_F.begin(), v_F.end()); //排好序 for(int i = 0; i &lt; v_F.size(); i++) &#123; cout &lt;&lt; v_F[i][0] &lt;&lt; &quot; &quot; &lt;&lt; v_F[i][1] &lt;&lt; endl; &#125;&#125; 思路二：调用 STL 的 map，其自动建立 key - value 的对应，且其中的数据是有序的，map 是一个模板类，需要 key value 两个参数，关键字 key 只能在 map 中存在一次，其增删改和容器类似，通过 pair 插入，迭代器访问，注意迭代器返回值是变化的 代码： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; //输入键值对的个数 map&lt;int, int&gt; m; //使用map容器，自带键值对数据结构 map&lt;int, int&gt;::iterator it; //map类型的迭代器 for(int i = 0; i &lt; n; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; //每行输入一个键值对 it = m.find(a); //查找键 a 是否存在，是返回所在位置，否返回 end 位置， if(it != m.end()) //如果存在，对键相同的单元的值部分求和 &#123; m[a] = it-&gt;second + b; &#125; else //若不存在生成新的键值对 &#123; m[a] = b; &#125; &#125; for(it = m.begin(); it != m.end(); it++) &#123; //遍历输出 cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0;&#125; HJ10 题目：字符个数统计，输入一个字符串，输入该字串中不重复的字符个数 思路一：利用集合set的自动降重功能，将字符串拆分成字符插入其中，再求集合的 size 即可（需要遍历整个字串，耗时） 代码： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; string str_tmp; set&lt;char&gt; str; while(getline(cin, str_tmp)) &#123; for(int i = 0; i &lt; str_tmp.size(); i++) &#123; str.insert(str_tmp[i]); &#125; &#125; cout &lt;&lt; str.size();&#125; 思路二：哈希表，待补充 HJ11 题目：数字颠倒，将输入的整数以字符串的形式逆序输出 思路：将整数转为字串类型，再利用函数翻转输出 代码： 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; string str; str = to_string(n); //int2string转换 reverse(str.begin(),str.end()); //逆序 cout &lt;&lt; str;&#125; HJ12 题目：反转字符串 思路：同HJ11 代码： 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); cout &lt;&lt; str;&#125; HJ13 题目：句子逆序，给定一个句子，逆序输出（非逆序字母） 思路：遍历字串找到空格，找到一个空格后，空格前的分割出来存下，空格后的分割出来继续找空格，循环直至字串中没有空格 代码： 12345678910111213141516171819202122232425262728293031323334353637//// Created by MQRoad on 2022/08/15.//#include&lt;iostream&gt;#include&lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; string str; getline(cin, str); int n = str.size(); vector&lt;string&gt; str_vec; for(int i = 0; i &lt; n; i++) &#123; if(str.find(&quot; &quot;) != string::npos) //有空格时 &#123; str_vec.push_back(str.substr(0,str.find(&quot; &quot;))); str = str.substr(str.find(&quot; &quot;) + 1); n = str.size(); //分割后新字串长度 i = 0; //新的字串从头开始 &#125; else &#123; str_vec.push_back(str); //最后一个单词也存一下 break; &#125; &#125; //输出 for (int i = str_vec.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; str_vec[i] &lt;&lt; &quot; &quot;; &#125;&#125; HJ14 题目：字符串按字典序列排序 思路：偷个懒，直接调库函数排序吧 代码： 123456789101112131415161718192021222324252627282930313233//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;string&gt; str; string str_tmp; int n; cin &gt;&gt; n; while(n) &#123; cin &gt;&gt; str_tmp; str.push_back(str_tmp); n--; &#125; sort(str.begin(),str.end()); for (auto k: str) &#123; cout &lt;&lt; k &lt;&lt; endl; &#125; // vector&lt;string&gt;::iterator it; // for(it = str.begin(); it &lt; str.end(); it++) // &#123; // cout &lt;&lt; *it &lt;&lt; endl; // &#125;&#125; HJ15 题目：int型整数的二进制中1的个数 思路一：笨人笨办法，先转成二进制，二进制顺序无所谓，再数 1 的个数 代码： 12345678910111213141516171819202122232425262728//// Created by MQRoad on 2022/08/15.//#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; string str; cin &gt;&gt; n; vector&lt;int&gt; k; int j = 0; while(n) //转二进制 &#123; k.push_back(n%2); n /= 2; &#125; for (int i = 0; i &lt; k.size(); ++i) &#123; if (k[i] == 1) j++; &#125; cout &lt;&lt; j;&#125; 思路二：用STL，bitset 代码： 1234567891011121314151617181920//// Created by MQRoad on 2022/08/15.//#include&lt;bitset&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; bitset&lt;32&gt; set(n); //题目要求大小不超过32// for (int i = 0; i &lt; set.size(); ++i)// &#123;// cout &lt;&lt; set[i];// &#125; cout &lt;&lt; set.count(); //直接返回 1 的个数&#125; 思路三：位运算：将整数对应的二进制数的每一位与 1 进行位与运算，为此，每次将该数右移 1 位 代码： 123456789101112131415161718192021//// Created by MQRoad on 2022/08/15.//#include&lt;bitset&gt;#include&lt;iostream&gt;using namespace std;//位与运算int main()&#123; int n; cin &gt;&gt; n; int count= 0; while(n) &#123; if (n &amp; 1) count++; n &gt;&gt;= 1; //右移一位 &#125; cout &lt;&lt; count;&#125; 思路三：（我反正是想不到）位与运算还有一个性质：n&amp;n-1结果会去掉n最末尾的1。比如1110&amp;1101=1100，直接就去掉了111011101110最后的1，我们依照这个性质，不断去掉n末尾的1，直到结果为全0，去掉过程中统计去掉过多少次，即1出现的次数 123456789101112131415#include&lt;iostream&gt;using namespace std; int main()&#123; int n; cin &gt;&gt; n; int count = 0; while(n)&#123; count++; //统计+1 n &amp;= (n - 1); //去掉末尾的1 &#125; cout&lt;&lt; count &lt;&lt; endl; return 0;&#125; HJ17 题目：坐标移动，ADWS，给定的数字表示移动距离 思路一：（纯纯暴力）和HJ13类似，先把给定的字串按 “;” 分割出来，再判断分割后的首位是 ADWS 的哪位，分类讨论，小类中再判断数字是否合理 代码：（垃圾代码，真的垃圾） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// Created by MQRoad on 2022/08/16.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;//#include &lt;set&gt;using namespace std;int main()&#123; string str = &quot;S87;S7;W56;S75;A8;S84;W23;W19;W40;D73;S87;A39;W97;W78;A53;D16;D15;A50;W41;S87;D47;W56;D56;A23;A91;S25;D61;D53;D58;W88;W58;S61;D69;W74;D89;A92;D39;D62;S78;W72;W73;W35;S76;W35;S36;W39;A4;&quot;;// getline(cin,str); vector&lt;string&gt; str_vec; for(int i = 0; i &lt; str.size(); i++) &#123; if ((str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;A&quot; || (str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;D&quot; || (str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;W&quot; || (str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;S&quot; )//首位不是ADWS的就不要了 &#123; str_vec.push_back(str.substr(0, str.find(&quot;;&quot;))); &#125; str = str.substr(str.find(&quot;;&quot;) + 1); i = 0; &#125; int x = 0, y = 0; for (int i = 0; i &lt; str_vec.size(); ++i) &#123; if(str_vec[i][0] == &#x27;A&#x27;) &#123; if (str_vec[i].size() == 3) //分割后的是不是有3位，是的话说明数字有两位，两位都要判断是不是数字 &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) x -= stoi(str_vec[i].substr(1)); //字串转int &#125; else if(str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) x -= stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == &#x27;D&#x27; ) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) x += stoi(str_vec[i].substr(1)); &#125; else if(str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) x += stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == &#x27;W&#x27; ) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) y += stoi(str_vec[i].substr(1)); &#125; else if(str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) y += stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == &#x27;S&#x27;) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) y -= stoi(str_vec[i].substr(1)); &#125; else if( str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) y -= stoi(str_vec[i].substr(1)); &#125;// else// continue;// str_vec[i].size() == 2 &amp;&amp; &#125; cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y; return 0;&#125; 看了排行一的代码，思路和我一样，但是代码简洁多了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; while(cin &gt;&gt; str) &#123; //初始化坐标 int x = 0, y = 0; //存储单步操作 vector&lt;string&gt; steps; //把字符串拆分 int wordlen = 0; for(int i = 0; i &lt; str.size(); ++i) &#123; while(str[i] != &#x27;;&#x27;) wordlen ++, i ++; steps.push_back(str.substr(i - wordlen, wordlen)); wordlen = 0; &#125; //分解成功 //for(auto x : steps) cout &lt;&lt; x &lt;&lt; endl; //对单个steps执行坐标变换 for(int i = 0; i &lt; steps.size(); ++i) &#123; int num = 0; //长度3 A10 if(steps[i].length() == 3 &amp;&amp; steps[i][1] &lt;= &#x27;9&#x27; &amp;&amp; steps[i][1] &gt;= &#x27;0&#x27; &amp;&amp; steps[i][2] &lt;= &#x27;9&#x27; &amp;&amp; steps[i][2] &gt;= &#x27;0&#x27;) num = (steps[i][1] - &#x27;0&#x27;) * 10 + steps[i][2] - &#x27;0&#x27;; //长度2 A5 if(steps[i].length() == 2 &amp;&amp; steps[i][1] &lt;= &#x27;9&#x27; &amp;&amp; steps[i][1] &gt;= &#x27;0&#x27;) num = steps[i][1] - &#x27;0&#x27;; switch(steps[i][0])//ASDW &#123; case &#x27;A&#x27;: x -= num; break; case &#x27;D&#x27;: x += num; break; case &#x27;W&#x27;: y += num; break; case &#x27;S&#x27;: y -= num; break; default: break; &#125; &#125; cout &lt;&lt; x &lt;&lt; &#x27;,&#x27; &lt;&lt; y &lt;&lt; endl; &#125; return 0;&#125; HJ20 题目：密码合格验证：大于8位；大小写、数字、其他符号中的至少三种；不能有三个字符重复 思路：分类判断：一是判断是否有三种类型，二是判断是否有重复 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by MQRoad on 2022/08/17.//#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int is3kind(string str)&#123; int count[4]=&#123;0&#125;; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;) count[0] = 1; else if (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) count[1] = 1; else if (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) count[2] = 1; else count[3] = 1; &#125; return count[0] +count[1] + count[2] + count[3];&#125;bool isrepet(string str)&#123; for (int i = 0; i+3 &lt; str.size(); ++i) //i+3超过str长度就无需判断了 &#123; if(str.find(str.substr(i,3), i + 3) != string::npos) //每次将输入字串截取3个，判断3个之后是否有相同 return true; &#125; return false;&#125;int main()&#123; string str; while(cin &gt;&gt; str) &#123; if (str.size() &lt;= 8||is3kind(str)&lt;3|| isrepet(str)) cout &lt;&lt; &quot;NG&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl; &#125;&#125; HJ21 题目：密码转换：按手机键盘九键，将小写字母转为对应的数字，大写字母转为对应小写的后一位，Z的直接转为a再转为数字 思路：（笨办法，暴力）先将小写字母转为数字，再将大写转为数字 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;c&#x27;) str[i] = &#x27;2&#x27;; else if (str[i] &gt;= &#x27;d&#x27; &amp;&amp; str[i] &lt;= &#x27;f&#x27;) str[i] = &#x27;3&#x27;; else if (str[i] &gt;= &#x27;g&#x27; &amp;&amp; str[i] &lt;= &#x27;i&#x27;) str[i] = &#x27;4&#x27;; else if (str[i] &gt;= &#x27;j&#x27; &amp;&amp; str[i] &lt;= &#x27;l&#x27;) str[i] = &#x27;5&#x27;; else if (str[i] &gt;= &#x27;m&#x27; &amp;&amp; str[i] &lt;= &#x27;o&#x27;) str[i] = &#x27;6&#x27;; else if (str[i] &gt;= &#x27;p&#x27; &amp;&amp; str[i] &lt;= &#x27;s&#x27;) str[i] = &#x27;7&#x27;; else if (str[i] &gt;= &#x27;t&#x27; &amp;&amp; str[i] &lt;= &#x27;v&#x27;) str[i] = &#x27;8&#x27;; else if (str[i] &gt;= &#x27;w&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) str[i] = &#x27;9&#x27;; else if (str[i] == &#x27;0&#x27;) str[i] = &#x27;0&#x27;; else if (str[i] == &#x27;1&#x27;) str[i] = &#x27;1&#x27;;// cout &lt;&lt; str[i]; &#125; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Y&#x27;) str[i] += 32 + 1; if (str[i] == &#x27;Z&#x27;) str[i] = &#x27;a&#x27;; cout &lt;&lt; str[i]; &#125;&#125; 优化代码：上述代码遍历了两次，优化如下 1234567891011121314151617181920212223242526272829303132333435//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; for(int i = 0; i &lt; s.size(); i++) &#123; if(s[i] &lt;= &#x27;9&#x27; &amp;&amp; s[i] &gt;= &#x27;0&#x27;) cout &lt;&lt; s[i]; else if(s[i] &lt; &#x27;Z&#x27; &amp;&amp; s[i] &gt;= &#x27;A&#x27;) &#123; s[i] = s[i] + 33; cout &lt;&lt; s[i]; &#125; else if(s[i] == &#x27;Z&#x27;) cout &lt;&lt; &quot;a&quot;; else if(s[i] &lt;= &#x27;z&#x27; &amp;&amp; s[i]&gt;= &#x27;a&#x27;) &#123; if(s[i] &lt;= &#x27;c&#x27; &amp;&amp; s[i] &gt;= &#x27;a&#x27;) cout &lt;&lt; &quot;2&quot;; if(s[i] &lt;= &#x27;f&#x27; &amp;&amp; s[i] &gt;= &#x27;d&#x27;) cout &lt;&lt; &quot;3&quot;; if(s[i] &lt;= &#x27;i&#x27; &amp;&amp; s[i] &gt;= &#x27;g&#x27;) cout &lt;&lt; &quot;4&quot;; if(s[i] &lt;= &#x27;l&#x27; &amp;&amp; s[i] &gt;= &#x27;j&#x27;) cout &lt;&lt; &quot;5&quot;; if(s[i] &lt;= &#x27;o&#x27; &amp;&amp; s[i] &gt;= &#x27;m&#x27;) cout &lt;&lt; &quot;6&quot;; if(s[i] &lt;= &#x27;s&#x27; &amp;&amp; s[i] &gt;= &#x27;p&#x27;) cout &lt;&lt; &quot;7&quot;; if(s[i] &lt;= &#x27;v&#x27; &amp;&amp; s[i] &gt;= &#x27;t&#x27;) cout &lt;&lt; &quot;8&quot;; if(s[i] &lt;= &#x27;z&#x27; &amp;&amp; s[i] &gt;= &#x27;w&#x27;) cout &lt;&lt; &quot;9&quot;; &#125; &#125; return 0;&#125; HJ22 题目：汽水瓶，3个空的换一瓶汽水，可以向老板要一个空瓶，但必须还给老板 思路：（看了题解我TM，这就是个智力题）3个换一个，有2个的话可以找老板要一下空的，换一瓶，喝完了还给老板，所以不管有多少空瓶，就看你有多 2，反正有 2 就可以换一瓶 代码： 1234567891011121314151617//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while ( cin &gt;&gt; n ) &#123; if(n == 0) continue; cout &lt;&lt; n/2 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"}]},{"title":"数据结构","slug":"数据结构/数据结构","date":"2022-07-29T13:20:49.000Z","updated":"2023-04-28T08:57:31.843Z","comments":true,"path":"data_structure/","link":"","permalink":"https://hbroad.github.io/data_structure/","excerpt":"","text":"宝藏级+保姆级课程-数据结构与算法基础-青岛大学-王卓老师 油管大神 时间复杂度时间复杂度：各条指令执行的时间之和 大O表示法 表示算法执行的渐进上限 性质： 任意常数 $c &gt;0$，$O(f(n))=O(cf(n))$ 常数乘以某个运算，不改变其时间复杂度（函数正的常系数可忽略等同于1） 任意常数$a&gt;b&gt;0$，$O(n^a+n^b)=O(n^a)$ 因 $a&gt;b$，故前者的影响大于后者，在整个过程中便可忽略后者的影响（低次项可忽略，保留最高次项） 空间复杂度 不计入输入本身 其他各方面消耗都计入 复杂度分析 常数时间复杂度 $O(1)$ 对数时间复杂度 $O(logn)$ 对数多项式复杂度 线性 $O(1)$ 哈希表哈希表用于判断一个元素是否出现在集合中，原理及问题 线性数据结构链表 链表结构由指针域+数据域组成 循环链表 尾部指针域指向头结点 一般使用带尾指针的循环链表 比较单链表为何在插入和删除上优于数组：对插入单个元素而言，两者并无明显优势，但若一次插入多个元素，对单链表而言，只需一次遍历，后续只需进行指针赋值等操作，故为 $O(1)$；而对数组而言，每个元素的插入和删除，伴随着插入位置后所有点的移动，为 $O(n)$。 栈 一种后入先出（LIFO）的结构 可通过数组或链表实现 主要可用于判断括号的匹配、程序中表达式是否正确 括号是否匹配：程序中的括号是否是一一对应的，比如 {[()]} 是一一对应且是正确的匹配，为了判断是否匹配，可从左至右遍历字符串，若遇到左括号，压入栈，遇到右括号时查看其与栈中的左括号是否匹配，匹配则将栈中元素弹出，否则说明括号不匹配 表达式检测：实际计算机检测时并非按我们写的表达式进行检测，其实际将其转换成前缀表示法或后缀表示法，具体参考 队列 一种先入先出（FIFO）的结构 可通过数组或链表实现 主要应用于服务请求中，如多个人同时请求打印机打印资料，此时打印机可根据请求的顺序排队，依次打印 字符串KMP算法参考 字符串匹配的快速算法，相交于暴力算法，去除了回溯（主串遇到不匹配字符时不再返回，而是一直前行），减小了时间复杂度，为$O(m+n)$，其中，$m$ 为主串长度，$n$ 为模式串长度 非线性数据结构树 一种非线性结构 典型应用： 存储分层数据：文件系统（文件和文件夹的层次结构） 快搜、增、删数据：如二叉数搜索 拼接检查：一种特殊的树 trie 网络路由算法 最常见的是二叉树 每个结点最多有两个子结点 可通过链表实现，每个节点由三部分组成，中间存储数据，左右分别存储左右子节点的地址","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://hbroad.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数字图像处理","slug":"图像处理/数字图像处理","date":"2022-07-17T03:00:47.000Z","updated":"2023-04-17T09:44:11.009Z","comments":true,"path":"digital_image_process/","link":"","permalink":"https://hbroad.github.io/digital_image_process/","excerpt":"数字图像处理基础理论（待补充） (通俗易懂的计算机视觉优质课程)北京邮电大学计算机学院-鲁鹏 参考:CS 543/ECE 549: Computer Vision （文中所有图片均摘自上述课程）","text":"数字图像处理基础理论（待补充） (通俗易懂的计算机视觉优质课程)北京邮电大学计算机学院-鲁鹏 参考:CS 543/ECE 549: Computer Vision （文中所有图片均摘自上述课程） 图像去噪（滤波）常见噪声 卷积 卷积：把相关运算的核旋转180° 线性：F(f1+f2) = F(f1)+F(f2) 平移不变形：F(S(f)) = S(F(f)) 满足线性平移不变性的操作均可定义为卷积 满足交换律、结合律、分配律 卷积时边缘的处理：边界填充 卷积核的特性导致卷积后的图像和原图不一样大 零填充（常用） 复制边缘 镜像边缘 常见核 单位脉冲核 平移核 平滑核 锐化操作 高斯卷积 平均卷积核的问题 中心与邻域的权重一致，导致振铃现象（卷积后图像出现的条状） 解决：根据邻域像素与中心的远近程度分配权重，离中心越近，权重越大 高斯卷积的生成 ​ 归一化即为 3 中各个位置权重值/总的权重值 参数的选取 大标准差或者大尺寸卷积核平滑能力强 小标准差或者小尺寸卷积核平滑能力弱 解释： 大标准差，对应的是核中中心元素的权重低于周围元素，即占比低，从而被平滑的越厉害（其实，$\\sigma$ 就是模板的模糊半径，该值越大，对应的圆越大，自然模糊的越厉害） 大尺寸，在标准差不变时，高斯函数值相等，但在归一化后，大尺寸的权重比小尺寸的小，平滑的越厉害 经验法则: 将卷积核的半窗宽度设置为 3𝜎，最终卷积模板尺寸为 2 × 3𝜎 + 1 即：只要指定一个参数 $\\sigma$ ，就可直接得到窗口大小，从而不用两个参数单独指定 为什么是 $3\\sigma$，因为大于该值以后，高斯值为 0，没有意义 高斯核特性说明 高斯核是低通滤波器，滤除图像中的高频成分 两个高斯卷积核卷积后得到的还是高斯卷积核 使用多次小方差卷积核连续卷积，可以得到与大方差卷积核相同的结果 使用标准差为 $\\sigma$ 的高斯核进行两次卷积与使用标准差 $\\sqrt 2 \\sigma$ 的高斯核进行一次卷积相同 高斯核 1 为 $f$，高斯核 2 为 $g$，两者卷积： $f$ $g$ $f\\star g$ 均值 $m_f$ $m_g$ $m_f + m_g$ 标准差 $\\sigma_f$ $\\sigma_g$ $\\sigma_f + \\sigma_g$ 可分离特性 大卷积核可分为两个一维高斯的乘积 降低计算复杂度 如 $m \\times m$ 的核卷积 $n \\times n$ 的图像 无分离时，复杂度为：$O(n^2m^2)$ 分离后，复杂度为：$O(n^2m)$ 中值滤波 用于去除椒盐噪声、脉冲噪声 使用邻域升序排列的中值作为中心像素的值 中值滤波的灰度值始终是原图像中的灰度值 卷积与边缘提取边缘图像中亮度明显而急剧变化的点（灰度不连续） 边缘种类 边缘检测 图像中灰度急剧变化的地方，其导数变化明显 图像求导 差分代替一般导数 一般2D函数的偏导为： \\frac{ \\partial f(x,y) }{\\partial x} = \\lim_{\\epsilon \\to 0} \\frac{f(x+\\epsilon) - f(x,y)}{\\epsilon} 但在数字图像中，$\\epsilon$ 不能为0，其最小单位为一个像素，故有： \\frac{ \\partial f(x,y) }{\\partial x} \\approx \\frac{f(x+1) - f(x,y)}{1} X 方向的导数提取了 Y 方向的特征， Y 同理 图像梯度 指向灰度变换最快的方向 X 方向的梯度与 Y 方向的边缘垂直，其他同理；即梯度方向与边缘垂直。具体可参考 可见，梯度向量与边缘垂直，故也称为边缘法线 梯度幅值的大小衡量了该点处是否是边的可能性的大小，越小，就说明 x 和 y 方向变换不明显，即接近平坦区域 需要对角边缘时，即需要二维核，Robert 算子采用对角性能（详见数字图像处理第四版P516） 上述核的功能在于其考虑了周围更多的邻域，减少了噪声的敏感性，以 Soble 算子为例，其可以分解为两个一维核： \\begin{bmatrix} 1 \\\\ 2 \\\\ 1 \\end{bmatrix} * \\begin{bmatrix} -1 & 0 & 1 \\end{bmatrix}可见，Sobel 是进行了高斯滤波，再进行边缘提取，故受噪声的影响较低。 注意： $3 \\times 3$ 的核：最小的中心对称核，考虑了中心对侧数据的性质 Soble 算子能够更好的平滑噪声 上图中所有的算子，权重和为 0，即在恒定灰度区域的响应为 0 （恒定区域灰度值相等，与核相乘相加为0） 梯度幅值的实现 实际中，使用平方及平方根的开销大，一般使用绝对值近似 M(x,y) \\approx |{g_x}| + |g_y| 虽计算简单，但使得滤波器不再具有各向同性（即旋转不变性） 实际情况但实际中，由于噪声的影响，求导的结果也无法得出边缘的位置 因而在求导前先平滑滤波处理 由于微分求导也是卷积，卷积具有结合性，故原图的高斯卷积与可求导结合（高斯一阶偏导核），最后和原图卷积，从而可节省一次卷积操作 高斯一阶偏导核 高斯与一阶偏导的对比 高斯核 消除高频成分（低通滤波器） 卷积核中的权值不可为负数（倒扣钟型） 权值总和为1（恒定区域不受卷积影响） 高斯一阶偏导核 高斯的导数 卷积核中的权值可以为负 权值总和是0（恒定区域无响应，急剧变化的地方响应大） 高对比度点的响应值大 Canny 检测算子 经过两个方向上高斯一阶导，得到梯度幅值图，可见，边缘较宽，这是因为在灰度斜坡上一阶导不为 0，如何得到更为准确的边缘？ 非极大值抑制 实质：规定梯度方向（边缘法线）的多个离散方向，如定义为水平、垂直、+45°、-45° 四个方向（一条边缘有正负两条边缘法线），即所有可能得边缘量化为这四个方向，但显然，边缘法线方向可能是任意的，故需要定义某个范围，落在该范围内就认为是哪个方向，该定义方式如下图所示（详见数字图像数字图像处理第四版 P526） 流程： 对任意一点，求该点的梯度幅值 $K$ 和方向 $\\alpha$ 在四种边缘法线中找到最接近梯度方向 $\\alpha$ 的，记为 $d_k$ 在 $d_k$ 方向上取一个或两个邻点，若 $K$ 小于所取点的梯度幅值，则令 $g_N(x,y) = 0$ （即抑制），否则为 $g_N(x,y) = K$（$g_N(x,y)$ 为非极大值抑制后的图像） 双阈值法 阈值过高导致细节丢失，过低则边缘杂乱 双阈值：先利用高阈值筛选出主要的边缘，再利用低阈值将这些边缘连接起来（低阈值虽然会引入噪声引起的假边，但是这种假边不会和高阈值筛选出的主要边缘有连接） Canny 整体流程： 用高斯一阶偏导核卷积图像 计算每个点的梯度幅值和方向 非极大值抑制： 将宽的“边缘”细化至单个像素宽度 连接与阈值（滞后）： 定义两个阈值：低和高 使用高阈值开始边缘曲线，使用低阈值继续边缘曲线 拟合引例在获得边缘后，接下来的问题是，对于图中的特征如何进行描述，即选择参数模型进行拟合，但实际中，面临三个问题： 噪声 局外点的影响 遮挡导致的数据丢失 为此，针对不同的情况需要不同的方法 如若知道所有点都属于一条直线，该如何找到这条最优直线？ 最小二乘 若存在外点呢？ 鲁棒最小二乘、RANSAC 若这些点属于多条直线呢？ 投票机制：RANSAC、Hough 变换 更一般的情况，不确定其是否是直线？ 模型筛选 最小二乘“垂直”最小二乘如图，对于 $n$ 个点，若其直线方程为 $y = mx + b$ ，则要使每个点到该直线的垂直距离最小化，方可说明这些点在该直线上 于是，可建立能量函数（目标函数），并使其最小化： E=\\sum_{i=1}^n (y_i -mx_i -b)^2这里之所以取平方，是因为我们只关心点到直线的距离，不关心正负。 对 $n$ 个点，有 \\begin{cases} y_1 = mx_1 + b \\\\\\\\ y_2 = mx_2 + b \\\\\\\\ \\vdots \\\\\\\\ y_n = mx_n + b \\end{cases}写成矩阵形式： Y = XB Y=\\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{bmatrix} \\qquad X=\\begin{bmatrix} x_1 & 1\\\\ x_2 & 1\\\\ \\vdots & \\vdots \\\\ x_n & 1 \\end{bmatrix} \\qquad B=\\begin{bmatrix} m \\\\ b \\\\ \\end{bmatrix}到此，前述的能量函数变为（平方和即为模）： E = ||Y-XB||^2$B$ 为待求项，$||X||$ 为向量的模，是内部元素的平方和开根号，这也是能量函数取平方的另一个好处。对一个向量 $A = \\begin{bmatrix} a_1\\\\ a_2 \\\\a_3 \\end{bmatrix} $，有： ||A|| ^2 = a_1^2 +a_2^2 + a_3^2 = A^TA故能量函数可写为： \\begin{align} E & = ||Y-XB||^2 = (Y-XB)^T(Y-XB) \\\\ & \\overset{展开}{=} (Y^T-B^TX^T)(Y-XB) \\\\ & = Y^TY - Y^TXB-B^TX^TY + B^TX^TXB \\\\ & = Y^TY-2(XB)^TY+(XB)^TXB \\end{align}为求 $B$，自然想到让 $E$ 对 $B$ 求导： \\frac{dE}{dB} = -2X^TY + 2X^TXB = 0从而求得： B = (X^TX)^{-1}X^TY 问题： 当直线垂直 x 轴时，方法失效 即不满足旋转不变性，直线转动到垂直时无法求解 全最小二乘 目的：解决垂直最小二乘的失效情况 原理 假设一点$(x_i,y_i)$ 和一直线 $ax+by=d$ （满足 $a^2+b^2=1$)，则该点到该直线的距离为 |ax_i+by_i-d|要拟合直线，即找到合适的 $(a,b,d)$ 使得所有的点到该直线的距离最小，即最小化能量函数： E=\\sum^n_{i=1}(ax_i+by_i-d)^2 \\tag{*}该函数对 $d$ 求导可得： \\frac{\\partial E}{\\partial d} = \\sum^n_{i=1} -2(ax_i+by_i-d) =0整理得： d = \\frac{a}{n}\\sum^n_{i=1} x_i + \\frac{b}{n}\\sum^n_{i=1} y_i = a\\bar{x} + b\\bar{y} \\tag{**}将其代入 (*) 式可得： E=\\sum^n_{i=1}(a(x_i-\\bar{x}) + b(y_i-\\bar{y}))^2 = || \\begin{bmatrix} x_1 - \\bar{x} & y_1 - \\bar{y} \\\\ \\vdots & \\vdots \\\\ x_n - \\bar{x} & y_n - \\bar{y} \\end{bmatrix} \\begin{bmatrix} a \\\\ b \\end{bmatrix} ||^2 = (UN)^T(UN)为求得 N，可求导： \\frac{dE}{dN}=2(U^TU)N= (U^TU)N =0根据特征值与特征向量的关系，对 $AN=\\lambda N$，要使其为 0，只能是 $\\lambda = 0$，故该方程的解为最小特征值对应的特征向量 事实上，上述的 $U^TU$ 矩阵为二阶矩矩阵，如下图，由前述(**)式可知点 $(\\bar{x},\\bar{y})$ 在该直线上，从几何角度来看，使得能量方程最小化的点即为使得任意点与该点的向量在该直线的法线上的分量最小。 鲁棒估计（鲁棒核函数）如图是最小二乘拟合的结果，可见，当出现外点（即噪声）的影响时，拟合的准确性很差 这是因为最小二乘要确保所有的点都使得能量函数最小化，所以直线朝着外点倾斜，外点距离真实直线的距离很远，拟合时所占的比重很大，为缩小这种外点的比重，引入了鲁棒估计 鲁棒估计引入鲁棒核函数 $\\rho$ ，该函数有一个缩放因子参数 $\\sigma$，通过该值可调整权重，其和距离类似，不同的是，当距离超过一定限度时，该值不再增加。以图中 $\\sigma = 0.1$ 为例，当横坐标值大于 4 时，值都为1。换句话说，对一点而言，不论该点距离直线的距离是1k还是1w，对能量函数而言其比重都为 4，这样就在一定程度上避免了外点占比过大，导致拟合精度差的问题。 缩放因子参数 $\\sigma$ 选取不同的拟合结果（一般取平均残差的1.5倍）： 合适/ 过小/ 过大 需注意的是，鲁棒拟合是一个非线性问题，须通过迭代求解，而迭代需要一个良好的初值，前述的最小二乘便可提供该初值。 RANSAC若无特殊说明，以下均以简单的直线拟合为例。 基本思想RANSAC是一种通用的模型估计思想，主要有四步： 在已有点中随机选择足够拟合某类形状的点（如拟合一条直线需要2点） 利用所选的点拟合该形状 查找剩余点，保留距离该形状较近的点，剔除外点 重复上述过程，直至找到最佳的形状 参数选择所需参数可见，我们需要指定一些参数才能使用该方法 初始点数 $s$：拟合形状所需的最小点数 距离阈值 $t$：该参数指定范围内的点是内点 采样次数 $N$：即迭代的次数 若外点率为 $e$，拟合的正确率为 $p = 0.99$，则拟合错误的概率为 $(1-p)$，内点率为 $(1-e)$，由于选择 $s$ 个进行拟合，故内点率为 $(1-e)^s$，则采样一次的错误率为 $1-(1-e)^s$，采样 $N$ 次为 $(1-(1-e)^s)^N$，从而 (1-(1-e)^s)^N=1-p对左右同时取对数： N = \\text{log}(1-p)/\\text{log}(1-(1-e)^s) 下图表显示了拟合不同的模型，当外点率不同时，要达到 0.99 的正确率所需的迭代次数 一致性点集 $d$：最终模型的内点数，应当和设置的内点率相适应，可通过设置该阈值选择保留哪些拟合结果 自适应参数选取实际使用中，我们可能压根不知道点集中的外点率，这时就需要自适应的参数选择 起初我们不知道要迭代多少次，就直接假设我们要迭代无穷次，设置一个迭代计数器（sample_count）记录迭代的次数，首次迭代时，可以计算出外点率 $e$，由外点率可计算出迭代的次数 $N$，据此便可迭代。 但在实际实验中，我们还是会指定迭代的次数，如指定 1k 或 1w，避免耗时过长。 优缺点分析 优势 简单，通用 通常能得到很好的结果 缺点 需要指定的参数多 内点率较低时，效果不好（迭代过多甚至失败） 并不总是能得到很好的初始化 实际中，在通过 RANSAC 方法获得内点后，还可继续对这些内点使用最小二乘拟合，以得到更为精确的拟合结果。 不难看出，RANSAC 实际是一种暴力的方法，通过随机选取点进行拟合，利用剩余的点进行投票，再通过设置一个阈值，只要大于这个阈值，就认为是正确的，这在匹配中应用广泛。 Hough 变换使用条件 是一种投票机制 噪声点对任何模型的投票均不具备一致性 丢失数据不影响，只要剩余的点足够拟合 整体思想 将图像空间离散化为霍夫参数空间 每个特征点都在参数空间中进行投票 投票最多的点即为所求 图像空间中的一条直线，对应参数空间中的一点（参数空间的横纵坐标是直线的参数） 图像空间中的一点，对应参数空间中的一条直线（参数空间中自变量和因变量变化了） 则对于图像空间中的两点（确定一条直线），在霍夫参数空间中对应两条直线，这两条直线的交点，即为投票最多的点 $(m^,b^)$，即为所要拟合直线的参数。换句话说，图像空间中这条直线上的所有点都经过参数空间中的交点。 但当直线是垂直线时，即 $x=a$，该直线上的所有点在参数空间中对应的直线是平行的，即没有交点，方法失效，参数空间无边界 改进方法通过极坐标表示，解决垂直直线的问题。（详见《数字图像处理》P531） 直线的极坐标参数化方程为 x\\text{cos}\\theta+y\\text{sin}\\theta=\\rho因而，图像空间中过一点的直线簇对应参数空间中的正弦曲线，交点 $(\\rho’,\\theta’)$ 即为图像空间中的直线，下图右边是参数空间划分的多个累加单元，初始时将其设为 0，对图像空间中的每个点，利用参数空间中的每个可能的 $\\theta$，计算出 $\\rho$。实际中，如果选择的 $\\theta_q$ 得到解 $\\rho_q$，则累加器增1（可以理解为给这个点头了一票），最终输出累加器最大的结果即为所求。 具体算法流程如下： 噪声的影响当存在噪声时，霍夫空间投票的结果就不再是聚焦于一点，还是一个区域，如下图 如何处理噪声? 恰当的离散化网格 既然噪声让聚焦点变成了区域，那么放大划分的网格，就让这块区域落在这一块网格中，即当做同一直线处理 但网格划分过大，会导致本来不是直线投票也被包含进来 同理，划分过细，导致本来属于一条直线的投票被去除 增加邻域投票（软投票） 类似高斯核，根据周围邻域到中心点的距离不同，投不同的票数，离得越近占比越大，中心始终占比最大 去除不相关的点 只使用梯度幅值较大的边缘点，即对每个点，通过计算其梯度方向确定角度，然后只是在该角度范围内投票 Hough 圆根据圆的方程 (x-u)^2+(y-v)^2=r^2可知，圆有三个参数 $(u,v,r)$，则霍夫空间为三维。 对于一个点，若已知半径 $r$，且圆过该点，则该圆可能的圆心是在该点梯度方向两侧，对应霍夫参数空间中的两点。 不同的半径对应不同的两点，经过投票，霍夫空间中存在一个立方体小空间，该空间中票数最高，对应的三个参数即为所求。 广义 HoughHough 变换可以推广到识别，比如下图的示例中，通过各组件与中心的方向与距离确定一个模板，在一堆混乱的组件中识别其中心，可根据模板中确定的组件方向和距离投票，最终得到票数最多的点即为中心点。实际使用中如由两车轮定位车辆中心。 优缺点 优点 不受非局部或遮挡影响 可检测多个模型 一定程度上不受噪声影响：可认为噪声点的投票不具有一致性 缺点 高维时参数空间复杂，搜索时间指数级增加 非目标模型在参数空间也可能产生极值点 参数空间的划分较难（较难确定一个比较好的划分方法） 特征检测为何提取需要提取特征？多视角拼接 特征提取特征的要求 可重复性：即使有几何变换等的影响，该特征仍能在多视角中找到 独特性：每个特征应当是独特的，否则难以匹配 高效性：考虑计算的高效性 局部性：特征只是局部的 Harris 角点原理详述见《数字图像处理》P627 角点：在各个方向移动时窗口内灰度变化大 平坦区域：各方向无变化 边：沿着边缘方向无变化 可见，为了检测角点，只需使用一个窗口进行滑动，判断窗口移动前后窗口区域内的灰度变化，如何从数学角度量化？ 如下图，红色实线框为移动前，绿色虚线框为移动后，$E(u,v)$ 表示移动前后差的平方的加权和，$\\text{w(x,y)}$ 为加权函数，主要有两种：盒式滤波器（窗口内为1，外为0）、高斯滤波器（根据距离远近分配权值） 然而，上述公式操作起来比较麻烦（每次移动后都要取像素），我们更希望有一种关系可以直接表达移动 $(u,v)$ 时两者与 $E(u,v)$ 的关系，为此，我们对上式在 $(0,0)$ 点进行泰勒展开（只保留二阶以下的项），每一项求导的结果如下： 上式可以简化为如下的矩阵形式：其中 $M$ 是二阶矩矩阵，可通过图像梯度求得 此时 $E(u,v)$ 可由 $M$ 确定，假设 $M = \\begin{bmatrix}\\lambda_1 &amp; 0 \\\\ 0 &amp; \\lambda_2 \\end{bmatrix}$，$E(u,v)=\\text{const}$ ，即： \\begin{bmatrix} u & v \\end{bmatrix} \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\tag{c1} \\frac{u^2}{(\\frac{1}{\\lambda_1})^2}+\\frac{v^2}{(\\frac{1}{\\lambda_2})^2} = \\text{const} \\tag{c2}可见结果为椭圆。 现在考虑这样一种情况，梯度方向是水平或者垂直的（即沿 x 或 y 方向的导数为 0，即 $\\lambda_1 = 0$ 或 $\\lambda_2 = 0$），那么窗口沿着垂直于梯度的方向运动时，另一个方向是不会变化的，也就是边的情况。换句话说，只要 $\\lambda_1$ 和 $\\lambda_2$ 任意一个接近于 0，那就不是角点；再者说，角点就是两者都比较大的地方。这就对前述的过程进行了量化。 如果角点是本节第一张图所示的样子，根据上述推导，易知其椭圆是一个正椭圆，但实际中显然不可能都是正椭圆，这时候就需要先对其进行旋转，旋转可由旋转矩阵表示，也就是说，如果有旋转， $M$ 的元素不再是 0，但其是一个实对称矩阵，由线代知识，可将其分解为 M= R^{-1} \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\tag{c3}根据旋转矩阵的性质：$R^{-1}=R^T$，将上式带入 (c1)式可得： \\begin{align} \\begin{bmatrix} u & v \\end{bmatrix} R^{-1} \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\\\ \\Rightarrow \\begin{bmatrix} u & v \\end{bmatrix} R^T \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\\\ \\Rightarrow (R \\begin{bmatrix} u \\\\ v \\end{bmatrix} )^T \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\end{align} \\tag{c4}$R$ 即为旋转矩阵，可见旋转到正椭圆后，就可只关注 $\\lambda$ 了 。 那么，$\\lambda$ 跟椭圆有什么关系呢？根据式(c2)可知，$\\lambda$ 越大，对应椭圆的短轴，且在该方向上梯度变化快，反之亦反之。 也就是说， $\\lambda$ 决定了椭圆的轴长，即决定了梯度变化的快慢，旋转矩阵 $R$ 则决定了其姿态 。 对 $M$ 进行可视化如下图，结果如上述推导，梯度变化的快慢决定了椭圆的形状。 二阶矩矩阵可视化 也就是说，我们只需要关注 $\\lambda$ 的大小就可知是否是角点 而在实际中，研究者觉得，要两个 $\\lambda$ 比较麻烦，实际过程中使用 $R$，通过该值判断，具体如下： 步骤 对每个像素计算高斯一阶导 在高斯窗口内计算每个像素的二阶矩矩阵 $M$ 计算角点响应函数 $R$ 设置 $R$ 的阈值 非极大值抑制以找到局部最大值（主要考虑到一块区域内存在多个在阈值范围内的极大值，可通过抑制保留最大的那个） 不变性分析 不变性(Invariance)：图像角度、光照的变化不影响角点的提取，即 $F(T(\\text{img}))=F(\\text{img})$ 协变性(covariance)：图像变换后需要经过相应的变换才能匹配，即 $F(T(\\text{img}))=T’F(\\text{img})$ 说白了，不变性就是不论图像怎么变，都能找到角点，而协变性是图像变了之后虽然能找到，但是经过相应的变换之后才能匹配。 灰度仿射变换 仅灰度是具有不变性的，对同一点，增加其灰度和减小其灰度，求导后其趋势不变 但灰度缩放导致部分点超过阈值，缩放前后不满足不变性 即灰度仿射变换满足部分不变性 说明：$I{out} = aI{in}+b$，$a$ 控制图像的对比度（即白的更白，黑的更黑），$b$ 控制其亮度的增减 图像平移变换满足协变性 平移之后角点的位置变化了，需要通过一个变换 $T$ 才能得到平移前的角点 图像旋转变换满足协变性 如下图，图像旋转之后，二阶矩矩阵对应的椭圆发生了旋转，但椭圆的轴未变，和平移类似，都能找到角点，但要经过旋转变换才能得到原来的点 不满足尺度不变性 对缩放这种尺度变换而言，放大后，角点就已经检测不到了，所有的点都会检测为边 Harris角点无法检测尺度变化的角点，那有没有尺度不变的检测算法呢，答案是肯定的！ 斑点（Blob）检测拉普拉斯核前述提到的 Harris 角点检测算法尺度缩放后无法检测，我们需要一种算法满足尺度协变性，即：不论图像中的特征被放大还是缩小，该算法都可以准确的检测该特征。 高斯一阶导可用于检测边缘，这里引出高斯二阶导： 高斯函数的一般形状为： G(x,y)=e^{-\\frac{x^2+y^2}{2\\sigma^2}}对高斯二阶导： \\begin{align} \\nabla^2G(x,y) & = \\frac{\\partial^2G(x,y)}{\\partial x^2}+\\frac{\\partial^2G(x,y)}{\\partial y^2} \\notag\\\\ & = \\frac{\\partial}{\\partial x}(\\frac{-x}{\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}})+\\frac{\\partial}{\\partial y}(\\frac{-y}{\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}}) \\notag\\\\ & = (\\frac{x^2}{\\sigma^4}-\\frac{1}{\\sigma^2})e^{-\\frac{x^2+y^2}{2\\sigma^2}}+(\\frac{y^2}{\\sigma^4}-\\frac{1}{\\sigma^2})e^{-\\frac{x^2+y^2}{2\\sigma^2}} \\notag \\\\ & = (\\frac{x^2+y^2-2\\sigma^2}{\\sigma^4})e^{-\\frac{x^2+y^2}{2\\sigma^2}} \\notag \\end{align}此即为 高斯拉普拉斯（LoG）函数，其长相如下：草帽 上述推导部分详见《数字图像处理》P521 尺度选择拉普拉斯核（差分表示的高斯二阶导）同样可以用于检测边缘（过零点即为边缘的位置），但 LoG 可用于尺度的检测。 高斯二阶导与信号卷积，如果两者相“匹配”，那么在斑点中心除便会产生极值 在实际使用中，我们无法知道信号和什么样的拉普拉斯核匹配，但是我们可以给定一堆核，让信号与其卷积，能得到极值的那个便是所需的核，然而现实往往很骨感：随着 $\\sigma$ 的变化，信号被衰减直至消失，这是为啥呢？ 为了搞清这个问题，我们以高斯一阶导为例，如下图，高斯偏导核与信号卷积时，卷积结果为 $\\frac{1}{\\sigma\\sqrt{2\\pi}}$，可见，随着 $\\sigma$ 的增大，相同的信号，卷积的结果不断减小。如何让卷积结果（尺度）恒定不变呢，当然是把 $\\sigma$ 去除，即 $\\frac{1}{\\sigma\\sqrt{2\\pi}}*\\sigma = \\frac{1}{\\sqrt{2\\pi}} $。那同理，对高斯二阶导而言，就需要乘 $\\sigma^2$。这个过程称为尺度归一化。 在尺度归一化后，信号在一堆拉普拉斯核中有一个极大值响应 即实际使用时进行尺度归一化： \\begin{align} \\nabla^2_{norm}g & = \\sigma^2\\nabla^2G(x,y) \\notag \\\\ & = (\\frac{x^2+y^2-2\\sigma^2}{\\sigma^2})e^{-\\frac{x^2+y^2}{2\\sigma^2}} \\tag{*} \\end{align}现在的问题是，拉普拉斯核在什么情况下相应才会最大呢？以二值圆形信号为例说明： 不难看出，只有当拉普拉斯核的零截面与信号对齐时（恰好卡住），响应值最大。 而对齐时，(*)式结果为0，则只能是 $x^2+y^2-2\\sigma^2 = r^2-2\\sigma^2 = 0$，即 $r=\\sqrt{2}\\sigma$，也即最大响应出现在 $\\sigma = r/\\sqrt{2}$ 处。 直观来看，只有当拉普拉斯核与二值圆形信号的圆一样大时，两者卷积的结果才最大（因为卷积就是信号的圆形区域与模板的圆形区域相差相加），只有两者完全重合时，卷积结果最大。 尺度空间前面我们一直在说，通过不同的 $\\sigma$ 进行尺度选择，不同的 $\\sigma$ 会形成不同的图像，这些不同的图像属于同一个尺度空间，即灰度图像 $f(x,y)$ 的尺度空间 $L(x,y,\\sigma)$ 是 $f$ 与一个可变尺度的高斯核 $G(x,y,\\sigma)$ 卷积的结果： L(x,y,\\sigma) = G(x,y,\\sigma) \\star f(x,y)其中，$\\sigma$ 控制尺度，$f$ 依次与标准差为 $\\sigma、k\\sigma、k^2\\sigma、k^3\\sigma、\\dots$ 的高斯核卷积，便可生成一堆由常量因子 $k$ 分隔的高斯平滑图像（如下图），即模糊程度不断变化，能模拟人眼由近到远时目标在视网膜上的形成过程。 $\\sigma$ 连续变化时，便可形成该图像的一个尺度空间（Lindeberg等人已证明高斯卷积核是实现尺度变换的唯一变换核，并且是唯一的线性核） 尺度空间中，只比较上下两个相邻的尺度空间，即比较相邻 27 个点，保留最大的那个（非极大值抑制） 如前述所述，需要不同的尺度空间，随着 $\\sigma$ 的增大，高斯核半径增大，计算量（乘法和加法）增加，显然效率不会很高。 SIFT原理我们已经知道了拉普拉斯函数，其计算较为复杂，但前辈们发现，该函数可用 高斯差分(DoG) 近似： LoG： L=\\sigma^2(G_{xx}(x,y,\\sigma)+G_{yy}(x,y,\\sigma))DoG： DoG=G(x,y,k\\sigma)-G(x,y,\\sigma)实验证明，对 LoG 进行一定的校正就可以通过 DoG 近似，性能基本相同。 DoG=G(x,y,k\\sigma)-G(x,y,\\sigma) \\approx (k-1)\\sigma^2 \\nabla^2G(x,y) 使用高斯差分近似的一大好处是，高斯核是可分离的，大的卷积核卷积的结果可以由两个小的卷积核完成。这样一来，我们不用让不同的核都与原图卷积，而是可以在现有卷积的基础上继续卷积。 举个例子： 这样做的好处显而易见，如果所有尺度都与原图卷积，随着尺度增大，计算量不断增大，如果在已有的结果上卷积，显然模糊半径小，这是 SIFT 特征检测的关键之一，即提速。 为了构建尺度空间，利用高斯金字塔实现，包括对原图像在多尺度下高斯卷积及降采样得到。其中，相同的分辨率的图像组成一个尺度空间（作者采用了每个尺度空间 6 张递增的高斯卷积结果图），每个尺度空间称为一个组（Octave），下一组的最底层图像由上一层的倒数第三张图下采样得到（一般是间隔采样，即隔离一个像素取一个，即缩小一半），从而形成了高斯差分金字塔。这是关键之二，这里的核心在于，对原图用 $\\sigma$ 卷积，和 将原图缩小一半，再用 $\\sigma$ 卷积，结果 *2 一致。 举个例子，原图中 10 mm 的圆，我用同样大小的 $\\sigma$ 卷积；另一种方案是，原图缩小一半，即待检测的圆只有 5mm 了，我仍然用前述的 $\\sigma$ 卷积，卷积后的结果是 5mm 的圆，*2 后就是原图中 10mm 的圆。这样做的好处在于，同样的核，但图像缩小了，速度也就上来了。 如上图所示，第一组有 5 层，可生成 4 层 DoG 尺度空间，这 4 层经过非极大值抑制可得到 2 个尺度，其他组同理。问题是，如何让不同组（Octave）的尺度形成连续的尺度空间？ 经过研究发现，只有当输出的尺度图像数与 k 之间的关系为 $k=s^{\\frac{1}{2}}$ 时，方可形成连续尺度空间。 以上图为例，第一组经过非极大值抑制后得到 $k\\sigma$、$k^2\\sigma$，同理第二组为 $2k\\sigma$、$2k^2\\sigma$，输出 2 张尺度图像，即 $k=2^{\\frac{1}{2}}$，带入可发现其形成了连续的尺度空间 $\\sqrt{2}\\sigma、2\\sigma、2\\sqrt{2}\\sigma、4\\sigma$。还可发现，要是最终输出 $s$ 张尺度图像，就得有 $s+2$ 张 DoG，$s+3$ 张 LoG。 前述中你可能会问为什么下一组的第一张图示上一组的倒数第三张下采样得到的？看完上面这个例子就显而易见了，我们最终输出 2 张尺度图像，对应的 DOG 有 4 层，4 层中的最底层不能参与特征值的提取，而 DOG 的最底层对应高斯尺度空间的最下面两层，也就是这两层，所以本尺度空间的关键信息点均在倒数第三层 上述即为 SIFT 的所有内容，下面进行总结。 不变性分析 拉普拉斯响应满足（旋转、缩放）不变性：即不论特征点有无缩放、旋转，都能检测到 特征的定位满足（旋转、缩放）协变性：特征都能检测到，但是匹配需要经过旋转、平移等操作 视角变化如何（仿射适应性） 如图，SIFT 只能输出图中的白色圆特征，但是右图视角变化后，很明显白色圈中的内容发生了变化，这样会导致后续匹配出问题，因而我们希望 SIFT 输出的是黄色圈，这样即使视角变化，其检测的特征还是一致的，匹配更有利。 如何实现这样的效果呢？ 回顾 Harris 角点检测的部分，其利用了二阶矩矩阵判断梯度变化，二阶矩矩阵的特征值的大小表征了两个方向上梯度变化的快慢。设想这样一种情况，如果左右图像检测到的特征完全一致的话，对应的二阶矩矩阵的椭圆应该是圆形的，因为其在两个方向上的梯度变化是一致的。 换句话说，以上左图黄色圈为例，其在椭圆长短轴方向的梯度变化基本是一致的了（图中头部），此时对应到二阶矩矩阵的椭圆就是圆了。 为了达到黄色椭圆的效果（说白了就是抠图扣得准确一点），可以先计算出二阶矩矩阵的特征值，然后将梯度方向变化小的反向向内收缩，直至其变成圆，达到各个方向梯度变化一致，此时 SIFT 输出的就是上图黄色椭圆部分。 注意：这里所说的是二阶矩矩阵的椭圆变成了圆，不是 SIFT 的特征输出了圆 SIFT 特征描述子现在我们有了仿射适应性，如何知道输出的特征是否是一致的呢？即如何对两幅图像检测到的特征进行比对？ 在尺度变化后，我们在两幅图像上检测到了大小不同的特征，为方便比较，我们进行归一化操作，即将特征转为大小一致的单位圆 归一化后，角度还是不一致，为了匹配，必须将其转到一致的方向，即消除旋转。 为此，提出梯度方向直方图的方法。具体做法是：我们在归一化后的窗口内，计算梯度幅值和方向，将 $0-360°$ 的方向划分为 8 份（下图画错了，只有 7 份），幅值是多少，直方图的值就加多少，给哪个块投票由方向角度决定（例如，某一像素点的梯度方向为17.856 度，那么这个点应该归入10-19 度这一区域），选取直方图中最大的方向作为主方向。 这个主方向与水平方向的夹角就是需要旋转的角度，对两张图都旋转到水平方向，从而消除旋转角度。 到此，我们完成尺度、旋转、角度的检测， 还剩下一个光照变化如何应对？SIFT 将经过前述变换的结果综合成为一个特征描述符，形成一个更加鲁棒的特征检测器。具体做法是：将检测特征圆区域划分成 16 个小区域，在每个小区域里面统计前述的梯度方向直方图，量化为 8 份的话，就会有 8 个方向，作为该小区域的描述子，故总共为 $16*8=128$ 维的描述符，两幅图像都如此，在比对时只需计算对应位置的 $L2$ 距离来判断相似性。 至于为什么划分为 16 块小区域，直方图 8 份，这就是作者实验的结果了，不过我们可以直观的理解，和 Harris 参数空间的划分类似，过大过小都不是好事。 邻域方向性信息联合的思想即增强了SIFT 算法的抗噪声能力，同时又对含有定位误差的特征匹配提供了很好 的容错性 实时性不高 有时特征点较少 对边缘光滑的目标无法准确提取特征点 对模糊的图像和边缘平滑的图像，检测出的特征点过少，对圆更是无能为力。近来不断有人改进，其中最著名的有SURF和CSIFT。 步骤SIFT 的实现包括以下几个步骤 构建高斯多尺度金字塔 检测尺度空间的极值点：上下26个点中最大才保留 精确定位极值点：局部的极值点不一定是全局的极值，拟合二次函数精确定位 选取特征点方向：前述是尺度不变，这里开始旋转不变 首先计算每一个特征点邻域内像素的梯度方向和幅值，然后选择在特征点邻域内最突出的方向赋给这个特征点，以此作为该特征点的主方向 统计直方图统计邻域内像素的梯度和方向，直方图中的最大值可认为是关键点的主方向 生成关键点描述子 金字塔保证特征点的空间不变性， 严格删选保证了特征点的准确性， 方向信息保证了特征点的旋转不变性 每一个关键点都拥有三个信息：位置、尺度以及方向 接下来需要为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变。描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 将坐标轴旋转为关键点的方向，以确保旋转不变性 选取一个大小为16×16的窗口，中心放在关键点上，这个16×16窗口中每一个又被分成4×4的小窗口，在每一个4×4的小窗口中分别计算其梯度幅值和方向 纹理纹理相关任务 纹理中估计形状：从图像的纹理估计表面方向或形状 利用纹理进行分割或分类：分析、表示纹理特征，将具有一致性的纹理分类 合成：生成新的纹理特征 定义及表示定义 纹理即重复出现的局部特征或模式 通常表示了材料属性 重要的外观线索，特别是形状相似时 表示既然纹理具有重复的模式，那么问题是： 如何找到这种模式： 使用和模式类似的滤波器（点状、条状、块状……） 考虑滤波器的响应幅值 局部窗口中观察其统计特性： 均值、标准差 直方图 比如我们使用高斯偏导核对一张图卷积，并统计每个窗口中两个方向上导数的均值。 根据统计的结果绘图如下，由此可进行简单的分类：$x,y$ 方向上都方向变化比较小，说明是平坦区域；$x$ 方向变化大而 $y$ 方向变化小，说明主要是竖直方向的特征（图中竖直的沟渠）；两方向都变化较大，说明是图中的绿草区域。 为了表示各类特征之间的相似性，可使用 $L2$ 距离。 当前我们假设已知了选取窗口的大小，但实际中我们是不知道该取多大的窗口才能分类。为此，我们可以尝试多个窗宽大小，选择区域内特征变化稳定（即不再变化）时对应的窗口大小。 滤波器组前面我们使用 x y 方向的偏导核对图像卷积，得到了局部特征，于是我们就想，如果我们找一堆的滤波器，形成一个滤波器组（Filter Banks)，这个滤波器组尽可能的包含更多的特征，如此一来卷积后得到的特征是否会更多更全呢？ 以下图为例，该滤波器组包含了尺度、方向以及不同类型的模式 Matlab code available for these examples 之前我们使用的高斯核都是一维或二维的，这里介绍一下多维高斯核，其形状如下图所示，$\\Sigma$ 是协方差矩阵，不同的 $\\Sigma$ 对应不同的高斯核。其中，45° 方向上的值不为 0 时表示 x y 方向上是相关的，即一方增大另一方亦增大。 据此可以结合多维高斯核，从不同尺度、方向出发，构建滤波器组 我们利用上述滤波器组对下图卷积：可以发现，随着卷积核的尺度越大，维度越高，所提取的特征也越发抽象。 同样，由滤波器组的均值响应向量可以确定纹理（下图的七维响应向量 A B C 是卷积核对图像卷积后再对卷积结果取平均，且越亮表示图像中主要是该类特征） 上述过程采用了均值响应，但也可以采用直接对每个点都使用 7 维的向量。 举例：假设原图为 $H\\times W$，滤器组有 $n$ 维，一种方式是每个点都让滤波器组卷积，即每个点都对应 $n$ 维，则卷积后的响应为 $H\\times W \\times n$ ；另一种是采用统计结果，如取均值，则每张图像对应一个响应结果。 上述观点十分重要，因为卷积神经网络的基本思想就是如此，所不同的是，上述的滤波器组是人为设置的，而卷积神经网络的滤波器组则是网络自己学习的，我们可以想象的是，神经网络学习了超强的滤波器组，从而完成相应的任务。 上述过程可用于分类任务，比如利用滤波器组卷积后得到响应结果，与数据库中的结果进行比对（L2距离)，根据相似性便可完成分类。 图像分割分割的目标 将相似的像素分为一组：是自底向上、无监督的过程，即不知道如何分，只根据像素的相似性分割 分割为“物体”，比如人和背景分开 诚然，终极目标是不断要分割出单个物体，还要从整体出发，理解某个个体组成的整体的内容。 比如下图，计算机可能只能分割出局部的特征，但对人类而言，还能观察到这些局部特征组成的整体特征。 更准确的说： 语义分割：只分割出目标 实例分割：不仅分割出目标，还需指出一类目标中谁是谁 K-Means 聚类分割 相似像素聚类：K-Means 聚类，比如基于灰度或者颜色，以彩色分割结果为例，图中相同颜色表示同类，这便是语义分割；但这种分割没法知道图中的两个辣椒是不一样的，而要指出这两个辣椒是不同的，就是实例分割。 为了达到实例分割的目的，还需要额外的约束，观察不难发现，两个辣椒的位置明显不同，于是我们在 RGB 的基础上增加 位置坐标 X Y，便可初步进行分割。但问题是，如下图红圈所示，都是背景，但由于位置不同导致分成了不同的类。 K-Means 聚类分割优缺点 简单、局部收敛 需要指定参数 K（即分为几类） 对初值、外点敏感 只适用于“球形”聚类 Mean Shift 聚类分割均值漂移算法的思想是在特征空间中寻找密度的局部最大值 主要过程是：随机选取一个 ROI，计算该 ROI 的重心，然后将该 ROI 向重心偏移，不断重复，最终找到密度的最大值 不论从哪个方向出发，最终都会导向密度最大的地方 具体思路如下： 给定特征，如颜色、梯度、纹理等 初始化特征点的窗口 进行均值漂移直至收敛 将具有相同峰值的（密度最大，三维角度看如下图）窗口合并为一类 优缺点分析 优点 无需假设是球形聚类（不同于 K-Means) 只需指定一个参数：窗宽 可找到不同的多个类别 对外点鲁棒 缺点 分割结果依赖于窗宽大小（太小容易局部收敛，导致过分割，太大则欠分割） 计算量大（基本上每个像素都要计算，因为要计算重心） 高维度下不适用 图割法图割思想 每个像素作为节点 每对像素之间的连线作为边，边由两个节点的相似度的权值决定（也即边决定两个像素是否相似） ​ 而分割的过程就是找到一种切割的方法切开图（断开边），要求断开的边的权重最小（也即最不相似的删掉） 既然图割依赖于相似性，那么该如何衡量相似性呢？ 假设每个像素可以用一个特征向量 $x$ 表示（可以是 rgb, x,y），再定义适合的距离函数（如 L2 距离）；然后可借助广义高斯核将两个特征向量之间的距离转为相似性度量： exp(-\\frac{1}{2\\sigma^2} \\text{dist}(x_i,x_j)^2)这样，相似性就由 $\\sigma$ 决定，其值越小，表明距离越近的点越相似（即距离我比较小的和我同类）；其值越大，表明即使距离很大，也有可能和我同类。下图中的右下三张图可看作是邻接矩阵的示意，邻接矩阵行和列的角点表示对应像素的相似性，不难发现，该矩阵是一个对称矩阵，因为像素 1-2 和像素 2-1 的相似度是一样的。 据此我们可知图割即： 去除一些边，使得图断开连接 图割的代价：去除边的权重之和 通过图割可以完成分割 如何得到一个“好”的图割结果？ 图割实现如之前所说，我们需要找到使得切掉边的所有的权重之和最小的情况，即最小割情形（这里涉及图论知识，菜鸡未深入接触） 但这种图割的方法存在的问题是：对于一些孤立的元素，容易形成很多独立的小区域，这是因为独立的点与其他的点连接边只有一个，自然权重最小 为了避免上述情况，也即我们希望 AB 中的元素更多一点，而不仅仅是单个元素，因而在实际中我们使用的是归一化的图割，其代价函数为： \\frac{\\text{w}(A,B)}{\\text{w}(A,V)} + \\frac{\\text{w}(A,B)}{\\text{w}(B,V)}其中，$\\text{w}(A,B)$ 是 $A$ 和 $B$ 之间所有边的权重之和，$\\text{w}(A,V)$ 同理。 可以这么理解上述公式：假设 A 只有一个元素，即上图的情况，此时上式中的 $\\text{w}(A,V)$ 就会很小（即 A 与其他边连接的很少），故 $\\frac{\\text{w}(A,B)}{\\text{w}(A,V)}$ 就会很大，这样整体的权重就大了，自然不会选择分割，就不会出现上图单元素分割的情况。 上式经过一系列推导（详见J. Shi and J. Malik. Normalized cuts and image segmentation. PAMI 2000），最终可得到下式： \\frac{y^T(D-W)y}{y^TDy}式中：$W$ 是图的邻接矩阵，$D(i,i)=\\Sigma_j(i,j)$，是一个对角矩阵，其元素是同一行元素的和。 至此，问题转为求解使得上式最小时的 $y$ 向量，该向量是元素不是 0 和 1，元素属于这个类就是 1，否则就是 0,（即归一化的图割只区分为两类）。 上式的求解采用的是拉格朗日法，转换为求解：$ (D − W)y = λDy$，该问题的解 $y$ 是次最小特征值对应的特征向量。 求解出 $y$ 后，可能会发现该向量并不是 0 或 1，而是带有小数，为此可设置阈值，归一化为 0 和 1（类似二值化）。 归一化的图割只能分为两类，如何实现多类分割呢？有两种方法： 在现有分割的基础上迭代 现有分割的基础上使用 K-Means 值得注意的是，前述中对图像进行描述时使用了 rgb,x,y 的形式，但对于纹理特征难以用其描述时，可采用纹理一节中提到的滤波器组。 优缺点分析 适用于众多不同的特征，比如选择不同的描述形式、不同的距离计算方式 计算耗时耗内存（所有像素参与） 倾向于均分为两类 图像增强 低照度图像增强算法-RetinexRetinex 理论模型 该算法的理论基础是光的三色理论和颜色恒常性 物体的颜色是由物体对长波（红）、中波（绿）、短波（蓝）的反射能力决定的，而不是由反射强度的绝对值决定的。此外，物体的颜色不受光照不均匀性的影响，具有一致性，也就是颜色恒常性。 不同于传统的线性、非线性图像增强方式只能增强某一类的特征，Retinex 可以在动态范围压缩、边缘增强、颜色恒常三个方面达到平横，可对各种不同类型的图像进行自适应增强。 Retinex 理论的基本假设是：原始图像 $S$ 是由光照图像 (照度图像) $L$、反射图像 $R$ 组成，前者是物体的入射分量的信息，表示为 $L(x,y)$，后者是物体的反射部分，表示为 $R(x,y)$，所以图像 $S$ 可表示为： S(x,y)=R(x,y)L(x,y)Retinex 增强的目的就是从原始图像 $S$ 中估计出 $L$，从而分解出 $R$，消除光照不均的影响，以改善图像的视觉效果。由于人眼感受亮度的过程与对数形式的变换相似，所以将上式转到对数域，这样做的一个好处是将复杂的乘法转为了加法： \\begin{align} logS & = log(RL) \\notag \\\\ & = logR+logL \\notag \\end{align}可见，如若估计得到 $L$，就可求得 $R$。 关键是如何得到 $L$ 呢？该值显然不能直接求得，那就只能近似。Retinex 的提出者认为，$L$ 可由原始图像和高斯核卷积得到，即： logR=logS-logS * G$G$ 即为高斯卷积核。 一般还需对 $R$ 量化映射到 $[0,255]$ 上，这里一般不会直接通过指数映射从 $logR$ 得到 $R$，一般取线性映射，方法是计算 $logR$ 的最大值 $Max$ 和 最小值 $Min$，然后对每一个 $Value$ 进行线性量化： R(x,y)=\\frac{Value-min}{Max-min}*255多尺度的原理类似，只是采用不同的尺度（由 $\\sigma$ 控制尺度空间），生成不同的高斯核与图像进行卷积，然后对这个尺度按权重计算，为了兼顾长中短三种波（即 RGB），通常取等权重（即 $\\omega_1=\\omega_2=\\omega_3=1/3$），注意权重和为 1。 直方图均衡化直方图均衡化是图像增强的一种方式，其结果是让过亮或过暗的图像灰度分布更加均匀，其主要是通过累积分布函数进行计算，提高图像的对比度。 颜色空间HSV圆锥模型空间 H：色相：具体是哪种颜色（角度表示） S：饱和度：颜色的深浅（0~1） V：亮度：颜色的明暗（0~1） YUVYUV是通过亮度-色差来描述颜色的颜色空间。 亮度信号经常被称作Y，色度信号是由两个互相独立的信号组成。视颜色系统和格式不同，两种色度信号经常被称作UV或PbPr或CbCr。这些都是由不同的编码格式所产生的，但是实际上，他们的概念基本相同。在DVD中，色度信号被存储成Cb和Cr（C代表颜色，b代表蓝色，r代表红色）。 空间滤波空间相关与卷积 相关：图像上移动核的中心，求每个位置的乘积之和 只满足分配律 卷积：把相关运算的核旋转180° 线性：F(f1+f2) = F(f1)+F(f2) 平移不变形：F(S(f)) = S(F(f)) 满足线性平移不变性的操作均可定义为卷积 满足交换律、结合律、分配律 卷积时边缘的处理：边界填充 卷积核的特性导致卷积后的图像和原图不一样大 零填充 复制边缘 镜像边缘 可分离核 可分离核：能够表示为两个向量外积的矩阵 $m \\times n$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v{m \\times 1}w{n \\times 1}^T$ $m \\times m$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v{m \\times 1}v{m \\times 1}^T$ 优势：减少计算量，大核分离为小核计算 判断是否可分离：矩阵的秩为 1（矩阵论：一列向量与一行向量的乘积的矩阵，秩为 1） 空间滤波器的构建","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"}]},{"title":"点云+PCL学习笔记","slug":"图像处理/点云+PCL学习笔记","date":"2022-07-16T16:00:00.000Z","updated":"2023-04-28T08:02:40.014Z","comments":true,"path":"point_cloud_pcl/","link":"","permalink":"https://hbroad.github.io/point_cloud_pcl/","excerpt":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充）","text":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充） 点云 分布在 N 维空间中的离散点集 是对物体表面信息的离散采样 点云库 三维处理算法：滤波、特征估计、表面重建等 PointT 类型PointXYZ 包含 x y z 坐标的点数据类型 成员变量 float x, y, z points[i].x 访问 多余的一个变量用来填充位置以满足存储对齐（?） 12345678910union&#123; float data[4]; struct &#123; float x; float y; float z; &#125;;&#125;; Point XYZI 包含 x y z 坐标及 intensity PointXYZRGBA rgba 单独作为一个整型变量（unit32_t） PCD 文件 包含文件头：声明存储点云数据的特性，必须用 ASCII 编码 123456789101112131415# .PCD v.7 - Point Cloud Data file formatVERSION .7 # 指定PCD文件版本FIELDS x y z rgb # 指定每个点可以有的每一个维度或字段的名字SIZE 4 4 4 4 # 用字节数指定 FIELDS 中每一个维度的大小TYPE F F F F # 用一个字符指定 FILEDS 中每一个维度的类型COUNT 1 1 1 1 # 指定每一个维度包含的元素数目WIDTH 213 # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目） 列HEIGHT 1 # 用点的数量表示点云数据集的高度；同 WIDTH 行 VIEWPOINT 0 0 0 1 0 0 0 # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）POINTS 213 # 数据集中点的总数 DATA ascii # 存储点云数据的数据类型：ASCII 或 二进制0.93773 0.33763 0 4.2108e+060.90805 0.35641 0 4.2108e+060.81915 0.32 0 4.2108e+060.97192 0.278 0 4.2108e+06 DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开 DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法 K-d tree理论 按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。 在 k-d tree 中查找距离查询点 $\\overline x$ 最近点的，意味着遍历整个树，找到包含 $\\overline x$ 的子节点。 实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。 两种查询方式（详见博士论文 P40） PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型： ==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点） ==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点 r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。 上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \\vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\\vec{q}$ ，但以 $ \\vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\\vec{q}’$ 。 另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 正确尺度因子 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。 如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。 所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。 Octree(八叉树) 一个根节点包含八个子节点 若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归 除近邻搜索外，可用于碰撞检测 点云连接点连接 需确保类型和维度相等 12cloud_c = cloud_a;cloud_c += cloud_b; 字段连接 需确保数目相等 1pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c); 点云滤波原因 噪声点：设备精度、操作者经验、环境因素等 离群点：外界干扰如障碍物等，产生离主体点云较远的离散点 双边滤波 通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果 有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征 直通滤波器 去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点） 123456pcl::PassThrough&lt;pcl::PointXYZ&gt; pass; // 创建直通滤波器对象pass.setInputCloud(cloud); // 输入pass.setFilterFieldName(&quot;z&quot;); // 设置滤波字段，此处为 z 轴pass.setFilterLimits(0.0, 200.0); // 设置滤波范围，超出则滤除pass.setFilterLimitsNegative (true); // 默认为 false，设为 ture 则返回被滤除点pass.filter(*cloud_filtered); // 执行滤波，并将滤波结果存储在 cloud_filtered VoxelGrid（体素化网格）滤波器 实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变 VoxelGrid 三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体== 通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示== 对所有体素处理后得到过滤后的点云 缺点：慢，比体素中心逼近法更慢 1234pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor; // 创建体素栅格滤波对象sor.setInputCloud(cloud); // 读入点云设置为输入sor.setLeafSize(0.01f, 0.01f, 0.01f); // 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米sor.filter(*cloud_filtered); // 执行滤波并存储到 cloud_filtered 滤波结果 &lt;img src=&quot;F:\\AFIGHT\\笔记\\PCL\\assets\\滤波前.png&quot; alt=&quot;滤波前&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;img src=&quot;F:\\AFIGHT\\笔记\\PCL\\assets\\滤波后.png&quot; alt=&quot;滤波后&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;/center&gt; 统计滤波 （详见博士论文 P40） 用于去除离群点 基于对近邻点集 $P^k$ 的统计分析 计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\\overline d$ 计算点云 $P$ 在平均距离上的分布，并估计平均值 $\\mu_k$ 及标准差 $\\sigma_k$ 对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离 去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。 假设第一次扫描 $Pi$ 和随后的 $P{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \\in Pi$，搜索其对应的近邻点 $p \\in P{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。 1234567pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor; // 创建统计滤波对象sor.setInputCloud(cloud); // 设置输入点云sor.setMeanK(50); // 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）sor.setStddevMulThresh(1.0); // 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点sor.filter(*cloud_filtered); // 执行并存储滤波结果sor.setNegative(true); // 获取离群点（此值默认为 false） 滤波结果 参数化模型投影点云 点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0 PCL 中有特意存储常见模型系数的数据结构 12345678910111213// Create a set of planar coefficients with X=Y=0,Z=1 pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients()); // 创建 模型系数 对象coefficients-&gt;values.resize(4); // 参数个数置为 4coefficients-&gt;values[0] = coefficients-&gt;values[1] = 0; // 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Ycoefficients-&gt;values[2] = 1.0;coefficients-&gt;values[3] = 0;// Create the filtering objectpcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj; // 设置投影滤波对象 proj.setModelType(pcl::SACMODEL_PLANE); // 设置对象对应的投影模型类型，此处为平面模型proj.setInputCloud(cloud); // 设置输入proj.setModelCoefficients(coefficients); // 设置模型系数为前述定义系数proj.filter(*cloud_projected); // 执行并保存 从一个点云中提取一个子集 基于 ExtractIndices 滤波器（基于分割算法） 12345pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; // 创建分割对象extract.setInputCloud(cloud_filtered); // 设置输入点云 extract.setIndices(inliers); // 设置分割后的内点为需要提取的点击（分割部分略）extract.setNegative(false); // 指定提取内点extract.filter(*cloud_p); // 执行并存储 RadiusOutlierRemoval / ConditionalRemoval 移除离群点RadiusOutlierRemoval 删除输入点云一定范围内没有达到足够多近邻的所有数据点 人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。 12345678pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem; // 创建半径滤波对象// build the filteroutrem.setInputCloud(cloud); // 设置输入点云outrem.setRadiusSearch(0.8); // 设置搜索半径为 0.8outrem.setMinNeighborsInRadius(2); // 设置所需近邻点数为 2outrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)// apply filteroutrem.filter(*cloud_filtered); // 执行滤波并保存 ConditionalRemoval 如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个 123456789101112pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::Ptr range_cond(new pcl::ConditionAnd&lt;pcl::PointXYZ&gt;()); // 创建条件定义对象range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(&quot;z&quot;, pcl::ComparisonOps::GT, 0.0))); // 添加比较算子：z 字段上大于 0.0 range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(&quot;z&quot;, pcl::ComparisonOps::LT, 0.8))); // 添加比较算子：z 字段上小于 0.8 // build the filterpcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem; // 初始化条件滤波condrem.setCondition(range_cond); // 设置条件为指定的比较算子condrem.setInputCloud(cloud); // 设置输入点云condrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN// apply filtercondrem.filter(*cloud_filtered); // 执行滤波并保存 CropHull 任意多边形内部点云提取 CropHull 滤波器得到 2D 封闭多边形内 / 外的点云 深度图像（Range/Depth Images） 将图像采集器到场景中各点的距离（深度）值作为像素值的图像（距离是相机到场景点的垂直距离，不是连线距离） 直接反映景物可见表面的几何状态 物体的三维表示形式，可通过立体相机或 TOF 相机获取 深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据 英文中常见的等价表述：range image，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles 注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息 从点云创建深度图像 主要函数为 createFromPointCloud，声明 9 个参数填充即可 12345678910111213141516171819202122232425void pcl::RangeImage::createFromPointCloud ( const PointCloudType &amp; point_cloud,float angular_resolution = pcl::deg2rad (0.5f),float max_angle_width = pcl::deg2rad (360.0f),float max_angle_height = pcl::deg2rad (180.0f),const Eigen::Affine3f &amp; sensor_pose = Eigen::Affine3f::Identity (),RangeImage::CoordinateFrame coordinate_frame = CAMERA_FRAME,float noise_level = 0.0f,float min_range = 0.0f,int border_size = 0 ) //Create the depth image from a point cloud./*Parameter EX:point_cloud the input point cloudangular_resolution the angular difference (in radians) between the individual pixels in the imagemax_angle_width an angle (in radians) defining the horizontal bounds of the sensormax_angle_height an angle (in radians) defining the vertical bounds of the sensorsensor_pose an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )coordinate_frame the coordinate frame (defaults to CAMERA_FRAME)noise_level - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.min_range the minimum visible range (defaults to 0)border_size the border size (defaults to 0)*/ 从深度图像提取边界 边界：前景跨越到背景的位置 物体边界（黑）、阴影边界（绿）、Veil 点集（红） 若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘 关键点 兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集 数量比原始点云或图像的数据量小很多 组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性 利于加快后续的处理速度 关键概念及算法NARF 关键点*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608. 从深度图像识别物体 步骤 遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测； 遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向； 根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定； 对兴趣值进行平滑过滤； 进行无最大值压缩找到最终的关键点，即为 NARF 关键点。 简化步骤* 给定深度图像，进行边缘提取 表面变化基于边界和曲率原则”评分“ 设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多 Harris关键点 通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点 若 Harris 矩阵特征的两个特征值都很大，则为关键点 对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测 3D Harris 关键点检测使用的是点云表面法向量的信息（2D 使用的是图像梯度） PCL 中的 keypoints深度图像提取 NARF 关键点12345678pcl::RangeImageBorderExtractor range_image_border_extractor; // 创建对象，用于边缘提取pcl::NarfKeypoint narf_keypoint_detector(&amp;range_image_border_extractor); // 创建对象，传入上述提取出的深度图像边缘narf_keypoint_detector.setRangeImage(&amp;range_image); // 传入深度图像narf_keypoint_detector.getParameters().support_size = support_size; // 设置支持范围(搜索空间球体的半径，邻域范围)//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;pcl::PointCloud&lt;int&gt; keypoint_indices; // 创建点云对象，存储检测到的点云narf_keypoint_detector.compute(keypoint_indices); // 计算 SIFT 关键点提取参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客 参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客 参考：SIFT（3）——-尺度空间极值检测_姗姗本人的博客-CSDN博客 注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。 ​ ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向 ​ ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 尺度不变性 局部特征描述子 12345678pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift; // 创建sift关键点检测对象pcl::PointCloud&lt;pcl::PointWithScale&gt; result; // 存储查询结果sift.setInputCloud(cloud_xyz); // 设置输入点云pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());sift.setSearchMethod(tree); // 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快sift.setScales(min_scale, n_octaves, n_scales_per_octave); // 设置限制关键点检测的阈值sift.compute(result); // 执行sift关键点检测，保存结果在result 123456789101112131415// setScales 函数原型void pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::setScales ( float min_scale,int nr_octaves,int nr_scales_per_octave ) 用于指定搜索关键点的尺度范围 // Specify the range of scales over which to search for keypoints.// Parameters 设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）// min_scale the standard deviation of the smallest scale in the scale space 高斯金字塔中组（octaves）的数目// nr_octaves the number of otaves (i.e. doublings of scale) to compute 每组计算的尺度数目// nr_scales_per_octave the number of scales to compute within each octave Harris 关键点提取123456789//harris_detector-&gt;setNonMaxSupression(true);harris_detector-&gt;setRadius(r_normal); // 设置法向量估计的半径harris_detector-&gt;setRadiusSearch(r_keypoint); // 设置关键点估计的近邻搜索半径harris_detector-&gt;setInputCloud (input_cloud);//harris_detector-&gt;setNormals(normal_source);//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);harris_detector-&gt;compute (*Harris_keypoints);cout&lt;&lt;&quot;Harris_keypoints的大小是&quot;&lt;&lt;Harris_keypoints-&gt;size()&lt;&lt;endl;writer.write&lt;pcl::PointXYZI&gt; (&quot;Harris_keypoints.pcd&quot;,*Harris_keypoints,false); 特征描述与提取特征描述 局部特征描述 + 全局特征描述 特征描述子三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有形状描述子（shape descriptors）、几何特征（gometric features）、点特征表示（point feature representations）等。 理论（详见博士论文 P23，37） 给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为： ||p_i^k-p_q||_x \\leq d_m \\tag{1.1}式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见范数）。 此外，$P^k$ 中近邻点的个数可被限制为给定值 k。 点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围： F(p_q,P^k)=\\{x_1,x_2,···,x_n\\}式中，$x_i$ , $i \\in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。 比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\\Gamma$ 为描述这两点之间差异的相似性度量，$d$ 为距离度量，则有： \\Gamma = d(F_1,F_2)当 $d$ 趋向于某个最小值时，即 $d \\to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。 个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。 通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。 理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣： 刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有旋转平移不变性 不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有抗密度干扰性 噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有鲁棒性 也就是说，一个点特征表示满足上述条件才可以说是好的表示法 邻域的概念确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方： ||X||_2 = \\sqrt{\\sum_{i=1}^n x_i^2}可用于度量两个向量间的差异，如平方差和： SSD(x_1,x_2) = \\sum_{i=1}^n(x_{1i}-x_{2i})^2也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。 但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。 特征提取输入点云的调用 输入点云调用函数主要有： setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量 setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算 setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间 后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208） 经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。 估计点云的表面法线（详见博士论文 P45） 描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线 一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②直接从点云数据集中近似推断表面法线 对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数 12345// PCL 中估计一点集对应的协方差矩阵Eigen::Matrix3f covariance_matrix; // 定义每个表面小块的 3×3 协方差矩阵的存储对象Eigen::Vector4f xyz_controid; // 定义一个表面小块的质心坐标16字节对其存储对象compute3DCentroid(cloud, xyz_controid); // 估计质心坐标computeCovarianceMatrix(cloud, xyz_controid, covariance_matrix); // 计算 3×3 协方差矩阵 一个平面可用一个点 $x$ 和 一个法向量 $\\overline n$ 表示，则一个点 $p_i \\in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \\overline n$ 。 $x$ 和 $\\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \\in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？） 设 x = \\overline p = \\frac{1}{k}· \\sum_{i=1}^{k}p_i为 $P^k$ 的质心，而 $\\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \\in R^{3 \\times 3}$ 的特征值和特征向量得到，其表达式如下： C = \\frac{1}{k} \\sum_{i=1}^{k} \\xi_i · (p_i - \\overline p)·(p_i - \\overline p)^T , \\ C· \\overline v_i = \\lambda_i· \\overline v_j , \\ j \\in \\{0,1,2\\}式中，$\\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\\lambda_j \\in R$ ，特征向量 $\\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \\le \\lambda_0 \\le \\lambda_1 \\le \\lambda_2$ ，则特征向量 $\\overline v_0$ 对应的最小特征值 $\\lambda_0$ 就是 $+ \\overline n = {n_x,n_y,n_z}$ 或 $ - \\overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\\overline n$ 可由球坐标中的一对角 $(\\phi,\\theta)$ 表示如下： \\phi = \\arctan \\frac{n_z}{n_y}, \\ \\theta = \\arctan\\frac{\\sqrt{(n_y^2+n_z^2)}}{n_x}问题是，这种主成分分析法（PCA）对方向仍然是模糊的。 表面曲率（详见博士论文P48） 方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\\lambda_0 = min(\\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\\overline n$ 的变化可使用下式估计： \\sigma_p = \\frac{\\lambda_0}{\\lambda_0+\\lambda_1+\\lambda_3} 该最小特征值与特征值之和的比值 $\\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。 source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998 法线的定向问题 没有数学方法可以解决法线的正负向问题 法线球体描述了点云中所有法线的方向 对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向 1234567// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）flipNormalTowardsViewpoint ( const PointCloud &amp; cloud,float vp_x,float vp_y,float vp_z,Normals &amp; normals ) 但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \\cdot n_j = 1$。 点特征直方图（PFH）（详见博士论文P51和PCL书P213） bin 可理解为分格的大小，就是直方图每一个柱子的宽度 理论通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。 一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。 为形成新的特征空间，引入 双环邻域 的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \\in P$ 有双环邻域的条件是： (\\exists)r_1,r_2 \\in R, \\ r_1","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"}]},{"title":"毕设：链片条复合模CAD系统使用须知","slug":"毕设/链片条复合模CAD系统使用须知","date":"2020-05-25T16:00:00.000Z","updated":"2023-04-28T07:59:11.371Z","comments":true,"path":"Graduate_2/","link":"","permalink":"https://hbroad.github.io/Graduate_2/","excerpt":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！","text":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！ 已知错误1：数据库引擎本系统采用 ACCESS 作为数据库，经测试（虚拟机测试），win7 等系统上会出现 “未在本地计算机上注册‘Microsoft. ACE. OLEDB. 12. 0’提供程序”类似的提示。 运行错误提示 解决1：安装数据库引擎即可，点击下方“下载”，下载完成后安装，提示安装成功后尝试再次运行本系统。 下载","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"毕设：链片条复合模CAD系统","slug":"毕设/链片条复合模CAD系统使用说明","date":"2020-05-24T16:00:00.000Z","updated":"2023-04-28T07:59:05.871Z","comments":true,"path":"Graduate_/","link":"","permalink":"https://hbroad.github.io/Graduate_/","excerpt":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖","text":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖 开发平台系统环境：Windows 10 2004 专业版开发环境：VB.NET数据库：ACCESSS 365软件平台：VS 2010 系统简介该复合模 CAD 系统主要包含以下功能： 用户登录 参数输入 设计计算 主界面 设计结果 标准件库 建模装配 关于系统 用户登录首先，用户在打开系统后，会出现登录界面，该界面四个按钮的功能如下：1.登录：如若账号密码均正确，通过此按钮即可进入下一界面；2.取消：如用户输入时出错，想直接清空输入框，可使用此按钮；3.注册：新用户可通过注册后再登录；4.退出：退出系统。 系统登陆界面 参数输入用户登录后将进入该界面，在该界面由用户输入需要的尺寸值，也可使用默认值，点击开始设计，并选择模具的最小闭合高度，在确定之后即可开始设计计算。 参数输入界面 闭合高度选择 主界面系统主界面下可进行设计结果的查询、标准件的尺寸查询、三维建模与装配（调用同组同学 GRIP 程序）、查看仿真动画、系统信息及帮助文档 此外，在查询结果菜单下，用户可通过点击零件图纸查看零件的三维模型。 系统主界面 系统主界面菜单 结果查询界面 零件信息界面 点击零件图纸查看零件的三维模型 剩余界面较为简单，这里不再赘述！ （密码：姓名拼音的首字母大写） 系统演示视频","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"全国性哀悼活动","slug":"悼念日","date":"2020-04-04T10:49:31.000Z","updated":"2023-04-17T12:01:52.090Z","comments":true,"path":"ChinaIsTheBest/","link":"","permalink":"https://hbroad.github.io/ChinaIsTheBest/","excerpt":"","text":"据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。","categories":[],"tags":[{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"}]},{"title":"开天辟地","slug":"hello-world","date":"2020-04-02T09:03:42.485Z","updated":"2023-04-28T07:59:46.489Z","comments":true,"path":"hexo_new/","link":"","permalink":"https://hbroad.github.io/hexo_new/","excerpt":"","text":"这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/tags/Hexo/"}]}],"categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/categories/Python/"},{"name":"Robot","slug":"Robot","permalink":"https://hbroad.github.io/categories/Robot/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"},{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/categories/Hexo/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"资讯","slug":"资讯","permalink":"https://hbroad.github.io/tags/%E8%B5%84%E8%AE%AF/"},{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/tags/Python/"},{"name":"UR5","slug":"UR5","permalink":"https://hbroad.github.io/tags/UR5/"},{"name":"HEC","slug":"HEC","permalink":"https://hbroad.github.io/tags/HEC/"},{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"},{"name":"Simulation","slug":"Simulation","permalink":"https://hbroad.github.io/tags/Simulation/"},{"name":"Coppeliasim/Vrep","slug":"Coppeliasim-Vrep","permalink":"https://hbroad.github.io/tags/Coppeliasim-Vrep/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hbroad.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"},{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"},{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/tags/Hexo/"}]}