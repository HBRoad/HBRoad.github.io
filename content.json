{"meta":{"title":"南阳向北","subtitle":"","description":"","author":"南阳","url":"https://hbroad.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-03T12:48:48.785Z","updated":"2020-05-03T12:48:48.785Z","comments":true,"path":"about/index.html","permalink":"https://hbroad.github.io/about/index.html","excerpt":"","text":"我是南阳 一个计算机的狂热爱好者"},{"title":"大佬们","date":"2020-04-04T11:21:13.453Z","updated":"2020-04-04T11:21:13.453Z","comments":true,"path":"friends/index.html","permalink":"https://hbroad.github.io/friends/index.html","excerpt":"虽然我很菜，但好在这里有大佬","text":"虽然我很菜，但好在这里有大佬 友链规范1234567name: # 博客名avatar: # 头像链接url: # 博客链接backgroundColor: &#39;#3E74C9&#39; # 卡片背景颜色textColor: &#39;#fff&#39; # 卡片文字颜色tags: [标签1, 标签2] # 标签desc: 描述文字"},{"title":"所有分类","date":"2020-04-03T05:37:58.645Z","updated":"2020-04-03T05:37:58.645Z","comments":true,"path":"categories/index.html","permalink":"https://hbroad.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-03T05:39:00.908Z","updated":"2020-04-03T05:39:00.908Z","comments":true,"path":"tags/index.html","permalink":"https://hbroad.github.io/tags/index.html","excerpt":"","text":""},{"title":"致谢","date":"2020-04-03T13:19:42.849Z","updated":"2020-04-03T13:19:42.849Z","comments":true,"path":"thx/index.html","permalink":"https://hbroad.github.io/thx/index.html","excerpt":"","text":"感谢 hexo 的博客网站框架！！ 感谢 xaoxuu 大佬的博客主题！！ 感谢 TRHX 大佬对小白的帮助！！"}],"posts":[{"title":"华为机试（牛客）","slug":"华为机试/华为机试","date":"2022-07-31T07:41:17.143Z","updated":"2022-08-01T14:26:39.303Z","comments":true,"path":"2022/07/31/HuaWei/","link":"","permalink":"https://hbroad.github.io/2022/07/31/HuaWei/","excerpt":"华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了","text":"华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了 HJ1 题目：查找输入字符串最后一个单词的长度 思路：字符串由空格分隔，找到最后一个空格，用整体的长度减去空格及空格前的长度，剩余的即为所求 代码： 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; getline(cin,str); // size_t len = str.size(); //总长度 // size_t found = str.rfind(\" \"); //最后空格的位置 // size_t found = str.find_last_of(\" \"); cout &lt;&lt; str.size() - str.rfind(\" \") - 1;&#125; 分析：关键有二： 字符串的获取 cin：遇空格或制表符即停，显然无法满足 getline：可连续读取输入并存入字符串 1istream&amp; getline (istream&amp; is, string&amp; str); 最后空格的定位 find_last_of()：给定待查找的字符，从后开始查找并返回其位置 123size_t find_last_of (const char* s, size_t pos = npos) const;//可以指定从何处开始查找，即指定第二个参数//注意字符串从0开始编号 find 家族辨析：参考 1234567891011//搜索指定位置开始的第一个完全匹配的字符（串），即与指定字串完全匹配时才返回，且是第一个size_t find (const string&amp; str, size_t pos = 0); //从前往后找size_t rfind (const string&amp; str, size_t pos = npos); //从后往前找//搜索指定位置开始的第一个匹配的字符（串），只需有一个字符满足即可size_t find_first_of (const string&amp; str, size_t pos = 0); //从前往后找size_t find_last_of (const string&amp; str, size_t pos = npos); //从后往前找 //查找与指定字串不匹配的字符（串）size_t find_first_not_of (const string&amp; str, size_t pos = 0) ;size_t find_last_not_of (const string&amp; str, size_t pos = npos) ; HJ2 题目：计算某字符出现的次数 思路：读入到两个变量中，遍历字串，是否和目标字符相等，若相等则 count 增1，再判断大小写的问题，大写和小写分别判断 代码：（低质量代码） 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str,str2; //读入两行内容 getline(cin, str); getline(cin, str2); //如相等则计数器k自增1 int k = 0; for(int i = 0; i &lt; str.size(); i++) &#123; if(str[i] == str2[0]) &#123; k++; //考虑大小写一致 for(int i = 0; i &lt; str.size(); i++) &#123; if(str2[0] &lt;= 'Z' &amp;&amp; str2[0] &gt;= 'A') //如目标字符是大写，则再判断其对应的小写是否有相等的 &#123; if(str[i]+0 == str2[0] + 32) k++; &#125; else if (str2[0] &lt;= 'z' &amp;&amp; str2[0] &gt;= 'a') //如目标字符是小写，则再判断其对应的大写是否有相等的 &#123; if(str[i]+0 == str2[0] - 32) k++; &#125; &#125; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl;&#125; 分析： 新手，想法简单粗暴 HJ3 题目：输入随机数个数及随机数，去重排序后按行输出 思路：（排名第一的思路，非本人想法）先确定随机数的个数（直接cin），定义一个数组，然后每次将读入的数作为数组的下标，值填充为1，然后输出数组值不为0的下标 核心：只要有重复值，对应到数组的下标还是同一个，达到既降重又排序的目的；转换思路，输入的值是下标而非数组的值 缺点：一是必须指定数组的大小是题目给定的范围，而不能动态的设置为输入随机数的个数；二是数组必须初始化，否则其中的垃圾数据会造成输入错误 代码 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int N, n; while (cin &gt;&gt; N) &#123; int a[1001] = &#123; 0 &#125;; while (N--) &#123; cin &gt;&gt; n; a[n] = 1; &#125; for (int i = 0; i &lt; 1001; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920//按上述思路重写了一下，比较容易理解和看懂#include &lt;iostream&gt;using namespace std;int main() &#123; int N, n; cin &gt;&gt; N; //读入数组的大小 int a[1001] = &#123;0&#125;; //指定大小并初始化（不管数组多小，都开辟了这么多空间） for(int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; n; a[n] = 1; //以读入的数作为下标，有多少重复都无所谓（填充值非零均可） &#125; for(int i = 0; i &lt; 1001; i++) &#123; if(a[i]) cout &lt;&lt; i &lt;&lt; endl; //输出数组值非零的下标 &#125; return 0;&#125;","categories":[],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"华为机考","slug":"华为机考","permalink":"https://hbroad.github.io/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/"}]},{"title":"数据结构","slug":"数据结构/数据结构","date":"2022-07-29T13:20:49.000Z","updated":"2022-07-31T11:36:22.255Z","comments":true,"path":"2022/07/29/data_structure/","link":"","permalink":"https://hbroad.github.io/2022/07/29/data_structure/","excerpt":"数据结构理论","text":"数据结构理论 时间复杂度时间复杂度：各条指令执行的时间之和 大O表示法 表示算法执行的渐进上限 性质： 任意常数 $c &gt;0$，$O(f(n))=O(cf(n))$ 常数乘以某个运算，不改变其时间复杂度（函数正的常系数可忽略等同于1） 任意常数$a&gt;b&gt;0$，$O(n^a+n^b)=O(n^a)$ 因 $a&gt;b$，故前者的影响大于后者，在整个过程中便可忽略后者的影响（低次项可忽略，保留最高次项） 空间复杂度 不计入输入本身 其他各方面消耗都计入 复杂度分析 常数时间复杂度 $O(1)$ 对数时间复杂度 $O(logn)$ 对数多项式复杂度 线性 $O(1)$","categories":[],"tags":[]},{"title":"数字图像处理","slug":"数字图像处理","date":"2022-07-17T03:00:47.000Z","updated":"2022-07-31T11:37:42.588Z","comments":true,"path":"2022/07/17/digital_image_process/","link":"","permalink":"https://hbroad.github.io/2022/07/17/digital_image_process/","excerpt":"数字图像处理基础理论（待补充）","text":"数字图像处理基础理论（待补充） 空间滤波空间相关与卷积 相关：图像上移动核的中心，求每个位置的乘积之和 只满足分配律 卷积：把相关运算的核旋转180° 满足交换律、结合律、分配律 可分离核 可分离核：能够表示为两个向量外积的矩阵 $m \\times n$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v_{m \\times 1}w_{n \\times 1}^T$ $m \\times m$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v_{m \\times 1}v_{m \\times 1}^T$ 优势：减少计算量，大核分离为小核计算 判断是否可分离：矩阵的秩为 1（矩阵论：一列向量与一行向量的乘积的矩阵，秩为 1） 空间滤波器的构建","categories":[],"tags":[{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"}]},{"title":"点云+PCL学习笔记","slug":"点云+PCL学习笔记","date":"2022-07-17T02:01:20.593Z","updated":"2022-07-29T12:30:06.305Z","comments":true,"path":"2022/07/17/point_cloud_pcl/","link":"","permalink":"https://hbroad.github.io/2022/07/17/point_cloud_pcl/","excerpt":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充）","text":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充） 点云 分布在 N 维空间中的离散点集 是对物体表面信息的离散采样 点云库 三维处理算法：滤波、特征估计、表面重建等 PointT 类型PointXYZ 包含 x y z 坐标的点数据类型 成员变量 float x, y, z points[i].x 访问 多余的一个变量用来填充位置以满足存储对齐（?） 12345678910union&#123; float data[4]; struct &#123; float x; float y; float z; &#125;;&#125;; Point XYZI 包含 x y z 坐标及 intensity PointXYZRGBA rgba 单独作为一个整型变量（unit32_t） PCD 文件 包含文件头：声明存储点云数据的特性，必须用 ASCII 编码 123456789101112131415# .PCD v.7 - Point Cloud Data file formatVERSION .7 # 指定PCD文件版本FIELDS x y z rgb # 指定每个点可以有的每一个维度或字段的名字SIZE 4 4 4 4 # 用字节数指定 FIELDS 中每一个维度的大小TYPE F F F F # 用一个字符指定 FILEDS 中每一个维度的类型COUNT 1 1 1 1 # 指定每一个维度包含的元素数目WIDTH 213 # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目） 列HEIGHT 1 # 用点的数量表示点云数据集的高度；同 WIDTH 行 VIEWPOINT 0 0 0 1 0 0 0 # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）POINTS 213 # 数据集中点的总数 DATA ascii # 存储点云数据的数据类型：ASCII 或 二进制0.93773 0.33763 0 4.2108e+060.90805 0.35641 0 4.2108e+060.81915 0.32 0 4.2108e+060.97192 0.278 0 4.2108e+06 DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开 DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法 K-d tree理论 按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。 在 k-d tree 中查找距离查询点 $\\overline x$ 最近点的，意味着遍历整个树，找到包含 $\\overline x$ 的子节点。 实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。 两种查询方式（详见博士论文 P40） PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型： ==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点） ==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点 r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。 上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \\vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\\vec{q}$ ，但以 $ \\vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\\vec{q}’$ 。 另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 正确尺度因子 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。 如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。 所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。 Octree(八叉树) 一个根节点包含八个子节点 若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归 除近邻搜索外，可用于碰撞检测 点云连接点连接 需确保类型和维度相等 12cloud_c = cloud_a;cloud_c += cloud_b; 字段连接 需确保数目相等 1pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c); 点云滤波原因 噪声点：设备精度、操作者经验、环境因素等 离群点：外界干扰如障碍物等，产生离主体点云较远的离散点 双边滤波 通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果 有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征 直通滤波器 去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点） 123456pcl::PassThrough&lt;pcl::PointXYZ&gt; pass; // 创建直通滤波器对象pass.setInputCloud(cloud); // 输入pass.setFilterFieldName(\"z\"); // 设置滤波字段，此处为 z 轴pass.setFilterLimits(0.0, 200.0); // 设置滤波范围，超出则滤除pass.setFilterLimitsNegative (true); // 默认为 false，设为 ture 则返回被滤除点pass.filter(*cloud_filtered); // 执行滤波，并将滤波结果存储在 cloud_filtered VoxelGrid（体素化网格）滤波器 实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变 VoxelGrid 三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体== 通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示== 对所有体素处理后得到过滤后的点云 缺点：慢，比体素中心逼近法更慢 1234pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor; // 创建体素栅格滤波对象sor.setInputCloud(cloud); // 读入点云设置为输入sor.setLeafSize(0.01f, 0.01f, 0.01f); // 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米sor.filter(*cloud_filtered); // 执行滤波并存储到 cloud_filtered 滤波结果 ### 统计滤波 （详见博士论文 P40） 用于去除离群点 基于对近邻点集 $P^k$ 的统计分析 计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\\overline d$ 计算点云 $P$ 在平均距离上的分布，并估计平均值 $\\mu_k$ 及标准差 $\\sigma_k$ 对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离 去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。 假设第一次扫描 $P_i$ 和随后的 $P_{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \\in P_i$，搜索其对应的近邻点 $p \\in P_{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。 1234567pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor; // 创建统计滤波对象sor.setInputCloud(cloud); // 设置输入点云sor.setMeanK(50); // 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）sor.setStddevMulThresh(1.0); // 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点sor.filter(*cloud_filtered); // 执行并存储滤波结果sor.setNegative(true); // 获取离群点（此值默认为 false） 滤波结果 参数化模型投影点云 点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0 PCL 中有特意存储常见模型系数的数据结构 12345678910111213// Create a set of planar coefficients with X=Y=0,Z=1 pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients()); // 创建 模型系数 对象coefficients-&gt;values.resize(4); // 参数个数置为 4coefficients-&gt;values[0] = coefficients-&gt;values[1] = 0; // 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Ycoefficients-&gt;values[2] = 1.0;coefficients-&gt;values[3] = 0;// Create the filtering objectpcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj; // 设置投影滤波对象 proj.setModelType(pcl::SACMODEL_PLANE); // 设置对象对应的投影模型类型，此处为平面模型proj.setInputCloud(cloud); // 设置输入proj.setModelCoefficients(coefficients); // 设置模型系数为前述定义系数proj.filter(*cloud_projected); // 执行并保存 从一个点云中提取一个子集 基于 ExtractIndices 滤波器（基于分割算法） 12345pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; // 创建分割对象extract.setInputCloud(cloud_filtered); // 设置输入点云 extract.setIndices(inliers); // 设置分割后的内点为需要提取的点击（分割部分略）extract.setNegative(false); // 指定提取内点extract.filter(*cloud_p); // 执行并存储 RadiusOutlierRemoval / ConditionalRemoval 移除离群点RadiusOutlierRemoval 删除输入点云一定范围内没有达到足够多近邻的所有数据点 人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。 12345678pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem; // 创建半径滤波对象// build the filteroutrem.setInputCloud(cloud); // 设置输入点云outrem.setRadiusSearch(0.8); // 设置搜索半径为 0.8outrem.setMinNeighborsInRadius(2); // 设置所需近邻点数为 2outrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)// apply filteroutrem.filter(*cloud_filtered); // 执行滤波并保存 ConditionalRemoval 如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个 123456789101112pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::Ptr range_cond(new pcl::ConditionAnd&lt;pcl::PointXYZ&gt;()); // 创建条件定义对象range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(\"z\", pcl::ComparisonOps::GT, 0.0))); // 添加比较算子：z 字段上大于 0.0 range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(\"z\", pcl::ComparisonOps::LT, 0.8))); // 添加比较算子：z 字段上小于 0.8 // build the filterpcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem; // 初始化条件滤波condrem.setCondition(range_cond); // 设置条件为指定的比较算子condrem.setInputCloud(cloud); // 设置输入点云condrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN// apply filtercondrem.filter(*cloud_filtered); // 执行滤波并保存 CropHull 任意多边形内部点云提取 CropHull 滤波器得到 2D 封闭多边形内 / 外的点云 深度图像（Range/Depth Images） 将图像采集器到场景中各点的距离（深度）值作为像素值的图像（距离是相机到场景点的垂直距离，不是连线距离） 直接反映景物可见表面的几何状态 物体的三维表示形式，可通过立体相机或 TOF 相机获取 深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据 英文中常见的等价表述：range image，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles 注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息 从点云创建深度图像 主要函数为 createFromPointCloud，声明 9 个参数填充即可 12345678910111213141516171819202122232425void pcl::RangeImage::createFromPointCloud ( const PointCloudType &amp; point_cloud,float angular_resolution = pcl::deg2rad (0.5f),float max_angle_width = pcl::deg2rad (360.0f),float max_angle_height = pcl::deg2rad (180.0f),const Eigen::Affine3f &amp; sensor_pose = Eigen::Affine3f::Identity (),RangeImage::CoordinateFrame coordinate_frame = CAMERA_FRAME,float noise_level = 0.0f,float min_range = 0.0f,int border_size = 0 ) //Create the depth image from a point cloud./*Parameter EX:point_cloud the input point cloudangular_resolution the angular difference (in radians) between the individual pixels in the imagemax_angle_width an angle (in radians) defining the horizontal bounds of the sensormax_angle_height an angle (in radians) defining the vertical bounds of the sensorsensor_pose an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )coordinate_frame the coordinate frame (defaults to CAMERA_FRAME)noise_level - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.min_range the minimum visible range (defaults to 0)border_size the border size (defaults to 0)*/ 从深度图像提取边界 边界：前景跨越到背景的位置 物体边界（黑）、阴影边界（绿）、Veil 点集（红） 若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘 关键点 兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集 数量比原始点云或图像的数据量小很多 组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性 利于加快后续的处理速度 关键概念及算法NARF 关键点*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608. 从深度图像识别物体 步骤 遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测； 遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向； 根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定； 对兴趣值进行平滑过滤； 进行无最大值压缩找到最终的关键点，即为 NARF 关键点。 简化步骤* 给定深度图像，进行边缘提取 表面变化基于边界和曲率原则”评分“ 设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多 Harris关键点 通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点 若 Harris 矩阵特征的两个特征值都很大，则为关键点 对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测 3D Harris 关键点检测使用的是点云表面法向量的信息（2D 使用的是图像梯度） PCL 中的 keypoints深度图像提取 NARF 关键点12345678pcl::RangeImageBorderExtractor range_image_border_extractor; // 创建对象，用于边缘提取pcl::NarfKeypoint narf_keypoint_detector(&amp;range_image_border_extractor); // 创建对象，传入上述提取出的深度图像边缘narf_keypoint_detector.setRangeImage(&amp;range_image); // 传入深度图像narf_keypoint_detector.getParameters().support_size = support_size; // 设置支持范围(搜索空间球体的半径，邻域范围)//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;pcl::PointCloud&lt;int&gt; keypoint_indices; // 创建点云对象，存储检测到的点云narf_keypoint_detector.compute(keypoint_indices); // 计算 SIFT 关键点提取参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客 参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客 参考：SIFT（3）—–尺度空间极值检测_姗姗本人的博客-CSDN博客 注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。 ​ ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向 ​ ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 尺度不变性 局部特征描述子 12345678pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift; // 创建sift关键点检测对象pcl::PointCloud&lt;pcl::PointWithScale&gt; result; // 存储查询结果sift.setInputCloud(cloud_xyz); // 设置输入点云pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());sift.setSearchMethod(tree); // 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快sift.setScales(min_scale, n_octaves, n_scales_per_octave); // 设置限制关键点检测的阈值sift.compute(result); // 执行sift关键点检测，保存结果在result 123456789101112131415// setScales 函数原型void pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::setScales ( float min_scale,int nr_octaves,int nr_scales_per_octave ) 用于指定搜索关键点的尺度范围 // Specify the range of scales over which to search for keypoints.// Parameters 设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）// min_scale the standard deviation of the smallest scale in the scale space 高斯金字塔中组（octaves）的数目// nr_octaves the number of otaves (i.e. doublings of scale) to compute 每组计算的尺度数目// nr_scales_per_octave the number of scales to compute within each octave Harris 关键点提取123456789//harris_detector-&gt;setNonMaxSupression(true);harris_detector-&gt;setRadius(r_normal); // 设置法向量估计的半径harris_detector-&gt;setRadiusSearch(r_keypoint); // 设置关键点估计的近邻搜索半径harris_detector-&gt;setInputCloud (input_cloud);//harris_detector-&gt;setNormals(normal_source);//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);harris_detector-&gt;compute (*Harris_keypoints);cout&lt;&lt;\"Harris_keypoints的大小是\"&lt;&lt;Harris_keypoints-&gt;size()&lt;&lt;endl;writer.write&lt;pcl::PointXYZI&gt; (\"Harris_keypoints.pcd\",*Harris_keypoints,false); 特征描述与提取特征描述 局部特征描述 + 全局特征描述 特征描述子三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有形状描述子（shape descriptors）、几何特征（gometric features）、点特征表示（point feature representations）等。 理论（详见博士论文 P23，37） 给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为：$$||p_i^k-p_q||_x \\leq d_m \\tag{1.1}$$式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见范数）。 此外，$P^k$ 中近邻点的个数可被限制为给定值 k。 点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围：$$F(p_q,P^k)={x_1,x_2,···,x_n}$$式中，$x_i$ , $i \\in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。 比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\\Gamma$ 为描述这两点之间差异的相似性度量，$d$ 为距离度量，则有：$$\\Gamma = d(F_1,F_2)$$当 $d$ 趋向于某个最小值时，即 $d \\to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。 个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。 通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。 理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣： 刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有旋转平移不变性 不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有抗密度干扰性 噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有鲁棒性 也就是说，一个点特征表示满足上述条件才可以说是好的表示法 邻域的概念确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方：$$||X||2 = \\sqrt{\\sum{i=1}^n x_i^2}$$可用于度量两个向量间的差异，如平方差和：$$SSD(x_1,x_2) = \\sum_{i=1}^n(x_{1i}-x_{2i})^2$$也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。 但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。 特征提取输入点云的调用 输入点云调用函数主要有： setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量 setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算 setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间 后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208） 经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。 估计点云的表面法线（详见博士论文 P45） 描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线 一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②直接从点云数据集中近似推断表面法线 对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数 12345// PCL 中估计一点集对应的协方差矩阵Eigen::Matrix3f covariance_matrix; // 定义每个表面小块的 3×3 协方差矩阵的存储对象Eigen::Vector4f xyz_controid; // 定义一个表面小块的质心坐标16字节对其存储对象compute3DCentroid(cloud, xyz_controid); // 估计质心坐标computeCovarianceMatrix(cloud, xyz_controid, covariance_matrix); // 计算 3×3 协方差矩阵 一个平面可用一个点 $x$ 和 一个法向量 $\\overline n$ 表示，则一个点 $p_i \\in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \\overline n$ 。 $x$ 和 $\\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \\in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？） 设$$x = \\overline p = \\frac{1}{k}· \\sum_{i=1}^{k}p_i$$为 $P^k$ 的质心，而 $\\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \\in R^{3 \\times 3}$ 的特征值和特征向量得到，其表达式如下：$$C = \\frac{1}{k} \\sum_{i=1}^{k} \\xi_i · (p_i - \\overline p)·(p_i - \\overline p)^T , \\ C· \\overline v_i = \\lambda_i· \\overline v_j , \\ j \\in {0,1,2}$$式中，$\\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\\lambda_j \\in R$ ，特征向量 $\\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \\le \\lambda_0 \\le \\lambda_1 \\le \\lambda_2$ ，则特征向量 $\\overline v_0$ 对应的最小特征值 $\\lambda_0$ 就是 $+ \\overline n = {n_x,n_y,n_z}$ 或 $ - \\overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\\overline n$ 可由球坐标中的一对角 $(\\phi,\\theta)$ 表示如下：$$\\phi = \\arctan \\frac{n_z}{n_y}, \\ \\theta = \\arctan\\frac{\\sqrt{(n_y^2+n_z^2)}}{n_x}$$问题是，这种主成分分析法（PCA）对方向仍然是模糊的。 表面曲率（详见博士论文P48） 方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\\lambda_0 = min(\\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\\overline n$ 的变化可使用下式估计：$$\\sigma_p = \\frac{\\lambda_0}{\\lambda_0+\\lambda_1+\\lambda_3}$$ 该最小特征值与特征值之和的比值 $\\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。 source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998 法线的定向问题 没有数学方法可以解决法线的正负向问题 法线球体描述了点云中所有法线的方向 对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向 1234567// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）flipNormalTowardsViewpoint ( const PointCloud &amp; cloud,float vp_x,float vp_y,float vp_z,Normals &amp; normals ) 但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \\cdot n_j = 1$。 点特征直方图（PFH）（详见博士论文P51和PCL书P213） bin 可理解为分格的大小，就是直方图每一个柱子的宽度 理论通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。 一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。 为形成新的特征空间，引入 双环邻域 的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \\in P$ 有双环邻域的条件是：$$(\\exists)r_1,r_2 \\in R, \\ r_1 &lt;r_2, \\ \\begin{cases} r_1 \\Rightarrow P^{k_1} \\ r_2 \\Rightarrow P^{k_2}\\end{cases}, \\ 0&lt;k_1&lt;k_2$$两个半径 $r_1$ 和 $r_2$ 用于确定点 $p_i$ 的两个不同的特征表示层：第一层表示的是查询点处的法线，从邻域集 $p^{k_1}$ 的主成分分析中获得，第二层即为 PFH。 PFH 是基于 $P_{k_2} $ 中的点及其法线之间的关系的，即通过参数化查询点与邻域点之间的空间差异，形成一个多维直方图对点的 k 邻域几何属性进行描述。直方图所在的高维超空间为特征表示提供了一个可度量的信息空间，对点云对应曲面的 6 维姿态来说它具有不变性，并且在不同的采样密度或邻域的噪音等级下具有鲁棒性。简言之，它考虑估计法线方向之间所有的相互作用，来尽可能捕获采样表面的变化。故合成的超空间依赖于每个点表面法线估计的质量。（人话就是：PFH 结果的优劣，取决于法线估计的好坏，这也说明，计算 PFH 的第一步就是表面法线的估计） 为计算两点 $p_i$ 和 $p_j$ 之间的相对差以及它们的法线 $n_i$ 和 $n_j$，在其中一点上定义了一个固定的局部坐标系。为使坐标系被唯一定义，做如下规定： 令 $p_{ji} = p_j - p_i, \\ p_{ij} = p_i - p_j$ ，$$if \\quad \\arccos(\\overline n_i \\cdot \\overline p_{ji}) \\le \\arccos(\\overline n_j \\cdot \\overline p_{ij})\\ then \\begin{cases} p_s = p_i,\\ n_s =n_i \\ p_t = p_j, \\ n_t = n_j \\end{cases}\\ else \\begin{cases} p_s = p_j,\\ n_s =n_j \\ p_t = p_i, \\ n_t = n_i \\end{cases}$$定义 $p_s$ 为源点，$p_t$ 为目标点，源点的选择使其法线与连接两点的直线之间的夹角最小。然后，可以在 $p_s$ 处将局部坐标系的原点定义为：$$\\begin{cases} u = n_s \\ v= u \\times \\frac{(p_t - p_s)}{||p_t - p_s||_2} \\ w = u \\times v\\end{cases}$$在该 uvw 坐标系下，两个法线 $n_s$ 和 $n_t$ 之间的差可以表示为一组角度特征，如下:$$\\begin{cases} \\alpha = v \\cdot n_t \\ \\phi = u \\cdot \\frac{(p_t-p_s)}{d} \\ \\theta = \\arctan(w \\cdot n_t,u \\cdot n_t)\\end{cases}$$式中，d 为欧氏距离，$d= ||p_t-p_s||_2$ 。 这样，就只需计算近邻点集 $P^{k_2}$ 中每一对点的特征组成的四个参数 $&lt;\\alpha,\\phi,\\theta,d&gt;$ （将其称为四元组），将原来的12（一个点有 $x,y,z,n_x,n_y,n_z$ (坐标及法线)）个参数减少到了4个。(在一般的实际问题中，d 往往不计在内，实验证明，不计在内效果更好) 下图是计算查询点 $p_q$ 的 PFH 时的影响区域图，查询半径（图中虚线，2D 中圆，3D中球）为 $r$ ，可见其 k 近邻点用网格完全互连。 为创建查询点 $p_i$ 的 PFH 表示，先将所有的四元组放进直方图，这个过程将每个特征的取值范围划分为 b 个子区域，并统计每个子区间中的特征出现次数。 代码123456789101112131415161718192021//为每一对点估计 PFH 四元组computePairFeatures (const pcl::PointCloud&lt;PointInT&gt; &amp; cloud, const pcl::PointCloud&lt; PointNT &gt; &amp; normals,int p_idx,int q_idx,float &amp; f1,float &amp; f2,float &amp; f3,float &amp; f4 ) Compute the 4-tuple representation containing the three angles and one distance between two points represented by Cartesian coordinates and normals.// Parameters 参照上图的坐标系理解[in] cloud the dataset containing the XYZ Cartesian coordinates of the two points //输入点云[in] normals the dataset containing the surface normals (assuming normalized vectors) at each point in cloud //法线[in] p_idx the index of the first point (source) // 源点[in] q_idx the index of the second point (target) // 目标点[out] f1 the first angular feature (angle between the projection of nq_idx and u) // θ[out] f2 the second angular feature (angle between nq_idx and v) // α[out] f3 the third angular feature (angle between np_idx and |p_idx - q_idx|) // Φ[out] f4 the distance feature (p_idx - q_idx) // d 距离 123456789101112131415161718192021222324252627282930// PFH 特征估计// Create the PFH estimation class, and pass the input dataset+normals to itpcl::PFHEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PFHSignature125&gt; pfh; //125是3个角特征量，每个又分为5个区间，故5^3// 这里的 125 是默认值，也就是直接忽略了 d 的pfh.setInputCloud (cloud);pfh.setInputNormals (normals);// 若点云类型是 PointNormal, pfh.setInputNormals (cloud);// Create an empty kdtree representation, and pass it to the PFH estimation object.// Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());pfh.setSearchMethod (tree);// Output datasetspcl::PointCloud&lt;pcl::PFHSignature125&gt;::Ptr pfhs (new pcl::PointCloud&lt;pcl::PFHSignature125&gt; ());// Use all neighbors in a sphere of radius 5cm// IMPORTANT: the radius used here has to be larger than the radius used to estimate the surface normals!!!pfh.setRadiusSearch (0.05);// Compute the featurespfh.compute (*pfhs);// pfhs-&gt;size () should have the same size as the input cloud-&gt;size ()*，即每个点对应一个 PFH特征向量// 实质上，该函数只是执行了以下步骤：对点云 P 中的每个点 p（1）得到p点的最近邻元素（2）对于邻域内的每对点，计算其三个角度特征参数值（3）将所有结果统计到一个输出直方图中 快速点特征直方图（FPFH）PFH 在计算中的复杂度用大O表示法表示的话为 $O(n k^2)$ ，不利于实时应用，需优化，FPFH 将复杂度降低为 $O(nk)$ ，同时保留了前者的识别特性。 理论（详见博士论文P57和PCL书P217） 首先，对每个查询点 $p_q$ ，计算该点及其近邻点的元组 $&lt;\\alpha,\\phi,\\theta&gt;$ ，这一步称为简化点特征直方图（SPFH），图中红线表示； 接着，重新确定每个点（这个点已经是 $p_q$ 的近邻点）的 k 近邻点，使用近邻点的 SPFH 值作为权重计算查询点 $p_q$ 的最终直方图，即为 FPFH：$$FPFH(p_q) = SPFH(p_q) + \\frac{1}{k} \\sum_{i=1}^{k} \\frac{1}{\\omega_k} \\cdot SPFH(p_k)$$式中，权重 $\\omega_k$ 表示在给定的度量空间中，查询点 $p_q$ 与近邻点 $p_k$ 之间的距离，用于评价点对 $(p_q,p_k)$ ，其影响区域图如下士，每个查询点(红色)只与它的k近邻点(由灰色圈包围)相连。每个直接近邻点又与自己的近邻点相连，所得到的直方图与查询点的直方图进行加权，形成FPFH。用粗线画出的是对 FPFH 计算了两次。 人话翻译：确定一个查询点，接着找出该查询点的近邻点，计算其参数元组（三个角度参数），（这个过程为 SPFH）然后对找到的所有近邻点，重新作为查询点，找到其近邻点，计算其 SPFH，然后使用上式进行加权，得到 FPFH。 关于 FPH 和 FPFH 的区别，这里略。 代码与 FPH 不同的是，FPFHEstimation 类的默认特征是将四个角特征量每个分为11个区间，分别计算后合并，形成有 33 个元素的特征向量。 点云配准 各个视角得到的点集合并到一个统一的坐标系下，形成完整的点云数据的过程 / 操作 实质：不同坐标系中测到点云之间的坐标变换 （寻找 R T 的过程）(==错==) 实质是：同一坐标系下不同视角的点云之间的配准，即测量设备始终是同一个，得到的点云在同一个坐标下 点云配准的过程是一个寻找刚性变换矩阵的过程，对于两个点云，一个为源点云 $P_s$ ，另一个为目标点云 $P_t$ ，将源点云通过一定的旋转（R）和平移（t）与目标点云配准（就是让它们完全重合），这个过程可表述为：$$P_t = P_s \\cdot R + t$$ 一对点云的配准（两两配准） 应用一个估计得到一个变换矩阵（R T）使两者完美配准 步骤： 从两个点云提取关键点，注意使用相同的标准 对所有关键点建立其特征描述子 估计对应关系，结合特征描述子在两个数据集中的坐标位置等进行 如含噪声，则去除对配准有影响的对应点 用剩下的正确点对估计刚体变换，完成配准 对应估计 找到相似特征，确定数据重叠部分，进行配准 使用不同方法来搜索特征之间的对应关系 点匹配（即只使用xyz坐标作为特征值）：穷举配准、k-d tree 最近邻查询、有序点云的图像空间查找、无序点云的索引空间查找 特征匹配（如法向量、形状直方图等）：穷举配准、k-d tree 最近邻查询 分类 直接对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点，确认为最终的对应点对（这是默认的估计方式） 相互对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点；接着对对点云 B 中的每个点，都找到其在点云 A 中的对应点，然后取它们的交集作为最终的对应点对 错误对应关系的去除实际中存在着噪声等影响，会导致产生的对应关系不一定是正确的（就是虽然算法找到了对应点对，但其在实际中可能并不是对应的），这些会对最终变换矩阵的估算产生影响，须去除它们，可以提高配准精度和速度。 去除方法：随机采样一致性（RANSAC）等 一对多 的情况：只取距离最近的对应点 ICP算法理论无序点云最经典的配准算法——ICP 算法（ Iterative Closest Point ）：通过最小化重叠区域之间的欧氏距离误差度量，来寻找两数据集之间的最优变换。ICP 算法假定两数据集的每个点都有相应的匹配，并使用待匹配与模型之间最近的点做对应。但问题是，两个点云之间不可能是完全的一一对应关系，所以要建立稳定的对应关系显得尤为重要。 ICP 的核心是不断的去寻找源点云和目标点云中点对的最小距离，并不断缩小这个距离，对变换后的点云继续重复该过程，也就是迭代的过程；该过程用数学表达就是求出 R 和 t ,使误差函数取得最小值：$$E(R,t) = \\frac{1}{n} \\sum_{i=1}^{n} ||P_t^i -(R \\cdot P_s^i+t)||^2$$式中，n 是点对的个数，也就是说，这个目标函数是所有点对之间的欧氏距离的平方和。 ==ICP 选择点对原则：对于源点云中的每个点，其对应点是目标点云中的最近邻点（按欧氏距离计算）== 主要步骤：[1]解则晓, 徐尚. 三维点云数据拼接中ICP及其改进算法综述[J]. 中国海洋大学学报(自然科学版). 对原始点云数据采样 确定初始对应点集 去除错误对应点对 求解坐标变换 ICP的主要问题在于搜索近邻点，这个过程耗时严重，为加速该过程，一般将目标点云存储到 k-d tree 结构中。 简单ICP代码12345678910pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp; // 创建 ICP 对象icp.setInputSource(cloud_in); // 设置一个输入点云作为 源点云icp.setInputTarget(cloud_out); // 设置一个输入点云作为 目标点云pcl::PointCloud&lt;pcl::PointXYZ&gt; Final; // 存储最终的匹配结果icp.align(Final); // 执行匹配std::cout &lt;&lt; \"has converged:\" &lt;&lt; icp.hasConverged() &lt;&lt; \" score: \" &lt;&lt; // 匹配是否正确，返回值为 1 则为正确 icp.getFitnessScore() &lt;&lt; std::endl; // 理解为对 配准的评分 std::cout &lt;&lt; icp.getFinalTransformation() &lt;&lt; std::endl; // 获取转换矩阵 逐步匹配多幅点云按输入的顺序两两匹配，得到最终的效果，结果是最终转换到第一个点云的坐标系下 交互式ICP通过可视化界面实现用户敲空格键时，进行配准，需在内部设置 ICP 迭代次数 详见Interactive Iterative Closest Point — Point Cloud Library 0.0 documentation (pcl.readthedocs.io) 正态分布变换配准（NDT） 适用于大型点云数据集 配准过程不使用对应点的特征计算及匹配，速度快 NDT 算法中，在目标点云对应的体素网格数据结构的统计计算中不使用单个点，而是使用包含在每个体素单元格中的点的统计数据 使用体素化数据结构 + More-Thuente 搜索 NDT 核心： 将空间划分为网格（2D 中为正方形，3D 中为立方体） 基于网格内的点分布，计算每个网格的概率密度分布（PDF）。每个网格中的 PDF 可理解为每个网格内曲面上的点 $\\overline x$ 的生成过程；也就是说，假设 $\\overline x$ 的位置是由 D 维的正态随机过程生成的 理论（详见：Magnusson M. The three-dimensional normal-distributions transform: an efficient representation for registration, surface analysis, and loop detection[D]. Örebro universitet, 2009. 从P55开始 两种常见的点云配准方法ICP&amp;NDT_banzhuan133的博客-CSDN博客_ndt点云配准） 对于一个随机（多维）变量，若其满足正态分布，则其对应的 PDF 为：（对应于点云：将目标点云网格化，然后计算每个网格内的多维正态分布）$$p(\\vec{x}) = \\frac{1}{(2 \\pi)^{D/2} \\sqrt{\\Sigma}} exp(- \\frac{(\\vec{x} - \\vec{\\mu})^T \\Sigma^{-1} (\\vec{x}-\\vec{\\mu})}{2})$$式中，$\\vec{\\mu}$ 为均值向量，$\\Sigma$ 为协方差矩阵（对角元素为每个变量的方差，非对角元素为协方差），$D$ 为维数。 $\\vec{\\mu}$ 和 $\\Sigma$ 可单独计算：$$\\vec{\\mu} = \\frac{1}{m} \\sum_{k=1}^{m} \\vec{y_k} \\\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad\\Sigma = \\frac{1}{m-1} \\sum_{k=1}^{m} (\\vec{y_k}-\\vec{\\mu})(\\vec{y_k}-\\vec{\\mu})^T$$式中的 $\\vec{y}_{1, \\cdots ,m}$ 表示一个网格中所有的点。（也就是说，上式中的 $p(\\vec{x})$ 实质是计算每个网格的 PDF ） 使用正态分布表示离散点云的优势在于：正态分布是对点云的分段（分块表示，网格）平滑表示，具有连续的导数；每个 PDF 可看作是局部表面的一种近似，描述了该表面的位置、方向、平滑度。在 2D 或 3D 中 ，表面方向和平滑度可用协方差矩阵的特征向量和特征值表示。对于三维的正态分布，随着 $\\Sigma$ 的特征值变化，有着不同的形状（图中箭头表示特征向量，长短表示其特征值的大小） ![3D 正态分布下的不同形状](F:\\AFIGHT\\笔记\\PCL\\assets\\Differ shape of 3D PDF.png) NDT 配准NDT 的配准目标是找到一个源点云的姿态，使源点云中的点位于目标点云平面上的可能性最大。（△） 若源点云为 $\\chi = { \\vec{x_1}, \\cdots , \\vec{x_n} }$ ，其姿态变换（R，T）用一个向量 $\\vec{p}$ 表示；假设空间变换函数 $T(\\vec{p},\\vec{x})$ 表示使用姿态变换 $\\vec{p}$ 来移动点 $\\vec{x}$ ；另外给定源点云的 $PDF \\quad p(\\vec{x})$ ，则最优位姿 $\\vec{p}$ 应是使似然函数最大化：$$\\Psi = \\prod_{k=1}^{n} p(T(\\vec{p}, \\vec{x}k))$$其等价于最小化 $\\Psi$ 的负对数似然函数（连乘转对数的和）：$$-log\\Psi = - \\sum{k=1}^{n} log(p(T(\\vec{p},\\vec{x}_k)))$$式中的函数 $p$ 即为上述提到的 $PDF \\quad p(\\vec{x})$ 。此外，PDF 也不一定是一个正态分布（只要可以局部捕获表面点结构，且对异常值具有鲁棒性即可）（详见P59）。 这也再次说明了我们的第一句话（△）：目的就是找到这个最优的 $\\vec{p}$ ，以最大化似然函数（目标函数） 目标很明确，就是优化这个位姿参数，NDT 使用 牛顿迭代法进行优化（见后续）。 问题是，负对数似然函数在远离均值的点上呈无限增长的趋势（见P59 图6.5b或下图)，故若数据中存在噪声等异常值，会对其结果产生较大的影响，有人提出了正态分布与均匀分布结合（$\\overline p(\\vec{x})$）的方式：$$\\overline p(\\vec{x}) = c_1 exp(- \\frac{(\\vec{x} - \\vec{\\mu})^T \\Sigma^{-1}(\\vec{x} - \\vec{\\mu})}{2}) + c_2p_0$$式中，$p_0$ 为异常值的期望值。利用这个函数，离群值的影响是有限的。常数 $c_1$ 和 $c_2$ 可以通过要求在单元格所跨越的空间内 $\\overline p(\\vec{x})$ 的概率质量等于1来确定。 另一个问题是，这种结合的方式没有简单的一阶和二阶导数（其实就是 log 函数求导不方便）；观察负对数似然函数（下图右绿色示），可发现其与高斯函数相像（下图左绿色示），故可用高斯函数来近似上述 $\\overline p(\\vec{x})$ 。 $\\overline p(\\vec{x})$ 对应的 log 形式为（这里 $c_2p_0$ 只剩 $c_2$ ，个人理解为其是一个期望值，是常数，可用一个代替？）：$$-\\log (c_1 exp(- \\frac{(\\vec{x} - \\vec{\\mu})^T \\Sigma^{-1}(\\vec{x} - \\vec{\\mu})}{2}) + c_2)$$函数形式为$$\\overline p(x) = - \\log(c_1 exp(\\frac{-x^2}{2 \\sigma ^2}) + c_2)$$的函数可用形式如下的高斯函数近似：$$\\tilde{p}(x) = d_1 exp(\\frac{-d_2 x^2}{2 \\sigma^2}) + d_3$$当 $x=1，x=\\sigma，x = \\infty$ 时，$\\overline p(x)$ 应与 $\\tilde p(x)$ 相等，以此来拟合 $d_i$ ：$$d_3 = - \\log(c_2) \\d_1 = - \\log(c_1 + c_2) -d_3 \\d_2 = -2 \\log(\\frac{-\\log(c_1 e^{- \\frac{1}{2}} + c_2 -d_3)} {d_1})$$如此，源点云中的一点对 NDT 评分函数的影响可用高斯函数近似为：$$\\tilde p(\\vec{x}_k) = -d_1 exp(- \\frac{d_2}{2} (\\vec{x}_k - \\vec{\\mu}_k)^T \\Sigma_k^{-1} (\\vec{x}_k - \\vec{\\mu}_k))$$这里忽略了常数 $d_3$ ，因其只是对评分函数进行了一个偏移，但并不影响其形状或参数。 到此，目标函数变为：$$s(\\vec{p}) = - \\sum_{k=1}^{n} \\tilde{p}(T(\\vec{p},\\vec{x}_k))$$所以上述过程就是将源点云的 PDF $p(x)$ 用 $\\tilde{p}(x)$ 近似的过程，最后得到的近似表示如上 可以看出，似然函数需要求 $\\Sigma^{-1}$ ，但若网格内的点是完全共面或共线，则 $\\Sigma$ 是奇异的，无法求逆（详见P60）。 位姿参数 $\\vec{p}$ 可用牛顿迭代法求解，其方程为：$$H \\Delta \\vec{p} = - \\vec{g}$$式中，$H$ 为海森矩阵，$\\vec{g}$ 为 $s(\\vec{p})$ 的梯度向量，$\\Delta \\vec{p}$ 在每次迭代过程中加到当前的位姿估计中，即 $\\vec{p} \\leftarrow \\vec{p} + \\Delta \\vec{p}$ 。 （具体求解详见P61) 代码12345678910111213141516171819202122// 一般在 NDT 配准前需要进行滤波处理，这里使用体素中心网格法pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);pcl::ApproximateVoxelGrid&lt;pcl::PointXYZ&gt; approximate_voxel_filter;approximate_voxel_filter.setLeafSize(0.2, 0.2, 0.2);approximate_voxel_filter.setInputCloud(input_cloud);approximate_voxel_filter.filter(*filtered_cloud);// NDT 参数初始化pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt; ndt.setTransformationEpsilon(0.01);//设置变换的ε：两个连续的变换(迭代)之间允许的最大差值，用于判断优化过程是否达到最终的阈值ndt.setStepSize(0.1); //牛顿法优化的最大步长（收敛速率系数，理解为什么时候终止？？）ndt.setResolution(1.0); //分辨率设置，也就是体素化网格的边长ndt.setMaximumIterations(35); //迭代的次数：达到该次数时停止ndt.setInputSource(filtered_cloud);ndt.setInputTarget(target_cloud);// 初始化变换参数并执行优化Eigen::AngleAxisf init_rotation(0.6931, Eigen::Vector3f::UnitZ()); //初始位姿 REigen::Translation3f init_translation (1.79387, 0.720047, 0); // TEigen::Matrix4f init_guess = (init_translation * init_rotation).matrix(); //初始搜索位置pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);ndt.align(*output_cloud, init_guess); //执行配准 点云分割 根据空间、几何、纹理等特征对点云进行划分，使得同一划分内的点云具有相似的特征 聚类分割算法 详见下一章——论文：聚类与分割 m 个数据，m 维空间内，定义点与点之间的某种性质的亲属聚类；若 m 个数据点构成 n 类，将具有最小距离的两类合为一类，然乎重新计算两类的之间的距离，如此迭代，直至两类之间的距离大于指定的阈值，或者类的个数少于指定的数目，完成分割。 RANSAC 随机采样一致性 从样本中随机抽取一个样本子集，使用最小方差估计法对自己进行模型参数的计算，再计算所有样本与该模型的偏差，将该偏差与设置好的阈值进行比较，若其小于设定的阈值，则为内点，否则为外点 根据一组包含噪声、外点等缺陷的样本数据集，估计出数据的数学模型，同时得到有效的样本数据 参数 $\\tau$ ：误差容忍度，判断样本是否满足模型 M 的误差容忍度 $Max$ ：随机抽取样本集的次数（即抽取子集的次数） $N$ ：指定的阈值 12345pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;::Ptr model_p(new pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;(cloud)); //定义为平面模型（还有其他模型）pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; ransac(model_p); ransac.setDistanceThreshold(.01); //阈值设置ransac.computeModel(); //计算模型ransac.getInliers(inliers); //获取内点 123456789101112Algorithm : RANSAC1) Initial: let A be a set of N feature correspondences2) repeat2.1) Randomly select a sample of s points from A2.2) Fit a model to these points2.3) Compute the distance of all other points to this model2.4) Construct the inlier set (i.e. count the number of points whose distance from the model &lt; d)2.5) Store these inliers2.6) until maximum number of iterations reached3) The set with the maximum number of inliers is chosen asa solution to the problem4) Estimate the model using all the inliers 平面点云分割123456789pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients); //模型系数对象pcl::PointIndices::Ptr inliers(new pcl::PointIndices); //内点对象pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg; // Create the segmentation object，点云分割对象seg.setOptimizeCoefficients(true); // Optional，可选项，设置是否优化系数seg.setModelType(pcl::SACMODEL_PLANE); // Mandatory，必选项，设置分割类型seg.setMethodType(pcl::SAC_RANSAC); // Mandatory，设置分割方法seg.setDistanceThreshold(0.01); // Mandatory，设置距离阈值seg.setInputCloud(cloud);seg.segment(*inliers, *coefficients); //执行分割 圆柱体模型分割12345678910seg.setOptimizeCoefficients(true);seg.setModelType(pcl::SACMODEL_CYLINDER);seg.setMethodType(pcl::SAC_RANSAC);seg.setNormalDistanceWeight(0.1);seg.setMaxIterations(10000);seg.setDistanceThreshold(0.05);seg.setRadiusLimits(0, 0.1);seg.setInputCloud(cloud_filtered2);seg.setInputNormals(cloud_normals2);seg.segment(*inliers_cylinder, *coefficients_cylinder); 欧式聚类提取12345678std::vector&lt;pcl::PointIndices&gt; cluster_indices;pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;ec.setClusterTolerance(0.02); // 2cmec.setMinClusterSize(100);ec.setMaxClusterSize(25000);ec.setSearchMethod(tree); //kd-treeec.setInputCloud(cloud_filtered);ec.extract(cluster_indices); 区域生长分割 从曲率最小的点开始生长（初始种子点） 输出是一个聚类集合，每个聚类集合属于同一光滑表面的一部分 基本思想： 根据输入点的曲率值对点排序，曲率最小的点为初始种子点，该点所在的区域为最平滑区域，也就是从最平滑区域开始生长，减少分割区域的总数，提高效率。 核心：比较近邻点与种子点之间的两个指标 法线夹角的比较：小于设定的阈值进入区域，即为同一类（满足此条件时进入下一步的判断） 曲率大小的比较：小于设定的阈值进入序列（这是为何进行排序的原因，形成一个种子序列，每完成一次比较，删除当前的种子点，使用序列中的下一个种子点继续进行比较，如此迭代） 还需设定一个最小点簇数和最大点簇数 种子序列为空时意味着算法完成了区域增长，从头开始进行重复上述过程 123456789101112pcl::RegionGrowing&lt;pcl::PointXYZ, pcl::Normal&gt; reg;reg.setMinClusterSize(50);reg.setMaxClusterSize(1000000);reg.setSearchMethod(tree);reg.setNumberOfNeighbours(30);reg.setInputCloud(cloud);//reg.setIndices (indices);reg.setInputNormals(normals);reg.setSmoothnessThreshold(3.0 / 180.0 * M_PI); // 平滑阈值reg.setCurvatureThreshold(1.0); //曲率阈值std::vector &lt;pcl::PointIndices&gt; clusters;reg.extract(clusters); //执行分割 超体素点云分割（VCCS） 空间八叉树结构 + k-mean 聚类的区域增长 直接对点云进行超体素分割 超体素特征： 在3D空间中，均匀分布（可通过在点云空间中均匀设定种子达到） 除非在体素空间上相连，否则超体素不能跨越边界 在空间分辨率为 $R_{seed}$ 的三维空间网格中，对均匀分布在空间中的种子点进行增长形成超体素。这里为提高搜索效率，只考虑以种子为中心的半径为 $R_{seed}$ 区域内的点。 论文：聚类与分割 聚类（clustering）将数据集中的样本划分为不相交的子集，每个子集成为一个“簇（cluster）” 聚类过程形成簇结构 簇标记（cluster label） 拟合简化的集合模型（平面模型） 不共线的三点确定一个平面，故先从点云 $\\mathcal{P}$ 中随机选取不共线的三点 ${p_i,p_j,p_k}$ 根据选定的三个点计算平面模型系数（$ax+by+cz+d=0$）（可根据克莱姆法则计算，详见 Plane (geometry) - Wikipedia） 计算点云 $\\mathcal{P}$ 中所有点 $p$ 到该平面模型的距离（$p_n \\quad (a,b,c,d)$） 保存距离在指定阈值内的点 $p^* \\in \\mathcal{P}$，并计算其个数 上述的最后一步表示对模型的评分；每个点集 $p^$ 都会被保存，且上述步骤会重复（迭代） $k$ 次。算法终止后，点的数量最多的点集（内点），就是对平面模型描述最好的点集（能最好的拟合平面模型）。对所有的点 $p^ \\in \\mathcal{P}$ ，平面模型系数用最小二乘估计。 上述过程就是找到内点集 $p^*$，拟合出平面或者估计出其2D边界多边形的简化过程，在实际应用中，还需增加额外的约束条件。 基本聚类技术 依赖于空间分解技术，基于给定的标准，寻找分块及边界，实现分类 评判标准：闵氏范数：曼哈顿距离（L1）、欧式距离（L2） 欧式聚类数据结构：八叉树（3D网格） 优点：易于快速构建，适用于不同情况，如需要占用空间的体积表示、用不同结构估计叶节点中的数据等 缺点：3D网格只适用于空间等分的情况 对于聚类分块大小不一的情况，需要更复杂的算法（下述）。 实例： 点聚类 $O_i = {p_i \\in \\mathcal{P}}$ 与点聚类 $O_j = {p_j \\in \\mathcal{P}}$ 不同的条件是： $$min||p_i-p_j||2 \\ge d{th}$$ 式中，$d_{th}$ 是指定的阈值。 即：点集 $p_i \\in \\mathcal{P}$ 与点集 $p_j \\in \\mathcal{P}$ 之间的最小距离大于指定的阈值，则前者中的点属于聚类 $O_i$，后者属于聚类 $O_j$ 。 一个问题是，这个最小距离该如何估计？ 最小距离的估计：使用 kd-tree 进行最近邻查询 算法伪代码： 输入点云 $\\mathcal{P}$ ，创建 kd-tree 表示 设置簇 $C$ 的空列表，以及点集序列 $Q$ 对输入点云的每一个点 $p_i \\in \\mathcal{P}$ ，执行以下步骤 将 $p_i$ 添加到当前序列 $Q$ 对添加到序列中的每个点 $p_i \\in Q$： 以3D空间中半径为 $r&lt;d_{th}$ 的球体搜索 $p_i$ 的近邻点（近邻点搜索半径 r），结果形成点集 $P_i^k$ （setRadiusSearch） 对每个近邻点 $p_i^k \\in P_i^k$，若未被分类则将其添加到序列 $Q$ 序列 $Q$ 中的所有点处理完后，将 $Q$ 添加到簇 $C$ 的序列（内点）并重置为空序列 算法终止条件：点云中的所有点均被遍历，且已成为簇 $C$ 的列表的一部分 聚类算法(cpp) 1234567891011//被分割出来的点云团（标号队列）std::vector&lt;pcl::PointIndices&gt; cluster_indices;//欧式分割器pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;ec.setClusterTolerance(0.02); // 2cmec.setMinClusterSize(100);ec.setMaxClusterSize(25000);//搜索策略树ec.setSearchMethod(tree);ec.setInputCloud(cloud_filtered);ec.extract(cluster_indices); 边缘查询 表面曲率可用于点云分割：是对点附近采样点的几何近似估计，它们对确定那些具有极高曲率值的点很有用，这些点代表点云数据集 $\\mathcal{P}$ 的几何边缘 2D 图像中边缘可用梯度定义，3D 中则是场景中几何形状变化剧烈的位置","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"}]},{"title":"毕设：链片条复合模CAD系统使用须知","slug":"链片条复合模CAD系统使用须知","date":"2020-05-25T16:53:26.616Z","updated":"2022-07-29T13:03:24.513Z","comments":true,"path":"2020/05/26/Graduate_2/","link":"","permalink":"https://hbroad.github.io/2020/05/26/Graduate_2/","excerpt":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！","text":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！ 已知错误1：数据库引擎本系统采用 ACCESS 作为数据库，经测试（虚拟机测试），win7 等系统上会出现 “未在本地计算机上注册‘Microsoft. ACE. OLEDB. 12. 0’提供程序”类似的提示。 运行错误提示 解决1：安装数据库引擎即可，点击下方“下载”，下载完成后安装，提示安装成功后尝试再次运行本系统。 下载","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"毕设：链片条复合模CAD系统","slug":"链片条复合模CAD系统使用说明","date":"2020-05-25T13:47:41.893Z","updated":"2022-07-31T11:37:26.933Z","comments":true,"path":"2020/05/25/Graduate_/","link":"","permalink":"https://hbroad.github.io/2020/05/25/Graduate_/","excerpt":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖","text":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖 开发平台系统环境：Windows 10 2004 专业版开发环境：VB.NET数据库：ACCESSS 365软件平台：VS 2010 系统简介该复合模 CAD 系统主要包含以下功能： 用户登录 参数输入 设计计算 主界面 设计结果 标准件库 建模装配 关于系统 用户登录首先，用户在打开系统后，会出现登录界面，该界面四个按钮的功能如下：1.登录：如若账号密码均正确，通过此按钮即可进入下一界面；2.取消：如用户输入时出错，想直接清空输入框，可使用此按钮；3.注册：新用户可通过注册后再登录；4.退出：退出系统。 系统登陆界面 参数输入用户登录后将进入该界面，在该界面由用户输入需要的尺寸值，也可使用默认值，点击开始设计，并选择模具的最小闭合高度，在确定之后即可开始设计计算。 参数输入界面 闭合高度选择 主界面系统主界面下可进行设计结果的查询、标准件的尺寸查询、三维建模与装配（调用同组同学 GRIP 程序）、查看仿真动画、系统信息及帮助文档 此外，在查询结果菜单下，用户可通过点击零件图纸查看零件的三维模型。 系统主界面 系统主界面菜单 结果查询界面 零件信息界面 点击零件图纸查看零件的三维模型 剩余界面较为简单，这里不再赘述！ 系统演示视频","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"全国性哀悼活动","slug":"悼念日","date":"2020-04-04T10:49:31.000Z","updated":"2022-07-29T13:02:42.816Z","comments":true,"path":"2020/04/04/ChinaIsTheBest/","link":"","permalink":"https://hbroad.github.io/2020/04/04/ChinaIsTheBest/","excerpt":"据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。","text":"据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。","categories":[{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/categories/Commemorate/"}],"tags":[{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"}]},{"title":"开天辟地","slug":"hello-world","date":"2020-04-02T09:03:42.485Z","updated":"2022-07-29T13:03:48.864Z","comments":true,"path":"2020/04/02/hexo_new/","link":"","permalink":"https://hbroad.github.io/2020/04/02/hexo_new/","excerpt":"这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！","text":"这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://hbroad.github.io/tags/git/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"},{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/categories/Commemorate/"},{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/categories/hexo/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"华为机考","slug":"华为机考","permalink":"https://hbroad.github.io/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/"},{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"},{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"},{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"},{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://hbroad.github.io/tags/git/"}]}