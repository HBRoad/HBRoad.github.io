{"meta":{"title":"南阳向北","subtitle":"","description":"","author":"南阳","url":"https://hbroad.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-03T12:48:48.785Z","updated":"2020-05-03T12:48:48.785Z","comments":true,"path":"about/index.html","permalink":"https://hbroad.github.io/about/index.html","excerpt":"","text":"我是南阳 一个计算机的狂热爱好者"},{"title":"大佬们","date":"2020-04-04T11:21:13.453Z","updated":"2020-04-04T11:21:13.453Z","comments":true,"path":"friends/index.html","permalink":"https://hbroad.github.io/friends/index.html","excerpt":"虽然我很菜，但好在这里有大佬","text":"虽然我很菜，但好在这里有大佬 友链规范1234567name: # 博客名avatar: # 头像链接url: # 博客链接backgroundColor: &#39;#3E74C9&#39; # 卡片背景颜色textColor: &#39;#fff&#39; # 卡片文字颜色tags: [标签1, 标签2] # 标签desc: 描述文字"},{"title":"所有分类","date":"2020-04-03T05:37:58.645Z","updated":"2020-04-03T05:37:58.645Z","comments":true,"path":"categories/index.html","permalink":"https://hbroad.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-03T05:39:00.908Z","updated":"2020-04-03T05:39:00.908Z","comments":true,"path":"tags/index.html","permalink":"https://hbroad.github.io/tags/index.html","excerpt":"","text":""},{"title":"致谢","date":"2020-04-03T13:19:42.849Z","updated":"2020-04-03T13:19:42.849Z","comments":true,"path":"thx/index.html","permalink":"https://hbroad.github.io/thx/index.html","excerpt":"","text":"感谢 hexo 的博客网站框架！！ 感谢 xaoxuu 大佬的博客主题！！ 感谢 TRHX 大佬对小白的帮助！！"}],"posts":[{"title":"C++ 学习笔记","slug":"CPP/C++","date":"2022-08-23T07:51:17.900Z","updated":"2022-08-23T07:51:07.496Z","comments":true,"path":"2022/08/23/cpp_learning/","link":"","permalink":"https://hbroad.github.io/2022/08/23/cpp_learning/","excerpt":"C++ 学习笔记上传（研） 原链接","text":"C++ 学习笔记上传（研） 原链接 小概念集锦 外存储器的容量大， 大部分可移动，便于在不同计算机之间进行信息交流。其只有被读入内存储器后才可被CPU读取，即CPU不能直接访问外存储器 进程是可以并发执行的程序的执行过程 循环队列是顺序存储结构 拷贝构造函数： 程序中需要新建立一个对象，并用另一个对象去初始化 函数的参数为类的对象 函数的返回值是类的对象 类外同名的变量赋值，不能改变类内的静态变量值 程序中的 typename 都可以替换为 class NULL 与 nullptr NULL 在 C 中表示 void，即指向任意类型的指针，C 中会完成隐式类型转换，但 C++ 中是强制类型转换，导致 void 不能隐式转换为其他类型 起初 C++ 用 0 代替空指针，但其在函数重载时发生二义性，后续直接用 nullptr，而 NULL 表示 0 CPP小概念基本框架结构化程序设计框架 函数是程序的基本单元 面向对象程序设计框架 类是程序的基本组成单元 数据类型 单精度不能超过 7 位有效数字，双精度不能超过 15 位 一个字符串常量在存储时在给定的字符序列后再加一个空字符（‘\\0’），而字符常量不加 任一种进制的整数，可添加后缀字母 U 或 L，表示无符号整型（usigned int）和长整型（long int），也可同时添加两者，无排序要求，如：55L，100LU 变量 变量的存储类属性 auto（自动变量）：默认存储类别，占用空间的分配和释放由系统自动完成 register（寄存器变量）：寄存器虽然快，但其数量有限，当其不够时，仍然按照 auto 处理 static（静态变量）：任何静态变量的生存期将延续到整个程序的终止；编译器为其分配的空间在整个程序运行期间不会释放；若未赋初值，系统自动赋值为 0 extern（外部变量）：声明为外部变量后，该变量可被其他文件引用，可避免为其重复分配内存 typedef 类型 给现有的数据类型起一个别名 符号常量 概念：用 const 修饰的标识符 原则：先声明，后使用 声明：const int i = 1； 用 const 声明的常量只能被读取，故在声明时需初始化，且其值在程序中无法改变 可用预处理命令 #define 定义符号常量：#define PI 3.14 运算符和表达式运算符 单目 双目 三目：?:（C++只此一个） 运算类型 赋值运算：可一次性给多变量赋值：x=y=z=1; 其从右往左依次赋值，即 z=1，接着将 z=1 赋给 y，得 y=z=1，最后得 x=y=z=1 自增运算 a++：先参与运算，运算后再 +1 ++a：先 +1，再参与到运算中 逻辑运算符 ！ &amp;&amp; || 优先级依次递减 其他运算符 条件运算符：?: a&gt;b ? 1:0；若a&gt;b，返回1 ，否则0 逗号运算符：返回最后表达式的值 (a = 3 * 5, a * 4), a + 5; // a = 15，表达式结果为 20 sizeof运算符：取得任何变量和类型在内存中占用的字节数 sizeof(int); //4 #include &lt;cmath&gt; // C++ 数学函数 指针指针和地址 指针：变量的地址就是该变量的指针 指针变量：存放地址的变量 指针运算 指针变量和整型量加减 = 指向下一元素 相同的指针变量类型之间可以赋值 两个指向同一类型的指针变量进行逻辑运算，实质是地址的比较 两指向同一数组成员的指针变量可减运算，结果为两指针之间相差的元素个数 指针和数组 数组名即为该数组首元素的地址，即指针 数组名是常量指针，而指针是指针变量 1234567891011int a[10];int *p;//首元素的地址给指针p = &amp;a[0];p = a;//取首元素a[0];*p;*a; 字符串常量可以赋给指针变量，会将前者第一个字符的指针给后者 引用 引用即为变量起别名 既然是起别名，在定义时就要初始化，即指定给谁起别名 既然是别名，那么对引用的操作就是对变量本身的操作 引用就是两个变量使用的是同一块内存单元 12int i = 1;int &amp;j = i; // 给 i 起别名为 j &amp;只是标识符，非取地址符 一旦引用被初始化，不可更改为另一变量的引用 动态存储分配 静态存储分配是在编译阶段确定变量占据的空间，而部分程序只有在运行时才能确定，即为动态内存分配 new 申请，delete 释放 1234567891011121314151617//对某种数据类型分配空间，赋初值10int *a;a = new int(10);//或int *a = new int;*a = 10;//释放delete a;// 对数组int *b;b = new int[10]; // 元素个数可以是变量，这是与一般的数组声明最大的区别//释放delete[] a; 动态内存分配是在堆内存或自由存储区，数量有限，当耗尽时再申请会返回空指针 NULL，故在分配空间后，可做判断如下： 12if (a == NULL) exit(0); //正常结束程序 动态分配后的内存需显式的释放，由 new 申请，则必须由 delete 释放 函数函数及声明 函数不能嵌套，即函数内部不能定义其他函数 函数原型声明的两种形式（注意是声明不是定义） 123double sort(int a[], int b);//或省略形参变量名double sort(int [], int); 函数参数参数的传递方式 值传递 实参不变，将实参复制一份给形参 虽不会改变实参的值，但当传递参数的大型的类对象时，空间和时间开销过大 传地址 传地址之后将改变实参的值 引用传递 隐式的传地址 参数声明为引用时，调用时编译器将自动传递实参的地址给被调用函数 一般情况下，当传递大型的数组或类对象时，采取传递指针的方式，因为任意类型的指针大小是一样的（32位下为 4 字节，64 位下为 8 字节），相比复制传递的方式，空间开销小很多。 建议传地址时使用引用代替指针 指针和引用的区别 定义和性质的不同 指针是地址，引用只是变量的别名，与原变量共用一块地址 函数传参时的区别 指针传参可以直接操作实参的地址，对实参进行改变 引用传参是直接传递实参本身，节约时间空间 默认参数 默认参数 缺省的实参只能用于替换函数调用中缺少的尾部实参，即函数调用是按位置依次赋值的，不是按照参数的类型匹配的，即实参的类型要和形参的顺序一致 12345int default_n(int a = 1, int b = 2, char c = ' ');//调用default_n(, , '&lt;&lt;'); // 该调用并不等价于 default_n(1, 2, '&lt;&lt;');defaulr_n('&lt;&lt;'); //同上 函数重载参数个数/参数类型不同 内联函数 为取代预处理宏函数 inline 关键字放在函数定义中的函数类型之前 内联函数和宏函数 宏函数由预处理器进行替换，而内联函数由编译器实现，是真正的函数 但内联函数调用时像宏一样展开，执行效率更高 内联函数和普通函数 普通函数的调用将控制转移给被调用函数，从而调用有一定的时间和空间开销 内联函数直接将被调用函数复制一份到调用的地方，效率更高 但该优点也是缺点，即内联函数的函数体不能太大，结构也不能太复杂，否则编译器将放弃内联方式转而采用普通方式调用 递归函数类和对象类 数据成员：属性 类中数据成员的类型任意，包括另一个类的对象 虽自身类的对象不能作为数据成员（因为类还没定义完成，该类型没法分配存储空间），但自身类的指针或引用可以（任意类型的指针大小是确定的） 类体内不能对数据初始化，初始化由构建函数完成 成员函数：行为 在类内定义的成员函数皆为内联函数 类外也可定义函数，通过类名+作用域运算符::来表明函数属于哪个类 成员函数可重载，参数可设置默认值 类成员的访问控制 私有成员只能被自己所属类中的成员函数及友元函数访问 对象 对象的定义 可定义一般类对象、对象数组、对象指针、对象引用 1234class c1;class c2[10];class *c3;class &amp;c4 = c1; 对象的成员及其访问 . 运算符：访问一般对象的成员（数据成员或成员函数），也可访问对象引用或对象数组的成员，方法一致 123456789class Time&#123; public: int hour; void settime();&#125;;Time T1;T1.hour;T1.settime(); -&gt;运算符：访问一个指针变量所指向的对象成员，等价于 (*对象指针名).成员 12345678Time T1;Time* T2 = T1;//对象指针变量 T2 的成员访问T2 -&gt; hour;T2 -&gt; settime();//或(*T2).hour;(*T2).settime; 构造函数和析构函数 构造函数的作用：用于新建对象的初始化工作 析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等 每当创建对象，需要对该对象完成初始化时，则需要定义自己的构造函数；而对象撤销，需要自己添加清理工作代码时，则需要定义自己的析构函数 共同特点： 类体中说明的两种成员函数 没有返回值，void也不行 构造函数可带参数，可重载；析构函数都不能 构造函数 函数名与类名相同 函数体可在体内/体外 一般声明为公有函数 在定义对象时被系统直接调用，用户不能直接调用构造函数 构造函数初始化对象：类名 对象名 (参数表)，如：class c1 (1,2,3); 运算符 new + 构造函数： class * c2 = new class () 定义对象数组时只能调用没有参数或所有参数都有默认值的参数 定义对象指针时不会调用构造函数，因为指针变量还未实例化 析构函数 ~ 类名 函数体可在体内/外 在对象生存期即将结束时由系统自动调用，之后对象消失，内存空间被释放 一个类只能定义一个析构函数 delete 运算符和析构函数一起使用 默认构造/析构函数 不带参数 函数与类名相同 参数为空或所有参数带默认值 用户未定义时系统自动建立 拷贝构造函数 只有一个参数，类型是本类对象的引用 每个类必须要有，若没有则编译系统自动生成一个公有的 被调用的 3 种情况： 用类的已知的对象去初始化另一对象 对象作为函数的实参传递给函数形参 对象作为函数的返回值 形式： Copy_ConsFun_Name(const class_name &amp;obj_name) 自由存储对象 由堆运算符 new 和 delete 建立和删除 new 创建单个对象：根据参数调用构造函数 new 创建对象数组：调用默认构造函数 delete 删除对象：调用析构函数 new 或 delete 是显式的调用构造函数，调用的顺序取决于 new 和 delete 的顺序，析构的顺序不一定与构造的顺序相反，但对象数组中各个元素的构造和析构仍然是相反的 delete 删除对象和对象数组时各调用一次析构函数 this 指针 对象创建后，对象的每个成员函数都含有一个系统自动生成的隐含指针，用于保存该对象的地址 “指向本对象的指针” 成员函数所属的对象指针，指向类对象的地址 成员函数可以通过该指针知道自己属于哪个类 this -&gt; 成员变量 可用于区分形参变量和对象成员变量（形参变量和成员变量标识符一致时更加明显） 一般不写，系统默认设置，但要注意： 只能在类的成员函数中使用，指向该函数被调用的对象，一般用于返回当前对象本身 静态成员函数没有 this 指针 编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。 友元函数没有 this 指针 （因为友元函数不属于任何类） 静态成员类中的非静态成员，每个类对象都有一个拷贝（副本），相互独立；而静态成员便是解决同一类的不同对象之间的数据和函数共享问题的，即不管该类拥有多少对象，其静态成员都只有一个副本，该副本被所有对象共享。 表示整个类范围的信息，以 static声明 静态数据成员 静态数据成员的值对所有对象都是一样的，但每个对象可以更新其值 必须初始化，格式为：数据类型 类名 :: 静态数据成员名 = 值 初始化在类体外进行，且前面不加 static，以免与一般静态变量或对象相混淆 初始化时使用作用域运算符来表明所属的类，因静态数据成员是类的成员 初始化时不加该成员的访问权限控制符 若静态数据成员为 public，可在程序中引用该成员：类名 :: 静态数据成员，此时若未初始化，编译系统会自动赋值 0 也即：静态成员变量既可以通过对象名引用（obj.static_memb），也可通过类名引用（class_name::static_memb） 静态成员函数 用于访问类中保护或私有成员的公有接口 以 static 声明，属于类，由所有对象共享 可在类内/外定义，类外定义时不加 static 对对象的访问： 可直接访问类中说明的静态成员，但不能是非静态成员 非静态成员需通过参数传递的方式得到对象后再通过对象访问 main() 函数中对静态函数的调用：类名 :: 静态成员函数名 (参数可选)或 对象名.静态成员函数名 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 常成员对于既需要共享，又不希望其值被改变的数据，可定义为常成员进行保护，保证其在整个程序运行期间不可改变，用 const修饰符定义 常对象使用 const 关键字修饰的对象 类名 const 对象名 或 const 类名 对象名 常对象必须有初值，且不能被更新 常对象只能调用类中的常成员函数 常成员函数使用 const 关键字说明的成员函数 返回类型 成员函数名 (参数) const 函数实现部分也要带有 const 关键字：type class_name :: memb_fun(argu) const 不能更新对象的数据成员，也不能调用类中没有用 const 修饰的函数 const 关键字可用于对重载函数的区分 常数据成员使用 const 关键字修饰的数据成员 const type name 定义必须出现在类体中 必须通过构造函数的成员初始化列表进行初始化（唯一的方法），且不能被更新，格式： 类名 :: 类名(形参) ：常数据成员 (赋值) 123456789101112class VLA&#123;private: const int m_len; int *m_arr;public: VLA(int len);&#125;;//必须使用初始化列表来初始化 m_lenVLA::VLA(int len): m_len(len)&#123; m_arr = new int[len];&#125; 友元 解决类外访问类的私有和保护成员 友元机制允许一个类授权其他的函数访问其非公有成员，减小开销，提高程序运行效率 友元声明 关键字： friend 只能在类的声明中出现 友元函数 在类体中以 friend 声明，独立于当前类的外部函数 可以是不属于任何类的非成员函数，也可以是其他类的成员函数，可访问该类中的私有成员 friend 数据类型 友元函数名 (形参) 在类定义时声明，一般在类外定义友元函数（类中声明，类外定义） 普通友元函数（即类的非成员函数）引用类的私有成员时，需通过对象，即对象名.的形式，因普通友元函数不是类的成员函数 一个函数可被多个类声明为友元函数 友元类类B为A的友元类，则： B 中的所有成员函数都是 A 的友元函数，可访问 A 的所有成员 friend 类名 友元类不具有对称性：B是A的友元类，但A不是B的 友元类不具有传递性：A是B的友元类，B是C的友元类，不代表A是C的友元类 对象数组 数组元素是对象，且每个元素是同一个类的对象 定义：类名 数组名 (元素个数可选) 访问：数组名[下标可选].成员名 创建类的对象数组的条件： 没有给出构造函数，调用系统默认构造函数 有一个不带参数的构造函数 一个构造函数的参数全是默认参数 对象数组的生命周期结束时，默认给每个元素调用一次析构函数，也可通过 delete 强制调用,，构造同理 若定义对象数组时没有使用初始化列表进行初始化，则会为每个对象调用默认构造函数 若初始化项少于数组中的对象，则对剩余的对象调用默认构造函数 成员对象 一个类的成员是另一个类的对象 class c { c1 obj1; c2 obj2; }; 类中有成员对象时，该类的构造函数要调用这些成员对象所在类的构造函数，并采用初始化列表进行初始化 构造函数的调用顺序取决于类中的说明顺序，析构的调用相反 只能调用成员对象的公有函数或变量 继承与派生基本概念 继承：在现有类的基础上创建新类，新类得到已有类已经具备的特性 派生：从已有类（基类）产生一个子类（派生类） 单继承、多继承 基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样 派生类将基类的所有成员全部接收过来，除了构造和析构函数 派生类可对基类初始化 派生类对基类的访问 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 - 基类中的私有成员在派生类中不可访问，只能在基类访问 - 派生类中可访问基类中中的公有和保护成员 派生类的析构和构造函数基类的构造和析构不能被继承，故派生类的构造函数须调用基类的构造函数以初始化，同理，对派生对象的清理也需要新的析构函数 派生类的构造函数 问题： 考虑新增成员的初始化 考虑基类成员的初始化 解决： 执行派生类的构造函数时，调用基类的构造，注意是调用基类的构造函数，不是声明 执行顺序： 调用基类的构造函数：按照定义派生类时基类的声明顺序进行，而与派生类构造函数的成员初始化列表给出的顺序无关 12class son_class:public dad_class1(x), dad_class2(x1) &#123;&#125;//调用构造函数时先调用基类 dad_class1 的构造，接着调用 dad_class2 的 调用成员对象的构造函数：派生类中有多个成员对象时，按照派生类中声明成员对象的顺序进行，同样与初始化列表无关 1234567class son_class:public dad_class1(x), dad_class2(x1) &#123; dad_class2 c2; dad_class1 c1; …&#125;//调用构造函数时先调用基类 dad_class2 的构造，接着调用 dad_class1 的 执行派生类构造函数体中的内容，完成对派生类的初始化 派生类中既有对基类的声明，又有成员对象时，先调用基类的构造函数，再调用成员对象所属类的构造函数，最后调用派生类自己的构造 1234567class son_class:public dad_class1(x)&#123; dad_class2 c2; son_class(……) &#123;……&#125; …&#125;//先调用基类 dad_class1 的构造，接着调用 dad_class2 的，最后调用自身的 派生类的析构函数调用过程与构造相反 对派生类普通成员清理 调用成员对象的析构，对派生类新增的成员对象清理 调用基类析构，对基类清理 多继承与虚基类多继承中的二义性 一个派生类有两个或多个基类 在派生类中对基类的访问应该是唯一的 在多继承情况下，派生类对基类中某个成员的访问出现不唯一的情况，即产生二义性 产生二义性问题的两种情况： 多继承中，有两个或两个以上的基类存在同名成员，采用对象名.函数名直接调用时无法判断属于哪个类 解决方法有二： 通过作用域运算符进行限定，指定是哪个基类的函数 对象名.基类名 :: 成员函数名() 在派生类中定义同名成员以屏蔽基类中二义性的成员，但此时仍然可通过 :: 指定访问 一个派生类从多个基类派生，且这些基类有一个共同的基类时，派生类访问该共同基类的成员时产生二义性 解决方法同上，但更优的方法是虚基类 虚基类（虚继承）http://c.biancheng.net/view/2280.html 解决二义性问题，将共同基类定义为虚基类，方式如下 定义 class c_name : virtual 继承方式 基类名 class c_name : 继承方式 virtual 基类名 注意 虚基类是在声明派生类时，指定继承方式时声明的 虚基类派生的类，只产生一个虚基类子对象 （可以理解为在派生类中只保留了一份共同基类的成员，这样就不会产生歧义了） 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 虚基类的构造函数 虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。 直接或间接继承虚基类的派生类，其构造函数的成员初始化列表中，都列出了对虚基类构造函数的调用，而在最后的派生类中，除了对直接基类的初始化，还要对虚基类初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;//虚基类Aclass A&#123;public: A(int a);protected: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;//直接派生类Bclass B: virtual public A&#123;public: B(int a, int b);public: void display();protected: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125; // B 的直接继承中调用了A 的构造void B::display()&#123; cout&lt;&lt;\"m_a=\"&lt;&lt;m_a&lt;&lt;\", m_b=\"&lt;&lt;m_b&lt;&lt;endl;&#125;//直接派生类Cclass C: virtual public A&#123;public: C(int a, int c);public: void display();protected: int m_c;&#125;;C::C(int a, int c): A(a), m_c(c)&#123; &#125; // C 的直接继承中调用了A 的构造void C::display()&#123; cout&lt;&lt;\"m_a=\"&lt;&lt;m_a&lt;&lt;\", m_c=\"&lt;&lt;m_c&lt;&lt;endl;&#125;//间接派生类Dclass D: public B, public C&#123;public: D(int a, int b, int c, int d);public: void display();private: int m_d;&#125;;// D 的间接继承中调用了直接继承 B、C 的构造，以及间接继承 A 的构造D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d)&#123; &#125;void D::display()&#123; cout&lt;&lt;\"m_a=\"&lt;&lt;m_a&lt;&lt;\", m_b=\"&lt;&lt;m_b&lt;&lt;\", m_c=\"&lt;&lt;m_c&lt;&lt;\", m_d=\"&lt;&lt;m_d&lt;&lt;endl;&#125;int main()&#123; B b(10, 20); b.display(); C c(30, 40); c.display(); D d(50, 60, 70, 80); d.display(); return 0;&#125; 子类型关系（向上转型）类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。 虚函数与多态性多态 同一接口为不同的对象服务 分类 编译时的多态：通过函数重载和模板实现，在编译阶段确定调用哪个函数，实现机制称为“静态绑定” 运行时的多态：只有在运行时才知道是哪个函数，“动态绑定” 多态是通过虚函数实现的 虚函数 指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数 通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数 而虚函数允许在派生类中定义与基类同名的函数，且可用基类的指针或引用访问基/派生类中的同名函数 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism） C++中虚函数的唯一用处就是构成多态，有了多态，只需要一个指针变量就可以调用所有派生类的虚函数 虚函数可以是另一个类的友元函数，但不能是静态成员函数、内联函数、构造函数 派生类中可以重新定义从基类继承下来的虚函数，也可以不需要。但在派生类中重新定义虚函数时，函数名、形参表、返回值类型必须保持不变 换句话说，虚函数使得派生类可以更改（其实是覆盖）基类中的同名函数 若基类声明了虚函数，则在派生类中凡与该函数同名，同类型，同参数个数的均为虚函数 虚析构函数 一般情况下，清理派生类的对象时先调用派生类的析构，再调用基类的析构 但若用 new 建立了临时对象，如果基类中有析构，且定义了一个指向基类的指针变量，那么程序在用带指针参数的 delete 撤销对象时，系统只调用基类的析构 故若要调用派生类的析构函数，就要将其声明为虚函数，即虚析构函数 纯虚函数 在基类中给派生类预留一个虚函数的名，但基类不知道拿这个函数干嘛，留给派生类补充函数体 即基类无法确定一个虚函数的具体操作方式或者内容，只能靠派生类提供该虚函数的具体实现方式，即为纯虚函数 virtual 类型 函数名 (参数表) = 0； 纯虚函数没有函数体 “=0” 并不是返回值为 0，只是告诉编译系统这是纯虚函数 是声明语句，所以句尾要有分号 将一函数声明为纯虚函数，仍可以有函数体，即纯虚函数的标志是 “=0”，而不是有无函数体 纯虚函数不得声明为内联函数 抽象类 拥有纯虚函数的类称为抽象类（一般为基类） 抽象类不能用来定义对象 若抽象类的派生类没有重新定义来自基类的纯虚函数，则该函数在派生类中亦是纯虚函数，派生类也为抽象类，而派生类可将重定义纯虚函数的任务转交给自己的派生类 几点说明： 只要基类包含一个或多个纯虚函数，就是抽象类，抽象类不能用于定义对象 在类的层次结构中，顶层或上面几层皆可为抽象基类，抽象基类是各类的共性 抽象基类是本类族的公共接口 抽象类可以实现多态，道理同虚函数 只有类中的虚函数才能声明为纯虚函数，普通的函数不能 12345678//顶层函数不能被声明为纯虚函数void fun() = 0; //compile errorclass base&#123;public : //普通成员函数不能被声明为纯虚函数 void display() = 0; //compile error&#125;; 运算符重载概念 运算符重载是多态的体现 C++ 把重载的运算符看做特殊的函数，称为运算符函数，故运算符重载就是函数重载的一种 运算符重载是对现有运算符的重载，不能利用重载创造新的运算符 不能重载的运算符：. 、·* 、-&gt;* 、:: 、?: 不得为运算符函数设置默认值，故在调用时不能省略实参 任何运算符在作为成员函数重载时不得重载为静态成员函数，new 和 delete 除外 只能作为成员函数重载：=、[]、()、-&gt;以及所有的类型转换运算符 关键字：operator 返回类型 operator 运算符 (参数表) {} 返回类型不能是 void 运算符重载函数也是函数，满足函数的一切性质 运算符重载的两种形式成员函数形式和友元函数形式，都可以访问类的私有成员 成员函数形式 定义：返回类型 operator 运算符 (参数表) 可将 operator 运算符部分看做是一个函数名 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class complex&#123;public: complex(); complex(double real, double imag);public: //声明运算符重载 complex operator+(const complex &amp;A) const; void display() const;private: double m_real; //实部 double m_imag; //虚部&#125;;complex::complex(): m_real(0.0), m_imag(0.0)&#123; &#125;complex::complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;//实现运算符重载complex complex::operator+(const complex &amp;A) const&#123; complex B; B.m_real = this-&gt;m_real + A.m_real; B.m_imag = this-&gt;m_imag + A.m_imag; return B;&#125;void complex::display() const&#123; cout&lt;&lt;m_real&lt;&lt;\" + \"&lt;&lt;m_imag&lt;&lt;\"i\"&lt;&lt;endl;&#125;int main()&#123; complex c1(4.3, 5.8); complex c2(2.4, 3.7); complex c3; c3 = c1 + c2; c3.display(); return 0;&#125;//结果 6.7 + 9.5i 执行 c3 = c1 + c2时，编译器检测到 +左边是一个 complex 的对象，故会调用成员函数 operator +()，将该式转换为 c3 = c1.operator(c2)，即对象 c3 调用重载的成员函数，该函数的参数是 c2。 所以说，重载为成员函数时，由于具有隐含的 this 指针，一般参数只有一个。对双目运算符如上述的 + 运算符，一般参数是第二个操作数；而对单目运算符，参数表为空。 友元函数形式 定义：friend 返回类型 operator 运算符 (参数表) 注意： 友元函数没有 this 指针，故对双目运算符，友元函数有两个参数；对单目运算符有一个参数 典型运算符的重载重载负运算符 “-” 一元运算符，作为成员函数重载时，参数为空，存在默认的 this 指针；以友元函数重载时，参数为1个。 重载加运算符 “+” 同前例子 重载自增/减运算符 “++/- - ” 作为类的成员函数重载 前缀运算：返回类型 operator ++ () 后缀运算：返回类型 operator ++ (int) 作为类的友元函数重载 前缀运算：friend 返回类型 operator ++ (参数 1) 后缀运算：friend 返回类型 operator ++ (参数 1，int) 为了与前缀运算符区别，c++ 编译器设定在后缀运算符重载函数中增加一个实际并不使用的整形参数，以示区别 以自增为例，前缀自增是先增1，用增 1 后的值参与运算，故返回的是增1之后运算的值，内部也增 1；后缀自增是先参与运算，运算完毕之后再增 1，故返回的是对象本身，内部依然增 1 重载类型转换运算符 “long” 必须作为成员函数重载 类型名就是返回值类型，故不需要声明返回值类型 operator long（参数表） 重载赋值运算符 “=” 必须作为成员函数重载 类中出现指向动态空间的指针时重载 注意： 返回值应声明为引用，但在函数体中通常使用return * this；语句返回 若参数被声明为指针或引用，一般应加上 const 修饰 一般拷贝函数也会同时出现 重载复合赋值运算符 “+/-/*=” 两种重载形式均可 当重载为友元函数时，需要两个参数，且第一个参数应声明为引用 重载关系运算符 “&gt;、&lt;、==” 返回逻辑值，即返回类型为 bool 重载下标访问运算符 “[]” 只能重载为成员函数 返回类型 operator [] (下标形参，一般为整型) 重载 C++ 流运算符 “&gt;&gt; / &lt;&lt;” 只能重载为非成员函数，一般为友元函数 friend istream&amp; operator &gt;&gt; (istream&amp;, 类名&amp;) friend ostream&amp; operator &lt;&lt; (ostream&amp;, 类名&amp;) 之所以返回 i/ostream 类对象的引用，是为了能够连续读取/输出 模板函数模板概念 一系列相关函数的模型或样板，这些函数的源代码相同，只是针对不同的数据类型 对函数模板而言，数据类型是其参数，故是一种参数化 类型 的函数 格式：template &lt;模板形参表声明&gt; 函数声明 模板形参表声明可以是多个，中间用逗号隔开 模板形参的形式： typename 参数名 class 参数名 类型修饰 参数名 关键字 typename 与 class 完全等价，两者声明的参数为 虚拟类型参数，即指定这个参数名是一种类型，而这种类型只有实例化时才知道是什么类型，其即可做函数的返回值，也可做形参的类型，还可做函数体内变量的类型；而 类型修饰 声明的参数为常规参数，形式上与普通函数的声明相同。 123456template&lt;typename T&gt; //此处可换行，但不能有分号void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125; 模板函数的实例化 函数模板中声明的函数称为 模板函数 编译系统生成函数模板的某个具体版本的过程称为函数模板的实例化 模板实参的省略 模板函数的调用格式：模板函数名 &lt;模板实参表&gt;（函数实参表） 调用一个模板函数时，编译系统需要足够的信息判断每个虚拟类型参数对应的实际参数，主要从 模板实参表 和 函数实参表 中获取信息，且后者优先于前者，如从后者获取的信息足够判断虚拟类型的具体参数，而它们恰好是参数表中最后的若干参数，则模板实参中的那几个参数可以省略，若都被省略，则 &lt;&gt; 为空，也可省略 12345//如上例，调用可分几种：Swap&lt;int, int&gt;(&amp;a, &amp;b);Swap&lt;int&gt;(&amp;a, &amp;b);Swap&lt;&gt;(&amp;a, &amp;b);Swap(&amp;a, &amp;b); 不能省略模板实参的情况： 从模板实参表获得的信息有矛盾 若一个函数实参中获得的是 int，另一个则是 float，显然 T 不能同时为 int 和 float，为此，可将其中一个显示的给出 T 的类型 123int a = 10;float b = 1;Swap&lt;int&gt;(&amp;a, &amp;b); //将 float 强制转为 int 需要获得特定的返回值，而不管参数的类型如何 123int a = 10;float b = 1;Swap&lt;double&gt;(&amp;a, &amp;b); //将 int，float 强制转为 double 虚拟参数类型没有出现在模板函数的形参表中 函数模板含有常规实参 类模板概念 类模板就一系列相关类的模板，只是类型不同 模板类的声明：template &lt;模板参数表声明&gt; 类声明 类模板的成员函数可在类体内或类体外定义，在类外定义模板类（需要带上模板头）： template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; 返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表) {函数体} 类模板的实例化 两种方式： 类名 &lt;模板实参表&gt; 对象名 类名 &lt;模板实参名&gt; 对象名(构造函数实参表) 注意： 使用类模板定义对象时，实参不能省略，即类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。 123Point&lt;int, int&gt; p1(10, 20);Point&lt;int, float&gt; p2(10, 15.5);Point&lt;float, char*&gt; p3(12.4, \"东经180度\"); 除了对象变量，我们也可以使用对象指针的方式来实例化 12Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3);Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;(\"东经180度\", \"北纬210度\"); 需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的： 1234//赋值号两边的数据类型不一致Point&lt;float, float&gt; *p = new Point&lt;float, int&gt;(10.6, 109);//赋值号右边没有指明数据类型Point&lt;float, float&gt; *p = new Point(10.6, 109); C++流12const int p = 1; // 应在声明时初始化，否则变量的值不确定且无法修改const int * pt;//指向常量的指针，即指针 *pt 是指向 const int 的，即 *pt 是 const的，不能修改","categories":[{"name":"cpp","slug":"cpp","permalink":"https://hbroad.github.io/categories/cpp/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"力扣专题刷题","slug":"力扣刷题/专题刷题","date":"2022-08-20T14:29:11.909Z","updated":"2022-08-22T14:01:46.462Z","comments":true,"path":"2022/08/20/Leetcode_group/","link":"","permalink":"https://hbroad.github.io/2022/08/20/Leetcode_group/","excerpt":"发现菜的不行，按专题来吧，学一点是一点 参考","text":"发现菜的不行，按专题来吧，学一点是一点 参考 链表203. 移除链表元素 思路一：若头结点已经是要删除的值，直接让头结点指向下一个即为删除头结点；若头结点非目标，则定义一个临时指针遍历链表，若该指针的下一节点是目标，则直接让其指向下下个节点 123456789101112131415161718192021222324252627282930class SolutionQ &#123;public: ListNodeQ* removeElements(ListNodeQ* head, int val) &#123; while(head-&gt;next != nullptr &amp;&amp; head-&gt;val == val) //头结点即相等的特殊情况 &#123; ListNodeQ *tmp = head; head = head-&gt;next; delete tmp; //C++不会自动释放内存，力扣不会报错 &#125; //头结点非相等情况 ListNodeQ *p; p = head; while(p != nullptr &amp;&amp; p-&gt;next != nullptr) &#123; if (p-&gt;next-&gt;val == val) &#123; ListNodeQ *tmp = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; delete p; &#125; else &#123; p = p-&gt;next; &#125; &#125; return head; &#125;&#125;; 思路二：创建一个节点作为虚拟头结点，让其指向头结点，那包括头结点在内的所有节点的删除方式就都一致了 1234567891011121314151617class SolutionQ2 &#123;public: ListNodeQ* removeElements(ListNodeQ* head, int val) &#123; ListNodeQ *dummy_head = new ListNodeQ; //new出来的是虚拟的头节点 dummy_head-&gt;next = head;//让虚拟头结点指向头结点 ListNodeQ *cur = dummy_head; while(cur-&gt;next) &#123; if (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; &#125; return dummy_head-&gt;next; &#125;&#125;; 707. 设计链表 包含了链表的增删改查等常见操作，采用虚拟头结点的方式，统一操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//// Created by MQRoad on 2022/08/21.//#include &lt;iostream&gt;using namespace std;class MyLinkedList&#123;public: struct LinkNode &#123; int val; LinkNode *next; LinkNode(): val(0), next(nullptr) &#123;&#125; //默认构造函数 LinkNode(int x): val(x), next(nullptr) &#123;&#125; //带单参数的构造函数 LinkNode(int x, LinkNode *next): val(x), next(next) &#123;&#125; //双参数构造 &#125;; MyLinkedList() //链表的初始化 &#123; dummyhead = new LinkNode; size = 0; //链表的长度 &#125; int get(int index) &#123; LinkNode *cur = dummyhead-&gt;next; if (index &lt; 0 || index &gt; size - 1)//本题头结点是第0个 return -1; while(index) //查找第i个值，也就是让临时指针移动i次， &#123; cur = cur-&gt;next; index--; &#125; return cur-&gt;val; &#125; //头插法 void addAtHead(int val) &#123; LinkNode *p = new LinkNode; p-&gt;val = val; //赋值 p-&gt;next = dummyhead-&gt;next;//新节点的后继是旧的头结点 dummyhead-&gt;next = p; //新节点的前驱是虚拟节点 size++; //链表长度+1 &#125; //尾插法 void addAtTail(int val) &#123; LinkNode *p = new LinkNode(val); //需要遍历得到最后一个节点的位置 LinkNode *cur = dummyhead; //临时指针用于遍历链表 while(cur-&gt;next) &#123; cur = cur-&gt;next; &#125;//循环结束cur指向最后一个节点 cur-&gt;next = p;// p-&gt;next = nullptr; //new节点的时候已经初始化了没必要再写 size++; &#125; //任意位置插入 void addAtIndex(int index, int val) &#123; LinkNode *p = new LinkNode(val); LinkNode *cur = dummyhead; if (index &lt; 0 || index &gt; size) return; while(index--) &#123; cur = cur-&gt;next; &#125; p-&gt;next = cur-&gt;next; //该程序也满足头部插入，如 n=0 位置前插入，循环不执行，其他亦满足条件 cur-&gt;next = p; size++; &#125; //删除节点 void deleteAtIndex(int index) &#123; LinkNode *cur = dummyhead; if (index &lt; 0 || index &gt;= size) return; while(index--) cur = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; size--; &#125; //打印链表 void printLinkedList() &#123; LinkNode *cur = dummyhead; while (cur-&gt;next) &#123; cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; \" \"; cur = cur-&gt;next; &#125; &#125;private: LinkNode *dummyhead; //虚拟头结点 int size; //链表长度&#125;;int main()&#123; MyLinkedList *obj = new MyLinkedList; for (int i = 0; i &lt; 10; i += 2) &#123; obj-&gt;addAtTail(i); &#125;// obj-&gt;addAtIndex(-1,2); obj-&gt;printLinkedList(); int param = obj-&gt;get(2);// cout &lt;&lt; param;&#125; 206. 反转链表 思路一：双指针法：利用两个指针交替完成 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *pre = nullptr; ListNode *cur = head; while(cur) &#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by MQRoad on 2022/08/21.//#include &lt;iostream&gt;using namespace std;struct mynode&#123; int val; mynode *next; mynode(int x): val(x), next(nullptr) &#123;&#125;&#125;;mynode* ini()&#123; mynode *node = new mynode(0); mynode *head = node; for (int i = 1; i &lt;= 5; ++i) &#123; node-&gt;next = new mynode(i); node = node-&gt;next;// newnode = nullptr; //构造函数已赋值 &#125; return head;&#125;//反转链表mynode* reverseLL(mynode *head)&#123; mynode *pre = nullptr; mynode *cur = head; mynode *tmp; while(cur) &#123; tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre;&#125;void printmynode(mynode *head)&#123; mynode *cur = head; while (cur) &#123; cout &lt;&lt; cur-&gt;val &lt;&lt; \" \"; //无虚拟头结点 cur = cur-&gt;next; &#125;&#125;int main()&#123; mynode *head = ini(); printmynode(head); cout &lt;&lt; endl; mynode *newhead = reverseLL(head); printmynode(newhead);&#125; 24. 两两交换链表中的节点 思路：链表题，老老实实画图吧 为方便操作，仍然定义一个虚拟头结点 总体流程：为了让 1 2 两节点交换，先让节点 2 成为头结点的后驱，再让节点 1 成为节点 2 的后驱，最后让节点 3 成为节点 1 的后驱，后续节点依次重读，如下图： 要注意的是，在完成第一步后，cur 的指向已经变化，所以无法进行第 2-3步，因而需要在操作前保存 cur 原来的指向 1-2 完成就的情况如下图： 即第三步是在前两步基础上的 cur-&gt;next-&gt;next-&gt;next 最后将 cur 后移两位，进行下一轮的交换 代码： 1234567891011121314151617181920212223242526272829303132333435//// Created by MQRoad on 2022/08/22.//#include &lt;iostream&gt;using namespace std;struct ListNode204&#123; int val; ListNode204 *next; ListNode204(int x): val(x), next(nullptr) &#123;&#125;&#125;;class sol204&#123;public: ListNode204* swappairs(ListNode204 *head) &#123; ListNode204 *dummynode = new ListNode204(0); dummynode-&gt;next = head; ListNode204 *cur = dummynode; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123; ListNode204 *tmp1 = cur-&gt;next; ListNode204 *tmp2 = cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; //步骤一 cur-&gt;next-&gt;next = tmp1; //步骤二 cur-&gt;next-&gt;next-&gt;next = tmp2; //步骤三 cur = cur-&gt;next-&gt;next; //指针后移 &#125; return dummynode-&gt;next; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"力扣每日一题","slug":"力扣刷题/力扣每日一题","date":"2022-08-14T07:34:15.521Z","updated":"2022-08-15T12:01:38.899Z","comments":true,"path":"2022/08/14/Leetcode_once_day/","link":"","permalink":"https://hbroad.github.io/2022/08/14/Leetcode_once_day/","excerpt":"刷的太少，思路只局限在暴力","text":"刷的太少，思路只局限在暴力 1422. 分割字符串的最大得分 思路：（暴力）对输入的字串分割成左右两个非空字串，再遍历左字串中字符 0 个数，由字串中字符 1 的个数；依次循环分割输入的字串，将对应的个数存入左右两个容器，遍历完所有的可能后，求和，再求最大值 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: int maxScore(string s) &#123; string strl, strr; vector&lt;int&gt; l, r; int l_tmp = 0, r_tmp = 0; for(int i = 1; i &lt; s.size(); i++) &#123; strl = s.substr(0, i); strr = s.substr(i); for(int j = 0; j &lt; strl.size(); j++) &#123; if(strl[j] == '0') l_tmp++; &#125; l.push_back(l_tmp); l_tmp = 0; //注意累加器置0 for(int k = 0; k &lt; strr.size(); k++) &#123; if(strr[k] == '1') r_tmp++; &#125; r.push_back(r_tmp); r_tmp = 0; &#125; vector&lt;int&gt; maxsum; for(int n = 0; n &lt; l.size(); n++) &#123; int a = l[n] + r[n]; maxsum.push_back(a); &#125; return *max_element(maxsum.begin(), maxsum.end()); //取最大值 &#125;&#125;;int main()&#123; Solution sol; string s = \"1111\"; cout &lt;&lt; sol.maxScore(s);&#125; 540. 有序数组中的单一元素 思路，根据异或运算的性质，两个相同的数异或为0，让数组元素依次异或，结果一定是只出现一次的数（代码中是依次一个一个异或，便于理解，推导过程中利用结合律、交换律，相同的数字先异或结果为0） 代码 123456789101112131415161718192021222324252627//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution3 &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = 0; int sum = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; sum ^= nums[i]; &#125; return sum; &#125;&#125;;int main()&#123; Solution3 sol3; vector&lt;int&gt; nums = &#123;1,1,2,3,3,4,4,8,8&#125;; cout &lt;&lt; sol3.singleNonDuplicate(nums); return 0;&#125; 268. 丢失的数字 思路：给定的范围是[0,n]，可求得该范围内所有数的和，用和减去现有数组中的数，结果即为缺失的数 代码 123456789101112131415161718192021222324252627282930//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int n = nums.size(); sum = (0 + n) * (n + 1)/2; //求和 for(int i = 0; i &lt; n; i++) &#123; sum -= nums[i]; //将现有元素全部减掉 &#125; return sum; &#125;&#125;;int main()&#123; Solution sol; vector&lt;int&gt; nums = &#123;9,6,4,2,3,5,7,0,1&#125;; cout &lt;&lt; sol.missingNumber(nums); return 0;&#125; https://flamsteed.github.io/tags/#HUAWEI 第一阶段: 练习字符串、数组、链表的基本操作，熟悉语言和编码手感 参考题目： 字符串，简单 1154，125，344，20，392，409，859，14，1694，551 数组，简单 1，169，53，1502，88，594，643，463， 链表，简单 234，21，141，83 第二阶段: 练习较为复杂的字符串，数组的处理 字符串，中等 468，692，151，686，1764 数组，中等56，229，347 第三阶段: 算法练习 字符串，中等，回溯93 数组，中等，回溯 39，90，46，78 数组，中等，深度优先，广度优先，417，994，385 数组，中等，滑动窗口，713 字符串，中等，滑动窗口424 动态规划，简单70 动态规划，中等64 数组，中等，双指针 16 字符串，中等，双指针15， 数组，中等，栈150","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"力扣Top100","slug":"力扣刷题/力扣Top100","date":"2022-08-14T01:43:11.903Z","updated":"2022-08-21T14:13:36.185Z","comments":true,"path":"2022/08/14/leetcode_top_100/","link":"","permalink":"https://hbroad.github.io/2022/08/14/leetcode_top_100/","excerpt":"Leetcode Top 100","text":"Leetcode Top 100 ……","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"华为机试（牛客）","slug":"华为机试/华为机试","date":"2022-07-31T07:41:17.143Z","updated":"2022-08-22T11:28:08.774Z","comments":true,"path":"2022/07/31/HuaWei/","link":"","permalink":"https://hbroad.github.io/2022/07/31/HuaWei/","excerpt":"放弃啦，简历都过不了 华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了 （知道自己菜，没想到这么菜）","text":"放弃啦，简历都过不了 华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了 （知道自己菜，没想到这么菜） 参考1 参考2 https://oi-wiki.org/ HJ1 题目：查找输入字符串最后一个单词的长度 思路：字符串由空格分隔，找到最后一个空格，用整体的长度减去空格及空格前的长度，剩余的即为所求 代码： 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; getline(cin,str); // size_t len = str.size(); //总长度 // size_t found = str.rfind(\" \"); //最后空格的位置 // size_t found = str.find_last_of(\" \"); cout &lt;&lt; str.size() - str.rfind(\" \") - 1;&#125; 分析：关键有二： 字符串的获取 cin：遇空格或制表符即停，显然无法满足 getline：可连续读取输入并存入字符串 1istream&amp; getline (istream&amp; is, string&amp; str); 最后空格的定位 find_last_of()：给定待查找的字符，从后开始查找并返回其位置 123size_t find_last_of (const char* s, size_t pos = npos) const;//可以指定从何处开始查找，即指定第二个参数//注意字符串从0开始编号 find 家族辨析：参考 1234567891011//搜索指定位置开始的第一个完全匹配的字符（串），即与指定字串完全匹配时才返回，且是第一个size_t find (const string&amp; str, size_t pos = 0); //从前往后找size_t rfind (const string&amp; str, size_t pos = npos); //从后往前找//搜索指定位置开始的第一个匹配的字符（串），只需有一个字符满足即可size_t find_first_of (const string&amp; str, size_t pos = 0); //从前往后找size_t find_last_of (const string&amp; str, size_t pos = npos); //从后往前找 //查找与指定字串不匹配的字符（串）size_t find_first_not_of (const string&amp; str, size_t pos = 0) ;size_t find_last_not_of (const string&amp; str, size_t pos = npos) ; HJ2 题目：计算某字符出现的次数 思路：读入到两个变量中，遍历字串，是否和目标字符相等，若相等则 count 增1，再判断大小写的问题，大写和小写分别判断 代码：（低质量代码） 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str,str2; //读入两行内容 getline(cin, str); getline(cin, str2); //如相等则计数器k自增1 int k = 0; for(int i = 0; i &lt; str.size(); i++) &#123; if(str[i] == str2[0]) &#123; k++; //考虑大小写一致 for(int i = 0; i &lt; str.size(); i++) &#123; if(str2[0] &lt;= 'Z' &amp;&amp; str2[0] &gt;= 'A') //如目标字符是大写，则再判断其对应的小写是否有相等的 &#123; if(str[i]+0 == str2[0] + 32) k++; &#125; else if (str2[0] &lt;= 'z' &amp;&amp; str2[0] &gt;= 'a') //如目标字符是小写，则再判断其对应的大写是否有相等的 &#123; if(str[i]+0 == str2[0] - 32) k++; &#125; &#125; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl;&#125; 分析： 新手，想法简单粗暴 HJ3 题目：输入随机数个数及随机数，去重排序后按行输出 思路一：（排名第一的思路，非本人想法）先确定随机数的个数（直接cin），定义一个数组，然后每次将读入的数作为数组的下标，值填充为1，然后输出数组值不为0的下标 核心：只要有重复值，对应到数组的下标还是同一个，达到既降重又排序的目的；转换思路，输入的值是下标而非数组的值 缺点：一是必须指定数组的大小是题目给定的范围，而不能动态的设置为输入随机数的个数；二是数组必须初始化，否则其中的垃圾数据会造成输入错误 代码： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int N, n; while (cin &gt;&gt; N) &#123; int a[1001] = &#123; 0 &#125;; while (N--) &#123; cin &gt;&gt; n; a[n] = 1; &#125; for (int i = 0; i &lt; 1001; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 123456789101112131415161718192021//按上述思路重写了一下，比较容易理解和看懂#include &lt;iostream&gt;using namespace std;int main()&#123; int N, n; cin &gt;&gt; N; //读入数组的大小 int a[1001] = &#123;0&#125;; //指定大小并初始化（不管数组多小，都开辟了这么多空间） for(int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; n; a[n] = 1; //以读入的数作为下标，有多少重复都无所谓（填充值非零均可） &#125; for(int i = 0; i &lt; 1001; i++) &#123; if(a[i]) cout &lt;&lt; i &lt;&lt; endl; //输出数组值非零的下标 &#125; return 0;&#125; 思路二：调用 STL，去重排序一步到位 12345678910111213141516171819#include&lt;iostream&gt;#include &lt;set&gt; //包含集合setusing namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; set&lt;int&gt; s;//自动实现去重和排序 for(int i=0;i&lt;n;i++) &#123; int x; cin&gt;&gt;x; s.insert(x); &#125; for(auto i:s) cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 分析： STL 中的 set（集合）自动将插入元素放入合适的位置（排序），同时对重复元素忽略，可以插入删除但不能更改 HJ4 题目：字符串的分割，以8为长度分割输入的字符串 思路：考虑 ==8 、&lt;8 、&gt;8 三种情况，利用容器，把分割后的字串存入其中，最后遍历容器输出，主要利用 substr 进行字串的分割 复盘：既然以 8 为单位分割，那只要不为 8 的倍数就要补 0，用余数判断一下需要补 0 的个数，利用 append 插入，再分割输出（另外本题没有给出输出的格式，我以为是空格，结果提交发现是换行） 代码：初次写的代码，重复代码太多了，自愧不如，简单问题复杂化了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;string&gt; str; string str_tmp; cin &gt;&gt; str_tmp; int n = str_tmp.size(); if(n % 8 == 0) &#123; //按8分割 for(int i = 0; i &lt; str_tmp.size();) &#123; str.push_back(str_tmp.substr(i, 8)); i += 8; &#125; &#125; else if(n &lt; 8) &#123; for(int j = 0; j &lt; 8-n; j++) &#123; str_tmp.push_back('0'); //小于8时判断补 0 的个数 &#125; str.push_back(str_tmp); &#125; else(n &gt; 8) &#123; int k = n / 8; //有几段以 8 为长度的 //需要补几个0 for(int j = 0; j &lt; 8 - n % 8; j++) &#123; str_tmp.push_back('0'); &#125; //按8分割 for(int i = 0; i &lt; str_tmp.size();) &#123; str.push_back(str_tmp.substr(i, 8)); i += 8; &#125; &#125;//遍历输出 for(int i = 0; i &lt; str.size(); i++) //注意这里是补 0 后新的大小 &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125;&#125; 复盘后改进的代码：简便多了 12345678910111213141516171819202122#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; int n = str.size(); if(n % 8 != 0) &#123; str.append(8 - n % 8, '0'); //不足8位的补0 &#125; //按8分割 for(int i = 0; i &lt; str.size();) //注意这里的 size 是补 0 后新的大小 &#123; cout &lt;&lt; str.substr(i, 8) &lt;&lt; endl; i += 8; &#125;&#125; 分析： substr 的用法 单参数：从该位置开始取到末尾 双参数：从该位置开始取到指定的长度 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; string s = \"time\"; cout &lt;&lt; \"单参数：\" &lt;&lt; s.substr(2) &lt;&lt; endl; //返回 me（从位置 2 截取到尾） cout &lt;&lt; \"双参数：\" &lt;&lt; s.substr(1, 3) &lt;&lt; endl; //返回 ime（从位置1开始，截取长度3）&#125; append 的用法 向 string 后面追加字符或字符串 1234str.append(4, '0'); //在 str 后追加 4 个字符 0str.append(c); //追加 char 类型字串 cstr.append(str_tmp); //追加 string 字串str.append(str_tmp, 5, 3); //追加从位置 5 开始的长度为 3 的字串（包括位置 5） HJ5 题目：输入十六进制字串，将其转为十进制数输出（华为肯定不会考这种题） 思路：（笨人笨方法啊）先把输入的前缀0x截掉，剩下的部分依次遍历，如是字符0-9，则转为数字0-9；如是字母A-F，则转为10~15 代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; //截掉前缀 string str_tmp; str_tmp = str.substr(2); //进制转换 int n = 0; int j = (str_tmp.size() - 1); //控制幂次 for (int i = 0; i &lt; str_tmp.size(); i++) &#123; //遍历每一位 if (str_tmp[i] &gt;= '0' &amp;&amp; str_tmp[i] &lt;= '9') //判断是否是数字 &#123; n += int(str_tmp[i] - '0')*pow(16, j); //转为0~9 &#125; else if (str_tmp[i] &gt;= 'A' &amp;&amp; str_tmp[i] &lt;= 'F')//判断是否是字母 &#123; n += (str_tmp[i] - 55)*pow(16, j); //A是65，减55是转为10~15 &#125; j--; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 其实可以直接调库的 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; int main()&#123; string str; while(cin&gt;&gt;str) &#123; cout &lt;&lt; stoi(str,0,16) &lt;&lt; endl; // 将str从位置 0 开始到末尾的 16 进制转为 十进制 &#125;&#125; HJ6 题目：质数因子，给定一个整数，输出该数的所有质数因子，包括重复值 思路：质数从 2 开始，让给定值从 2 开始遍历，能整除则继续，否则 +1 后再判断是否能整除，这样提交后内存超限 看了题解，一个数至少有一个质数因子不会超过其平方根，这样就可以从 2 遍历到其平方根，再判断是否是因子。需要注意该值本身就是质数的情况 代码： 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; long n; cin &gt;&gt; n; for(long i = 2; i &lt;= sqrt(n) &amp;&amp; i &lt;= n; i++)&#123; //从小到大的质因子，质因子不会超过它的平方根 while(n % i == 0)&#123; //所有的质数前面全部除掉，后续就不会有合因子 cout &lt;&lt; i &lt;&lt; \" \"; n /= i; //除掉质因子 &#125; &#125; if(n - 1) //前面已经除掉了所有因子，故在此判断该值是否是 1 ，不是就说明自己本身就是质数 cout &lt;&lt; n &lt;&lt; \" \"; return 0;&#125; HJ7 输入浮点数，四舍五入 思路：都说了入门题了 代码： 1234567891011121314#include &lt;iostream&gt;//#include &lt;cmath&gt;using namespace std;int main()&#123; float a; cin &gt;&gt; a; // cout &lt;&lt; round(a); if(a - int(a) &gt;= 0.5) cout &lt;&lt; int(a) + 1; else cout &lt;&lt; int(a);&#125; HJ8 题目：合并表记录：给定索引及对应的值，将相同索引的值求和，并按索引升序排序输出 思路一：（题目本意是考察哈希表，这里直接暴力解决）首先读入键值对数，再将键值对存入个vector，接着遍历并判断索引号是否相等，如若相等则加到第一个上，同时将另一个清除；新建一个vector，将不为空的复制进去，调用 sort 排序再输出 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int a, b, c; vector&lt;vector&lt;int&gt;&gt; v; vector&lt;vector&lt;int&gt;&gt; v_F; vector&lt;int&gt; v_tmp; cin &gt;&gt; a; for(int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; b &gt;&gt; c; v_tmp.push_back(b); v_tmp.push_back(c); v.push_back(v_tmp); v_tmp.clear(); //注意清空 &#125; for(int i = 0; i &lt; v.size(); i++) &#123; for(int j = i+1; j &lt; v.size(); j++) &#123; if(v[i][0] == v[j][0]) &#123; v[i][1] += v[j][1]; // v[j].clear(); v[j].erase(v[j].begin(), v[j].end()); //清除元素 &#125; &#125; if(v[i].empty() == false) v_F.push_back(v[i]); //非空存入新的容器 &#125; sort(v_F.begin(), v_F.end()); //排好序 for(int i = 0; i &lt; v_F.size(); i++) &#123; cout &lt;&lt; v_F[i][0] &lt;&lt; \" \" &lt;&lt; v_F[i][1] &lt;&lt; endl; &#125;&#125; 思路二：调用 STL 的 map，其自动建立 key - value 的对应，且其中的数据是有序的，map 是一个模板类，需要 key value 两个参数，关键字 key 只能在 map 中存在一次，其增删改和容器类似，通过 pair 插入，迭代器访问，注意迭代器返回值是变化的 代码： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; //输入键值对的个数 map&lt;int, int&gt; m; //使用map容器，自带键值对数据结构 map&lt;int, int&gt;::iterator it; //map类型的迭代器 for(int i = 0; i &lt; n; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; //每行输入一个键值对 it = m.find(a); //查找键 a 是否存在，是返回所在位置，否返回 end 位置， if(it != m.end()) //如果存在，对键相同的单元的值部分求和 &#123; m[a] = it-&gt;second + b; &#125; else //若不存在生成新的键值对 &#123; m[a] = b; &#125; &#125; for(it = m.begin(); it != m.end(); it++) &#123; //遍历输出 cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0;&#125; HJ10 题目：字符个数统计，输入一个字符串，输入该字串中不重复的字符个数 思路一：利用集合set的自动降重功能，将字符串拆分成字符插入其中，再求集合的 size 即可（需要遍历整个字串，耗时） 代码： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; string str_tmp; set&lt;char&gt; str; while(getline(cin, str_tmp)) &#123; for(int i = 0; i &lt; str_tmp.size(); i++) &#123; str.insert(str_tmp[i]); &#125; &#125; cout &lt;&lt; str.size();&#125; 思路二：哈希表，待补充 HJ11 题目：数字颠倒，将输入的整数以字符串的形式逆序输出 思路：将整数转为字串类型，再利用函数翻转输出 代码： 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; string str; str = to_string(n); //int2string转换 reverse(str.begin(),str.end()); //逆序 cout &lt;&lt; str;&#125; HJ12 题目：反转字符串 思路：同HJ11 代码： 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); cout &lt;&lt; str;&#125; HJ13 题目：句子逆序，给定一个句子，逆序输出（非逆序字母） 思路：遍历字串找到空格，找到一个空格后，空格前的分割出来存下，空格后的分割出来继续找空格，循环直至字串中没有空格 代码： 12345678910111213141516171819202122232425262728293031323334353637//// Created by MQRoad on 2022/08/15.//#include&lt;iostream&gt;#include&lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; string str; getline(cin, str); int n = str.size(); vector&lt;string&gt; str_vec; for(int i = 0; i &lt; n; i++) &#123; if(str.find(\" \") != string::npos) //有空格时 &#123; str_vec.push_back(str.substr(0,str.find(\" \"))); str = str.substr(str.find(\" \") + 1); n = str.size(); //分割后新字串长度 i = 0; //新的字串从头开始 &#125; else &#123; str_vec.push_back(str); //最后一个单词也存一下 break; &#125; &#125; //输出 for (int i = str_vec.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; str_vec[i] &lt;&lt; \" \"; &#125;&#125; HJ14 题目：字符串按字典序列排序 思路：偷个懒，直接调库函数排序吧 代码： 123456789101112131415161718192021222324252627282930313233//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;string&gt; str; string str_tmp; int n; cin &gt;&gt; n; while(n) &#123; cin &gt;&gt; str_tmp; str.push_back(str_tmp); n--; &#125; sort(str.begin(),str.end()); for (auto k: str) &#123; cout &lt;&lt; k &lt;&lt; endl; &#125; // vector&lt;string&gt;::iterator it; // for(it = str.begin(); it &lt; str.end(); it++) // &#123; // cout &lt;&lt; *it &lt;&lt; endl; // &#125;&#125; HJ15 题目：int型整数的二进制中1的个数 思路一：笨人笨办法，先转成二进制，二进制顺序无所谓，再数 1 的个数 代码： 12345678910111213141516171819202122232425262728//// Created by MQRoad on 2022/08/15.//#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; string str; cin &gt;&gt; n; vector&lt;int&gt; k; int j = 0; while(n) //转二进制 &#123; k.push_back(n%2); n /= 2; &#125; for (int i = 0; i &lt; k.size(); ++i) &#123; if (k[i] == 1) j++; &#125; cout &lt;&lt; j;&#125; 思路二：用STL，bitset 代码： 1234567891011121314151617181920//// Created by MQRoad on 2022/08/15.//#include&lt;bitset&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; bitset&lt;32&gt; set(n); //题目要求大小不超过32// for (int i = 0; i &lt; set.size(); ++i)// &#123;// cout &lt;&lt; set[i];// &#125; cout &lt;&lt; set.count(); //直接返回 1 的个数&#125; 思路三：位运算：将整数对应的二进制数的每一位与 1 进行位与运算，为此，每次将该数右移 1 位 代码： 123456789101112131415161718192021//// Created by MQRoad on 2022/08/15.//#include&lt;bitset&gt;#include&lt;iostream&gt;using namespace std;//位与运算int main()&#123; int n; cin &gt;&gt; n; int count= 0; while(n) &#123; if (n &amp; 1) count++; n &gt;&gt;= 1; //右移一位 &#125; cout &lt;&lt; count;&#125; 思路三：（我反正是想不到）位与运算还有一个性质：n&amp;n-1结果会去掉n最末尾的1。比如1110&amp;1101=1100，直接就去掉了111011101110最后的1，我们依照这个性质，不断去掉n末尾的1，直到结果为全0，去掉过程中统计去掉过多少次，即1出现的次数 123456789101112131415#include&lt;iostream&gt;using namespace std; int main()&#123; int n; cin &gt;&gt; n; int count = 0; while(n)&#123; count++; //统计+1 n &amp;= (n - 1); //去掉末尾的1 &#125; cout&lt;&lt; count &lt;&lt; endl; return 0;&#125; HJ17 题目：坐标移动，ADWS，给定的数字表示移动距离 思路一：（纯纯暴力）和HJ13类似，先把给定的字串按 “;” 分割出来，再判断分割后的首位是 ADWS 的哪位，分类讨论，小类中再判断数字是否合理 代码：（垃圾代码，真的垃圾） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// Created by MQRoad on 2022/08/16.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;//#include &lt;set&gt;using namespace std;int main()&#123; string str = \"S87;S7;W56;S75;A8;S84;W23;W19;W40;D73;S87;A39;W97;W78;A53;D16;D15;A50;W41;S87;D47;W56;D56;A23;A91;S25;D61;D53;D58;W88;W58;S61;D69;W74;D89;A92;D39;D62;S78;W72;W73;W35;S76;W35;S36;W39;A4;\";// getline(cin,str); vector&lt;string&gt; str_vec; for(int i = 0; i &lt; str.size(); i++) &#123; if ((str.substr(0, str.find(\";\"))).substr(0,1) == \"A\" || (str.substr(0, str.find(\";\"))).substr(0,1) == \"D\" || (str.substr(0, str.find(\";\"))).substr(0,1) == \"W\" || (str.substr(0, str.find(\";\"))).substr(0,1) == \"S\" )//首位不是ADWS的就不要了 &#123; str_vec.push_back(str.substr(0, str.find(\";\"))); &#125; str = str.substr(str.find(\";\") + 1); i = 0; &#125; int x = 0, y = 0; for (int i = 0; i &lt; str_vec.size(); ++i) &#123; if(str_vec[i][0] == 'A') &#123; if (str_vec[i].size() == 3) //分割后的是不是有3位，是的话说明数字有两位，两位都要判断是不是数字 &#123; if (str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9' &amp;&amp; str_vec[i][2] &gt;= '0' &amp;&amp; str_vec[i][2] &lt;= '9') x -= stoi(str_vec[i].substr(1)); //字串转int &#125; else if(str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9') x -= stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == 'D' ) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9' &amp;&amp; str_vec[i][2] &gt;= '0' &amp;&amp; str_vec[i][2] &lt;= '9') x += stoi(str_vec[i].substr(1)); &#125; else if(str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9') x += stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == 'W' ) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9' &amp;&amp; str_vec[i][2] &gt;= '0' &amp;&amp; str_vec[i][2] &lt;= '9') y += stoi(str_vec[i].substr(1)); &#125; else if(str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9') y += stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == 'S') &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9' &amp;&amp; str_vec[i][2] &gt;= '0' &amp;&amp; str_vec[i][2] &lt;= '9') y -= stoi(str_vec[i].substr(1)); &#125; else if( str_vec[i][1] &gt;= '0' &amp;&amp; str_vec[i][1] &lt;= '9') y -= stoi(str_vec[i].substr(1)); &#125;// else// continue;// str_vec[i].size() == 2 &amp;&amp; &#125; cout &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y; return 0;&#125; 看了排行一的代码，思路和我一样，但是代码简洁多了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; while(cin &gt;&gt; str) &#123; //初始化坐标 int x = 0, y = 0; //存储单步操作 vector&lt;string&gt; steps; //把字符串拆分 int wordlen = 0; for(int i = 0; i &lt; str.size(); ++i) &#123; while(str[i] != ';') wordlen ++, i ++; steps.push_back(str.substr(i - wordlen, wordlen)); wordlen = 0; &#125; //分解成功 //for(auto x : steps) cout &lt;&lt; x &lt;&lt; endl; //对单个steps执行坐标变换 for(int i = 0; i &lt; steps.size(); ++i) &#123; int num = 0; //长度3 A10 if(steps[i].length() == 3 &amp;&amp; steps[i][1] &lt;= '9' &amp;&amp; steps[i][1] &gt;= '0' &amp;&amp; steps[i][2] &lt;= '9' &amp;&amp; steps[i][2] &gt;= '0') num = (steps[i][1] - '0') * 10 + steps[i][2] - '0'; //长度2 A5 if(steps[i].length() == 2 &amp;&amp; steps[i][1] &lt;= '9' &amp;&amp; steps[i][1] &gt;= '0') num = steps[i][1] - '0'; switch(steps[i][0])//ASDW &#123; case 'A': x -= num; break; case 'D': x += num; break; case 'W': y += num; break; case 'S': y -= num; break; default: break; &#125; &#125; cout &lt;&lt; x &lt;&lt; ',' &lt;&lt; y &lt;&lt; endl; &#125; return 0;&#125; HJ20 题目：密码合格验证：大于8位；大小写、数字、其他符号中的至少三种；不能有三个字符重复 思路：分类判断：一是判断是否有三种类型，二是判断是否有重复 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by MQRoad on 2022/08/17.//#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int is3kind(string str)&#123; int count[4]=&#123;0&#125;; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') count[0] = 1; else if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') count[1] = 1; else if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') count[2] = 1; else count[3] = 1; &#125; return count[0] +count[1] + count[2] + count[3];&#125;bool isrepet(string str)&#123; for (int i = 0; i+3 &lt; str.size(); ++i) //i+3超过str长度就无需判断了 &#123; if(str.find(str.substr(i,3), i + 3) != string::npos) //每次将输入字串截取3个，判断3个之后是否有相同 return true; &#125; return false;&#125;int main()&#123; string str; while(cin &gt;&gt; str) &#123; if (str.size() &lt;= 8||is3kind(str)&lt;3|| isrepet(str)) cout &lt;&lt; \"NG\" &lt;&lt; endl; else cout &lt;&lt; \"OK\" &lt;&lt; endl; &#125;&#125; HJ21 题目：密码转换：按手机键盘九键，将小写字母转为对应的数字，大写字母转为对应小写的后一位，Z的直接转为a再转为数字 思路：（笨办法，暴力）先将小写字母转为数字，再将大写转为数字 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'c') str[i] = '2'; else if (str[i] &gt;= 'd' &amp;&amp; str[i] &lt;= 'f') str[i] = '3'; else if (str[i] &gt;= 'g' &amp;&amp; str[i] &lt;= 'i') str[i] = '4'; else if (str[i] &gt;= 'j' &amp;&amp; str[i] &lt;= 'l') str[i] = '5'; else if (str[i] &gt;= 'm' &amp;&amp; str[i] &lt;= 'o') str[i] = '6'; else if (str[i] &gt;= 'p' &amp;&amp; str[i] &lt;= 's') str[i] = '7'; else if (str[i] &gt;= 't' &amp;&amp; str[i] &lt;= 'v') str[i] = '8'; else if (str[i] &gt;= 'w' &amp;&amp; str[i] &lt;= 'z') str[i] = '9'; else if (str[i] == '0') str[i] = '0'; else if (str[i] == '1') str[i] = '1';// cout &lt;&lt; str[i]; &#125; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Y') str[i] += 32 + 1; if (str[i] == 'Z') str[i] = 'a'; cout &lt;&lt; str[i]; &#125;&#125; 优化代码：上述代码遍历了两次，优化如下 1234567891011121314151617181920212223242526272829303132333435//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; for(int i = 0; i &lt; s.size(); i++) &#123; if(s[i] &lt;= '9' &amp;&amp; s[i] &gt;= '0') cout &lt;&lt; s[i]; else if(s[i] &lt; 'Z' &amp;&amp; s[i] &gt;= 'A') &#123; s[i] = s[i] + 33; cout &lt;&lt; s[i]; &#125; else if(s[i] == 'Z') cout &lt;&lt; \"a\"; else if(s[i] &lt;= 'z' &amp;&amp; s[i]&gt;= 'a') &#123; if(s[i] &lt;= 'c' &amp;&amp; s[i] &gt;= 'a') cout &lt;&lt; \"2\"; if(s[i] &lt;= 'f' &amp;&amp; s[i] &gt;= 'd') cout &lt;&lt; \"3\"; if(s[i] &lt;= 'i' &amp;&amp; s[i] &gt;= 'g') cout &lt;&lt; \"4\"; if(s[i] &lt;= 'l' &amp;&amp; s[i] &gt;= 'j') cout &lt;&lt; \"5\"; if(s[i] &lt;= 'o' &amp;&amp; s[i] &gt;= 'm') cout &lt;&lt; \"6\"; if(s[i] &lt;= 's' &amp;&amp; s[i] &gt;= 'p') cout &lt;&lt; \"7\"; if(s[i] &lt;= 'v' &amp;&amp; s[i] &gt;= 't') cout &lt;&lt; \"8\"; if(s[i] &lt;= 'z' &amp;&amp; s[i] &gt;= 'w') cout &lt;&lt; \"9\"; &#125; &#125; return 0;&#125; HJ22 题目：汽水瓶，3个空的换一瓶汽水，可以向老板要一个空瓶，但必须还给老板 思路：（看了题解我TM，这就是个智力题）3个换一个，有2个的话可以找老板要一下空的，换一瓶，喝完了还给老板，所以不管有多少空瓶，就看你有多 2，反正有 2 就可以换一瓶 代码： 1234567891011121314151617//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while ( cin &gt;&gt; n ) &#123; if(n == 0) continue; cout &lt;&lt; n/2 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"华为机考","slug":"华为机考","permalink":"https://hbroad.github.io/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/"}]},{"title":"数据结构","slug":"数据结构/数据结构","date":"2022-07-29T13:20:49.000Z","updated":"2022-08-14T12:25:50.559Z","comments":true,"path":"2022/07/29/data_structure/","link":"","permalink":"https://hbroad.github.io/2022/07/29/data_structure/","excerpt":"数据结构理论 宝藏级+保姆级课程-数据结构与算法基础-青岛大学-王卓老师","text":"数据结构理论 宝藏级+保姆级课程-数据结构与算法基础-青岛大学-王卓老师 时间复杂度时间复杂度：各条指令执行的时间之和 大O表示法 表示算法执行的渐进上限 性质： 任意常数 $c &gt;0$，$O(f(n))=O(cf(n))$ 常数乘以某个运算，不改变其时间复杂度（函数正的常系数可忽略等同于1） 任意常数$a&gt;b&gt;0$，$O(n^a+n^b)=O(n^a)$ 因 $a&gt;b$，故前者的影响大于后者，在整个过程中便可忽略后者的影响（低次项可忽略，保留最高次项） 空间复杂度 不计入输入本身 其他各方面消耗都计入 复杂度分析 常数时间复杂度 $O(1)$ 对数时间复杂度 $O(logn)$ 对数多项式复杂度 线性 $O(1)$ 链表循环链表 尾部指针域指向头结点 一般使用带尾指针的循环链表","categories":[],"tags":[]},{"title":"数字图像处理","slug":"图像处理/数字图像处理","date":"2022-07-17T03:00:47.000Z","updated":"2022-08-25T07:25:57.479Z","comments":true,"path":"2022/07/17/digital_image_process/","link":"","permalink":"https://hbroad.github.io/2022/07/17/digital_image_process/","excerpt":"数字图像处理基础理论（待补充） (通俗易懂的计算机视觉优质课程)北京邮电大学计算机学院-鲁鹏","text":"数字图像处理基础理论（待补充） (通俗易懂的计算机视觉优质课程)北京邮电大学计算机学院-鲁鹏 图像去噪（滤波）常见噪声 卷积 卷积：把相关运算的核旋转180° 线性：F(f1+f2) = F(f1)+F(f2) 平移不变形：F(S(f)) = S(F(f)) 满足线性平移不变性的操作均可定义为卷积 满足交换律、结合律、分配律 卷积时边缘的处理：边界填充 卷积核的特性导致卷积后的图像和原图不一样大 零填充（常用） 复制边缘 镜像边缘 常见核 单位脉冲核 平移核 平滑核 锐化操作 高斯卷积 平均卷积核的问题 中心与邻域的权重一致，导致振铃现象（卷积后图像出现的条状） 解决：根据邻域像素与中心的远近程度分配权重，离中心越近，权重越大 高斯卷积的生成 ​ 归一化即为 3 中各个位置权重值/总的权重值 参数的选取 大标准差或者大尺寸卷积核平滑能力强 小标准差或者小尺寸卷积核平滑能力弱 解释： 大标准差，对应的是核中中心元素的权重低于周围元素，即占比低，从而被平滑的越厉害 大尺寸，在标准差不变时，高斯函数值相等，但在归一化后，大尺寸的权重比小尺寸的小，平滑的越厉害 经验法则: 将卷积核的半窗宽度设置为 3𝜎，最终卷积模板尺寸为 2 × 3𝜎 + 1 即：只要指定一个参数 $\\sigma$ ，就可直接得到窗口大小，从而不用两个参数单独指定 为什么是 $3\\sigma$，因为大于该值以后，高斯值为 0，没有意义 高斯核特性说明 高斯核是低通滤波器，滤除图像中的高频成分 两个高斯卷积核卷积后得到的还是高斯卷积核 使用多次小方差卷积核连续卷积，可以得到与大方差卷积核相同的结果 使用标准差为 $\\sigma$ 的高斯核进行两次卷积与使用标准差 $\\sqrt 2 \\sigma$ 的高斯核进行一次卷积相同 高斯核 1 为 $f$，高斯核 2 为 $g$，两者卷积： $f$ $g$ $f\\star g$ 均值 $m_f$ $m_g$ $m_f + m_g$ 标准差 $\\sigma_f$ $\\sigma_g$ $\\sigma_f + \\sigma_g$ 可分离特性 大卷积核可分为两个一维高斯的乘积 降低计算复杂度 如 $m \\times m$ 的核卷积 $n \\times n$ 的图像 无分离时，复杂度为：$O(n^2m^2)$ 分离后，复杂度为：$O(n^2m)$ 中值滤波 用于去除椒盐噪声、脉冲噪声 使用邻域升序排列的中值作为中心像素的值 中值滤波的灰度值始终是原图像中的灰度值 卷积与边缘提取边缘图像中亮度明显而急剧变化的点（灰度不连续） 边缘种类 边缘检测 图像中灰度急剧变化的地方，其导数变化明显 图像求导 差分代替一般导数 一般2D函数的偏导为：$$\\frac{ \\partial f(x,y) }{\\partial x} = \\lim_{\\epsilon \\to 0} \\frac{f(x+\\epsilon) - f(x,y)}{\\epsilon}$$但在数字图像中，$\\epsilon$ 不能为0，其最小单位为一个像素，故有：$$\\frac{ \\partial f(x,y) }{\\partial x} \\approx \\frac{f(x+1) - f(x,y)}{1}$$ + X 方向的导数提取了 Y 方向的特征， Y 同理 图像梯度 指向灰度变换最快的方向 X 方向的梯度与 Y 方向的边缘垂直，其他同理；即梯度方向与边缘垂直。具体可参考 可见，梯度向量与边缘垂直，故也称为边缘法线 需要对角边缘时，即需要二维核，Robert 算子采用对角性能（详见数字图像处理第四版P516） 注意： $3 \\times 3$ 的核：最小的中心对称核，考虑了中心对侧数据的性质 Soble 算子能够更好的平滑噪声 上图中所有的算子，权重和为 0，即在恒定灰度区域的响应为 0 （恒定区域灰度值相等，与核相乘相加为0） 梯度幅值的实现 实际中，使用平方及平方根的开销大，一般使用绝对值近似$$M(x,y) \\approx |{g_x}| + |g_y|$$ ​ 虽计算简单，但使得滤波器不再具有各向同性（即旋转不变性） 实际情况但实际中，由于噪声的影响，求导的结果也无法得出边缘的位置 因而在求导前先平滑滤波处理 由于微分求导也是卷积，卷积具有结合性，故原图的高斯卷积与可求导结合（高斯一阶偏导核），最后和原图卷积，从而可节省一次卷积操作 高斯一阶偏导核 高斯与一阶偏导的对比 高斯核 消除高频成分（低通滤波器） 卷积核中的权值不可为负数（倒扣钟型） 权值总和为1（恒定区域不受卷积影响） 高斯一阶偏导核 高斯的导数 卷积核中的权值可以为负 权值总和是0（恒定区域无响应，急剧变化的地方响应大） 高对比度点的响应值大 Canny 检测算子 ​ 经过两个方向上高斯一阶导，得到梯度幅值图，可见，边缘较宽，这是因为在灰度斜坡上一阶导不为 0，如何得到更为准确的边缘？ 非极大值抑制 实质是规定梯度方向（边缘法线）的多个离散方向，如定义为水平、垂直、+45°、-45° 四个方向（一条边缘有正负两条边缘法线），即所有可能得边缘量化为这四个方向，但显然，边缘法线方向可能是任意的，故需要定义某个范围，落在该范围内就认为是哪个方向，该定义方式如下图所示（详见数字图像数字图像处理第四版 P526） 流程： 对任意一点，求该点的梯度幅值 $K$ 和方向 $\\alpha$ 在四种边缘法线中找到最接近梯度方向 $\\alpha$ 的，记为 $d_k$ 在 $d_k$ 方向上取一个或两个邻点，若 $K$ 小于所取点的梯度幅值，则令 $g_N(x,y) = 0$ （即抑制），否则为 $g_N(x,y) = K$）（$g_N(x,y)$ 为非极大值抑制后的图像） 双阈值法 阈值过高导致细节丢失，过低则边缘杂乱 双阈值：先利用高阈值筛选出主要的边缘，再利用低阈值将这些边缘连接起来（低阈值虽然会引入噪声引起的假边，但是这种假边不会和高阈值筛选出的主要边缘有连接） Canny 整体流程： 用高斯一阶偏导核卷积图像 计算每个点的梯度幅值和方向 非极大值抑制： 将宽的“边缘”细化至单个像素宽度 连接与阈值（滞后）： 定义两个阈值：低和高 使用高阈值开始边缘曲线，使用低阈值继续边缘曲线 拟合最小二乘RANSAC角点检测为何提取需要提取特征？多视角拼接 特征提取 特征的要求 可重复性：即使有几何变换等的影响，该特征仍能在多视角中找到 独特性：每个特征应当是独特的，否则难以匹配 高效性：考虑计算的高效性 局部性：特征只是局部的 角点 只有角点在各个方向移动时窗口内灰度变化大 Harris角点检测 不变性分析 灰度仿射变换 仅灰度是具有不变性的，对同一点，增加其灰度和减小其灰度，求导后其趋势不变 但灰度缩放导致部分点超过阈值，缩放前后不满足不变性， 即灰度仿射变换满足部分不变性 图像平移变换满足不变性 图像旋转变换满足协变性 不满足尺度不变性 斑点（Blob）检测 高斯二阶导 同一信号，不同的 $\\sigma$ 产生不同的相应，适当的模板会产生极大值（尺度归一化），实现多尺度检测 尺度空间中，只比较上下两个相邻的尺度空间，比较相邻27个点，进行非最大化抑制 改进 Harris-Lap SIFT 尺度不变性特征检测 DOG：高斯差分近似拉普拉斯 利用高斯核的可分离性 空间滤波空间相关与卷积 相关：图像上移动核的中心，求每个位置的乘积之和 只满足分配律 卷积：把相关运算的核旋转180° 线性：F(f1+f2) = F(f1)+F(f2) 平移不变形：F(S(f)) = S(F(f)) 满足线性平移不变性的操作均可定义为卷积 满足交换律、结合律、分配律 卷积时边缘的处理：边界填充 卷积核的特性导致卷积后的图像和原图不一样大 零填充 复制边缘 镜像边缘 可分离核 可分离核：能够表示为两个向量外积的矩阵 $m \\times n$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v_{m \\times 1}w_{n \\times 1}^T$ $m \\times m$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v_{m \\times 1}v_{m \\times 1}^T$ 优势：减少计算量，大核分离为小核计算 判断是否可分离：矩阵的秩为 1（矩阵论：一列向量与一行向量的乘积的矩阵，秩为 1） 空间滤波器的构建","categories":[],"tags":[{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"}]},{"title":"点云+PCL学习笔记","slug":"点云+PCL学习笔记","date":"2022-07-17T02:01:20.593Z","updated":"2022-08-02T11:11:45.734Z","comments":true,"path":"2022/07/17/point_cloud_pcl/","link":"","permalink":"https://hbroad.github.io/2022/07/17/point_cloud_pcl/","excerpt":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充）","text":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充） 点云 分布在 N 维空间中的离散点集 是对物体表面信息的离散采样 点云库 三维处理算法：滤波、特征估计、表面重建等 PointT 类型PointXYZ 包含 x y z 坐标的点数据类型 成员变量 float x, y, z points[i].x 访问 多余的一个变量用来填充位置以满足存储对齐（?） 12345678910union&#123; float data[4]; struct &#123; float x; float y; float z; &#125;;&#125;; Point XYZI 包含 x y z 坐标及 intensity PointXYZRGBA rgba 单独作为一个整型变量（unit32_t） PCD 文件 包含文件头：声明存储点云数据的特性，必须用 ASCII 编码 123456789101112131415# .PCD v.7 - Point Cloud Data file formatVERSION .7 # 指定PCD文件版本FIELDS x y z rgb # 指定每个点可以有的每一个维度或字段的名字SIZE 4 4 4 4 # 用字节数指定 FIELDS 中每一个维度的大小TYPE F F F F # 用一个字符指定 FILEDS 中每一个维度的类型COUNT 1 1 1 1 # 指定每一个维度包含的元素数目WIDTH 213 # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目） 列HEIGHT 1 # 用点的数量表示点云数据集的高度；同 WIDTH 行 VIEWPOINT 0 0 0 1 0 0 0 # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）POINTS 213 # 数据集中点的总数 DATA ascii # 存储点云数据的数据类型：ASCII 或 二进制0.93773 0.33763 0 4.2108e+060.90805 0.35641 0 4.2108e+060.81915 0.32 0 4.2108e+060.97192 0.278 0 4.2108e+06 DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开 DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法 K-d tree理论 按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。 在 k-d tree 中查找距离查询点 $\\overline x$ 最近点的，意味着遍历整个树，找到包含 $\\overline x$ 的子节点。 实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。 两种查询方式（详见博士论文 P40） PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型： ==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点） ==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点 r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。 上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \\vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\\vec{q}$ ，但以 $ \\vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\\vec{q}’$ 。 另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 正确尺度因子 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。 如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。 所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。 Octree(八叉树) 一个根节点包含八个子节点 若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归 除近邻搜索外，可用于碰撞检测 点云连接点连接 需确保类型和维度相等 12cloud_c = cloud_a;cloud_c += cloud_b; 字段连接 需确保数目相等 1pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c); 点云滤波原因 噪声点：设备精度、操作者经验、环境因素等 离群点：外界干扰如障碍物等，产生离主体点云较远的离散点 双边滤波 通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果 有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征 直通滤波器 去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点） 123456pcl::PassThrough&lt;pcl::PointXYZ&gt; pass; // 创建直通滤波器对象pass.setInputCloud(cloud); // 输入pass.setFilterFieldName(\"z\"); // 设置滤波字段，此处为 z 轴pass.setFilterLimits(0.0, 200.0); // 设置滤波范围，超出则滤除pass.setFilterLimitsNegative (true); // 默认为 false，设为 ture 则返回被滤除点pass.filter(*cloud_filtered); // 执行滤波，并将滤波结果存储在 cloud_filtered VoxelGrid（体素化网格）滤波器 实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变 VoxelGrid 三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体== 通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示== 对所有体素处理后得到过滤后的点云 缺点：慢，比体素中心逼近法更慢 1234pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor; // 创建体素栅格滤波对象sor.setInputCloud(cloud); // 读入点云设置为输入sor.setLeafSize(0.01f, 0.01f, 0.01f); // 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米sor.filter(*cloud_filtered); // 执行滤波并存储到 cloud_filtered 滤波结果 ### 统计滤波 （详见博士论文 P40） 用于去除离群点 基于对近邻点集 $P^k$ 的统计分析 计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\\overline d$ 计算点云 $P$ 在平均距离上的分布，并估计平均值 $\\mu_k$ 及标准差 $\\sigma_k$ 对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离 去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。 假设第一次扫描 $P_i$ 和随后的 $P_{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \\in P_i$，搜索其对应的近邻点 $p \\in P_{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。 1234567pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor; // 创建统计滤波对象sor.setInputCloud(cloud); // 设置输入点云sor.setMeanK(50); // 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）sor.setStddevMulThresh(1.0); // 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点sor.filter(*cloud_filtered); // 执行并存储滤波结果sor.setNegative(true); // 获取离群点（此值默认为 false） 滤波结果 参数化模型投影点云 点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0 PCL 中有特意存储常见模型系数的数据结构 12345678910111213// Create a set of planar coefficients with X=Y=0,Z=1 pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients()); // 创建 模型系数 对象coefficients-&gt;values.resize(4); // 参数个数置为 4coefficients-&gt;values[0] = coefficients-&gt;values[1] = 0; // 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Ycoefficients-&gt;values[2] = 1.0;coefficients-&gt;values[3] = 0;// Create the filtering objectpcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj; // 设置投影滤波对象 proj.setModelType(pcl::SACMODEL_PLANE); // 设置对象对应的投影模型类型，此处为平面模型proj.setInputCloud(cloud); // 设置输入proj.setModelCoefficients(coefficients); // 设置模型系数为前述定义系数proj.filter(*cloud_projected); // 执行并保存 从一个点云中提取一个子集 基于 ExtractIndices 滤波器（基于分割算法） 12345pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; // 创建分割对象extract.setInputCloud(cloud_filtered); // 设置输入点云 extract.setIndices(inliers); // 设置分割后的内点为需要提取的点击（分割部分略）extract.setNegative(false); // 指定提取内点extract.filter(*cloud_p); // 执行并存储 RadiusOutlierRemoval / ConditionalRemoval 移除离群点RadiusOutlierRemoval 删除输入点云一定范围内没有达到足够多近邻的所有数据点 人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。 12345678pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem; // 创建半径滤波对象// build the filteroutrem.setInputCloud(cloud); // 设置输入点云outrem.setRadiusSearch(0.8); // 设置搜索半径为 0.8outrem.setMinNeighborsInRadius(2); // 设置所需近邻点数为 2outrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)// apply filteroutrem.filter(*cloud_filtered); // 执行滤波并保存 ConditionalRemoval 如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个 123456789101112pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::Ptr range_cond(new pcl::ConditionAnd&lt;pcl::PointXYZ&gt;()); // 创建条件定义对象range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(\"z\", pcl::ComparisonOps::GT, 0.0))); // 添加比较算子：z 字段上大于 0.0 range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(\"z\", pcl::ComparisonOps::LT, 0.8))); // 添加比较算子：z 字段上小于 0.8 // build the filterpcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem; // 初始化条件滤波condrem.setCondition(range_cond); // 设置条件为指定的比较算子condrem.setInputCloud(cloud); // 设置输入点云condrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN// apply filtercondrem.filter(*cloud_filtered); // 执行滤波并保存 CropHull 任意多边形内部点云提取 CropHull 滤波器得到 2D 封闭多边形内 / 外的点云 深度图像（Range/Depth Images） 将图像采集器到场景中各点的距离（深度）值作为像素值的图像（距离是相机到场景点的垂直距离，不是连线距离） 直接反映景物可见表面的几何状态 物体的三维表示形式，可通过立体相机或 TOF 相机获取 深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据 英文中常见的等价表述：range image，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles 注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息 从点云创建深度图像 主要函数为 createFromPointCloud，声明 9 个参数填充即可 12345678910111213141516171819202122232425void pcl::RangeImage::createFromPointCloud ( const PointCloudType &amp; point_cloud,float angular_resolution = pcl::deg2rad (0.5f),float max_angle_width = pcl::deg2rad (360.0f),float max_angle_height = pcl::deg2rad (180.0f),const Eigen::Affine3f &amp; sensor_pose = Eigen::Affine3f::Identity (),RangeImage::CoordinateFrame coordinate_frame = CAMERA_FRAME,float noise_level = 0.0f,float min_range = 0.0f,int border_size = 0 ) //Create the depth image from a point cloud./*Parameter EX:point_cloud the input point cloudangular_resolution the angular difference (in radians) between the individual pixels in the imagemax_angle_width an angle (in radians) defining the horizontal bounds of the sensormax_angle_height an angle (in radians) defining the vertical bounds of the sensorsensor_pose an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )coordinate_frame the coordinate frame (defaults to CAMERA_FRAME)noise_level - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.min_range the minimum visible range (defaults to 0)border_size the border size (defaults to 0)*/ 从深度图像提取边界 边界：前景跨越到背景的位置 物体边界（黑）、阴影边界（绿）、Veil 点集（红） 若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘 关键点 兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集 数量比原始点云或图像的数据量小很多 组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性 利于加快后续的处理速度 关键概念及算法NARF 关键点*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608. 从深度图像识别物体 步骤 遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测； 遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向； 根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定； 对兴趣值进行平滑过滤； 进行无最大值压缩找到最终的关键点，即为 NARF 关键点。 简化步骤* 给定深度图像，进行边缘提取 表面变化基于边界和曲率原则”评分“ 设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多 Harris关键点 通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点 若 Harris 矩阵特征的两个特征值都很大，则为关键点 对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测 3D Harris 关键点检测使用的是点云表面法向量的信息（2D 使用的是图像梯度） PCL 中的 keypoints深度图像提取 NARF 关键点12345678pcl::RangeImageBorderExtractor range_image_border_extractor; // 创建对象，用于边缘提取pcl::NarfKeypoint narf_keypoint_detector(&amp;range_image_border_extractor); // 创建对象，传入上述提取出的深度图像边缘narf_keypoint_detector.setRangeImage(&amp;range_image); // 传入深度图像narf_keypoint_detector.getParameters().support_size = support_size; // 设置支持范围(搜索空间球体的半径，邻域范围)//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;pcl::PointCloud&lt;int&gt; keypoint_indices; // 创建点云对象，存储检测到的点云narf_keypoint_detector.compute(keypoint_indices); // 计算 SIFT 关键点提取参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客 参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客 参考：SIFT（3）—–尺度空间极值检测_姗姗本人的博客-CSDN博客 注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。 ​ ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向 ​ ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 尺度不变性 局部特征描述子 12345678pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift; // 创建sift关键点检测对象pcl::PointCloud&lt;pcl::PointWithScale&gt; result; // 存储查询结果sift.setInputCloud(cloud_xyz); // 设置输入点云pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());sift.setSearchMethod(tree); // 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快sift.setScales(min_scale, n_octaves, n_scales_per_octave); // 设置限制关键点检测的阈值sift.compute(result); // 执行sift关键点检测，保存结果在result 123456789101112131415// setScales 函数原型void pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::setScales ( float min_scale,int nr_octaves,int nr_scales_per_octave ) 用于指定搜索关键点的尺度范围 // Specify the range of scales over which to search for keypoints.// Parameters 设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）// min_scale the standard deviation of the smallest scale in the scale space 高斯金字塔中组（octaves）的数目// nr_octaves the number of otaves (i.e. doublings of scale) to compute 每组计算的尺度数目// nr_scales_per_octave the number of scales to compute within each octave Harris 关键点提取123456789//harris_detector-&gt;setNonMaxSupression(true);harris_detector-&gt;setRadius(r_normal); // 设置法向量估计的半径harris_detector-&gt;setRadiusSearch(r_keypoint); // 设置关键点估计的近邻搜索半径harris_detector-&gt;setInputCloud (input_cloud);//harris_detector-&gt;setNormals(normal_source);//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);harris_detector-&gt;compute (*Harris_keypoints);cout&lt;&lt;\"Harris_keypoints的大小是\"&lt;&lt;Harris_keypoints-&gt;size()&lt;&lt;endl;writer.write&lt;pcl::PointXYZI&gt; (\"Harris_keypoints.pcd\",*Harris_keypoints,false); 特征描述与提取特征描述 局部特征描述 + 全局特征描述 特征描述子三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有形状描述子（shape descriptors）、几何特征（gometric features）、点特征表示（point feature representations）等。 理论（详见博士论文 P23，37） 给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为：$$||p_i^k-p_q||_x \\leq d_m \\tag{1.1}$$式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见范数）。 此外，$P^k$ 中近邻点的个数可被限制为给定值 k。 点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围：$$F(p_q,P^k)={x_1,x_2,···,x_n}$$式中，$x_i$ , $i \\in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。 比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\\Gamma$ 为描述这两点之间差异的相似性度量，$d$ 为距离度量，则有：$$\\Gamma = d(F_1,F_2)$$当 $d$ 趋向于某个最小值时，即 $d \\to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。 个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。 通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。 理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣： 刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有旋转平移不变性 不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有抗密度干扰性 噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有鲁棒性 也就是说，一个点特征表示满足上述条件才可以说是好的表示法 邻域的概念确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方：$$||X||2 = \\sqrt{\\sum{i=1}^n x_i^2}$$可用于度量两个向量间的差异，如平方差和：$$SSD(x_1,x_2) = \\sum_{i=1}^n(x_{1i}-x_{2i})^2$$也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。 但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。 特征提取输入点云的调用 输入点云调用函数主要有： setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量 setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算 setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间 后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208） 经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。 估计点云的表面法线（详见博士论文 P45） 描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线 一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②直接从点云数据集中近似推断表面法线 对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数 12345// PCL 中估计一点集对应的协方差矩阵Eigen::Matrix3f covariance_matrix; // 定义每个表面小块的 3×3 协方差矩阵的存储对象Eigen::Vector4f xyz_controid; // 定义一个表面小块的质心坐标16字节对其存储对象compute3DCentroid(cloud, xyz_controid); // 估计质心坐标computeCovarianceMatrix(cloud, xyz_controid, covariance_matrix); // 计算 3×3 协方差矩阵 一个平面可用一个点 $x$ 和 一个法向量 $\\overline n$ 表示，则一个点 $p_i \\in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \\overline n$ 。 $x$ 和 $\\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \\in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？） 设$$x = \\overline p = \\frac{1}{k}· \\sum_{i=1}^{k}p_i$$为 $P^k$ 的质心，而 $\\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \\in R^{3 \\times 3}$ 的特征值和特征向量得到，其表达式如下：$$C = \\frac{1}{k} \\sum_{i=1}^{k} \\xi_i · (p_i - \\overline p)·(p_i - \\overline p)^T , \\ C· \\overline v_i = \\lambda_i· \\overline v_j , \\ j \\in {0,1,2}$$式中，$\\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\\lambda_j \\in R$ ，特征向量 $\\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \\le \\lambda_0 \\le \\lambda_1 \\le \\lambda_2$ ，则特征向量 $\\overline v_0$ 对应的最小特征值 $\\lambda_0$ 就是 $+ \\overline n = {n_x,n_y,n_z}$ 或 $ - \\overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\\overline n$ 可由球坐标中的一对角 $(\\phi,\\theta)$ 表示如下：$$\\phi = \\arctan \\frac{n_z}{n_y}, \\ \\theta = \\arctan\\frac{\\sqrt{(n_y^2+n_z^2)}}{n_x}$$问题是，这种主成分分析法（PCA）对方向仍然是模糊的。 表面曲率（详见博士论文P48） 方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\\lambda_0 = min(\\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\\overline n$ 的变化可使用下式估计：$$\\sigma_p = \\frac{\\lambda_0}{\\lambda_0+\\lambda_1+\\lambda_3}$$ 该最小特征值与特征值之和的比值 $\\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。 source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998 法线的定向问题 没有数学方法可以解决法线的正负向问题 法线球体描述了点云中所有法线的方向 对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向 1234567// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）flipNormalTowardsViewpoint ( const PointCloud &amp; cloud,float vp_x,float vp_y,float vp_z,Normals &amp; normals ) 但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \\cdot n_j = 1$。 点特征直方图（PFH）（详见博士论文P51和PCL书P213） bin 可理解为分格的大小，就是直方图每一个柱子的宽度 理论通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。 一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。 为形成新的特征空间，引入 双环邻域 的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \\in P$ 有双环邻域的条件是：$$(\\exists)r_1,r_2 \\in R, \\ r_1 &lt;r_2, \\ \\begin{cases} r_1 \\Rightarrow P^{k_1} \\ r_2 \\Rightarrow P^{k_2}\\end{cases}, \\ 0&lt;k_1&lt;k_2$$两个半径 $r_1$ 和 $r_2$ 用于确定点 $p_i$ 的两个不同的特征表示层：第一层表示的是查询点处的法线，从邻域集 $p^{k_1}$ 的主成分分析中获得，第二层即为 PFH。 PFH 是基于 $P_{k_2} $ 中的点及其法线之间的关系的，即通过参数化查询点与邻域点之间的空间差异，形成一个多维直方图对点的 k 邻域几何属性进行描述。直方图所在的高维超空间为特征表示提供了一个可度量的信息空间，对点云对应曲面的 6 维姿态来说它具有不变性，并且在不同的采样密度或邻域的噪音等级下具有鲁棒性。简言之，它考虑估计法线方向之间所有的相互作用，来尽可能捕获采样表面的变化。故合成的超空间依赖于每个点表面法线估计的质量。（人话就是：PFH 结果的优劣，取决于法线估计的好坏，这也说明，计算 PFH 的第一步就是表面法线的估计） 为计算两点 $p_i$ 和 $p_j$ 之间的相对差以及它们的法线 $n_i$ 和 $n_j$，在其中一点上定义了一个固定的局部坐标系。为使坐标系被唯一定义，做如下规定： 令 $p_{ji} = p_j - p_i, \\ p_{ij} = p_i - p_j$ ，$$if \\quad \\arccos(\\overline n_i \\cdot \\overline p_{ji}) \\le \\arccos(\\overline n_j \\cdot \\overline p_{ij})\\ then \\begin{cases} p_s = p_i,\\ n_s =n_i \\ p_t = p_j, \\ n_t = n_j \\end{cases}\\ else \\begin{cases} p_s = p_j,\\ n_s =n_j \\ p_t = p_i, \\ n_t = n_i \\end{cases}$$定义 $p_s$ 为源点，$p_t$ 为目标点，源点的选择使其法线与连接两点的直线之间的夹角最小。然后，可以在 $p_s$ 处将局部坐标系的原点定义为：$$\\begin{cases} u = n_s \\ v= u \\times \\frac{(p_t - p_s)}{||p_t - p_s||_2} \\ w = u \\times v\\end{cases}$$在该 uvw 坐标系下，两个法线 $n_s$ 和 $n_t$ 之间的差可以表示为一组角度特征，如下:$$\\begin{cases} \\alpha = v \\cdot n_t \\ \\phi = u \\cdot \\frac{(p_t-p_s)}{d} \\ \\theta = \\arctan(w \\cdot n_t,u \\cdot n_t)\\end{cases}$$式中，d 为欧氏距离，$d= ||p_t-p_s||_2$ 。 这样，就只需计算近邻点集 $P^{k_2}$ 中每一对点的特征组成的四个参数 $&lt;\\alpha,\\phi,\\theta,d&gt;$ （将其称为四元组），将原来的12（一个点有 $x,y,z,n_x,n_y,n_z$ (坐标及法线)）个参数减少到了4个。(在一般的实际问题中，d 往往不计在内，实验证明，不计在内效果更好) 下图是计算查询点 $p_q$ 的 PFH 时的影响区域图，查询半径（图中虚线，2D 中圆，3D中球）为 $r$ ，可见其 k 近邻点用网格完全互连。 为创建查询点 $p_i$ 的 PFH 表示，先将所有的四元组放进直方图，这个过程将每个特征的取值范围划分为 b 个子区域，并统计每个子区间中的特征出现次数。 代码123456789101112131415161718192021//为每一对点估计 PFH 四元组computePairFeatures (const pcl::PointCloud&lt;PointInT&gt; &amp; cloud, const pcl::PointCloud&lt; PointNT &gt; &amp; normals,int p_idx,int q_idx,float &amp; f1,float &amp; f2,float &amp; f3,float &amp; f4 ) Compute the 4-tuple representation containing the three angles and one distance between two points represented by Cartesian coordinates and normals.// Parameters 参照上图的坐标系理解[in] cloud the dataset containing the XYZ Cartesian coordinates of the two points //输入点云[in] normals the dataset containing the surface normals (assuming normalized vectors) at each point in cloud //法线[in] p_idx the index of the first point (source) // 源点[in] q_idx the index of the second point (target) // 目标点[out] f1 the first angular feature (angle between the projection of nq_idx and u) // θ[out] f2 the second angular feature (angle between nq_idx and v) // α[out] f3 the third angular feature (angle between np_idx and |p_idx - q_idx|) // Φ[out] f4 the distance feature (p_idx - q_idx) // d 距离 123456789101112131415161718192021222324252627282930// PFH 特征估计// Create the PFH estimation class, and pass the input dataset+normals to itpcl::PFHEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PFHSignature125&gt; pfh; //125是3个角特征量，每个又分为5个区间，故5^3// 这里的 125 是默认值，也就是直接忽略了 d 的pfh.setInputCloud (cloud);pfh.setInputNormals (normals);// 若点云类型是 PointNormal, pfh.setInputNormals (cloud);// Create an empty kdtree representation, and pass it to the PFH estimation object.// Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());pfh.setSearchMethod (tree);// Output datasetspcl::PointCloud&lt;pcl::PFHSignature125&gt;::Ptr pfhs (new pcl::PointCloud&lt;pcl::PFHSignature125&gt; ());// Use all neighbors in a sphere of radius 5cm// IMPORTANT: the radius used here has to be larger than the radius used to estimate the surface normals!!!pfh.setRadiusSearch (0.05);// Compute the featurespfh.compute (*pfhs);// pfhs-&gt;size () should have the same size as the input cloud-&gt;size ()*，即每个点对应一个 PFH特征向量// 实质上，该函数只是执行了以下步骤：对点云 P 中的每个点 p（1）得到p点的最近邻元素（2）对于邻域内的每对点，计算其三个角度特征参数值（3）将所有结果统计到一个输出直方图中 快速点特征直方图（FPFH）PFH 在计算中的复杂度用大O表示法表示的话为 $O(n k^2)$ ，不利于实时应用，需优化，FPFH 将复杂度降低为 $O(nk)$ ，同时保留了前者的识别特性。 理论（详见博士论文P57和PCL书P217） 首先，对每个查询点 $p_q$ ，计算该点及其近邻点的元组 $&lt;\\alpha,\\phi,\\theta&gt;$ ，这一步称为简化点特征直方图（SPFH），图中红线表示； 接着，重新确定每个点（这个点已经是 $p_q$ 的近邻点）的 k 近邻点，使用近邻点的 SPFH 值作为权重计算查询点 $p_q$ 的最终直方图，即为 FPFH：$$FPFH(p_q) = SPFH(p_q) + \\frac{1}{k} \\sum_{i=1}^{k} \\frac{1}{\\omega_k} \\cdot SPFH(p_k)$$式中，权重 $\\omega_k$ 表示在给定的度量空间中，查询点 $p_q$ 与近邻点 $p_k$ 之间的距离，用于评价点对 $(p_q,p_k)$ ，其影响区域图如下士，每个查询点(红色)只与它的k近邻点(由灰色圈包围)相连。每个直接近邻点又与自己的近邻点相连，所得到的直方图与查询点的直方图进行加权，形成FPFH。用粗线画出的是对 FPFH 计算了两次。 人话翻译：确定一个查询点，接着找出该查询点的近邻点，计算其参数元组（三个角度参数），（这个过程为 SPFH）然后对找到的所有近邻点，重新作为查询点，找到其近邻点，计算其 SPFH，然后使用上式进行加权，得到 FPFH。 关于 FPH 和 FPFH 的区别，这里略。 代码与 FPH 不同的是，FPFHEstimation 类的默认特征是将四个角特征量每个分为11个区间，分别计算后合并，形成有 33 个元素的特征向量。 点云配准 各个视角得到的点集合并到一个统一的坐标系下，形成完整的点云数据的过程 / 操作 实质：不同坐标系中测到点云之间的坐标变换 （寻找 R T 的过程）(==错==) 实质是：同一坐标系下不同视角的点云之间的配准，即测量设备始终是同一个，得到的点云在同一个坐标下 点云配准的过程是一个寻找刚性变换矩阵的过程，对于两个点云，一个为源点云 $P_s$ ，另一个为目标点云 $P_t$ ，将源点云通过一定的旋转（R）和平移（t）与目标点云配准（就是让它们完全重合），这个过程可表述为：$$P_t = P_s \\cdot R + t$$ 一对点云的配准（两两配准） 应用一个估计得到一个变换矩阵（R T）使两者完美配准 步骤： 从两个点云提取关键点，注意使用相同的标准 对所有关键点建立其特征描述子 估计对应关系，结合特征描述子在两个数据集中的坐标位置等进行 如含噪声，则去除对配准有影响的对应点 用剩下的正确点对估计刚体变换，完成配准 对应估计 找到相似特征，确定数据重叠部分，进行配准 使用不同方法来搜索特征之间的对应关系 点匹配（即只使用xyz坐标作为特征值）：穷举配准、k-d tree 最近邻查询、有序点云的图像空间查找、无序点云的索引空间查找 特征匹配（如法向量、形状直方图等）：穷举配准、k-d tree 最近邻查询 分类 直接对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点，确认为最终的对应点对（这是默认的估计方式） 相互对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点；接着对对点云 B 中的每个点，都找到其在点云 A 中的对应点，然后取它们的交集作为最终的对应点对 错误对应关系的去除实际中存在着噪声等影响，会导致产生的对应关系不一定是正确的（就是虽然算法找到了对应点对，但其在实际中可能并不是对应的），这些会对最终变换矩阵的估算产生影响，须去除它们，可以提高配准精度和速度。 去除方法：随机采样一致性（RANSAC）等 一对多 的情况：只取距离最近的对应点 ICP算法理论无序点云最经典的配准算法——ICP 算法（ Iterative Closest Point ）：通过最小化重叠区域之间的欧氏距离误差度量，来寻找两数据集之间的最优变换。ICP 算法假定两数据集的每个点都有相应的匹配，并使用待匹配与模型之间最近的点做对应。但问题是，两个点云之间不可能是完全的一一对应关系，所以要建立稳定的对应关系显得尤为重要。 ICP 的核心是不断的去寻找源点云和目标点云中点对的最小距离，并不断缩小这个距离，对变换后的点云继续重复该过程，也就是迭代的过程；该过程用数学表达就是求出 R 和 t ,使误差函数取得最小值：$$E(R,t) = \\frac{1}{n} \\sum_{i=1}^{n} ||P_t^i -(R \\cdot P_s^i+t)||^2$$式中，n 是点对的个数，也就是说，这个目标函数是所有点对之间的欧氏距离的平方和。 ==ICP 选择点对原则：对于源点云中的每个点，其对应点是目标点云中的最近邻点（按欧氏距离计算）== 主要步骤：[1]解则晓, 徐尚. 三维点云数据拼接中ICP及其改进算法综述[J]. 中国海洋大学学报(自然科学版). 对原始点云数据采样 确定初始对应点集 去除错误对应点对 求解坐标变换 ICP的主要问题在于搜索近邻点，这个过程耗时严重，为加速该过程，一般将目标点云存储到 k-d tree 结构中。 简单ICP代码12345678910pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp; // 创建 ICP 对象icp.setInputSource(cloud_in); // 设置一个输入点云作为 源点云icp.setInputTarget(cloud_out); // 设置一个输入点云作为 目标点云pcl::PointCloud&lt;pcl::PointXYZ&gt; Final; // 存储最终的匹配结果icp.align(Final); // 执行匹配std::cout &lt;&lt; \"has converged:\" &lt;&lt; icp.hasConverged() &lt;&lt; \" score: \" &lt;&lt; // 匹配是否正确，返回值为 1 则为正确 icp.getFitnessScore() &lt;&lt; std::endl; // 理解为对 配准的评分 std::cout &lt;&lt; icp.getFinalTransformation() &lt;&lt; std::endl; // 获取转换矩阵 逐步匹配多幅点云按输入的顺序两两匹配，得到最终的效果，结果是最终转换到第一个点云的坐标系下 交互式ICP通过可视化界面实现用户敲空格键时，进行配准，需在内部设置 ICP 迭代次数 详见Interactive Iterative Closest Point — Point Cloud Library 0.0 documentation (pcl.readthedocs.io) 正态分布变换配准（NDT） 适用于大型点云数据集 配准过程不使用对应点的特征计算及匹配，速度快 NDT 算法中，在目标点云对应的体素网格数据结构的统计计算中不使用单个点，而是使用包含在每个体素单元格中的点的统计数据 使用体素化数据结构 + More-Thuente 搜索 NDT 核心： 将空间划分为网格（2D 中为正方形，3D 中为立方体） 基于网格内的点分布，计算每个网格的概率密度分布（PDF）。每个网格中的 PDF 可理解为每个网格内曲面上的点 $\\overline x$ 的生成过程；也就是说，假设 $\\overline x$ 的位置是由 D 维的正态随机过程生成的 理论（详见：Magnusson M. The three-dimensional normal-distributions transform: an efficient representation for registration, surface analysis, and loop detection[D]. Örebro universitet, 2009. 从P55开始 两种常见的点云配准方法ICP&amp;NDT_banzhuan133的博客-CSDN博客_ndt点云配准） 对于一个随机（多维）变量，若其满足正态分布，则其对应的 PDF 为：（对应于点云：将目标点云网格化，然后计算每个网格内的多维正态分布）$$p(\\vec{x}) = \\frac{1}{(2 \\pi)^{D/2} \\sqrt{\\Sigma}} exp(- \\frac{(\\vec{x} - \\vec{\\mu})^T \\Sigma^{-1} (\\vec{x}-\\vec{\\mu})}{2})$$式中，$\\vec{\\mu}$ 为均值向量，$\\Sigma$ 为协方差矩阵（对角元素为每个变量的方差，非对角元素为协方差），$D$ 为维数。 $\\vec{\\mu}$ 和 $\\Sigma$ 可单独计算：$$\\vec{\\mu} = \\frac{1}{m} \\sum_{k=1}^{m} \\vec{y_k} \\\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad\\Sigma = \\frac{1}{m-1} \\sum_{k=1}^{m} (\\vec{y_k}-\\vec{\\mu})(\\vec{y_k}-\\vec{\\mu})^T$$式中的 $\\vec{y}_{1, \\cdots ,m}$ 表示一个网格中所有的点。（也就是说，上式中的 $p(\\vec{x})$ 实质是计算每个网格的 PDF ） 使用正态分布表示离散点云的优势在于：正态分布是对点云的分段（分块表示，网格）平滑表示，具有连续的导数；每个 PDF 可看作是局部表面的一种近似，描述了该表面的位置、方向、平滑度。在 2D 或 3D 中 ，表面方向和平滑度可用协方差矩阵的特征向量和特征值表示。对于三维的正态分布，随着 $\\Sigma$ 的特征值变化，有着不同的形状（图中箭头表示特征向量，长短表示其特征值的大小） ![3D 正态分布下的不同形状](F:\\AFIGHT\\笔记\\PCL\\assets\\Differ shape of 3D PDF.png) NDT 配准NDT 的配准目标是找到一个源点云的姿态，使源点云中的点位于目标点云平面上的可能性最大。（△） 若源点云为 $\\chi = { \\vec{x_1}, \\cdots , \\vec{x_n} }$ ，其姿态变换（R，T）用一个向量 $\\vec{p}$ 表示；假设空间变换函数 $T(\\vec{p},\\vec{x})$ 表示使用姿态变换 $\\vec{p}$ 来移动点 $\\vec{x}$ ；另外给定源点云的 $PDF \\quad p(\\vec{x})$ ，则最优位姿 $\\vec{p}$ 应是使似然函数最大化：$$\\Psi = \\prod_{k=1}^{n} p(T(\\vec{p}, \\vec{x}k))$$其等价于最小化 $\\Psi$ 的负对数似然函数（连乘转对数的和）：$$-log\\Psi = - \\sum{k=1}^{n} log(p(T(\\vec{p},\\vec{x}_k)))$$式中的函数 $p$ 即为上述提到的 $PDF \\quad p(\\vec{x})$ 。此外，PDF 也不一定是一个正态分布（只要可以局部捕获表面点结构，且对异常值具有鲁棒性即可）（详见P59）。 这也再次说明了我们的第一句话（△）：目的就是找到这个最优的 $\\vec{p}$ ，以最大化似然函数（目标函数） 目标很明确，就是优化这个位姿参数，NDT 使用 牛顿迭代法进行优化（见后续）。 问题是，负对数似然函数在远离均值的点上呈无限增长的趋势（见P59 图6.5b或下图)，故若数据中存在噪声等异常值，会对其结果产生较大的影响，有人提出了正态分布与均匀分布结合（$\\overline p(\\vec{x})$）的方式：$$\\overline p(\\vec{x}) = c_1 exp(- \\frac{(\\vec{x} - \\vec{\\mu})^T \\Sigma^{-1}(\\vec{x} - \\vec{\\mu})}{2}) + c_2p_0$$式中，$p_0$ 为异常值的期望值。利用这个函数，离群值的影响是有限的。常数 $c_1$ 和 $c_2$ 可以通过要求在单元格所跨越的空间内 $\\overline p(\\vec{x})$ 的概率质量等于1来确定。 另一个问题是，这种结合的方式没有简单的一阶和二阶导数（其实就是 log 函数求导不方便）；观察负对数似然函数（下图右绿色示），可发现其与高斯函数相像（下图左绿色示），故可用高斯函数来近似上述 $\\overline p(\\vec{x})$ 。 $\\overline p(\\vec{x})$ 对应的 log 形式为（这里 $c_2p_0$ 只剩 $c_2$ ，个人理解为其是一个期望值，是常数，可用一个代替？）：$$-\\log (c_1 exp(- \\frac{(\\vec{x} - \\vec{\\mu})^T \\Sigma^{-1}(\\vec{x} - \\vec{\\mu})}{2}) + c_2)$$函数形式为$$\\overline p(x) = - \\log(c_1 exp(\\frac{-x^2}{2 \\sigma ^2}) + c_2)$$的函数可用形式如下的高斯函数近似：$$\\tilde{p}(x) = d_1 exp(\\frac{-d_2 x^2}{2 \\sigma^2}) + d_3$$当 $x=1，x=\\sigma，x = \\infty$ 时，$\\overline p(x)$ 应与 $\\tilde p(x)$ 相等，以此来拟合 $d_i$ ：$$d_3 = - \\log(c_2) \\d_1 = - \\log(c_1 + c_2) -d_3 \\d_2 = -2 \\log(\\frac{-\\log(c_1 e^{- \\frac{1}{2}} + c_2 -d_3)} {d_1})$$如此，源点云中的一点对 NDT 评分函数的影响可用高斯函数近似为：$$\\tilde p(\\vec{x}_k) = -d_1 exp(- \\frac{d_2}{2} (\\vec{x}_k - \\vec{\\mu}_k)^T \\Sigma_k^{-1} (\\vec{x}_k - \\vec{\\mu}_k))$$这里忽略了常数 $d_3$ ，因其只是对评分函数进行了一个偏移，但并不影响其形状或参数。 到此，目标函数变为：$$s(\\vec{p}) = - \\sum_{k=1}^{n} \\tilde{p}(T(\\vec{p},\\vec{x}_k))$$所以上述过程就是将源点云的 PDF $p(x)$ 用 $\\tilde{p}(x)$ 近似的过程，最后得到的近似表示如上 可以看出，似然函数需要求 $\\Sigma^{-1}$ ，但若网格内的点是完全共面或共线，则 $\\Sigma$ 是奇异的，无法求逆（详见P60）。 位姿参数 $\\vec{p}$ 可用牛顿迭代法求解，其方程为：$$H \\Delta \\vec{p} = - \\vec{g}$$式中，$H$ 为海森矩阵，$\\vec{g}$ 为 $s(\\vec{p})$ 的梯度向量，$\\Delta \\vec{p}$ 在每次迭代过程中加到当前的位姿估计中，即 $\\vec{p} \\leftarrow \\vec{p} + \\Delta \\vec{p}$ 。 （具体求解详见P61) 代码12345678910111213141516171819202122// 一般在 NDT 配准前需要进行滤波处理，这里使用体素中心网格法pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);pcl::ApproximateVoxelGrid&lt;pcl::PointXYZ&gt; approximate_voxel_filter;approximate_voxel_filter.setLeafSize(0.2, 0.2, 0.2);approximate_voxel_filter.setInputCloud(input_cloud);approximate_voxel_filter.filter(*filtered_cloud);// NDT 参数初始化pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt; ndt.setTransformationEpsilon(0.01);//设置变换的ε：两个连续的变换(迭代)之间允许的最大差值，用于判断优化过程是否达到最终的阈值ndt.setStepSize(0.1); //牛顿法优化的最大步长（收敛速率系数，理解为什么时候终止？？）ndt.setResolution(1.0); //分辨率设置，也就是体素化网格的边长ndt.setMaximumIterations(35); //迭代的次数：达到该次数时停止ndt.setInputSource(filtered_cloud);ndt.setInputTarget(target_cloud);// 初始化变换参数并执行优化Eigen::AngleAxisf init_rotation(0.6931, Eigen::Vector3f::UnitZ()); //初始位姿 REigen::Translation3f init_translation (1.79387, 0.720047, 0); // TEigen::Matrix4f init_guess = (init_translation * init_rotation).matrix(); //初始搜索位置pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);ndt.align(*output_cloud, init_guess); //执行配准 点云分割 根据空间、几何、纹理等特征对点云进行划分，使得同一划分内的点云具有相似的特征 聚类分割算法 详见下一章——论文：聚类与分割 m 个数据，m 维空间内，定义点与点之间的某种性质的亲属聚类；若 m 个数据点构成 n 类，将具有最小距离的两类合为一类，然乎重新计算两类的之间的距离，如此迭代，直至两类之间的距离大于指定的阈值，或者类的个数少于指定的数目，完成分割。 RANSAC 随机采样一致性 从样本中随机抽取一个样本子集，使用最小方差估计法对自己进行模型参数的计算，再计算所有样本与该模型的偏差，将该偏差与设置好的阈值进行比较，若其小于设定的阈值，则为内点，否则为外点 根据一组包含噪声、外点等缺陷的样本数据集，估计出数据的数学模型，同时得到有效的样本数据 参数 $\\tau$ ：误差容忍度，判断样本是否满足模型 M 的误差容忍度 $Max$ ：随机抽取样本集的次数（即抽取子集的次数） $N$ ：指定的阈值 12345pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;::Ptr model_p(new pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;(cloud)); //定义为平面模型（还有其他模型）pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; ransac(model_p); ransac.setDistanceThreshold(.01); //阈值设置ransac.computeModel(); //计算模型ransac.getInliers(inliers); //获取内点 123456789101112Algorithm : RANSAC1) Initial: let A be a set of N feature correspondences2) repeat2.1) Randomly select a sample of s points from A2.2) Fit a model to these points2.3) Compute the distance of all other points to this model2.4) Construct the inlier set (i.e. count the number of points whose distance from the model &lt; d)2.5) Store these inliers2.6) until maximum number of iterations reached3) The set with the maximum number of inliers is chosen asa solution to the problem4) Estimate the model using all the inliers 平面点云分割123456789pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients); //模型系数对象pcl::PointIndices::Ptr inliers(new pcl::PointIndices); //内点对象pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg; // Create the segmentation object，点云分割对象seg.setOptimizeCoefficients(true); // Optional，可选项，设置是否优化系数seg.setModelType(pcl::SACMODEL_PLANE); // Mandatory，必选项，设置分割类型seg.setMethodType(pcl::SAC_RANSAC); // Mandatory，设置分割方法seg.setDistanceThreshold(0.01); // Mandatory，设置距离阈值seg.setInputCloud(cloud);seg.segment(*inliers, *coefficients); //执行分割 圆柱体模型分割12345678910seg.setOptimizeCoefficients(true);seg.setModelType(pcl::SACMODEL_CYLINDER);seg.setMethodType(pcl::SAC_RANSAC);seg.setNormalDistanceWeight(0.1);seg.setMaxIterations(10000);seg.setDistanceThreshold(0.05);seg.setRadiusLimits(0, 0.1);seg.setInputCloud(cloud_filtered2);seg.setInputNormals(cloud_normals2);seg.segment(*inliers_cylinder, *coefficients_cylinder); 欧式聚类提取12345678std::vector&lt;pcl::PointIndices&gt; cluster_indices;pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;ec.setClusterTolerance(0.02); // 2cmec.setMinClusterSize(100);ec.setMaxClusterSize(25000);ec.setSearchMethod(tree); //kd-treeec.setInputCloud(cloud_filtered);ec.extract(cluster_indices); 区域生长分割 从曲率最小的点开始生长（初始种子点） 输出是一个聚类集合，每个聚类集合属于同一光滑表面的一部分 基本思想： 根据输入点的曲率值对点排序，曲率最小的点为初始种子点，该点所在的区域为最平滑区域，也就是从最平滑区域开始生长，减少分割区域的总数，提高效率。 核心：比较近邻点与种子点之间的两个指标 法线夹角的比较：小于设定的阈值进入区域，即为同一类（满足此条件时进入下一步的判断） 曲率大小的比较：小于设定的阈值进入序列（这是为何进行排序的原因，形成一个种子序列，每完成一次比较，删除当前的种子点，使用序列中的下一个种子点继续进行比较，如此迭代） 还需设定一个最小点簇数和最大点簇数 种子序列为空时意味着算法完成了区域增长，从头开始进行重复上述过程 123456789101112pcl::RegionGrowing&lt;pcl::PointXYZ, pcl::Normal&gt; reg;reg.setMinClusterSize(50);reg.setMaxClusterSize(1000000);reg.setSearchMethod(tree);reg.setNumberOfNeighbours(30);reg.setInputCloud(cloud);//reg.setIndices (indices);reg.setInputNormals(normals);reg.setSmoothnessThreshold(3.0 / 180.0 * M_PI); // 平滑阈值reg.setCurvatureThreshold(1.0); //曲率阈值std::vector &lt;pcl::PointIndices&gt; clusters;reg.extract(clusters); //执行分割 超体素点云分割（VCCS） 空间八叉树结构 + k-mean 聚类的区域增长 直接对点云进行超体素分割 超体素特征： 在3D空间中，均匀分布（可通过在点云空间中均匀设定种子达到） 除非在体素空间上相连，否则超体素不能跨越边界 在空间分辨率为 $R_{seed}$ 的三维空间网格中，对均匀分布在空间中的种子点进行增长形成超体素。这里为提高搜索效率，只考虑以种子为中心的半径为 $R_{seed}$ 区域内的点。 论文：聚类与分割 聚类（clustering）将数据集中的样本划分为不相交的子集，每个子集成为一个“簇（cluster）” 聚类过程形成簇结构 簇标记（cluster label） 拟合简化的集合模型（平面模型） 不共线的三点确定一个平面，故先从点云 $\\mathcal{P}$ 中随机选取不共线的三点 ${p_i,p_j,p_k}$ 根据选定的三个点计算平面模型系数（$ax+by+cz+d=0$）（可根据克莱姆法则计算，详见 Plane (geometry) - Wikipedia） 计算点云 $\\mathcal{P}$ 中所有点 $p$ 到该平面模型的距离（$p_n \\quad (a,b,c,d)$） 保存距离在指定阈值内的点 $p^* \\in \\mathcal{P}$，并计算其个数 上述的最后一步表示对模型的评分；每个点集 $p^$ 都会被保存，且上述步骤会重复（迭代） $k$ 次。算法终止后，点的数量最多的点集（内点），就是对平面模型描述最好的点集（能最好的拟合平面模型）。对所有的点 $p^ \\in \\mathcal{P}$ ，平面模型系数用最小二乘估计。 上述过程就是找到内点集 $p^*$，拟合出平面或者估计出其2D边界多边形的简化过程，在实际应用中，还需增加额外的约束条件。 基本聚类技术 依赖于空间分解技术，基于给定的标准，寻找分块及边界，实现分类 评判标准：闵氏范数：曼哈顿距离（L1）、欧式距离（L2） 欧式聚类数据结构：八叉树（3D网格） 优点：易于快速构建，适用于不同情况，如需要占用空间的体积表示、用不同结构估计叶节点中的数据等 缺点：3D网格只适用于空间等分的情况 对于聚类分块大小不一的情况，需要更复杂的算法（下述）。 实例： 点聚类 $O_i = {p_i \\in \\mathcal{P}}$ 与点聚类 $O_j = {p_j \\in \\mathcal{P}}$ 不同的条件是： $$min||p_i-p_j||2 \\ge d{th}$$ 式中，$d_{th}$ 是指定的阈值。 即：点集 $p_i \\in \\mathcal{P}$ 与点集 $p_j \\in \\mathcal{P}$ 之间的最小距离大于指定的阈值，则前者中的点属于聚类 $O_i$，后者属于聚类 $O_j$ 。 一个问题是，这个最小距离该如何估计？ 最小距离的估计：使用 kd-tree 进行最近邻查询 算法伪代码： 输入点云 $\\mathcal{P}$ ，创建 kd-tree 表示 设置簇 $C$ 的空列表，以及点集序列 $Q$ 对输入点云的每一个点 $p_i \\in \\mathcal{P}$ ，执行以下步骤 将 $p_i$ 添加到当前序列 $Q$ 对添加到序列中的每个点 $p_i \\in Q$： 以3D空间中半径为 $r&lt;d_{th}$ 的球体搜索 $p_i$ 的近邻点（近邻点搜索半径 r），结果形成点集 $P_i^k$ （setRadiusSearch） 对每个近邻点 $p_i^k \\in P_i^k$，若未被分类则将其添加到序列 $Q$ 序列 $Q$ 中的所有点处理完后，将 $Q$ 添加到簇 $C$ 的序列（内点）并重置为空序列 算法终止条件：点云中的所有点均被遍历，且已成为簇 $C$ 的列表的一部分 聚类算法(cpp) 1234567891011//被分割出来的点云团（标号队列）std::vector&lt;pcl::PointIndices&gt; cluster_indices;//欧式分割器pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;ec.setClusterTolerance(0.02); // 2cmec.setMinClusterSize(100);ec.setMaxClusterSize(25000);//搜索策略树ec.setSearchMethod(tree);ec.setInputCloud(cloud_filtered);ec.extract(cluster_indices); 边缘查询 表面曲率可用于点云分割：是对点附近采样点的几何近似估计，它们对确定那些具有极高曲率值的点很有用，这些点代表点云数据集 $\\mathcal{P}$ 的几何边缘 2D 图像中边缘可用梯度定义，3D 中则是场景中几何形状变化剧烈的位置","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"}]},{"title":"毕设：链片条复合模CAD系统使用须知","slug":"链片条复合模CAD系统使用须知","date":"2020-05-25T16:53:26.616Z","updated":"2022-07-29T13:03:24.513Z","comments":true,"path":"2020/05/26/Graduate_2/","link":"","permalink":"https://hbroad.github.io/2020/05/26/Graduate_2/","excerpt":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！","text":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！ 已知错误1：数据库引擎本系统采用 ACCESS 作为数据库，经测试（虚拟机测试），win7 等系统上会出现 “未在本地计算机上注册‘Microsoft. ACE. OLEDB. 12. 0’提供程序”类似的提示。 运行错误提示 解决1：安装数据库引擎即可，点击下方“下载”，下载完成后安装，提示安装成功后尝试再次运行本系统。 下载","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"毕设：链片条复合模CAD系统","slug":"链片条复合模CAD系统使用说明","date":"2020-05-25T13:47:41.893Z","updated":"2022-08-15T03:59:01.960Z","comments":true,"path":"2020/05/25/Graduate_/","link":"","permalink":"https://hbroad.github.io/2020/05/25/Graduate_/","excerpt":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖","text":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖 开发平台系统环境：Windows 10 2004 专业版开发环境：VB.NET数据库：ACCESSS 365软件平台：VS 2010 系统简介该复合模 CAD 系统主要包含以下功能： 用户登录 参数输入 设计计算 主界面 设计结果 标准件库 建模装配 关于系统 用户登录首先，用户在打开系统后，会出现登录界面，该界面四个按钮的功能如下：1.登录：如若账号密码均正确，通过此按钮即可进入下一界面；2.取消：如用户输入时出错，想直接清空输入框，可使用此按钮；3.注册：新用户可通过注册后再登录；4.退出：退出系统。 系统登陆界面 参数输入用户登录后将进入该界面，在该界面由用户输入需要的尺寸值，也可使用默认值，点击开始设计，并选择模具的最小闭合高度，在确定之后即可开始设计计算。 参数输入界面 闭合高度选择 主界面系统主界面下可进行设计结果的查询、标准件的尺寸查询、三维建模与装配（调用同组同学 GRIP 程序）、查看仿真动画、系统信息及帮助文档 此外，在查询结果菜单下，用户可通过点击零件图纸查看零件的三维模型。 系统主界面 系统主界面菜单 结果查询界面 零件信息界面 点击零件图纸查看零件的三维模型 剩余界面较为简单，这里不再赘述！ （密码：姓名拼音的首字母大写） 系统演示视频","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"全国性哀悼活动","slug":"悼念日","date":"2020-04-04T10:49:31.000Z","updated":"2022-07-29T13:02:42.816Z","comments":true,"path":"2020/04/04/ChinaIsTheBest/","link":"","permalink":"https://hbroad.github.io/2020/04/04/ChinaIsTheBest/","excerpt":"据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。","text":"据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。","categories":[{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/categories/Commemorate/"}],"tags":[{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"}]},{"title":"开天辟地","slug":"hello-world","date":"2020-04-02T09:03:42.485Z","updated":"2022-07-29T13:03:48.864Z","comments":true,"path":"2020/04/02/hexo_new/","link":"","permalink":"https://hbroad.github.io/2020/04/02/hexo_new/","excerpt":"这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！","text":"这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://hbroad.github.io/tags/git/"}]}],"categories":[{"name":"cpp","slug":"cpp","permalink":"https://hbroad.github.io/categories/cpp/"},{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"},{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/categories/Commemorate/"},{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/categories/hexo/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"},{"name":"华为机考","slug":"华为机考","permalink":"https://hbroad.github.io/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/"},{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"},{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"},{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"},{"name":"hexo","slug":"hexo","permalink":"https://hbroad.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://hbroad.github.io/tags/git/"}]}