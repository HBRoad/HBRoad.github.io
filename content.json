{"meta":{"title":"南阳向北","subtitle":"业精于勤荒于嬉，行成于思毁于随","description":"","author":"MQRoad","url":"https://hbroad.github.io","root":"/"},"pages":[{"title":"","date":"2023-04-07T11:42:45.586Z","updated":"2023-04-07T11:42:45.586Z","comments":true,"path":"thx/index.html","permalink":"https://hbroad.github.io/thx/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-07T02:23:10.435Z","updated":"2023-04-07T02:23:10.435Z","comments":true,"path":"categories/index.html","permalink":"https://hbroad.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-04-07T08:46:05.000Z","updated":"2023-04-07T08:47:06.406Z","comments":false,"path":"about/index.html","permalink":"https://hbroad.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-07T02:22:42.000Z","updated":"2023-04-07T02:49:31.441Z","comments":true,"path":"link/index.html","permalink":"https://hbroad.github.io/link/index.html","excerpt":"","text":""},{"title":"essay","date":"2023-04-07T14:06:41.000Z","updated":"2023-04-07T14:07:37.495Z","comments":true,"path":"essay/index.html","permalink":"https://hbroad.github.io/essay/index.html","excerpt":"","text":""},{"title":"大佬们","date":"2020-04-20T08:38:53.572Z","updated":"2020-04-04T11:21:13.453Z","comments":true,"path":"friends/index.html","permalink":"https://hbroad.github.io/friends/index.html","excerpt":"虽然我很菜，但好在这里有大佬","text":"虽然我很菜，但好在这里有大佬 友链规范1234567name: # 博客名avatar: # 头像链接url: # 博客链接backgroundColor: &#x27;#3E74C9&#x27; # 卡片背景颜色textColor: &#x27;#fff&#x27; # 卡片文字颜色tags: [标签1, 标签2] # 标签desc: 描述文字"},{"title":"所有标签","date":"2023-04-07T13:39:16.202Z","updated":"2023-04-07T13:39:16.202Z","comments":true,"path":"tags/index.html","permalink":"https://hbroad.github.io/tags/index.html","excerpt":"","text":""},{"title":"建站小记","date":"2023-04-09T12:25:01.000Z","updated":"2023-04-17T12:11:03.890Z","comments":true,"path":"timeline/index.html","permalink":"https://hbroad.github.io/timeline/index.html","excerpt":"","text":"2023 04-06 神奇之旅继续，更换主题为AnZhiYu，开启新纪元 2022 08-02 神奇之旅继续，部署到 Gitee，便于国内访问 2020 04-04 神奇之旅开启，Hexo + Github Pages，使用了Volantis主题 2019 01-13 Deployed"}],"posts":[{"title":"SQL Server 从入门到放弃","slug":"SQL/SQL-Server-从入门到放弃","date":"2023-08-09T11:39:02.000Z","updated":"2023-08-19T09:11:55.011Z","comments":true,"path":"sqlserver_learning/","link":"","permalink":"https://hbroad.github.io/sqlserver_learning/","excerpt":"","text":"数据库基础数据库存储技术的发展 人工管理阶段 文件系统阶段 数据库系统阶段 数据库系统的组成 数据库 数据库管理系统（数据库管理员） 应用开发工具 应用系统（用户） 用户 数据库体系结构 内模式：存储模式，只能有一个 模式：逻辑模式/概念模式，只能有一个 外模式：用户模式，可多个 数据模型 概念 数据结构 数据操作 完整性约束 常见数据模型 层次模型 网状模型 关系模型 关系模型 关系：一个二维表就是一个关系 属性：二维表中的一列，类型和值表示 元祖：二维表中的一行 域：每个属性的取值范围，如性别属性的域为 {男，女} 范式理论 第一范式：在一个关系中，消除重复字段，且每一个字段都是最小的存储单元（原子性） 如下关系中，班级字段并不是最小的存储单元，应将其拆分成年级和班级 学号 姓名 班级 年级 001 李孟 三年级1班 三年级 第二范式：在满足第一范式的基础上，关系中每一个非主关键字段都完全依赖于主关键字段，不能只部分依赖于主关键字段的一部分 如下关系中：学生证号、学生证办理时间完全依赖于学生证，但后续借书证则不然；为此，可将其拆分为学生证和借书证两个关系 学生证 学生证号 学生证办理时间 借书证 借书证号 借书证办理时间 第三范式：若关系属于第一范式，且关系中所有非主关键字段都完全依赖于主关键字段，第三范式要求去除传递依赖（即非主键字段之间不能存在依赖） 第四、五范式：不常用 更多可参考关于范式的通俗解释 关系数据库的设计原则 数据库内数据文件的数据组织应获得最大限度的共享、最小的冗余度，消除数据及数据依赖关系中的冗余部分，使依赖于同一个数据模型的数据达到有效的分离 保证输入、修改数据时数据的一致性与正确性 保证数据与使用数据的应用程序之间的高度独立性 实体与关系 一对一 一对多 多对多 创建和管理数据库数据库对象表、字段、索引、视图、存储过程 数据库组成由文件和文件组组成，数据库中的所有数据和对象都被存储在文件中 文件 主要数据文件（.mdf）：存放数据和数据库的初始化信息，每个数据库有且只有一个 次要数据文件（.ndf）：存放除主要数据文件以外的所有数据文件，可能没有，也可能有多个 事务日志文件（.ldf）：存放用于恢复数据库的所有日志信息，至少有一个，也可有多个 文件组 SQL Server 数据文件的一种逻辑管理单位，将数据库文件分成不同的文件组，便于文件的分配和管理 主文件组：包含主要数据文件和任何没有明确指派给其他文件组的文件，系统表的所有页都分配在主文件组中（一般为默认文件组） 用于自定义文件组：主要是在 create database 和 alter database 语句中，使用 filegroup 关键字指定的文件组 系统数据库SQL Server 默认安装 4 个系统数据库 master 数据库：记录 SQL Server 实例的所有系统级信息，如实例范围的元数据、端点等 tempdb 数据库：临时数据库，用于保存临时对象或中间结果集 model 数据库：SQL Server 实例上创建的所有数据库的模板，对其的修改会应用到以后创建的所有数据库 msdb 数据库：用于 SQL Server 代理计划警报和作业 SQL Server 命名规范标识符 标识符格式 首字母：a~z、A~Z、_ 、@、# 后续字母：a~z、A~Z、0~9、_ 、@、#、$ 特殊意义：@：局部变量或参数；#：临时表或过程；##：全局临时对象（不建议使用） 标识符分类 常规标识符：符合标识符格式规则 分隔标识符：包含在 “” 或 [] 之间的标识符，可不符合标识符规则，如[SQL Server]，虽有空格，但使用了 []，视为分隔标识符 对象命名规则创建数据库对象后，数据库完整名称由服务器名、数据库名、拥有者名、对象名组成： 1[[[server.][database].][owner_name].]object_name 前 3 者为对象名称限定符，不需要时可直接用英文句号以省略，如 123server.database.owner_name.object_nameserver...object_nameobject_name 实例命名规则 默认实例：由计算机网络名称标识（一台计算机每次只能有一个版本作为默认实例运行） 命名实例：可同时运行任意个命名实例，通过计算机的网络名称加上实例名称以 &lt;计算机名称&gt;\\&lt;实例名称&gt; 格式进行标识，即 computer name\\instance name，但该实例名不能超过l6个字符 数据库操作 以SSMS UI 创建、修改、删除 命令创建、修改、删除 1234567891011-- 创建数据库create database db_name -- 修改alter database db_name&#123;add file|add log file|remove file…&#125;-- 删除drop database db_name 操作数据表数据表基础基本数据类型 整数：BIT、INT、SMALLINT、TINYINT；存储整数或小数 货币：MONEY、SMALLMONEY；存储货币值，使用时前加货币符号，默认“￥” 浮点：REAL、FLOAT、DECIMAL、NUMERIC；存储十进制小数 日期/时间：DATETIME、SMALLDATETIME、DATE、DATETIME(2)、DATETIMESTAMPOFFSET；存储日期和时间类型的组合数据 字符：char、nchar(n)、varchar(n)、nvarchar(n)；用于存储各种字母、数字符号、特殊符号 二进制：binary、varbinary；存储二进制数据 图像和文本数据类型：text、ntext(n)、image；存储大量字符及二进制数据 用户自定义数据类型通过 sp_addtype 增加数据类型 1exec sp_addtype type_name &#x27;char(8)&#x27;, &#x27;not null&#x27; type_name 为自定义数据类型名称，’char(8)’ 为该类型所依据的系统类型，’not null’ 指定其非空 数据表的数据完整性 数据完整性是指列中每个事件都有正确的数据值。数据值的数据类型必须正确，并且数据值必须位于正确的域中。 引用完整性指表之间的关系得到正确维护。一个表中的数据只应指向另一个表中的现有行，不应指向不存在的行。 数据表操作 创建 1234create table table_name( 列名1 数据类型, 列名2 数据类型,) 修改 1234567alter table tb_nameadd col_name col_name_type -- 实例alter table tb1add age int -- 向表中添加列drop column age -- 从表中删除列 删除 1drop table tb_name 更新 1234567insert into tb(id, name) values(1, &#x27;小李&#x27;)select * from tb where id = 1update tb set name = &#x27;小李&#x27; where id = 1delete [from] tb where id = 1 创建、修改、删除约束非空约束 创建非空约束 允许 null 值属性为否 修改、删除非空约束 123456alter table tb_namealter column column_name column_type null|not null-- 实例alter table tb1alter column id int not null 主键约束 创建表时创建主键约束 12345678910create table tb_name(id int constraint pk_id primary key,name varchar(20))-- 实例create table tb1(id int constraint pk_id primary key,name varchar(20)) 现有表中创建主键约束 123456alter table table_nameadd constraint constraint_name primary key (ID)-- 实例alter table tb2add constraint pk_id2 primary key (id) 修改主键约束 必须先删除现有的主键约束，再创建新的 删除主键约束 12alter table tb2drop constraint pk_id2 -- 先删除 唯一约束 创建表时创建唯一约束 1234create table tb3(id int constraint uq_id unique,name varchar(20)) 现有表中创建唯一约束 12alter table tb3add constraint un_name unique(name) 修改唯一约束 修改前必须删除 删除唯一约束 12alter table tb3drop constraint un_name 检查约束 创建表时创建检查约束 123456create table tb4(id int,name varchar(20),sex char(2) constraint ck_sex check(sex in (&#x27;male&#x27;, &#x27;female&#x27;)),age int) 现有表中创建检查约束 12alter table tb4add constraint ck_sex check(sex = &#x27;female&#x27;) 修改检查约束 修改前需先删除 删除检查约束 12alter table tb4drop constraint ck_sex 默认约束 创建默认约束 123456create table tb3(id int,name varchar(50),sex bit constraint defa_cs default &#x27;0&#x27;) 现有表中创建默认约束 12alter table tb3add constraint def_sex default &#x27;1&#x27; for sex 修改、删除默认约束 12alter table tb3drop constraint defa_cs 外键约束 创建表时创建外键约束 123456create table lab(id int,wage money,constraint Fkey_id Foreign key(id) references tb1(id)) 此时表 tb1 必须设置主键，且主键为 id。 现有表中创建外键约束 1234alter table labadd constraint Fkey_id foreign key(id) references tb1(id) 修改、删除外键约束 12alter table labdrop constraint Fkey_id 关系创建与维护表与表之间的关联 一对一 一对多 多对多：通过第三个中间表建立关系 Transact-SQL 语法组成 数据定义语言：create、alter、drop 数据检索语言：select 数据操纵语言：insert、delete、update 数据控制语言：grant、revoke 语句结构1234567SELECT 子句[INTO 子句]FROM 子句[WHERE 子句][GROUP BY 子句][HAVING 子句][ORDER BY 子句] 常量 字符串常量：单引号内，由 a~z，A~Z，0~9，！、@、# 组成，如 ‘Hello’ 二进制常量：0x，十六进制，无需引号，如 0xB0A1 bit 常量：0 或 1，无需引号 日期和时间常量：遵循日期格式，需单引号，如 ‘2023年8月14日’ 变量局部变量用户自定义，以 @ 开头 声明： 1234DECLARE&#123; @var_name datatype [,…,n]&#125; 赋值： 1234567-- select 语句赋值SELECT @var_name = expression[FROM table_name [,…,n]WHERE clause ]-- set 语句赋值SET @var_name = expression 12345678DECLARE @coursename varchar(50)SELECT @coursename = nameFROM tb1WHERE name = &#x27;SQL 从入门到放弃&#x27;print @coursenameDECLARE @name char(20)SET @name = &#x27;LiHua&#x27; 全局变量 SQL Server 已定义好的变量 以 @@ 开头 常用全局变量： @@CONNECTIONS：记录最后一次服务器启动以来，所有针对这台服务器进行的连接数目，包含未连接成功的尝试 @@CUP_BUSY：记录自上次启动以来尝试的连接数，无论链接成功与否，都以 ms 为单位的 CPU 工作时间 @@CURSOR_ROWS：返回本次服务链接中，打开游标取出数据行的数目 @@DBTS：返回当前数据库中 timestamp 数据类型的当前值 @@ERROR：返回执行上一条 T-SQL 语句所返回的错误代码 执行成功将返回 @@ ERROR 的值为 0，每一条语句执行后其被清除且重置，故应在语句验证后立即检查，或将其保存在一个局部变量中。 注释符、运算符、通配符注释符— 或 /**/ 运算符常量、变量、列之间的数学运算和比较操作 算术运算符：+ - * / %（% 两边的数必须是整型） 赋值运算符：= 比较运算符：&gt;、&lt; 、= 、&gt;= 、&lt;=、!=、!&gt;、!&lt; 逻辑运算符：ALL、AND、ANY、BETWEEN、EXISTS、IN、LIKE、NOT、OR、SOME 位运算符：&amp; | ^ ~ 字串连接：+ 运算符优先级 通配符通常用 LIKE 关键字与通配符搭配实现模式查询 通配符 描述 示例 % 包含零个或更多字符的任意字符 ‘loving%’ 即为前缀为loving，后缀任意 _ 任意单个字符 ‘loving_’ 表示 ‘lovinga’ 等，即只能接一个字符 [] 指定范围 [a~f] 或集合 [abcdef] 中的任何单个字符 ‘[0~9]123’ 表示以 0~9 任意字符开头，以 123 结尾的字符 不属于指定范围 [a~f] 或集合 [abcdef] 中的任何单个字符 ‘[\\^0~5]123’ 表示不以 0~5 之间任意一个字符开头，却以 123 结尾的字符 流程控制BEGIN…AND用于将多个 T-SQL 语句组合为一个逻辑块（两条及以上的语句）： 123BEGIN&#123;sql_statement&#125;END 1234567891011DECLARE @x int, @y int, @t intSET @x = 1SET @y = 2BEGINSET @t = @xSET @x = @ySET @y = @tENDprint @xprint @y IF1234IF&lt;条件表达式&gt;&#123; 命令行 | 程序块&#125; 12345DECLARE @x intSET @x = 10IF @x % 2 = 0 PRINT &#x27;偶数&#x27;PRINT &#x27;END&#x27; IF…ELSE12345678IF&lt;条件表达式&gt;&#123; 命令行1 | 程序块1&#125;[ELSE&#123; 命令行2 | 程序块2&#125;] 1234567DECLARE @x int, @y intSET @x = 3SET @y = 2IF @x &gt; @y PRINT &#x27;OK&#x27;ELSE PRINT &#x27;NG&#x27; 也可嵌套 CASE 更方便实现多重选择， 减少 IF…ELSE 的嵌套 简单 CASE 函数 1234CASE input_express WHEN when_expression THEN result_expression […n] [ELSE else_result_expression]END CASE 搜索函数 1234CASE WHEN Booleam_exp THEN result_exp […n] [ELSE else_result_exp]END WHILE1234WHILE&lt;条件表达式&gt;BEGIN &lt;命令行 | 程序块&gt;END 123456789DECLARE @x int, @sum intSET @x = 1SET @sum = 0WHILE @x &lt;= 10BEGINSET @sum += @xSET @x += 1ENDPRINT @sum WHILE…CONTINUE…BREAK1234567WHILE&lt;条件表达式&gt;BEGIN &lt;命令行 | 程序块&gt; [BREAK] [CONTINUE] [命令行 | 程序块]END 123456789101112DECLARE @x int, @sum intSET @x = 1SET @sum = 0WHILE @x &lt; 10BEGIN SET @x += 1 IF @x % 2 = 0 SET @sum += @x ELSE CONTINUEENDPRINT @sum RETURN1RETURN &lt;整数值&gt; 常见的返回值及其含义如下：| 返回值 | 含义 || ——| —————||0|程序执行成功||-1|找不到对象||-2|数据类型错误||-3|死锁||-4|违反权限原则| GOTO1GOTO 标识符 WAITFOR1WAITFOR&#123;DELAY&lt;&#x27;时间&#x27;&gt; | TIME&lt;&#x27;时间&#x27;&gt;&#125; 12345WAITFOR DELAY &#x27;00:00:05&#x27; //等待 5s 后执行PRINT &#x27;5s lost!&#x27;WAITFOR TIME &#x27;13:34:59&#x27; //到了指定的时间点才执行PRINT &#x27;TIME IS UP!&#x27; 常用命令 命令 含义 DBCC 数据库一致性检查程序，用于验证数据库完整性、查找错误、分析系统使用情况等 CHECKPOINT 检查当前工作的数据库中被更改过的数据页或日志页，并将其从数据缓冲器中强制写入硬盘 DECLARE 声明一个或多个局部变量、游标变量或表变量 PRINT 向客户端返回一个用户自定义的信息，即显示一个字符串、局部变量或全局变量的内容 RAISEERROR 返回错误信息的同时返回用户指定的信息 READTEXT 读取text、ntext、image列中的值，从指定的位置开始读取指定的字符数 BACKUP 将数据库内容或其事物处理日志备份到存储介质（软硬盘、磁带等） RESTORE 将数据库或事务处理日志备份文件由存储介质还原到 SQL Server 系统 SELECT 可以用于局部变量的赋值 SET 可用于局部变量的赋值；可用于执行 SQL 命令时 SQL Server的处理选项设定 SHUTDOWN 立即停止 SQL Server 的执行 WRITETEXT 允许对 text、ntext、image 的列进行交互式更新，但不能用于视图中 USE 在当前工作区打开或关闭数据库 123456DBCC CHECKALLOC (&#x27;db2&#x27;) -- 指定数据库的磁盘结构CHECKPOINT [checkpoint_duration] -- 指定查询所用的时间，单位为sSHUTDOWN [WITH NOWAIT]WRITETEXT &#123;table.column text_ptr&#125; [WITH LOG] &#123;data&#125;USE &#123;数据库&#125; SQL 函数的使用聚合函数对一组值进行计算，并返回单一的值，通常聚合函数会与 SELECT 语句的 GROUP BY 子句一同使用，此时聚合函数会为每个组产生一个单一值，而不会为整个表产生一个单一值。 包括 SUM、AVG、MIN、MAX、COUNT 函数。 SUM：返回表达式中所有值的和或仅非重复值的和，只能用于数字列，空值将被忽略 1SUM([ALL | DISTINCT] expression) 12SELECT SUM(Score) as 总成绩 FROM Course WHERE ID = 1SELECT SUM(DISTINCT Score) as 总成绩 from Course where ID in (1, 2) AVG：返回组中各值的平均值，空值会被忽略 1AVG([ALL | DISTINCT] expression) 1SELECT AVG(Score) as 总平均成绩 from Course where ID in (1, 2) |表达式结果 | 返回类型 || —- | ——|| 整数分类 | int || decimal分类(p, s)decimal(38, s) | 除以 decimal(10, 0) || money 和 smallmoney 分类 | money || float 和 read 分类 | float | MIN：返回表达式最小值 1MIN&#123;[ALL | DISTINCT] expression&#125; 1SELECT MIN(Score) as 成绩最小值 from Course where ID in (1, 2) MAX：最大值 1MAX&#123;[ALL | DISTINCT] expression&#125; 1SELECT MAX(Score) as 成绩最大值 from Course where ID in (1, 2) COUNT：返回组中的项数，返回值为 int 类型 1COUNT(&#123;[[ALL | DISTINCT] expression] | *&#125;) 12SELECT COUNT(*) as 课程数 from Course where ID in (1, 2)SELECT COUNT(CourseName) AS 各科数目 FROM Course GROUP BY CourseName DISTINCT：删除指定集中的重复元祖，返回结果集 1DISTINCT(Set_Expression) 1SELECT DISTINCT(CourseName) as 课程 FROM Course HAVING子句：查询表中的重复记录；只能和 SELECT 子句一起使用，且通常在 GROUP BY 子句中 1HAVING &lt;search condition&gt; 12SELECT CourseName, COUNT(CourseName) as 重复课程数 FROM CourseGROUP BY CourseName HAVING COUNT(CourseName) &gt; 0 数学函数 可对整型、实型、浮点型、货币型和 smallmoney 的列进行操作 返回值为 6 位小数，出错时返回 NULL 值及提示信息 可用在 SQL 语句表达式中 函数名 说明 ABS 绝对值 COS 余弦值 COT 余切值 SIN 正弦值 TAN 正切值 PI 圆周率 POWER 幂次，计算结果必须为整数 ROUND 四舍五入 RAND 0~1 之间的随机 float 数 SIGN 0，正（+）、负（-） SQUARE 平方 SQRT 平方根 12345678SELECT ABS(-1), ABS(-5)SELECT PI()SELECT POWER(2, 3)SELECT RAND()SELECT ROUND(3.141599, 3)SELECT SQUARE(2)SELECT SQRT(9)SELECT SIN(PI()/6) -- 三角函数传值是弧度 字符串函数 作用于 char、varchar、binary、varbinary 数据类型以及可隐式转换为 char 或 varchar 的数据类型 可用在 SQL 语句表达式中 函数名称 说明 ASCII 返回字符表达式中最左端字符的 ASCII 代码值 CHARINDEX 返回字串中指定表达式的起始位置 LEFT 从左边开始，取得字串左边指定个数的字数 RIGHT 从右边开始，取得字串右边指定个数的字数 LEN 返回字串中字符的个数，包括空格 REPALCE 将指定的字串替换为另一指定的字串 REVERSE 字符表达式反转 STR 返回由数字数据转换来的字符数据 SUBSTRING 返回指定个数的字符 1234567891011121314151617SELECT ASCII(&#x27;XYZ&#x27;)SELECT CHARINDEX(&#x27;ABCd&#x27;, &#x27;XYZDABCd&#x27;) -- 5SELECT LEFT(&#x27;XYZD&#x27;, 2) -- XYSELECT LEFT(name, 1), COUNT(LEFT(name, 1)) FROM tb2 GROUP BY LEFT(name, 1)SELECT RIGHT(&#x27;XYZD&#x27;, 2) -- ZDSELECT RIGHT(name, 2) FROM tb2SELECT LEN(&#x27; ABC &#x27;) -- 4REPLACE(character_expression, search_string, replacement_string)SELECT REPLACE(&#x27;XYZCR&#x27;, &#x27;CR&#x27;, &#x27;W&#x27;) -- XYZWSELECT REVERSE(&#x27;XYZW&#x27;)SELECT STR(3.1415926)SELECT STR(3.1415926, 5, 2) -- (nums, 总长度，小数点位数)SELECT SUBSTRING(&#x27;SUBSTRIN&#x27;, 5, 2) -- TR 日期和时间函数 函数 说明 GETDATE 返回当前系统日期和时间（返回结果长度为 29 个字符） DAY 返回指定日期的天；整数，表示日期的“日”部分 MONTH 返回指定日期的月；整数，表示日期的“月”部分 YEAR 返回指定日期的年；整数，表示日期的“年”部分 DATEDIFF 返回日期和时间的边界数 DATEADD 添加日期时间，将给定的时间间隔加到指定的日期上 1234567891011121314SELECT GETDATE() as &#x27;当前时间&#x27;SELECT DAY(GETDATE()) as &#x27;今天几号&#x27;SELECT MONTH(GETDATE()) as &#x27;现在是几月&#x27;SELECT YEAR(GETDATE()) as &#x27;现在哪一年&#x27;SELECT DATEDIFF(DAY, &#x27;2023-01-01&#x27;,GETDATE()) as &#x27;过去了多少天&#x27;SELECT DATEDIFF(MONTH, &#x27;2023-01-01&#x27;,GETDATE()) as &#x27;过去了几个月&#x27;SELECT DATEDIFF(YEAR, &#x27;2022-01-01&#x27;,GETDATE()) as &#x27;过去了几年&#x27;SELECT DATEDIFF(HOUR, &#x27;2023-08-15 00:00:00&#x27;,GETDATE()) as &#x27;过去了几小时&#x27;-- 当前日期加2天、月、年SELECT DATEADD(DAY, 2, GETDATE()) SELECT DATEADD(MONTH, 2, GETDATE())SELECT DATEADD(YEAR, 2, GETDATE()) 转换函数 函数 说明 CAST 将某种数据类型表达式显示转换为另一种数据类型 CONVERT 非标准SQL函数，可按指定格式家那个数据转为另一种数据类型 123456SELECT CAST(DAY(GETDATE()) as varchar(5)) + &#x27;号&#x27; as &#x27;今天几号&#x27;SELECT CAST(&#x27;123456&#x27; as int)SELECT GETDATE(),CAST(GETDATE() as datetime),CONVERT(datetime, GETDATE(), 126) -- (目标类型，待转换值, 日期显示的样式) 元数据函数描述了数据的结构和意义，主要用于返回数据库中的相应信息，包括： 数据库中数据表或视图的个数和名称 数据表中数据字段的名称、数据类型、长度等描述信息 数据表中定义的约束、索引、主键、外键等信息 函数 说明 COL_LENGTH 返回列的定义长度（单位字节） COL_NAME 返回数据库列的名称，该列具有的表标识号、列标识号 DB_NAME 返回数据库名 OBJECT_ID 返回数据库对象标识号 123SELECT COL_LENGTH(&#x27;student&#x27;, &#x27;ID&#x27;)SELECT COL_NAME(OBJECT_ID(&#x27;student&#x27;),1)SELECT DB_NAME() -- 空值时返回当前数据名称；带参数时传入 db_id 数据查询选择查询1234567SELECT select_list[into new_table] -- 查询结果放入一张新表FROM table_source[WHERE search_condition][GROUP BY group_by_expr] -- 分组，如分为 ‘男’‘女’两组[HAVING search_condition][ORDER BY order_expr [ASC | DESC]] 选择所有字段 1SELECT * FROM table_n 选择部分字段 1SELECT column_name1, column_name2 FROM table_n 重新队列排序 1SELECT * FROM table_n ORDER BY Score DESC -- 默认ASC 也可多级排列，即： 1SELECT * FROM table_n ORDER BY Score DESC, ID ASC 当 Score 相同时，按 ID 排序 使用运算符或函数进行列计算 1SELECT Score = Score + 1 FROM table_n 利用 WHERE 参数过滤数据 比较运算符：=、&lt;、&gt;、&lt;&gt; 1SELECT * FROM table_n WHERE Score &gt; 88 范围说明：BETWEEN、NOT BETWEEN 12SELECT * FROM table_n WHERE Score BETWEEN 60 AND 100SELECT * FROM table_n WHERE Score NOT BETWEEN 60 AND 100 可选值列表：IN、NOT IN 12SELECT * FROM table_n WHERE ID in (1, 2, 5)SELECT * FROM table_n WHERE ID not in (1, 2, 5) 模式匹配：LIKE、NOT LIKE（模糊查询） 123SELECT * FROM table_n WHERE name LIKE &#x27;李%&#x27;SELECT * FROM student WHERE age LIKE (&#x27;2[^3-8]&#x27;)SELECT * FROM student WHERE age LIKE (&#x27;2[0-9]&#x27;) 逻辑组合：AND、OR、NOT 1SELECT * FROM table_n WHERE ID = 1 OR ID = 5 消除重复记录 1SELECT DISTINCT age FROM student GROUP BY 子句 SELECT 子句的字段列表中，除聚合函数外，其他字段需在 GROUP BY 中有定义；且 text、ntext、image 数据类型不能作为该子句的分组依据；且不能使用字段别名 123SELECT sex as &#x27;性别&#x27; FROM student GROUP BY sex-- SELECT name, sex as &#x27;性别&#x27; FROM student GROUP BY sex -- 错误，name 不是聚合函数，且未出现在 GROUP BY 子句中SELECT COUNT(sex) FROM student GROUP BY sex HAVING 子句 分组之前的条件要用 WHERE 关键字，分组之后的条件要用关键字 HAVING 子句 1234-- 选择平均年龄大于 20，按性别分组SELECT AVG(age), sex FROM student GROUP BY sex HAVING AVG(age) &gt; 20SELECT AVG(age) as &#x27;平均年龄&#x27;, id, sex FROM student GROUP BY sex, id HAVING AVG(age) &gt; 20 UNION 合并UNION 用于合并多个查询结果 UNION 与连接之间的区别合并操作与连接相似，都是将两个表合并起来形成另一个表；但其合并方法有本质上的不同，其中 连接是左右，合并是上下，即 连接 [A|B]；合并 [A/B]。换句话说，合并的两个表的列数、数据类型是一致的，而连接后的列则可能来自两个表中的一个或两个都有。 1234-- 查询的数据列的个数及类型必须相同或兼容（如下，两列，类型为 int，varchar）SELECT age,name FROM studentUNIONSELECT id,name FROM teacher UNION ALL 功能：不删除重复行也不对行进行自动排序 优势：需要的计算资源少，尤其是处理大型表的时候 适用： 知道有重复行并想保留该行 知道不可能有任何重复的行 不在乎是否有任何重复的行 即使满足第一个查出了，后续满足亦查出时会再次显示，即可得到重复值 123SELECT * FROM student WHERE age &gt; 22 -- 同一个满足年龄大于 22UNION ALLSELECT * FROM student WHERE id IN(1,5,8) -- 又满足 id 是 1,5，8，显示两次 UNOIN 与 ORDER BY 合并表时有且只能有一个 ORDER BY 子句，且必须在语句末尾 对两个 SELECT 语句均提供了用于合并所有行的排序 排序依据： 来自第一个 SELECT 子句的别名 来自第一个 SELECT 子句的列别名 UNION 中列的位置的编号 123SELECT age, sex FROM student where sex = &#x27;女&#x27;UNION ALLSELECT id, name FROM teacher ORDER BY age -- age 不在 teacher 表，通过 UNION ALL 连接后可访问 student 表中的 age UNION 中自动类型转换 合并两个表时，两表源中对应的每个列数据类型不一定要完全相同，只需类型兼容即可 如文本数据类型，合并两表源中第一列数据类型虽都是文本，但长度不一致；但合并表时，只要字符短的列等于字符长的列的长度，即保证了长度长的列不会丢失任何数据；数值类型也同理； 即自动数据类型转换，故说任何两个文本列、数字列都是兼容的 1234-- age 为 int，id 为 tinyint，自动转换；同理 sex 为 char，name 为 varcharSELECT age, sex FROM student where sex = &#x27;女&#x27;UNION ALLSELECT id, name FROM teacher ORDER BY age UNION 合并不同类型数据两个表源中对应列的数据类型不一致时，需借助数据类型转换函数，亦可完成合并 123SELECT STR(age), sex FROM student where sex = &#x27;女&#x27;UNION ALLSELECT name, STR(id) FROM teacher UNION 合并不同列数表若两个表源列数不同，只需向其中一个表源中添加列即可合并 123SELECT age, name, sex FROM studentUNION ALLSELECT id, name, null FROM student -- 通过 null 补齐列 UNION 多表合并可以合并多表，数量可达十多个，但需遵循合并表的规则。 12345SELECT age, name, sex FROM studentUNION ALLSELECT id, name, null FROM studentUNION ALLSELECT id, null, null FROM lab JOIN连接 JOIN 将两个表连接在一起的连接谓词 连接条件可在 FROM 或 WHERE 中指定，建议在 FROM 子句中指定 交叉连接两个表的笛卡尔积，即两表的交叉乘积 12SELECT filedlist FROM table1CROSS JOIN table2 12SELECT * FROM tb1 CROSS JOIN tb2 WHERE tb1.id in (1,2) AND tb2.id in (1,2) 内连接 也叫连接，是最早的一种连接（又称普通连接或自然连接） 从结果中删除其他被连接表中没有匹配的行的所有行，可能会丢失数据 123SELECT filedlist FROM tb1[INNER] JOIN tb2ON tb1.column = tb2.column 123SELECT * FROM tb1JOIN tb2ON tb1.id = tb2.id -- 只选出两表中 id 相等的列 外连接扩充了内连接功能，其将内连接中删除的列保留下来，由于保留下来的行不同，分为不同的连接 左外连接结果集包含 LEFT JOIN 子句中指定的左表的所有行，若左表中的某一行在右表中没有匹配行，在结果集中来自右表的所有列均为空值 NULL。 123SELECT filedlist FROM tb1LEFT JOIN tb2ON tb1.column = tb2.column 123SELECT * FROM tb1LEFT JOIN tb2ON tb1.id = tb2.id 右外连接左外连接的反向连接；结果集包含 RIGHT JOIN 子句中指定的右表的所有行，若右表中的某一行在左表中没有匹配行，在结果集中来自左表的所有列均为空值 NULL。 123SELECT filedlist FROM tb1RIGHT JOIN tb2ON tb1.column = tb2.column 123SELECT * FROM tb1RIGHT JOIN tb2ON tb1.id = tb2.id 全外连接FULL JOIN 连接返回左右表中的所有行，当某行在另一表中没有匹配行时，选择列包含空值；若表之间有匹配行，则整个结果集行包含基表的数据值。 123SELECT filedlist FROM tb1FULL JOIN tb2ON tb1.column = tb2.column 123SELECT * FROM tb1FULL JOIN tb2ON tb1.id = tb2.id -- 得到两表中的所有列，不一致的为空 子查询与嵌套查询IN、NOT IN12WHERE 查询表达式 IN (子查询)WHERE 查询表达式 NOT IN (子查询) 1SELECT id FROM student WHERE id NOT IN (SELECT id FROM teacher WHERE id is not null) 比较运算符子查询注意子查询只能返回一个值 1SELECT * FROM student WHERE id = (SELECT id FROM teacher WHERE name = &#x27;王老师&#x27;) SOME、ANY、ALL1234-- 选择年龄大于平均年龄的人员信息SELECT * FROM studentWHERE age &gt; SOME -- ALL、ANY 都类似(SELECT AVG(age) FROM student) SOME、ANY：子查询结果有真就返回，可以相互替换使用 ALL：子查询的结果都为真时，才返回 使用 EXISTS 的子查询只注重子查询是否返回行，若子查询返回一个或多个行，则为真，否则为假，其不关注行的内容 12345678SELECT * FROM studentWHERE EXISTS(SELECT * FROM teacher WHERE student.id = teacher.id) SELECT * FROM studentWHERE NOT EXISTS(SELECT * FROM grade WHERE student.id = grade.id) 视图操作视图中的内容是由查询定义来的，且视图和查询都是通过 SQL 语句定义的 创建视图 123CREATE VIEW view_tb1 -- 基于哪个表ASSELECT * FROM tb1 修改视图 123ALTER VIEW view_nameASSELECT name, age FROM tb1 -- 从 * 修改为 name,age 删除视图 1DROP VIEW view_name 视图操作数据 从视图中增删改数据，都是对其中表的修改 存储过程存储过程概述 存储过程（Stored Procedure）是在数据库服务器端执行的 T-SQL 语句的集合，经编译后存放于数据库服务器 存储过程作为一个单元进行处理并由一个名称来标识 能够向用户返回数据、在数据表中写入或修改数据，还可执行系统函数和管理操作 用户在编程时只需给出存储过程的名称和必需的参数，即可调用 其优点如下： 嵌套：可以嵌套使用，支持代码重用 接受并使用参数：可接受和使用参数，动态地执行 SQL 语句 执行速度快：在创建时已经编译，执行时无需编译，故速度快于单独的 SQL 语句 安全特性：具有安全特性和所有权链接，可附加到其证书；用户可被授予权限来执行存储过程，而不必直接对其中引用的对象具有权限 允许模块化程序设计：一旦创建，以后可以随时调用，可以改进程序的可维护性 可减少网络通信流量：一个需要数百行 SQL 语句的操作可通过一条存储过程执行代码执行，无需再网络中发送数百行代码 可强制应用程序安全性：参数化存储过程有助于保护应用程序不受 SQL Injection 攻击 SQL Server 提供了 3 种类型的存储过程： 系统存储过程：管理 SQL Server、显示有关数据库和用户信息 自定义存储过程：用户采用 SQL 语句创建 扩展存储过程：通过其他语言如 C 创建外部例程，并将其作为存储过程使用 创建存储过程 SSMS GUI创建 命令创建 123456789CREATE PROCEDURE proc_name as -- PROCEDURE 可简写为 PROCSELECT * FROM tb_nameCREATE PROC proc_stu @proc_id intASSELECT * FROM student WHERE id = @proc_id -- 据传入 id 查询学生信息EXEC proc_stu 5 执行存储过程EXECUTE 命令： 1EXECUTE proc_name -- EXECUTE 可简写为 EXEC 删改存储过程 查看存储过程 123sp_helptext proc_name -- 文本信息(存储过程定义)sp_depends proc_name -- 关联信息sp_help -- 一般信息 修改存储过程 只会修改 SQL 语句，不会修改权限 1234567ALTER PROCEDURE proc_nameALTER PROCEDURE proc_stu@id int = 5,@age int = 20ASSELECT * FROM student WHERE id = @id AND age &gt; @age 重命名存储过程 123sp_rename proc_name proc_new_namesp_rename &#x27;proc_teacher&#x27;, &#x27;proc_teach&#x27; 删除存储过程 1DROP PROCEDURE proc_name 触发器触发器 一种特殊的存储过程 在插入、删除、修改特定表中的数据时触发执行 触发器可强制执行一定的业务规则，以保持数据完整性、检查数据有效性、实现数据库管理任务和一些附加功能 一张表中可有多个触发器 不论触发器所进行的操作多复杂，其都只作为一个独立单元被执行，被看做是一个事务 若执行触发器过程中发生了错误，则整个事务将会自动回滚 不能通过名称进行调用，更不能设置参数 触发器功能 级联修改数据库中的表 执行比核查约束更为复杂的约束操作 拒绝或回滚违反引用完整性的操作，检查对数据表的操作是否违反引用完整性，并选择相应的操作 比较表修改前后数据之间的区别，并根据差别采取相应的操作 触发器分类 DML 触发器：作用于数据表 INSERT 触发器 UPDATE 触发器 DELETE 触发器 DDL 触发器：作用于数据库 登录触发器 创建触发器 DML 触发器创建 12345CREATE TRIGGER trigger_nameON table1_nameAFTER DELETE -- 具体操作，如 DELETE、UPDATE、INSERT，执行这些操作时触发ASPRINT &#x27;你成功删除（更新、插入）了一条数据！&#x27; DDL 触发器 12345678CREATE TRIGGER trigger_nameON DATEBASE -- 触发器作用域为数据库FOR DROP_TABLE -- 删除数据库中的表时触发ASBEGINPRINT &#x27;触发器禁止删除数据库&#x27;ROLLBACKEND 修改触发器1234567ALTER TRIGGER trigger_nameON table1_nameAFTER UPDATEASPRINT &#x27;已修改数据表中的信息！&#x27; UPDATE teacher SET name = &#x27;孟老师&#x27; WHERE id = 4 -- 修改时输出提示信息 删除触发器1DROP TRIGGER trigger_name 索引索引概念 数据库索引是对数据表中一个或多个列的值进行排序的结构 优点 创建唯一性索引，可保证数据库中每一行数据的唯一性 大大加快数据的检索速度，这也是创建索引的主要原因 加速表与表之间的连接，在实现数据的参考完整性方面 使用分组和排序子句进行数据检索时，可减少操作时间 可在查询过程中使用优化隐藏器，提高系统性能 缺点 创建和维护索引要耗费时间，且随着数据量的增加而增加 索引需占用物理空间，聚集索引占用的空间更大 对表中数据进行增删改时，索引也需动态维护，降低了数据维护速度 索引分类聚集索引 基本思想 根据数据行的键值在表或视图中排序和存储数据行 索引定义中包含聚集索引列 每个表只能有一个聚集索引，因数据行本身只能按一个顺序排序 表与聚集索引： 只有当表中包含聚集索引时，表中的数据才按排序顺序存储 若表具有聚集索引，该表为聚集表 若表没有聚集索引，其数据行存在无序结构堆中 每个表都应有聚集索引（个别表除外） 聚集索引可提高查询的性能，也可按需重新生成或重新组织以控制碎片 聚集索引实现 PRIMARY KEY 和 UNIQUE 约束 创建主键约束时，若不存在该表的聚集索引且未指定唯一非聚集索引，则将自动对一列或多列创建唯一聚集索引（主键列不允许空值） 创建唯一性约束时，默认将创建唯一非聚集索引，以便强制 UNIQUE 约束；若不存在该表的聚集索引，则可指定唯一聚集索引 独立于约束的索引 指定非聚集主键约束后，用户可对非主键列的列创建聚集索引 索引视图 创建索引视图时，需对一个或多个视图列定义唯一聚集索引。 非聚集索引 具有独立于数据行的结构 包含非聚集索引键值，且每个键值项都有指向包含该键值的数据行的指针 行定位器：从非聚集索引中的索引行指向数据行的指针 其结构取决于数据页存储在堆中还是聚集表中。 对于堆，行定位器是指向行的指针； 对于聚集表，行定位器是聚集索引键。 索引操作创建索引123CREATE [UNIQUE] [CLUSTERED] [NONCLUSTERED]INDEX index_nameON &#123;TABLE | VIEW&#125; (column [ASC | DESC]) 1234567-- 不唯一，非聚集索引创建CREATE INDEX index_teachON teacher(id)-- 唯一，聚集约束CREATE UNIQUE CLUSTERED INDEX index_stuON tb3(id) 删除索引1DROP INDEX table1_name.index1_name 索引分析与维护 索引分析 SHOWPLAN_ALL：执行或运行时设置，而不是在分析时设置。返回执行信息（不执行语句） SHOWPLAN_TEXT：返回每个 T-SQL 语句的执行计划信息 12SET SHOWPLAN_ALL &#123;ON | OFF&#125;SET SHOWPLAN_TEXT &#123;ON | OFF&#125; 12345SET SHOWPLAN_ALL ONGOSELECT * FROM student WHERE id = 2GOSET SHOWPLAN_ALL OFF STATISTIC IO：显示有关由 T-SQL 语句生成的磁盘活动量信息 1SET STATISTICS IO &#123;ON | OFF&#125; 12345SET STATISTICS IO ONGOSELECT * FROM student WHERE id = 2GOSET STATISTICS IO OFF 索引维护 DBCC SHOWCONTIG：显示指定表的数据和索引的碎片信息。当对表进行大量修改或添加数据后，应通过该语句查看有无碎片。 1DBCC SHOWCONTIG WITH FAST -- 快速查看 DBCC DBREINDEX：对指定数据库中的表重新生成一个或多个索引","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://hbroad.github.io/categories/SQL-Server/"}],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://hbroad.github.io/tags/SQL-Server/"}]},{"title":"C# 从入门到放弃","slug":"C#/C#-从入门到放弃","date":"2023-07-23T03:18:30.000Z","updated":"2023-08-19T09:02:49.859Z","comments":true,"path":"CSharp_learning/","link":"","permalink":"https://hbroad.github.io/CSharp_learning/","excerpt":"","text":"参考课程：刘铁猛 - C# 语言入门详解 数据类型 C# 是强类型语言，即声明变量为一种类型时，不能将另一种类型赋值给该变量 纯 面向对象 的语言 为模仿弱类型，C# 提出了动态类型 1234dynamic myvar = 100;Console.WriteLine(myvar);myvar = &quot;myvar&quot;;Console.WriteLine(myvar); C# 中存在垃圾回收机制，堆中申请的内存无人使用时会自动回收，较 C++ 安全 C# 五大数据类型 类 结构体 枚举 接口 委托 其中，类、接口、委托 属于 引用类型，结构体、枚举 属于 值类型，它们都属于 object 基类 值类型 无实例（具体的对象），其与变量合而为一 按变量类型分配内存空间 十进制转为二进制存储，对负数，按位取反再加1后存储；对两字节，补零后高八位存储在内存地址较大的位置，后八位存储在较低位置 引用类型以类为例 直接分配四个字节 在堆中开辟内存，即引用类型的变量中存储的是对象的内存地址 参数种类 传值 传引用 ref 输出 out 变量 静态变量：属于类，而非对象 本地变量必须初始化，否则编译报错（int x = 0;) 类中的成员变量不赋值时默认初始化为 0 或 null 常量 const 修饰的常量初始化后不能再更改 装箱与拆箱Boxing &amp; Unboxing 目前不常用，因其涉及性能损失 详见 C07S05 05:14 装箱：由栈到堆 123int x = 100;object obj; //此时只是在栈中为 obj 分配 4 字节空间，并初始化为0obj = x; //此时先在堆中开辟 4 字节空间，并将 x 的值复制到该空间中，再将该空间对应的首地址存储在obj 中 拆箱：由堆到栈 1int y = (int)obj; //先在栈中为 y 分配 4 字节空间，再将堆中 obj 变量的值复制到 y 所在的内存中 可见，装箱和拆箱涉及堆栈数据的交换，必然损失性能 装箱时是和类型一起装箱的，故拆箱时类型要一致 字符与字符串字符 使用 char/Char 定义 只能用单引号，单引号之间是单个字符 1234char ch1 = &#x27;a&#x27;;Console.WriteLine(char.ToUpper(ch1));Console.WriteLine(char.IsDigit(ch1));Console.WriteLine(char.IsLetter(ch1)); 转义字符 通过“\\”完成转义 1Console.WriteLine(&quot;C:\\\\Windows\\\\soft\\\\test\\\\2053\\\\11&quot;); 可见，若目录层级较深，通过该方法指定路径繁琐，可通过 @ 符号实现多层转义（或者说@是取消转义）： 1Console.WriteLine(@&quot;C:\\Windows\\soft\\test\\2053\\11&quot;); 字符串字串初始化 字串声明后不赋初值时，默认为 null 引用字串常量初始化 1string str = &quot;每日疑问，C# 入门了嘛&quot;； 提取字符数组中的一部分初始化 12char[] ch = &#123; &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;;string str = new string(ch, 2, 3); //起始索引、截取长度 空字串与空引用区别 12string str = null; //空对象string str = &quot;&quot;; //是一个空串 空对象，没有指向任何引用地址，调用 string 的方法会抛出 NullReferenceException 空引用异常 空串，分配了内存空间，可调用 string 的任意方法 字串拼接12string str_con = &quot;123&quot; + &quot;456&quot;;str_con += &quot;xyz&quot;; 字串比较 Compare 方法 比较的是字母排序的大小 12public static int Compare(string strA, strB)public static int Compare(string strA, strB, bool ignoreCase) CompareTo 方法 12public int CompareTo(object value)public int CompareTo(string value) Equals 方法 12public bool Equals(string value)public static bool Equals(string a, string b) 实例 1234567string a = &quot;string&quot;;string b = &quot;string&quot;;Console.WriteLine(string.Compare(a, b));Console.WriteLine(string.Compare(a, b, true));Console.WriteLine(a.CompareTo(b));Console.WriteLine(a.Equals(b));Console.WriteLine(string.Equals(a, b)); 格式化字串 Format 方法： 12public static string Format(string format, object arg0)public static string Format(string format, params Object[] args) 标准数值格式规范 12string.Format(&quot;&#123;0:C&#125;&quot;, 256); //默认保留两位小数string.Format(&quot;&#123;0:C0&#125;&quot;, 256); //设置小数位数 标准日期时间格式规范 12DateTime dateTime = DateTime.Now;string.Format(&quot;&#123;0:D&#125;&quot;, dateTime); ToString 方法： 12DateTime dateTime = DateTime.Now;dateTime.ToString(&quot;D&quot;); 截取字串12public string Substring(int startIndex)public string Substring(int startIndex, int length) 123string filename = &quot;program.cs&quot;;Console.WriteLine(filename.Substring(filename.IndexOf(&quot;.&quot;))); //扩展名Console.WriteLine(filename.Substring(0, filename.IndexOf(&quot;.&quot;))); //文件名 分割字串将字串按照指定的符号分割成数组 12public string[] Split(params char[] separator)public string[] Split(char[] separator, int count) //指定分割数量 123456string str_sep = &quot;123, 456; byd&quot;;string[] str_asep = str_sep.Split(new char[] &#123; &#x27;,&#x27;, &#x27;;&#x27; &#125;);//指定分割的个数string str_sep = &quot;123, 456; byd&quot;;string[] str_asep = str_sep.Split(new char[] &#123; &#x27;,&#x27;, &#x27;;&#x27; &#125;, 2); 插入字串1public string Insert(int startIdenx, string value) 123string str_sep = &quot;123,456;byd&quot;;string new_str = str_sep.Insert(4, &quot;xyz;&quot;);Console.WriteLine(new_str); 删除字串12public string Remove(int startIndex)public string Remove(int startIndex, int count) // 指定删除字符数 12345string str_sep = &quot;123,456;byd&quot;;string new_str1 = str_sep.Remove(4);string new_str2 = str_sep.Remove(4, 3);Console.WriteLine(new_str1);Console.WriteLine(new_str2); 复制字串12public static string Copy(string str) //完整赋值public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) 1234string str_sep = &quot;123,456;byd&quot;;char[] chars = new char[10];str_sep.CopyTo(str_sep.IndexOf(&quot;456&quot;), chars, 0, 4);Console.WriteLine(chars); 替换字符1public string Replace(char Oldchar, char Newchar) 123string str_rp = str_sep.Replace(&#x27;,&#x27;, &#x27;;&#x27;);string str_rp1 = str_sep.Replace(&quot;456&quot;, &quot;789&quot;);Console.WriteLine(str_rp); 可变字串类string 类型的对象，当我们对其进行拼接等操作时，其总是在内存中重新申请一块空间来存储操作后的对象；倘若我们需要大量重复此类操作，会导致开销过大。 为此，引入 stringBuilder 可变字串类，该类位于 System.Text 命名空间，效率更高。 123456public StringBuilder()public StringBuilder(int capacity)public StringBuilder(string value)public StringBuilder(int capacity, int maxCapacity)public StringBuilder(string value, int capacity)public StringBuilder(string value, int startIndex, int length, int capacity) 该类常见的几种方法如下： 12345StringBuilder strbu = new StringBuilder(&quot;(), (), (), 2, 4, 6, 7, 8&quot;);strbu.Remove(0, 11);Console.WriteLine(strbu);strbu.Insert(0, &quot;(门前大桥下), (游过一群鸭), (快来快来数一数),&quot;);Console.WriteLine(strbu); 不变与可变字串在操作次数较大时耗时差异明显： 123456789101112131415string str_op = &quot;&quot;;long start_time = DateTime.Now.Millisecond;for (int i = 0; i &lt; 10000; i++) str_op += i;long end_time = DateTime.Now.Millisecond;long lost_time = end_time - start_time;Console.WriteLine(lost_time); //32msStringBuilder sb = new StringBuilder();start_time = DateTime.Now.Millisecond;for (int i = 0; i &lt; 10000; i++) sb.Append(i);end_time = DateTime.Now.Millisecond;long lost_time2 = end_time - start_time;Console.WriteLine(lost_time2); //1ms 正则表达式常用符号 行限定符 行的开始：^ 行的结尾：$ 元字符 .：匹配除换行符以外的任意字符 \\w：匹配字母、数字、下划线 \\s：匹配任意的空白符 \\b：匹配单词的开始或结束 \\d：匹配数字 限定符 字符类 在方括号中列出 [aeiou]：匹配任何一个元音首字母 [.?!]：匹配标点符号. ? ! [\\u4e00-\\u9fa5]：匹配给定字串中的任意一个汉字 [\\u4e00-\\u9fa5]+：匹配连续多个汉族 排除字符 a-zA-Z：排除所有字母 选择字符：[ | ] 分组：() C# 与正则表达式 命名空间：System.Text.RegularExpressions 类名：Regex 方法：IsMatch、Match、Matches、Replace、Split 数组一维数组数组定义时指定的大小必须初始化 123int[] arr = new int[5] &#123;1,2,3&#125;; //错误int[] arr = new int[5] &#123;1, 2, 3, 4, 5&#125;; int[] arr = &#123;1, 2, 3, 4, 5&#125;; 二维数组 二维数组的定义 直接指定行列： 1int[,] arr = new int[2, 4]; // 2行 4列 只指定行，再为每行指定列，且每行列数可不同（不规则数组）： 123int[][] arr = new int[2][]; //该方式只能指定行数arr[0] = new int[2]; // 为每行单独指定列arr[1] = new int[3]; 二维数组的初始化 给每一行每一列分别赋值 12int[,] arr = new int[2,2];arr[0, 1] = 0; arr[0, 1] = 1; arr[1, 0] = 3; arr[1, 1] = 4; 给每一维数组赋值 123int[][] arr = new int[2][];arr[0] = new int[] &#123; 0, 1 &#125;;arr[1] = new int[] &#123; 2, 3 &#125;; 声明时初始化 123int[,] arr1 = new int[2, 2] &#123; &#123; 1, 0 &#125;, &#123; 1, 2 &#125; &#125;;int[,] arr2 = new int[,] &#123; &#123; 1, 0 &#125;, &#123; 1, 2 &#125; &#125;;int[,] arr3 = &#123; &#123; 1, 0 &#125;, &#123; 1, 2 &#125; &#125;; ArrayList 类 本质就是容器，一种动态数组 使用：创建 ArrayList 对象 内部的元素类型可不一致 操作： 添加：Add（从最后添加）、Insert（指定位置插入） 遍历：foreach 删除：Remove（移除第一个匹配项）、RemoveAt、RemoveRange、Clear 查找：Contains（完全匹配）、IndexOf、LastIndexOf（从后往前查找，返回索引） 12345678910111213141516171819ArrayList al = new ArrayList();al.Add(1);al.Add(2);al.Add(2);al.Add(2);al.Add(&quot;AL&quot;);al.Insert(2, &quot;Insert&quot;);al.Remove(2);al.RemoveAt(2);al.RemoveRange(2, 2);al.Clear();Console.WriteLine(al.Count == 0);Console.WriteLine(al.Contains(5));Console.WriteLine(al.IndexOf(&quot;AL&quot;));Console.WriteLine(al.LastIndexOf(&quot;AL&quot;));foreach (var p in al)&#123; Console.WriteLine(p);&#125; 哈希表 本质：Hashtable 方法： Add(K key, V value)：将键值数据存入哈希表 Contains/ContainsKey(object key)：查找哈希表中是否存在某个键 Remove(object key)：删除指定的键 ContainsValue(object value)：查找哈希表中是否存在某个值 获取哈希表中的键值：DictionaryEntry 结构 12345678910111213Hashtable hashtable = new Hashtable();hashtable.Add(1, &quot;a&quot;);hashtable.Add(2, &quot;b&quot;);hashtable.Add(3, &quot;c&quot;);hashtable.Remove(1);Console.WriteLine(hashtable.Contains(2));Console.WriteLine(hashtable.ContainsKey(3));Console.WriteLine(hashtable.ContainsValue(&quot;d&quot;));foreach (DictionaryEntry entry in hashtable)&#123; Console.WriteLine($&quot;#&#123;entry.Key&#125; is &#123;entry.Value&#125;&quot;);&#125; 方法的定义、调用和调试方法 方法（成员函数）是类或结构体的成员 隐藏复杂的逻辑、大算法分解为小算法、代码复用 C# 中声明定义不分家（不同于 C++ 分为头文件和源文件） 方法名为动词或动词短语，且每个单词首字母大写 以 static 修饰时，为静态变量，该成员函数属于类；其他的方法属于对象 构造器 即构造函数 直接敲 ctor 命令可直接生成一个构造函数代码片段 构造器内存原理 若构造函数内部变量类型也是类（如 string），则会在构造时继续在堆中开辟新内存，并将其首地址存储在先前开辟内存中 方法的重载 方法名一致，方法签名（方法名称、参数个数、参数类型）、类型形参（模板，泛型编程）、参数种类不一致 不包含 返回值类型 构造函数也可重载 方法的调用与栈方法调用时栈内存的分配 call stack：调用堆栈，用于显示方法之间的调用关系 stack frame：方法被调用时在栈内存中的布局 方法的参数归调用者管辖，且参数按顺序压入栈 1234567891011121314151617181920212223242526272829using System;using System.Windows.Forms;namespace Csharptest&#123; internal class test &#123; static void Main(string[] args) &#123; double x = 10, y = 20; Calculator cal = new Calculator(); Console.WriteLine(cal.GetCylinderVolume(x, y)); // 此处的 x y 属于 Main 栈，并按从左至右的顺序压入栈中 &#125; &#125; class Calculator &#123; public double Getcirclearea(double r) &#123; return Math.PI * r * r; //返回值暂存于 CPU 寄存器中 &#125; public double GetCylinderVolume(double r, double h) &#123; return Getcirclearea(r) * h; &#125; &#125;&#125; 操作符操作符概览 操作符的本质 函数或算法的简记法 不能脱离数据的类型 举例：方法的定义和调用的常规的写法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections.Generic;namespace Csharptest&#123; internal class test &#123; static void Main(string[] args) &#123; Person p1 = new Person(); Person p2 = new Person(); p1.name = &quot;B&quot;; p2.name = &quot;YD&quot;; List&lt;Person&gt; list = Person.Getmarry(p1, p2); //List&lt;Person&gt; list = p1 + p2; //通过操作符调用 foreach (var p in list) &#123; Console.WriteLine(p.name); &#125; &#125; &#125; class Person &#123; public string name; public static List&lt;Person&gt; Getmarry(Person p1, Person p2) //public static List&lt;Person&gt; operator+ (Person p1, Person p2)//操作符定义 &#123; List&lt;Person&gt; list = new List&lt;Person&gt;(); list.Add(p1); list.Add(p2); for (int i = 0; i &lt; 10; i++) &#123; Person child = new Person(); child.name = p1.name + &quot;&amp;&quot; + p2.name + &quot;&#x27;s child&#x27;&quot;; list.Add(child); &#125; return list; &#125; &#125;&#125; 而该方法可通过运算符简化，只需将 方法名 Getmarry 改为 operator+ 即可，主函数中调用时不再通过方法名调用，而是直接采用自定义的操作符 + 调用即可。 操作符的优先级 可通过括号提升优先级 带赋值功能操作符的运算顺序是由右向左 没有结合律，同级运算统一从左至右 操作符注：以下均为操作符，并不做关键字看待 基本操作符 元素访问操作符 数组元素访问 1234567int[] array = new int[10]; // 创建但不初始化int[] array2 = new int[]&#123; 1, 2, 5 &#125;; // 创建且初始化Console.WriteLine(array2.Length);foreach (var i in array2)&#123; Console.WriteLine(i);&#125; 字典元素访问 1234567891011Dictionary&lt;string, student&gt; SDic = new Dictionary&lt;string, student&gt;();for (int i = 0; i &lt; 10; i++)&#123; student stud = new student(); stud.name = &quot;s_&quot; + i.ToString(); stud.age = i + 100; SDic.Add(stud.name, stud);&#125;student nameage = SDic[&quot;s_6&quot;];Console.WriteLine(nameage.age); new 操作符 构造实例 初始化实例 123Form myform = new Form() &#123; Text = &quot;MY&quot; &#125;; //带初始化//myform.Text = &quot;my&quot;;myform.ShowDialog(); 创建匿名类型 12345var person = new &#123; name = &quot;BYD&quot;, age = 20 &#125;; //自动类型推断Console.WriteLine(person.name);Console.WriteLine(person.age);Console.WriteLine(person.GetType().Name);//&lt;&gt;f__AnonymousType0`2 // 0 表示自己创建类型的编号，2 表示该类型有两个参数 checked、unchecked 检查或不检查是否溢出 12345678910111213uint e = uint.MaxValue;Console.WriteLine(e);string stre = Convert.ToString(e, 2);Console.WriteLine(stre);try&#123; uint f = checked(e + 1); // e 已经是最大值了，加 1 肯定溢出，若为 unchecked，则不再检查溢出 Console.WriteLine(f);&#125;catch (OverflowException ex) // 捕获溢出&#123; Console.WriteLine(&quot;EX Catched&quot;);&#125; 检查上下文溢出，在包围域中的所有都会被检查 123456789101112checked&#123; try &#123; uint f = e + 1; Console.WriteLine(f); &#125; catch (OverflowException ex) &#123; Console.WriteLine(&quot;EX Catched&quot;); &#125;&#125; delegate 做操作符已被 lambda 表达式替代，以 wpf 程序为例说明 常规写法： 12345678910111213public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); this.mybutton.Click += Mybutton_Click; //常规 &#125; private void Mybutton_Click(object sender, RoutedEventArgs e) &#123; this.mybox.Text = &quot;BYD&quot;; &#125;&#125; 使用 delegate 操作符： 123456789101112public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); //this.mybutton.Click += Mybutton_Click; //常规 this.mybutton.Click += delegate (object sender, RoutedEventArgs e) &#123; this.mybox.Text = &quot;BYD&quot;; &#125;; //注意分号 &#125;&#125; 使用 lambda 表达式（推荐）： 1234567891011public partial class MainWindow : Window&#123; public MainWindow() &#123; InitializeComponent(); this.mybutton.Click += (sender, e) =&gt; &#123; this.mybox.Text = &quot;BYD&quot;; &#125;; //注意分号 &#125;&#125; -&gt; 操作符 由于 C# 有指针，但不建议使用，故操作指针时需放在 unsafe 环境下才行，且只能操作结构体类型 1234567891011unsafe //且需在项目-属性-生成-勾选 不安全代码&#123; mystru stru = new mystru(); stru.ID = 1; stru.name = &quot;Test&quot;; mystru* pstru = &amp;stru; pstru-&gt;ID = 2; // (*pstru).ID = 2; pstru-&gt;name = &quot;pointer&quot;; // (*pstru).name = &quot;pointer&quot;; Console.WriteLine(stru.ID); Console.WriteLine(stru.name);&#125; 单目操作符 *：解引用 接前序例子，由于 . 操作符的优先级高于 ，故通过加括号方式提升优先级，如 (\\pstru).ID = 2 !：取反操作符 按位取反 条件取反 12345678910111213141516171819class human&#123; public human(string name) &#123; if (!string.IsNullOrEmpty(name)) //取反操作符的应用 &#123; this.name = name; &#125; else &#123; throw new ArgumentException(&quot;name can&#x27;t be null&quot;); &#125; &#125; public int ID; public string name;&#125;//此时构造对象时传入空串将抛异常human hu1 = new human(null); //抛异常 强制类型转换操作符 隐式类型转换 不丢失精度的转换 子类向父类的转换：转换时只能访问到该变量的类型所具有的类型 装箱 显示类型转换 可能丢失精度甚至发生错误的转换，即 cast，(T)varibable 拆箱 使用 Convert 类 如将字串转数值类型 Convert 类：Convert.ToSth 各类数据类型的 Parse/TryParse 方法 12string str = &quot;50&quot;;double k = double.Parse(str); 但 Parse 只接受正确的数据格式： 12string str2 = &quot;50ab3&quot;double j = double.Parse(str2); //System.FormatException: 输入字串格式不正确 可采用 TryParse 方法，返回值表征是否转换成功 1234string str3 = &quot;50ab3&quot;;double result;bool success = double.TryParse(str3, out result);Console.WriteLine(success); //False 数值转字串时，可采用 Convert 类的静态方法或数值数据的实例方法 12345678string str1 = &quot;50&quot;;string str2 = &quot;60&quot;;double x = Convert.ToDouble(str1);double y = Convert.ToDouble(str2);double sum = x + y;Console.WriteLine(sum);Console.WriteLine(Convert.ToString(sum));//Convert类的静态方法Console.WriteLine(sum.ToString());// 数值的实例方法 显示类型转换操作符 123456789101112131415161718192021222324252627282930313233using System;using System.Collections.Generic;namespace Csharptest&#123; internal class test &#123; static void Main(string[] args) &#123; Stone stone = new Stone(); //Monkey mk = (Monkey)stone; //石头转为孙猴子，但编译器并不知道该转换，需在被转换类中定义 stone.age = 5000; Monkey mk = (Monkey)stone; Console.WriteLine(mk.age); &#125; &#125;&#125;class Stone&#123; public int age; //显式转换 public static explicit operator Monkey(Stone stone) &#123; Monkey mk = new Monkey(); mk.age = stone.age / 500; return mk; &#125;&#125;class Monkey&#123; public int age;&#125; 上述显式转换可改为隐式转换，只需更换关键字即可： 12345678910// 隐式转换public static implicit operator Monkey(Stone stone)&#123; Monkey mk = new Monkey(); mk.age = stone.age / 500; return mk;&#125;// 调用时直接赋值，包含了隐式转换Monkey mk = stone; 自定义类型转换 移位操作符 左移：左移一位等同于 *2 右移：右移一位等同于 /2 is、as as：类似强制类型转换，转换不成功返回 null 123456789101112student stude = new student();var re = stude is student;Console.WriteLine(re.GetType().FullName);Console.WriteLine(re);object obj = new student();student person = obj as student;if (person != null)&#123; person.age = 15; Console.WriteLine(person.age);&#125; null 合并 某些情况下我们需要对变量赋空值，此时须通过可控类型实现，C# 将其以关键字 ? 代替 12345678//Nullable&lt;int&gt; p = null;//等价于int? p = null;//p = 100;Console.WriteLine(p.HasValue);// null 合并操作符int y = x ?? 1; // x 是 null 则赋值 1 条件操作符 if 语句的简写 123int x = 50;string str = (x &gt; 60) ? &quot;及格&quot; : &quot;挂科&quot;;Console.WriteLine(str); 表达式、语句 算法逻辑的最小单元，表达一定的算法意图 操作符有优先级，故表达式亦有优先级 常用的块语句： try…catch…[finally] 可自定义异常消息提示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace CSharptest2&#123; internal class Program &#123; static void Main(string[] args) &#123; Calculator cal = new Calculator(); Console.WriteLine(cal.Add(&quot;999999999999999&quot;, &quot;100&quot;)); &#125; &#125; class Calculator &#123; public int Add(string str1, string str2) &#123; int a = 0; int b = 0; try &#123; a = int.Parse(str1); b = int.Parse(str2); &#125; catch (ArgumentNullException) &#123; Console.WriteLine(&quot;Argument can&#x27;t be NULL&quot;); &#125; catch (FormatException) &#123; Console.WriteLine(&quot;Argument Format Wrong&quot;); &#125; catch(OverflowException) &#123; Console.WriteLine(&quot;Out of Range&quot;); &#125; return a + b; &#125; &#125;&#125; 也可通过异常实例带出异常的具体信息 123456789101112catch (ArgumentNullException ane)&#123; Console.WriteLine(ane.Message);&#125;catch (FormatException fe)&#123; Console.WriteLine(fe.Message);&#125;catch(OverflowException of) &#123; Console.WriteLine(of.Message);&#125; 若在 catch 中不想处理该异常，则可通过 throw 关键字抛出异常，由调用者自行处理异常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace CSharptest2&#123; internal class Program &#123; static void Main(string[] args) &#123; Calculator cal = new Calculator(); int reslut = 0; try &#123; reslut = cal.Add(&quot;99999999999999&quot;, &quot;100&quot;); &#125; catch (OverflowException oe) &#123; Console.WriteLine(oe.Message); &#125; &#125; &#125; class Calculator &#123; public int Add(string str1, string str2) &#123; int a = 0; int b = 0; try &#123; a = int.Parse(str1); b = int.Parse(str2); &#125; catch (ArgumentNullException ane) &#123; Console.WriteLine(ane.Message); &#125; catch (FormatException fe) &#123; Console.WriteLine(fe.Message); &#125; catch(OverflowException of) &#123; throw of; //抛出由调用者处理 &#125; return a + b; &#125; &#125;&#125; throw 关键字的语法是灵活的，可不实例化： 1234567891011catch(OverflowException of) &#123; throw of; //抛出由调用者处理&#125;//等同于catch(OverflowException) &#123; throw; //抛出由调用者处理&#125; foreach：是迭代器的简记，主要用于对集合的遍历 foreach 中的变量是只读的 不能在内部修改实例的值 当泛型实例是类时，可通过其修改类的属性 123456789101112131415161718192021222324252627List&lt;int&gt; list = new List&lt;int&gt;() &#123; 1,2,3,4&#125;;foreach (var item in list)&#123; //item = 1; //只读，不可修改 //list.Remove(item); //不能在循环内修改内部值 //泛型是对象，则可赋值 Console.WriteLine(item);&#125;//当 List 泛型实例是类时，可通过其修改List&lt;Student&gt; students = new List&lt;Student&gt;();foreach (var item in students)&#123; //item = new Student(&quot;lihao&quot;); item.name = &quot;lihao&quot;; //item.name = &quot;lihao&quot;; Console.WriteLine(item);&#125;class Student&#123; public string name; public Student(string name) &#123; this.name = name; &#125;&#125; 字段、属性、索引器、常量字段 即成员变量，属于类 字段名必须是名词 实例字段：与对象关联的字段 初始化时机：实例被创建时 12345678910class Student&#123; public int age = 10; //声明即初始化 //利用实例构造器初始化 public int age; public Student() &#123; age = 10; &#125;&#125; readonly：只读实例字段，在声明或创建对象时初始化，且初始化后无法被修改 12345678910111213class Student&#123; //public readonly int Id = 10; //声明即初始化 //在实例构造器中初始化 public readonly int Id; public Student(int id) &#123; this.Id = id; &#125;&#125;Student stu = new Student(6600888); //创建实例时初始化且不能再被修改Console.WriteLine(stu.ID); 静态字段：与类关联的字段，由 static 修饰；不属于某个具体的对象，用于表征状态 初始化时机：类被加载时（静态构造器在数据类型被运行环境加载时执行，且只执行一次） 12345678910class Student&#123; public static int age = 10; //声明即初始化 //利用静态构造器初始化 public static int age; static Student() &#123; Student.age = 10; &#125;&#125; readonly：静态只读字段，同前 123456789101112131415161718class Color&#123; public int Red; public int Green; public int Blue;&#125;class Brush&#123; public static readonly Color DeafultColor = new Color() &#123; Red = 0, Green = 255, Blue = 0 &#125;; //声明时初始化 //构造器初始化 public static readonly Color DeafultColor; static Brush() &#123; Brush.DeafultColor = new Color() &#123; Red = 0, Green = 0, Blue = 0 &#125;; &#125;&#125; 属性属性的由来 反映对象的特征或状态 是字段的扩展 对外：数据可以存储在字段，亦可动态计算 对内：保护字段不被非法值污染 最初，保护字段的方法是将 public 属性改为 private， 将数据保护起来，并设置对外的接口，C++ 采用该方法。 123456789101112131415161718192021222324252627282930313233343536class Student&#123; private int age; public int GetAge() &#123; return this.age; &#125; public void SetAge(int age) &#123; if(age &gt; 0 &amp;&amp; age &lt;= 120) this.age = age; else throw new Exception(&quot;Wrong age!&quot;); &#125;&#125;//调用时可捕获异常 try &#123; Student stu11 = new Student(); stu11.SetAge(10); Student stu12 = new Student(); stu12.SetAge(20); Student stu13 = new Student(); stu13.SetAge(30); int aveage = (stu11.GetAge() + stu12.GetAge() + stu13.GetAge()) / 3; Console.WriteLine(aveage); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; 可见，这种方式在写法上有些冗余，故提出了 属性，也算是“语法糖”。 属性采用了设置器 setter 和 获取器 getter，并引入上下文关键字 value，代表由用户传入的值，出了 set/get 域之后该功能消失。 123456789101112131415161718192021222324252627282930313233343536373839404142class Student3&#123; private int age = 10; //属性的写法 public int Age //公有属性，作为 get/set 的包装器，名称遵循pascal命名 &#123; get //相当于前述 GetAge() &#123; return this.age; &#125; set //相当于前述 SetAge() &#123; if (value &gt; 0 &amp;&amp; value &lt;= 120) //value 关键字接受用户输入值 this.age = value; else throw new Exception(&quot;Wrong age!&quot;); &#125; &#125;&#125;//调用时更加简洁try&#123; //Student3 stu11 = new Student3(); //stu11.Age = 10; // set //上面这两句可合并为一句 Student3 stu11 = new Student3() &#123; Age = 10 &#125;; Student3 stu12 = new Student3(); stu12.Age = 20; Student3 stu13 = new Student3(); stu13.Age = 30; int aveage3 = (stu11.Age + stu12.Age + stu13.Age) / 3; // get Console.WriteLine(aveage3);&#125;catch (Exception ex)&#123; Console.WriteLine(ex.Message);&#125; 实际上，编译器是自己生成并调用了 get_Age()/set_Age(int32) 的方法，该方法由其编译属性时自动生成。 属性的声明属性的完整声明 VS 完整属性代码片段快捷操作：propfull，按两次 tab 以静态属性为例，静态属性对应的成员变量也需为静态： 1234567891011121314151617181920212223242526class Student3&#123; private static int amount; public static int Amount &#123; get&#123; return amount; &#125; set &#123; if (value &gt;= 0) Student3.amount = value; else throw new Exception(&quot;Wrong Amount!&quot;); &#125; &#125;&#125;try&#123; Student3.Amount = -150; Console.WriteLine(Student3.Amount);&#125;catch (Exception ex)&#123; Console.WriteLine(ex.Message);&#125; 属性的简略声明 VS 简略属性代码片段快捷操作：prop，按两次 tab 属性的简略声明在功能上 = 公有的字段，数据不受保护 一般用于传递数据，代码简单 属性的说明 属性只有 get 时为只读属性，无法修改 123456789101112class Student3&#123; private string name = &quot;XYZ&quot;; public string Name &#123; get&#123; return this.name; &#125; &#125;&#125;Student3 STU = new Student3();Console.WriteLine(STU.Name);//STU.Name = &quot;xyz&quot;; //只读，无法修改 属性同时有 set/get，但 get 被设置为 private，在外界无法访问，但并不是只读属性 123456private string name = &quot;XYZ&quot;;public string Name &#123; get&#123; return this.name; &#125; private set &#123; this.name = value; &#125; //类外无法访问，非只读属性&#125; 动态计算值的属性 属性中的值是动态计算的 1234567891011public bool CanWork&#123; //get &#123; return canWork; &#125; get &#123; if (this.age &gt;= 16) //根据年龄的大小动态计算 return true; else return false; &#125;&#125; 建议：用属性来向外暴露数据，字段应当是 private 或 protected 的 索引器 Indexer 集合类型特有 VS 快速操作：ind，tab*2 常量 隶属于类而非实例（对象），没有“实例常量” 只能是常见的数据类型，不能是类或自定义类型 “实例常量”的角色可由只读字段来承担 提高程序运行效率（编译时直接替换） 成员常量、局部常量 1public const double PI = 3.1415926535897931; //成员常量 “只读”场景 为提高程序的可读性和执行效率——常量 为防止对象的值被改变——只读字段 向外暴露不允许修改的字段——只读属性 当希望成为常量的值类型不能被常量声明接受时（类或自定义结构体）——静态只读字段（即类或自定义结构体不能由 const 修饰，而应是静态只读字段） 参数传值参数 值类型作为参数：值参数（形参）只是创建了变量的副本，对值参数的操作并不会影响方法体外变量的值 引用类型作为参数：同样创建了外部变量的副本，但由于参数是引用，故该副本同样指向外部变量所指的对象，更改任何一个都将影响另一个（这种用法在实际中不常用，被称为方法的副作用，side-effect） 123456789101112131415161718192021class test2&#123; public string Name &#123; get; set; &#125; //属性&#125;internal class Program&#123; static void Main(string[] args) &#123; test2 ts = new test2(); ts.Name = &quot;Test2&quot;; MyMethod(ts); // 引用参数传值 Console.WriteLine(&quot;&#123;0&#125;\\t&#123;1&#125;&quot;, ts.Name, ts.GetHashCode()); &#125; static void MyMethod(test2 ts2) &#123; ts2.Name = &quot;Test1&quot;; // 指向同一对象，方法内修改，外部亦被修改 Console.WriteLine(&quot;&#123;0&#125;\\t&#123;1&#125;&quot;, ts2.Name, ts2.GetHashCode()); &#125;&#125; 但若在方法体内重新创建了对象，则方法体内变量的改变将不会对外部变量有影响 1234567static void MyMethod(test2 ts2)&#123; //ts2.Name = &quot;Test2&quot;; ts2 = new test2(); //重新创建了对象 ts2.Name = &quot;Test3&quot;; Console.WriteLine(&quot;&#123;0&#125;\\t&#123;1&#125;&quot;, ts2.Name, ts2.GetHashCode());&#125; 引用参数 用 ref 修饰符声明的形参 引用形参不创建新的存储位置 值类型作为引用参数：通过 ref 修饰符显式的指出，该方法会改变实参的值 12345678910111213141516internal class Program&#123; static void Main(string[] args) &#123; int y = 1; RefTest(ref y); //传参时也需用 ref 修饰符，明确表明实参会被修改 Console.WriteLine(y); &#125; static void RefTest(ref int x) &#123; x += 100; Console.WriteLine(x); &#125;&#125; 引用类型作为引用参数：和前述类似，引用类型作为参数传入后，形参和实参指向同一个对象；但若在方法体内为引用变量赋新值或创建新的对象，则实参也会随之改变，此时形参和实参指向了新的对象 1234567891011121314151617181920212223class test3&#123; public string Name &#123; get; set; &#125;&#125;internal class Program&#123; static void Main(string[] args) &#123; test3 out_ts3 = new test3(); out_ts3.Name = &quot;out_name&quot;; Console.WriteLine(&quot;&#123;0&#125;\\t&#123;1&#125;&quot;, out_ts3.Name, out_ts3.GetHashCode()); RefOfRefParam(ref out_ts3); Console.WriteLine(&quot;&#123;0&#125;\\t&#123;1&#125;&quot;, out_ts3.Name, out_ts3.GetHashCode()); &#125; static void RefOfRefParam(ref test3 ts3) //引用类型作为引用参数 &#123; //ts3.Name = &quot;in_name&quot;; //只改变对象值，不创建对象，内部更改，外部实参亦更改 ts3 = new test3() &#123; Name = &quot;in_name&quot; &#125;;//创建新对象后内外同时指向新对象 Console.WriteLine(&quot;&#123;0&#125;\\t&#123;1&#125;&quot;, ts3.Name, ts3.GetHashCode()); &#125;&#125; 输出参数 用 out 修饰符修饰的形参，显式指出是通过参数向外输出值 不创建新的存储位置，类似 ref 初始值可有可无 值类型： 前述强制类型转换中我们提到了 TryParse 方法，该函数将数字字串转为对应类型的数字，返回值为 bool 类型，表征转换的成功与否，但我们最终需拿到转换的结果，该结果便可通过 out 输出 1234string num_str = &quot;12306&quot;;double num = 0;bool IsOk = double.TryParse(num_str, out num); //显式表明输出Console.WriteLine(num + 6); 注：TryParse 转换失败时会把原值覆盖为 0 输出参数在方法体中必须赋值，否则编译报错，如自定义一个带输出参数的方法： 123456789101112131415161718192021222324internal class Program&#123; static void Main(string[] args) &#123; string num_str = &quot;12306&quot;; double num = 0; DoubleParse(num_str, out num); Console.WriteLine(num + 6); &#125; static bool DoubleParse(string str, out double result) &#123; try &#123; result = double.Parse(str); //出方法体前必须给 out 变量赋值 return true; &#125; catch &#123; result = 0; //出方法体前必须给 out 变量赋值 return false; &#125; &#125;&#125; 引用类型： 形参和实参指向同一对象，形参赋新值后，实参和形参指向同一新对象 123456789101112131415161718192021222324252627class students&#123; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125;&#125;class studentFactory&#123; public static bool studentF(string name, int age, out students stu) &#123; stu = null; if (name == null) return false; if (age &lt; 0 || age &gt; 80) return false; stu = new students() &#123; Age = age, Name = name &#125;; Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;, stu.Name, stu.Age, stu.GetHashCode()); return true; &#125;&#125;students stus;bool Isok = studentFactory.studentF(&quot;Tom&quot;, 20, out stus);Console.WriteLine(Isok);Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;, stus.Name, stus.Age, stus.GetHashCode());//通过输出可知两者指向同一对象 数组参数常规中，假若要调用一个形参为数组的方法，必须要先声明一个数组，略显啰嗦，为此提出了 params 关键字。 常规写法： 12345678910111213141516internal class Program&#123; static void Main(string[] args) &#123; int[] arr = new int[] &#123; 1, 2, 3 &#125;; //需事先定义数组方可调用 Console.WriteLine(ArrSum(arr)); &#125; static int ArrSum(int[] arr) &#123; int sum = 0; foreach (var i in arr) sum += i; return sum; &#125;&#125; 只需在方法声明时的形参前加 params 修饰符，调用时直接传入数组元素即可（编译器会自动创建一个数组），无需再新建数组： 123456789101112131415internal class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(ArrSum(1, 2, 3)); //直接传入数组元素 &#125; static int ArrSum(params int[] arr) &#123; int sum = 0; foreach (var i in arr) sum += i; return sum; &#125;&#125; 但要注意的是，必须是形参列表中的最后一个，由 params 修饰，否则编译器无法确定传入参数属于哪个数组。 具名参数 参数位置不再受约束 传入的参数是带有名字的 换句话说，传入的参数没必要按形参的顺序传入，这样做的优点是： 提高代码的可读性 可以按任意顺序传递参数 123456789101112131415161718internal class Program&#123; static void Main(string[] args) &#123; //常规调用 string name = &quot;TOM&quot;; int age = 20; JuMingParam(name, age); //具名参数 JuMingParam(name: &quot;Tom&quot;, age: 20); //可读性更强 JuMingParam(age: 20, name: &quot;Tom&quot;); //不受顺序影响 &#125; static void JuMingParam(string name, int age) &#123; Console.WriteLine(&quot;Hi, &#123;0&#125;, you are &#123;1&#125;&quot;, name, age); &#125;&#125; 可选参数 形参带有默认值的参数 不推荐使用 扩展方法（this 参数）扩展方法的“三必须”： 必须由一个静态类（类名一般为 TypeExtension）统一收纳对 Type 的扩展方法 方法必须是公有、静态的，即被 public static 修饰 必须是形参列表中的第一个，由 this 修饰 以 double 类型为例，若需对一个数据求解精确的小数位数，常规操作为： 123double x = 3.1415926;double y = Math.Round(x, 4);Console.WriteLine(y); 若想对 double 类型扩展出一个 Round 函数，即可通过 this 参数实现： 1234567891011static class DoubleExtension &#123; public static double Round(this double input, int digits) // this 参数 &#123; return Math.Round(input, digits); &#125;&#125;double x = 3.1415926;double y = x.Round(4); //输入时参数只有一个，一个通过 x. 的 this 参数指定了Console.WriteLine(y); 可见，当无法对源码进行修改时，可通过扩展方法对目标类型追加方法，如著名的 LINQ 方法。 委托委托定义 函数指针的升级版 要理解委托，必须先理解一切皆地址： 变量（数据）：以某个地址为起点的一段内存中所存储的值 函数（算法）：以某个地址为起点的一段内存中所存储的一组机器语言指令 对函数的调用： 直接调用：通过函数名调用，CPU 通过函数名直接获得函数所在的地址并执行、返回 间接调用：通过函数指针调用函数，CPU 通过读取函数指针存储的值从而获得函数所在的地址并执行、返回 C# 中已有的两种常见的委托为 Action 和 Func。 Action：只接受返回值为 void 类型函数的委托，带参数时采用泛型 1234567891011121314151617181920212223class CalculatorDelegate&#123; public void Report() &#123; Console.WriteLine(&quot;All 3 Methods&quot;); &#125; public int Add(int x, int y) &#123; return x + y; &#125; public int Sub(int x, int y) &#123; return x - y; &#125;&#125;CalculatorDelegate caldg = new CalculatorDelegate();caldg.Report(); //常规调用Action action = new Action(caldg.Report); //委托给 Actionaction.Invoke(); // 通过委托间接调用action(); // 模仿函数指针的调用 Func：泛型委托，有 17 个重载，其中参数是待委托函数的参数类型，返回值类型 123Func&lt;int,int,int&gt; func = new Func&lt;int, int, int&gt;(caldg.Add); func.Invoke(1, 2);func(1, 2); 委托声明 委托是一种类，类是一种数据类型，故委托也是一种数据类型 声明方式与一般的类不同，主要是照顾可读性和 C/C++ 传统 基于前例，采用自定义委托： 123456789101112131415161718192021222324252627282930313233343536namespace CSharptest2&#123; //自定义委托声明，委托是类，故和类平级 public delegate int Calcudg(int x, int y); internal class Program &#123; static void Main(string[] args) &#123; //自定义委托 CalculatorDelegate caldg = new CalculatorDelegate(); Calcudg calcudg = new Calcudg(caldg.Add); calcudg.invoke(1, 2); calcudg(1, 2); &#125; class CalculatorDelegate &#123; public void Report() &#123; Console.WriteLine(&quot;All 3 Methods&quot;); &#125; public int Add(int x, int y) &#123; Console.WriteLine(x + y); return x + y; &#125; public int Sub(int x, int y) &#123; Console.WriteLine(x - y); return x - y; &#125; &#125;&#125; 由于 C# 也是允许类嵌套的，因而自定义委托也可放置在类中，但辞职该委托已不再是独立的类。 委托使用 把方法当做参数传给另一个方法 模板方法：填空题，委托有返回值，常位于代码中部 回调方法：流水线，委托无返回值，常位于代码末尾 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Product&#123; public string Name &#123;get; set;&#125;&#125;class Box&#123; public Product Product &#123;get; set;&#125;&#125;class WrapFactory&#123; public Box WrapProduct(Func&lt;Product&gt; getProduct) //模板方法 &#123; Product prod = getProduct(); Box box = new Box(); box.Product = prod; return box; &#125;&#125;class ProductFactory&#123; public Product MakePizza() &#123; Product prod = new Product(); prod.Name = &quot;Pizza&quot;; return prod; &#125; public Product MakeToys() &#123; Product prod = new Product(); prod.Name = &quot;Toys&quot;; return prod; &#125;&#125;//调用WrapFactory wf = new WrapFactory();ProductFactory pf = new ProductFactory();Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(pf.MakePizza);Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(pf.MakeToys); Box box1 = wf.WrapProduct(func1);Box box2 = wf.WrapProduct(func2);Console.WriteLine(box1.Product.Name);Console.WriteLine(box2.Product.Name); 可见，不论 ProductFactory 生产什么样的产品，WrapFactory 都会将其打包并输出结果，代码复用性提高。 回调方法也类似，在前例基础上稍作改进即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace CSharptest3&#123; internal class Program &#123; static void Main(string[] args) &#123; WrapFactory wrapFactory = new WrapFactory(); ProductFactory productFactory = new ProductFactory(); Logger logger = new Logger(); Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza); Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeToys); Action&lt;Product&gt; action = new Action&lt;Product&gt;(logger.Log); //log封装进 action Box box1 = wrapFactory.WrapProduct(func1, action); Box box2 = wrapFactory.WrapProduct(func2, action); Console.WriteLine(box1.Product.Name); Console.WriteLine(box2.Product.Name); &#125; &#125; class Product &#123; public string Name &#123; get; set; &#125; public double Price &#123; get; set; &#125; &#125; class Box &#123; public Product Product &#123; get; set; &#125; &#125; class WrapFactory &#123; public Box WrapProduct(Func&lt;Product&gt; getProduct, Action&lt;Product&gt; getLog) // 回调方法用 Action 封装 &#123; Product product = getProduct(); Box box = new Box(); box.Product = product; if(product.Price &gt; 50) &#123; getLog(product); &#125; return box; &#125; &#125; class ProductFactory &#123; public Product MakePizza() &#123; Product pizza = new Product(); pizza.Name = &quot;Pizza&quot;; pizza.Price = 50; return pizza; &#125; public Product MakeToys() &#123; Product toys = new Product(); toys.Name = &quot;Toys&quot;; toys.Price = 100; return toys; &#125; &#125; class Logger //记录日志 &#123; public void Log(Product product) &#123; Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;, product.Name, DateTime.Now, product.Price); &#125; &#125;&#125; 使用委托要小心，防止滥用 委托高级使用多播委托多个委托合并到一个，按合并顺序执行 123456789101112131415161718192021222324252627282930313233class Student&#123; public int ID; public ConsoleColor PenColor &#123; get; set; &#125; public void DrawPic() &#123; for (int i = 0; i &lt; 5; i++) &#123; Console.ForegroundColor = this.PenColor; Console.WriteLine(&quot;Student&#x27;ID : &#123;0&#125;, draw pen &#123;1&#125;&quot;, ID, i); Thread.Sleep(100); &#125; &#125;&#125;Student stu1 = new Student() &#123;ID = 1, PenColor = ConsoleColor.Red&#125;;Student stu2 = new Student() &#123;ID = 2, PenColor = ConsoleColor.Green&#125;;Student stu3 = new Student() &#123;ID = 3, PenColor = ConsoleColor.Blue&#125;;Action action1 = new Action(stu1.DrawPic);Action action2 = new Action(stu2.DrawPic);Action action3 = new Action(stu3.DrawPic);//分别调用action1();action2();action3();//合并调用action1 += action2; // 2 合并到 1action1 += action3; // 3 合并到 1action1(); //只需调用 1 即可全部调用，因 1 封装了 1 2 3 共 3 个方法 隐式异步调用 同步与异步区别 同步：你做完了我在你的基础上接着做（顺序执行，执行完一个再执行下一个，需要等待、协调运行） 异步：两人同时做（彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作） 同步调用与异步调用区别 每个运行的程序为一个进程（process） 每个进程可有一个或多个线程（thread），每个进程运行时最先运行的那个为主线程，其他为分支线程 同步调用是在同一线程内：同步调用是主线程在运行中遇到方法调用时，先停下主线程去执行调用的方法，执行结束后再返回继续执行主线程，如此往复 异步调用则是多个线程之间相互独立，互不影响，其底层机理是多线程 串行——同步——单线程；并行——异步——多线程 前述多播委托即为同步调用。 异步调用实例如下： 123action1.BeginInvoke(null, null); //隐式异步调用，会自动生成分支线程，由于不用执行后续操作，故参数为 nullaction2.BeginInvoke(null, null);action3.BeginInvoke(null, null); 显示异步调用，即自定义多线程： 使用 Thread 显式异步调用： 123456Thread thread1 = new Thread(new ThreadStart(stu1.DrawPic));Thread thread2 = new Thread(new ThreadStart(stu2.DrawPic));Thread thread3 = new Thread(new ThreadStart(stu2.DrawPic));thread1.Start();thread2.Start();thread3.Start(); 也有较高级的异步调用方式，即 Task： 1234567Task task1 = new Task(new Action(stu1.DrawPic));Task task2 = new Task(new Action(stu2.DrawPic));Task task3 = new Task(new Action(stu3.DrawPic));task1.Start();task2.Start();task3.Start(); 若对委托使用不当，会导致代码可读性降低，Debug 也更难，为此，可适当使用 接口 取代一些委托的使用，JAVA 中完全使用接口取代了委托 事件事件概念 定义：Event，能够发生的事情 角色：是对象或类具备通知能力的成员（可见其是类的成员） 使用：用于对象或类间的动作协调与信息传递 原理：事件模型（event model），即 发生-响应 模型 隐含“订阅”关系 被通知的人根据拿到的事件信息（事件数据、事件参数、通知）对事件做出响应（处理事件） 应用：多用于桌面、手机等客户端开发，这类程序靠事件驱动 事件模型事件模型的5个组成部分： 事件的拥有者（event source）：类、对象 事件成员（event）：成员 事件的响应者（event subscriber)：类、对象 事件处理器（event handler）：方法成员，本质是一个回调方法 事件订阅：将事件处理器与事件关联在一起，本质是一个以委托类型为基础的“约定”（+=） 事件需要委托类型作约束，该约束规定了事件能发送什么样的消息给事件的响应者，亦规定了事件响应者能收到什么样的消息 当事件的响应者向事件拥有者提供了事件处理器后，需要将其保存，能够引用方法的也只有委托的实例（对象）了 事件的拥有者、事件的source、事件消息的发送者一致，这也是事件方法参数第一个参数的由来。 1234567891011121314151617181920212223242526using System;using System.Timers;namespace CSharptest3&#123; internal class Program &#123; static void Main(string[] args) &#123; Timers timers = new Timers; timers.Interval = 1000; Boy boy = new Boy(); timers.Elapsed += boy.Action; timer.Start(); Console.ReadLine(); &#125; &#125; class Boy &#123; internal void Action(object sender, ElapsedEventArgs e) &#123; Console.WriteLine(&quot;BOY&quot;); &#125; &#125;&#125; 实例1：事件的响应者（事件处理器）订阅事件的拥有者（事件） 12345678910111213141516171819202122232425262728293031323334using System;using System.Windows.Forms;namespace CSharptest3&#123; internal class Program &#123; static void Main(string[] args) &#123; Form form = new Form(); Controller controller = new Controller(form); form.ShowDialog(); &#125; &#125; class Controller &#123; private Form form; public Controller(Form form) &#123; if(this.form != null) &#123; this.form = form; this.form.Click += this.FormClicked; &#125; &#125; private void FormClicked(object sender, EventArgs e) &#123; this.form.Text = DateTime.Now.ToString(); &#125; &#125;&#125; 实例2：事件的拥有者同时是事件的响应者 1234567891011121314151617181920212223using System;using System.Windows.Forms;namespace CSharptest3&#123; internal class Program &#123; static void Main(string[] args) &#123; MyForm myform = new MyForm; myForm.Click += myForm.Action; myForm.ShowDialog(); &#125; &#125; class MyForm: Form &#123; internal void Action(object sender, EventArgs e) &#123; this.Text = DateTime.Now.ToString(); &#125; &#125;&#125; 实例3：事件的拥有者是事件响应者的一个字段，事件的响应者利用自己的方法订阅事件 123456789101112131415161718192021222324252627class MForm: Form //事件响应者 Form&#123; private TextBox textBox; private Button button; //事件拥有者 button，是 Form 的字段成员 public MForm() &#123; this.textBox = new TextBox(); this.button = new Button(); this.Controls.Add(this.textBox); this.Controls.Add(this.button); this.button.Click += this.ButtonClicked; // click 事件由方法订阅 //this.button.Text = &quot;Clicked&quot;; //this.button.Top = 50; //this.button.AutoSize = true; &#125; // 事件处理器为 Form 的方法 private void ButtonClicked(object sender, EventArgs e) &#123; this.textBox.Text = DateTime.Now.ToString(); &#125;&#125;//调用MForm myForm2 = new MForm();myForm2.ShowDialog(); 事件处理器挂接 事件处理器可重用，但必须和被处理事件保持约束一致 挂接方式1：代码显式挂接 1234567891011121314151617181920212223242526272829303132333435namespace WindowsFormsApp1&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); //事件处理器挂接方式1：方法名 this.button3.Click += button1_Click; //事件处理器挂接方式2：通过委托实例 this.button3.Click += new EventHandler(this.button1_Click); //事件处理器挂接方式3：Lambda 表达式 this.button3.Click += (object sender, EventArgs s) =&gt; &#123; this.textBox1.Text = &quot;Lambda&quot;; &#125;; // Lambda 表达式中，编译器可根据参数自动推断类型，可省略类型 this.button3.Click += (sender, s) =&gt; &#123; this.textBox1.Text = &quot;Lambda&quot;; &#125;; &#125; private void button1_Click(object sender, EventArgs e) &#123; if (sender == this.button1) this.textBox1.Text = &quot;Button1&quot;; if (sender == this.button2) this.textBox1.Text = &quot;Button2&quot;; if (sender == this.button3) this.textBox1.Text = &quot;Button3&quot;; &#125; &#125;&#125; 挂接方式2：在属性-事件面板下，选择相应的事件处理器即可 综上可见，一个事件可挂接多个事件处理器（如前述 Timers 事件），一个事件处理器也可被多个事件挂接（如上述 button1_Click）。 事件处理器对事件的订阅并不是任意的，匹配与否由声明事件时所使用的委托类型来检测，如上列中，button 的 click 事件的委托类型是 EventHandler 对于事件的暂时理解：你去餐馆吃饭，点菜即为事件，服务员拥有事件处理器，一旦你点菜的事件发生，服务员将你点的菜（事件信息）告诉（事件处理器）厨师。 自定义事件 完整声明 要声明事件，需先声明委托，委托是事件的基础，事件是委托的上层建筑。如前列中，button 的 click 事件的委托类型是 EventHandler，但我们自定义事件并没有预制的委托类型，故需先声明委托 据 .NET 的规定，声明事件的委托类型时，委托名以 EventHandler 作为后缀；若需声明事件参数（即传输事件信息）的基础类时，类名以 EventArgs 作为后缀，且需继承 EventArgs 基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112using System;using System.Diagnostics.Tracing;using System.Threading;namespace CSharptest4&#123; internal class Program &#123; static void Main(string[] args) &#123; Customer customer = new Customer(); Waiter waiter = new Waiter(); customer.Order += waiter.Action; customer.Action(); customer.PaytheBill(); &#125; &#125; public class OrderEventArgs: EventArgs //传递事件信息 &#123; public string DishName &#123; get; set; &#125; public string Size &#123; get; set; &#125; &#125; public delegate void OrderEventHandler(Customer customer, OrderEventArgs e); //声明委托类型，事件的基础 public class Customer &#123; private OrderEventHandler e; //声明事件，关键字 event public event OrderEventHandler Order &#123; //事件处理器添加器 add &#123; this.e += value; &#125; //事件处理器移除器 remove &#123; this.e -= value; &#125; &#125; public double Bill &#123; get; set; &#125; public void PaytheBill() &#123; Console.WriteLine(&quot;I will pay $&#123;0&#125;&quot;, this.Bill); &#125; public void Walkin() &#123; Console.WriteLine(&quot;Run into resraunt&quot;); &#125; public void SitDown() &#123; Console.WriteLine(&quot;Sit Down&quot;); &#125; public void Think() &#123; for (int i = 0; i &lt; 5; i++) &#123; Console.WriteLine(&quot;Need Some time to think……&quot;); Thread.Sleep(1000); &#125; //触发事件 if(this.e != null) &#123; OrderEventArgs ea = new OrderEventArgs(); ea.DishName = &quot;GongPao Chicken&quot;; ea.Size = &quot;large&quot;; this.e.Invoke(this, ea); &#125; &#125; public void Action() &#123; Console.ReadLine(); this.Walkin(); this.SitDown(); this.Think(); &#125; &#125; public class Waiter &#123; public void Action(Customer customer, OrderEventArgs e) &#123; Console.WriteLine(&quot;Your Dish - &#123;0&#125;&quot;, e.DishName); double price = 10; switch (e.Size) &#123; case &quot;small&quot;: price *= 0.5; break; case &quot;large&quot;: price *= 1.5; break; default: break; &#125; customer.Bill += price; &#125; &#125;&#125; 简洁声明：无需写事件添加器和移除器，但由于没有了手动声明委托字段，故在调用时使用事件名（实际上编译器会生成委托字段，只是我们没法访问，只能通过事件名访问） 1234567891011//事件简略声明public event OrderEventHandler Order;//触发事件if(this.Order!= null)&#123; OrderEventArgs ea = new OrderEventArgs(); ea.DishName = &quot;GongPao Chicken&quot;; ea.Size = &quot;large&quot;; this.Order.Invoke(this, ea);&#125; 但其实，我们可以不用单独去声明 OrderEventHandler 这个委托类型，而是直接使用 .NET 已有的 EventHandler，其定义如下： 1public delegate void EventHandler(object sender, EventArgs e); 由于 object 是所有类型的基类，故可传入任意类型的参数；此外，定义事件参数 OrderEventArgs 时，继承了 EventArgs 基类，故其亦可接受派生类参数。 1234567891011121314151617181920212223public event EventHandler Order;//此时 waiter 的方法需进行数据类型的转换public void Action(object sender, EventArgs e)&#123; Customer customer = sender as Customer; OrderEventArgs ea = e as OrderEventArgs; Console.WriteLine(&quot;Your Dish - &#123;0&#125;&quot;, ea.DishName); double price = 10; switch (ea.Size) &#123; case &quot;small&quot;: price *= 0.5; break; case &quot;large&quot;: price *= 1.5; break; default: break; &#125; customer.Bill += price;&#125; 此外，上述中的例子也说明，事件只能由事件的拥有者触发，访问级别一般为 protected，防止被“借刀杀人”。前述中，事件是在 Think 方法中触发的，但一般一个方法只做一件事，且触发事件的方法一般命名为 OnMethodName。 1234567891011121314151617181920public void Think()&#123; for (int i = 0; i &lt; 5; i++) &#123; Console.WriteLine(&quot;Need Some time to think……&quot;); Thread.Sleep(1000); &#125; this.OnOrder(&quot;GongPao Chicken&quot;, &quot;Large&quot;);&#125;//触发事件的方法protected void OnOrder(string dishname, string size)&#123; if (this.Order != null) &#123; OrderEventArgs ea = new OrderEventArgs(); ea.DishName = dishname; ea.Size = size; this.Order(this, ea); &#125;&#125; 事件本质 委托字段的一个包装器 该包装器对委托字段的访问起到限制作用，即封装 事件对外界隐藏了委托实例的大部分功能，仅暴露添加、移除事件处理器的功能 类什么是类 一种数据结构 一种数据类型 C# 中的类是一种引用类型，但具体到每个不同的类的时候，又是一种自定义的（引用）类型。 代表现实中的“种类” 构造和析构 静态构造器：（只能）初始化静态成员，如属性或字段 Ｃ# 有 GC （Garbage Collector)，即垃圾回收机制，垃圾回收过程中做的事可以放在析构中 类的声明 一般声明在命名空间里，即使声明在命名空间外，该类也位于是全局命名空间下的 也可以声明在已有的类里面，此时是该已有类的成员（成员类） C# 中类的声明即定义（注意不同于 C++，大多数时候是.h/.hpp声明，.cpp定义） 类的权限 public：可以暴露给其他项目 internal：在本项目中完全可访问，出了本项目无法访问（默认）（限制在同一程序集 assembly中） private：只在嵌套类中可使用 sealed：封闭关键字，修饰后该类不能再作为基类 类的继承 派生类的实例也是基类的实例，即可用基类类型的变量引用派生类类型的实例 C# 规定每个类只能有一个基类 子类的访问级别不能高于基类 派生类的对象，是从基类开始构造，直到该派生类 派生类不继承基类的实例构造器 base. 只能访问派生类的上一级对象 123456789101112131415161718192021Class Vehicle //默认继承 全局基类 object&#123; public Vehicle() &#123; this.Owner = &quot;N/A&quot;; &#125; public string Owner &#123;get; set;&#125;&#125;public Car : Vehicle&#123; public Car() &#123; this.Owner = &quot;Car Owner&quot;; //派生类继承了基类除实例构造器外的所有 &#125; public void ShowOwner() &#123; Console.WriteLine(base.Owner); // base只能访问上一级，即 Vehicle, 但不能访问 Vehicle 的基类 &#125;&#125; 可见，派生类正确构造的前提是基类先被正确构造，上例中，假若基类不再是构造器，则派生类也应做出相应的改变： 12345678910111213141516171819Class Vehicle //默认继承 全局基类 object&#123; public Vehicle(string owner)//含参构造器 &#123; this.Owner = owner; &#125; public string Owner &#123;get; set;&#125;&#125;public Car : Vehicle&#123; //派生类必须把基类构造器的参数传入 public Car(string owner) : base(owner) &#123;&#125; public void ShowOwner() &#123; Console.WriteLine(base.Owner); // base只能访问上一级，即 Vehicle, 但不能访问 Vehicle 的基类 &#125;&#125; 派生类、基类访问级别 public：可以暴露给其他项目 internal：在本项目中完全可访问，出了本项目无法访问（默认）（限制在同一程序集） private：只在本类中可访问（限制在类中）（字段、属性默认值） 变量名前面加 _ ，表示实例字段，且是私有的，相等于 this.varname protected：限制在继承链上，即子类都能访问，但非继承关系的无法访问，且是跨程序集的（即在其他项目中有派生类的话，也是可访问的） 目前还有 internal protected 等组合 重写、隐藏、多态 类似 C++ 虚函数，若基类中的方法可能在派生类中重写，则加 virtual 修饰，在派生类中重写时，加 override 修饰符 方法、属性属于函数成员，均可被重写 派生类的实例调用派生类的方法，基类的实例调用基类的方法 123456789101112131415161718192021class Vehicle&#123; public virtual void Run() &#123; Console.WriteLine(&quot;This is Base&quot;); &#125;&#125;class Car : Vehicle&#123; public override void Run() &#123; Console.WriteLine(&quot;This is Derived &quot;); &#125;&#125;//调用Car car = new Car();car.Run(); //子类的 Run 方法Vehicle vehicle = new Vehicle();vehicle.Run(); // 父类的 Run 方法 前述中提到过，父类也是可以引用子类的实例的，即便是父类的变量，但其引用的是子类的实例，故调用的还是子类的方法，这便是多态，即用父类类型的变量引用子类的实例时，总是调用到最新重写的方法， 12Vehicle vehicle2 = new Car();vehicle2.Run(); //子类的 Run 方法 隐藏则是另一种情况，即在没有 virtual 和 override 修饰时。子父类直接对父类的同名方法进行了隐藏： 12345678910111213141516171819202122232425class Vehicle&#123; public void Run() &#123; Console.WriteLine(&quot;This is Base&quot;); &#125;&#125;class Car : Vehicle&#123; public void Run() &#123; Console.WriteLine(&quot;This is Derived &quot;); &#125;&#125;//调用Car car = new Car();car.Run(); // 子类的 Run 方法，隐藏了父类// 父类的 Run 方法，由于不是重写，直接调用了 父类的方法Vehicle vehicle = new Vehicle();vehicle.Run(); Vehicle vehicle2 = new Car();vehicle2.Run(); 实际项目中一般不会使用隐藏（Hide）！ 上述是对方法的重写，但属性也属于函数成员，故其也是可以重写的： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Vehicle&#123; private int _speed; public virtual int Speed //属性 &#123; get &#123; return _speed / 10; &#125; set &#123; _speed = value; &#125; &#125; public virtual void Run() &#123; _speed = 1000; Console.WriteLine(&quot;Speed =&#123;0&#125;&quot;, Speed); &#125;&#125;public class Car : Vehicle&#123; private int _fuel; public override int Speed //重写属性 &#123; get &#123; return _fuel + 100; &#125; set &#123; _fuel += value; &#125; &#125; public override void Run() &#123; _fuel = 100; Console.WriteLine(&quot;OR = &#123;0&#125;&quot;, Speed); &#125;&#125;//调用Car car = new Car();car.Run();Vehicle vehicle = new Vehicle();vehicle.Run();Vehicle vehicle2 = new Car(); //Car 的实例，调用重写方法vehicle2.Run(); 综上，重写能够发生的条件是： 函数成员：如方法、属性 可见：继承的成员、方法对子类是可见的，如在父类中是 private 则必不能重写 签名一致：方法名/属性名、方法的参数必须一致 抽象类 函数成员未被完全实现的类（众多函数成员中至少有一个未被实现） （类似 C++ 中含有纯虚函数的类） 抽象类与设计原则中的 “开放/关闭” 原则 关系紧密，该原则强调类中应封装一些不变的、稳定的、固定的和确定的成员，而把那些不确定的、有可能改变的成员留给子类去实现 被 abstract 修饰的函数成员不能有任何实现，即没有函数体，对应的类也需用 abstract 修饰，该类也不能被实例化，可用于： 用作基类（其实是转为作基类而生的） 用基类类型的变量引用派生类的实例 为复用而生，专门作为基类使用，也具有解耦功能 12345678910111213141516171819202122abstract class Vehicle //抽象类&#123; public void Stop() &#123; Console.WriteLine(&quot;Vehicle Is Stopped&quot;); &#125; public void Fuel() &#123; Console.WriteLine(&quot;Vehicle Is Fuelling&quot;); &#125; abstract public void Run(); //函数成员不实现&#125;class RaceCar : Vehicle&#123; public override void Run() //子类必须实现基类中的抽象成员 &#123; Console.WriteLine(&quot;RaceCar is Running&quot;); &#125;&#125; 接口初识接口抽象类中部分函数成员是被实现了的，那有没有所有的函数成员均未被实现的类呢？这就是纯抽象类，其作用就是说明这个类可能含有这些功能，即留下接口，让子类去实现（类似 C++），这种情况在 C# 中就是接口 Interface，即纯抽象类 = 接口。 为解耦而生：高内聚，低耦合，方便单元测试 接口亦不能实例化 成员必须是 public 的 接口的产生：自底向上（重构），自定向下（设计） 1234567891011121314151617181920abstract class VehicleBase //纯抽象类&#123; abstract public void Run(); abstract public void Stop(); abstract public void Fuel();&#125;abstract class Vehicle : VehicleBase&#123; public override void Stop() //子类实现 &#123; Console.WriteLine(&quot;Vehicle Is Stopped&quot;); &#125; public override void Fuel() &#123; Console.WriteLine(&quot;Vehicle Is Fuelling&quot;); &#125;&#125; abstract class 换为 interface，且接口要求其成员必须是 public 的，由此上述代码换为接口的写法为： 12345678910111213141516171819202122232425262728293031323334353637interface IVehicle&#123; void Run(); void Stop(); void Fuel();&#125;abstract class Vehicle : IVehicle //实现接口&#123; public void Stop() // 接口实现时无需加 override &#123; Console.WriteLine(&quot;Vehicle Is Stopped&quot;); &#125; public void Fuel() &#123; Console.WriteLine(&quot;Vehicle Is Fuelling&quot;); &#125; abstract public void Run(); // 未实现的方法继续预留&#125;class RaceCar : Vehicle&#123; public override void Run() &#123; Console.WriteLine(&quot;RaceCar is Running&quot;); &#125;&#125;//调用RaceCar raceCar = new RaceCar();raceCar.Run();raceCar.Stop();raceCar.Fuel();Vehicle vehicle = new RaceCar();vehicle.Run(); 关于抽象类和接口的总结说明： 接口和抽象类都是“软件工程产物“ 具体类→抽象类→接口：越来越抽象，内部实现的东西越来越少 抽象类是未完全实现逻辑的类（可以有字段和非 public 成员，它们代表了“具体逻辑”） 抽象类为复用而生：专门作为基类来使用，也具有解耦功能 封装确定的，开放不确定的，推迟到合适的子类中去实现 接口是完全未实现逻辑的“类”（“纯虚类”；只有函数成员：成员全部 public） 接口为解耦而生：“高内聚，低耦合”，方便单元测试 接口是一个“协约”，旱已为工业生产所熟知（有分工必有协作，有协作必有协约） 它们都不能实例化，只能用来声明变量、引用具体类(concrete class)的实例 接口本质是一种契约，一种协议！ 假若有两个不同类型的数组需求和及均值，代码如下： 12345678910111213141516171819202122232425262728293031323334internal class Program&#123; static void Main(string[] args) &#123; int[] arr1 = new int[] &#123; 1, 2, 3, 4, 5 &#125;; ArrayList arr2 = new ArrayList &#123; 1, 2, 3, 4, 5 &#125;; Console.WriteLine(Sum(arr1)); Console.WriteLine(Ave(arr1)); &#125; static int Sum(int[] arr) &#123; int sum = 0; foreach (int i in arr) sum += i; return sum; &#125; static int Ave(int[] arr) &#123; int sum = 0, ave = 0; foreach (int i in arr) &#123; sum += i; ave++; &#125; ave = sum / ave; return ave; &#125; //对 ArrayList 类型再写Sum 和 Ave 函数&#125; 可见，对于不同的类型，同样的功能存在重复，但若采用接口就会方便很多：由于 Sum 和 Ave 内部只要求传入元素满足可迭代性（foreach 循环迭代），而整型数组类型的基类 Array 、ArrayList 实例均实现了 IEnumerable 接口，改接口支持简单迭代，故代码可重写为： 123456789101112131415161718192021222324252627282930313233internal class Program&#123; static void Main(string[] args) &#123; int[] arr1 = new int[] &#123; 1, 2, 3, 4, 5 &#125;; ArrayList arr2 = new ArrayList &#123; 1, 2, 3, 4, 5 &#125;; Console.WriteLine(Sum(arr1)); Console.WriteLine(Ave(arr1)); Console.WriteLine(Sum(arr2)); Console.WriteLine(Ave(arr2)); &#125; static int Sum(IEnumerable arr) //接口 &#123; int sum = 0; foreach (int i in arr) sum += i; return sum; &#125; static int Ave(IEnumerable arr)//接口 &#123; int sum = 0, ave = 0; foreach (int i in arr) &#123; sum += i; ave++; &#125; ave = sum / ave; return ave; &#125;&#125; 依赖和耦合 紧耦合：一个类B完全依赖另一个类A，在 A 类出问题时，B 类无法正常工作 12345678910111213141516171819202122232425262728293031class Engine&#123; public int RPM &#123; get; private set; &#125; public void Work(int gas) &#123; RPM = 1000 * gas; &#125;&#125;class Car&#123; private Engine _engine; //对 Engine 类有了依赖 public Car(Engine engine) &#123; _engine = engine; &#125; public int Speed &#123; get; private set; &#125; public void Run(int gas) &#123; _engine.Work(gas); this.Speed = _engine.RPM / 100; &#125;&#125;// 调用Engine engine = new Engine();Car car = new Car(engine);car.Run(2);Console.WriteLine(car.Speed); 降低耦合度：通过接口，暴露在外的接口一定是稳定可靠的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576interface Iphone&#123; void Dail(); void PicKUp(); void Send(); void Receive();&#125;class NokiaPhone : Iphone&#123; public void Dail() &#123; Console.WriteLine(&quot;Dailling, Hello&quot;); &#125; public void PicKUp() &#123; Console.WriteLine(&quot;Who is this&quot;); &#125; public void Send() &#123; Console.WriteLine(&quot;Are you ok&quot;); &#125; public void Receive() &#123; Console.WriteLine(&quot;Great&quot;); &#125;&#125;class HuaweiPhone : Iphone&#123; public void Dail() &#123; Console.WriteLine(&quot;Dailling, Hello&quot;); &#125; public void PicKUp() &#123; Console.WriteLine(&quot;Who is this&quot;); &#125; public void Send() &#123; Console.WriteLine(&quot;Are you ok&quot;); &#125; public void Receive() &#123; Console.WriteLine(&quot;Great&quot;); &#125;&#125;class Users&#123; private Iphone _phone; public Users(Iphone iphone) &#123; _phone = iphone; &#125; public void UsePhone() &#123; _phone.Dail(); _phone.PicKUp(); _phone.Send(); _phone.Receive(); &#125;&#125;//调用var users = new Users(new HuaweiPhone());//var users = new Users(new NokiaPhone());users.UsePhone(); 可见，用户与手机之间的耦合度大幅降低，用户换手机只需传入手机名，因为不同手机的基本功能是一致的，即功能或服务的提供方是可更换的！ 接口可以有多个基接口，但类只能有一个基类 设计原则详见 SOLID 设计原则 依赖反转原则 单元测试：新建 xUnit 项目（对 .NET Core 兼容性最好），每个类是一个测试用例（这个可以参考开源库中的测试） 可通过 mock 框架简化单元测试 依赖反转是单元测试的基础。 接口隔离原则：调用者不会多调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182namespace CSharptest5&#123; internal class Program &#123; static void Main(string[] args) &#123; var drivers = new Driver(new Car()); drivers.Drive(); &#125; &#125; class Driver &#123; private IVehicle _vehicle; public Driver(IVehicle vehicle) &#123; _vehicle = vehicle; &#125; public void Drive() &#123; _vehicle.Run(); &#125; &#125; #region Interface_Vehicle interface IVehicle &#123; void Run(); &#125; class Car : IVehicle &#123; public void Run() &#123; Console.WriteLine(&quot;Car is running&quot;); &#125; &#125; class Truck : IVehicle &#123; public void Run() &#123; Console.WriteLine(&quot;Truck is Running&quot;); &#125; &#125; #endregion #region Interface_Tank interface ITank &#123; void Run(); void Fire(); &#125; class LightTank : ITank &#123; public void Fire() &#123; Console.WriteLine(&quot;Light Fire!&quot;); &#125; public void Run() &#123; Console.WriteLine(&quot;Light Tank run&quot;); &#125; &#125; class HeavyTank : ITank &#123; public void Fire() &#123; Console.WriteLine(&quot;Heavy Fire!&quot;); &#125; public void Run() &#123; Console.WriteLine(&quot;Heavy tank run&quot;); &#125; &#125; #endregion&#125; 可见，由于在 Driver 类的构造函数是 IVehicle 接口，当我们想通过其访问 Itank 的类时，只能通过修改 Driver 类的 IVehicle 接口类型为 ITank 接口类型，此时问题又出现了，Itank接口的 Fire 方法永远也无法用到，这就说明该接口“胖了”，即该接口封装了两个本质完全不同的方法，应将其拆分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586namespace CSharptest5&#123; internal class Program &#123; static void Main(string[] args) &#123; var drivers = new Driver(new LightTank()); drivers.Drive(); &#125; &#125; class Driver &#123; private IVehicle _vehicle; public Driver(IVehicle vehicle) &#123; _vehicle = vehicle; &#125; public void Drive() &#123; _vehicle.Run(); &#125; &#125; #region Interface_Vehicle interface IVehicle &#123; void Run(); &#125; class Car : IVehicle &#123; public void Run() &#123; Console.WriteLine(&quot;Car is running&quot;); &#125; &#125; class Truck : IVehicle &#123; public void Run() &#123; Console.WriteLine(&quot;Truck is Running&quot;); &#125; &#125; #endregion #region Interface_Tank interface IWeapon &#123; void Fire(); &#125; interface ITank : IVehicle, IWeapon // Tank 继承两个接口 &#123; &#125; class LightTank : ITank &#123; public void Fire() &#123; Console.WriteLine(&quot;Light Fire!&quot;); &#125; public void Run() &#123; Console.WriteLine(&quot;Light Tank run&quot;); &#125; &#125; class HeavyTank : ITank &#123; public void Fire() &#123; Console.WriteLine(&quot;Heavy Fire!&quot;); &#125; public void Run() &#123; Console.WriteLine(&quot;Heavy tank run&quot;); &#125; &#125; #endregion&#125; 当把两个完全不同的功能：Fire 与 Run 分开后，ITank 接口只需同时继承这两个接口即可，此时无需更改 Driver 类（该类只负责 Drive，其他均无法传入），实现了接口分离。 接口显式声明 1234567891011121314151617181920212223242526272829303132#region Interface_Explicityinterface IGentleman&#123; void love();&#125;interface IKiller&#123; void kill();&#125;class WarmKiller : IGentleman, IKiller&#123; public void love() &#123; Console.WriteLine(&quot;Forever!&quot;); &#125; void IKiller.kill() //显式实现接口 &#123; Console.WriteLine(&quot;Explicity Kill&quot;); &#125;&#125;#endregion //调用IKiller killer = new WarmKiller();killer.kill();var wk = (WarmKiller)killer; //可通过类型转换访问wk.love();var wk2 = killer as WarmKiller;wk2.love(); 该例旨在说明，实际案例中，Killer 不会明目张胆的被访问，而是隐藏自己，这个过程可通过显式实现接口解决，显示实现接口后，要调用方法，必须是该类型的变量。 换句话说，显示接口成员属于接口的成员，并不是类的成员，故不能通过类对象直接访问，而是通过接口对象来访问。 反射 反射不是 C# 语言的功能，而是 .NET 框架功能 创建对象不用 new 操作符 泛型初识泛型 避免成员膨胀或类型膨胀 类型膨胀：为实现不同类型的产品，每新增一个产品就增加一个类，导致类的数量快速膨胀 正交性：泛型与类、接口、委托、方法、属性、字段等均有交叉，泛型看做横轴，其它实体看做纵轴的话，它们是正交的，由此形成了泛型类、泛型接口…… 泛型实例 泛型类 123456789101112131415class Apple&#123; public string Color &#123;get; set;&#125;&#125;class AppleBox&#123; public Apple Cargo &#123;get; set;&#125;&#125;// 调用Apple apple = new Apple() &#123;Color = &quot;Red&quot;&#125;;AppleBox applebox = new AppleBox() &#123;Cargo = apple&#125;;Console.WriteLine(applebox.Cargo.Color); 假设该老板后续想卖其它东西，则需为每样东西写一个对应的类及包装盒的类，导致类膨胀。 一个解决的办法是，只定义一种盒子，该盒子可装任意类型的产品： 123456789101112131415161718192021222324class Apple&#123; public string Color &#123; get; set; &#125;&#125;class Book&#123; public string Name &#123; get; set; &#125;&#125;class Box&#123; public object Cargo &#123; get; set; &#125; // object 类型&#125;// 调用Apple apple = new Apple() &#123; Color = &quot;Red&quot; &#125;;Book book = new Book() &#123; Name = &quot;Book&quot; &#125;;Box box1 = new Box() &#123; Cargo = apple &#125;;Box box2 = new Box() &#123; Cargo = book &#125;;Console.WriteLine((box1.Cargo as Apple)?.Color); //若是Apple, 打印 ColorConsole.WriteLine((box2.Cargo as Book)?.Name); 但该方法仍然不是最佳的，泛型类更加合理。 12345678910111213141516171819202122232425class Apple&#123; public string Color &#123; get; set; &#125;&#125;class Book&#123; public string Name &#123; get; set; &#125;&#125;class Box&lt;TCargo&gt; //泛型类，类型参数&#123; public TCargo Cargo &#123; get; set; &#125; &#125;// 调用Apple apple = new Apple() &#123; Color = &quot;Red&quot; &#125;;Book book = new Book() &#123; Name = &quot;Book&quot; &#125;;//泛型特化Box&lt;Apple&gt; box3 = new Box&lt;Apple&gt;() &#123; Cargo = apple &#125;;Box&lt;Book&gt; box4 = new Box&lt;Book&gt; &#123; Cargo = book &#125;;Console.WriteLine(box3.Cargo.Color);Console.WriteLine(box4.Cargo.Name); 泛型接口 若类实现的是泛型接口，该类也是泛型的 123456789101112131415interface IUnique&lt;TID&gt; //泛型接口&#123; TID Id &#123; get; set; &#125;&#125;class Student&lt;TID&gt; : IUnique&lt;TID&gt; //类实现的是泛型接口，该类也是泛型的&#123; public TID Id &#123; get; set; &#125; public string Name &#123; get; set; &#125;&#125;//特化Student&lt;int&gt; student = new Student&lt;int&gt;() &#123; Id = 1 , Name = &quot;LiHua&quot;&#125;;Console.WriteLine(student.Id);Console.WriteLine(student.Name); 也可以在实现接口时特化，此时类不再是泛型的： 123456789101112131415interface IUnique&lt;TID&gt;&#123; TID Id &#123; get; set; &#125;&#125;class Student : IUnique&lt;ulong&gt; //实现时特化&#123; public ulong Id &#123; get; set ; &#125; public string Name &#123; get; set; &#125;&#125;//直接调用Student student2 = new Student() &#123; Id = 2, Name = &quot;LiLei&quot; &#125;;Console.WriteLine(student2.Id);Console.WriteLine(student2.Name); 类型参数 类型参数的数量 上述例子中，泛型的类型参数是单个的，但其也可多个，如字典这个数据结构： 12345IDictionary&lt;int,string&gt; keyValues = new Dictionary&lt;int, string&gt;();keyValues[1] = &quot;LiHua&quot;;keyValues[2] = &quot;LiLei&quot;;Console.WriteLine($&quot;Student Num.1 is &#123;keyValues[1]&#125;&quot;);Console.WriteLine($&quot;Student Num.2 is &#123;keyValues[2]&#125;&quot;); 类型参数自动推断 一个很简单的例子，不同类型的数求和，若用方法实现，每个类型的数据都需要写一个方法，导致成员方法膨胀！ 123456789101112131415static int Sum(int a, int b)&#123; return a + b;&#125;static double Sum(double a, double b)&#123; return a + b;&#125;//调用int a1 = 1, b1 = 10;double a2 = 1.1, b2 = 2.2;Console.WriteLine(Sum(a1, b1));Console.WriteLine(Sum(a2, b2)); 采用泛型可解决上述问题（关于这里可以直接使用＋运算符可参考文档，.NET版本7-8）： 1234567891011static T Sum&lt;T&gt;(T left, T right) where T : INumber&lt;T&gt;&#123; return left + right;&#125;// 调用int a1 = 1, b1 = 10;double a2 = 1.1, b2 = 2.2;Console.WriteLine(Sum(a1, b1));Console.WriteLine(Sum(a2, b2)); 在传入参数时，无需显示特化参数的类型，编译器会自动推荐其类型。 泛型委托 Action 泛型委托：引用没有返回值的方法，特化传入方法形参类型 1234567891011121314151617static void Say(string str)&#123; Console.WriteLine($&quot;Hello, &#123;str&#125;&quot;);&#125;static void Mul(int a)&#123; Console.WriteLine(a * 100);&#125;// 调用Action&lt;string&gt; action1 = Say;action1.Invoke(&quot;LiHua&quot;);action1(&quot;LiHua&quot;);Action&lt;int&gt; action2 = Mul;action2.Invoke(1); Func 泛型委托：泛型参数指代方法形参的类型，最后一个参数为返回值类型 123456789101112131415161718static int Sum(int a, int b)&#123; return a + b;&#125;static double Sum(double a, double b)&#123; return a + b;&#125;//调用//Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(Sum);//var func1 = new Func&lt;int, int, int&gt;(Sum);Func&lt;int, int, int&gt; func1 = Sum;Func&lt;double, double, double&gt; func2 = Sum;Console.WriteLine(func1.Invoke(10, 20));Console.WriteLine(func2.Invoke(10.5, 20.5)); 泛型委托与 Lambda 表达式 对某些功能简单的方法不想声明，而是随调用随声明，且是匿名声明 12Func&lt;int, int, int&gt; func3 = (int a, int b) =&gt; &#123; return a + b; &#125;;Console.WriteLine(func3(10, 20)); 由于声明泛型委托时已经指明了参数类型，故 Lambda 表达式中可省略参数类型： 1Func&lt;int, int, int&gt; func3 = (a, b) =&gt; &#123; return a + b; &#125;; 这样做的好处是，我们不想将简单的功能声明在命名空间中，占用或污染命名空间，而是留给重要的功能。 声明泛型委托：自定义泛型委托 123456789delegate T MyDele&lt;T&gt;(T a, T b); //泛型委托声明static int Add(int a, int b) &#123; return a + b; &#125;static double Mul(double a, double b) &#123; return a * b; &#125;//调用MyDele&lt;int&gt; myDele1 = new MyDele&lt;int&gt;(Add);Console.WriteLine(myDele1(100, 200));MyDele&lt;double&gt; myDele2 = new MyDele&lt;double&gt;(Mul);Console.WriteLine(myDele2(3.0, 5.2)); 自定义委托使用不多，一般使用内置的 Action 和 Func。 partial 类 C# 编译器允许把一个类分成两部分或多部分编写，且每部分都以自己的节奏进行版本更新 减少派生类：使用 partial 类后，不再需要派生，各部分合起来还是基类的名称 允许不同部分用不同的编程语言编写，如 WPF 程序由 C# 和 XAML 语言组成 枚举 目的：有限的约束 本质：限制了取值范围的整数 如一周只有七天，从星期一到星期天，为了正确约束，可用枚举类型，即只能从枚举中选择一个。 1234567enum Week&#123; MON, TUS, Won, //最后一项,可写可不写，建议写，方便下次添加其他项 //…&#125; 枚举默认第一个值为 0，依次递增，也可自定义值。 比特位用法：利用整数的 按位与或 操作 比如一个人同时掌握多项技能（假若这些技能是有限且固定的），可利用整数的比特位操作（如8421这样的整数，对应的二进制的特性）： 123456789101112131415161718192021enum Skill&#123; Drive = 1, Cook = 2, Program = 4, Teach = 8,&#125;class Person&#123; public int ID &#123; get; set; &#125; public string Name &#123; get; set; &#125; public Skill Skill &#123; get; set; &#125;&#125;//调用Person person = new Person();person.Skill = Skill.Cook | Skill.Teach | Skill.Drive | Skill.Program;Console.WriteLine(person.Skill); // 15 = 8+4+2+1//通过按位与的方式判断是否掌握了某种技能Console.WriteLine((person.Skill &amp; Skill.Teach) == Skill.Teach); //True 结构体 值类型 对象之间的赋值是完整的赋值一份，相互不会影响 123456789101112struct Students&#123; public int ID &#123; get; set; &#125; public string Name &#123; get; set; &#125;&#125;Students students1 = new Students() &#123; ID = 1, Name = &quot;Hua&quot; &#125;;Students students2 = students1; //赋值，是两个独立的对象students2.Name = &quot;Lei&quot;; //不会改变 students1 的属性students2.ID = 2;Console.WriteLine($&quot;Num:&#123;students1.ID&#125;, Name: &#123;students1.Name&#125;&quot;);Console.WriteLine($&quot;Num:&#123;students2.ID&#125;, Name: &#123;students2.Name&#125;&quot;); 可以实现接口 123456789101112131415161718interface ISpeak&#123; void Speak();&#125;struct Students:ISpeak&#123; public int ID &#123; get; set; &#125; public string Name &#123; get; set; &#125; public void Speak() &#123; Console.WriteLine($&quot;I&#x27;m Num &#123;this.ID&#125; student &#123;this.Name&#125;&quot;); &#125;&#125;Students students1 = new Students() &#123; ID = 1, Name = &quot;Hua&quot; &#125;;students1.Speak(); 可以从接口派生：结构体不能有基结构体，即结构体不能从其他类或结构体派生而来，但可从接口派生 不能拥有显式无参构造器，但允许显式有参构造器 123456789101112131415161718192021222324252627interface ISpeak&#123; void Speak();&#125;struct Students:ISpeak&#123; //public Students() //不允许显示无参 //&#123; //&#125; public Students(int id, string name) //允许显式有参 &#123; this.ID = id; this.Name = name; &#125; public int ID &#123; get; set; &#125; public string Name &#123; get; set; &#125; public void Speak() &#123; Console.WriteLine($&quot;I&#x27;m Num &#123;this.ID&#125; student &#123;this.Name&#125;&quot;); &#125;&#125;Students students = new Students(3,&quot;May&quot;);students.Speak(); Lambda 表达式 一种 inline （调用时才声明）的匿名方法 省略函数名，直接给出参数，通过符号 =&gt; 给出函数体，意为将参数带入符号后表达式或函数体 1234Func&lt;int, int, int&gt; func = new Func&lt;int, int, int&gt;((int a, int b) =&gt; &#123; return a * b; &#125;);Console.WriteLine(func(10, 5));func = new Func&lt;int, int, int&gt;((a,b) =&gt; &#123; return a + b; &#125;);//可重用Console.WriteLine(func(10, 5)); 上述写法略显冗余，实际中常用简洁的写法： 123//简洁写法，常用Func&lt;int, int, int&gt; func = (int a, int b) =&gt; &#123; return a * b; &#125;;func = (a,b) =&gt; &#123; return a + b; &#125;; //重用 可见，既然可以直接把 Lambda 表达式赋值给泛型委托类型的实例，那么，假若有个函数的参数是泛型委托实例，则可以直接传入 Lambda 表达式。 123456789static void DoSTH&lt;T&gt;(Func&lt;T, T, T&gt; func, T x, T y)&#123; Console.WriteLine(func(x, y));&#125;//调用DoSTH&lt;int&gt;((int a, int b) =&gt; &#123; return a * b; &#125;, 100, 200);//由于传入的 100， 200 为整型，编译器会自动推荐其类型，故简化为：DoSTH((a, b) =&gt; &#123; return a + b; &#125;, 100, 200); LINQ数据访问 LINQ2SQL：集成于 .NET，功能不强 EF（ADO.NET）：独立于 .NET，功能强大 本质是通过 C# 进行数据库的访问，底层还是将 C# 转为了 SQL 具体方法参考微软文档：直接传入 Lambda 表达式 Windows 窗体 窗体是 Windows 应用程序的基本单元 窗体也是对象，窗体类定义了生成窗体的模板，每实例化一个窗体类，就产生一个窗体 .NET框架类库的 System.Windows.Forms 命名空间中定义的 Form 类是所有窗体类的基类 窗台常用方法 Show：显示窗体 12public void Show()public void Show(IWin32Window owner) Hide：隐藏窗体 1public void Hide() Close：关闭窗体 1public void Close() 窗体常用事件 Load：窗体加载 1private void Form1_Load(object sender, EventArgs e) &#123;&#125; FormClosing：窗体关闭时触发 1private void Form1Closing(object sender, FormClosingEventArgs e) &#123;&#125; ＭDI 窗体 父子窗体设置 设置父窗体：属性面板中，将 IsMdiContainer 属性设置为 True 子窗体：form.MdiParent = this 子窗体排列 通过使用带有 MdiLayout 枚举的 LayoutMdi 方法来排列多文档界面父窗体中的子窗体 123456public void LayoutMdi(MdiLayout value)// 调用LayoutMdi(MdiLayout.TileHorizontal); // 水平平铺LayoutMdi(MdiLayout.TileVertical); // 垂直平铺LayoutMdi(MdiLayout.Cascade); // 层叠排列 继承窗体 作用：将一个窗体的全部功能继承 方法： 修改继承类：直接在代码后面添加要继承的窗体 使用 VS 继承选取器：添加-窗体-继承的窗体 继承前必须先编译，再添加继承项 继承后的窗体控件默认锁定无法修改，需修改基窗体的 Modifiers 属性，由 private 改为 public（修改后编译生效） 控件控件概述 控件是带有可视化表示形式的组件（空间是可视化的，组件是不可视化的） Control 类是定义控件的基类（该基类的命名空间System.Windows.Forms） 常用控件以下控件内容、属性、事件均可在属性中修改 Label：标签控件，显示用户不能编辑的文本 123//可直接在属性中修改this.label1.Text = &quot;输入&quot;;this.label1.Visible = false; Button：按钮控件 TextBox：文本框控件，获取用户输入数据或显示文本（可编辑文本，也可为只读控件，可多行） 1234this.textBox1.Multiline = true;this.textBox1.PasswordChar = &#x27;*&#x27;;this.textBox1.ReadOnly = true;private void textBox1_TextChanged(object sender, EventArgs e) &#123;&#125; //事件 RichTextBox：显示、输入、操作带格式文本 12345678910richTextBox1.SelectionFont = new Font(&quot;宋体&quot;, 12, FontStyle.Bold);richTextBox1.SelectionColor = Color.Red;richTextBox1.Text = &quot;www.byd.com&quot;;richTextBox1.SelectionBullet = true; //段落样式richTextBox1.SelectionIndent = 10; //设置距离左边距离private void richTextBox1_LinkClicked(object sender, LinkClickedEventArgs e) //超链接点击事件&#123; System.Diagnostics.Process.Start(e.LinkText);&#125; ComboBox：下拉组合框控件 12345678this.comboBox1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList; //可在属性中设置private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)&#123; //SelectedItem 获取用户选中项 MessageBox.Show(comboBox1.SelectedItem.ToString());&#125; CheckBox：是否选取了某个控件 1234567891011private void checkBox1_CheckedChanged(object sender, EventArgs e)&#123; //if (checkBox1.Checked) //&#123; // MessageBox.Show(&quot;Clicked!&quot;); //&#125; if (checkBox1.CheckState == CheckState.Checked) &#123; MessageBox.Show(&quot;Clicked!&quot;); &#125;&#125; RadioButton：单选按钮控件（多个控件只能选一个） 12345private void radioButton1_CheckedChanged(object sender, EventArgs e)&#123; if (radioButton1.Checked == true) MessageBox.Show(&quot;YES&quot;);&#125; NumericUpDown：数字按钮调节 12numericUpDown1.Value = 10; //设置或获取默认值，0~100numericUpDown1.DecimalPlaces = 2; //小数点位数 ListBox：列表控件，显示一个列表，用户可选择一项或者多项 12listBox1.Items.Add(&quot;UPDOWN&quot;);listBox1.Items.Remove(&quot;UPDOWN&quot;); Panel：分组窗体，批量控制控件的隐藏和显示（panel 内部的所有空间隐藏或显示） 12panel1.Hide();panel1.Show(); GroupBox：分组框 TabControl：选项卡 1234567891011// 在选项卡中添加控件System.Windows.Forms.Button btn = new System.Windows.Forms.Button();btn.Text = &quot;New Button&quot;;tabPage2.Controls.Add(btn);//选项卡的添加删除TabPage tabPage = new TabPage(&quot;New 1&quot;);//tabPage.Text = &quot;New1&quot;;tabControl1.TabPages.Add(tabPage);tabControl1.TabPages.Remove(tabControl1.SelectedTab);tabControl1.TabPages.Clear(); MenuStrip：菜单栏，支持多文档、菜单合并、工具提示等诸多功能 快捷键设置：直接在 Text 属性中的文字后添加 (&amp;快捷键) ToolStrip：工具栏 StatusStrip：状态栏，显示窗体上一些对象的相关信息，通常放置在窗体最底部 高级控件 ImageList：存储图片资源并在控件上显示，可通过属性设置 ListView：列表视图 TreeView：树形 ErrorProvider：不打扰用户的情况下提示用户，是组件 Timer：计时器组件，定期触发事件 时间间隔长度由 Interval 属性定义，单位为 ms 启用该组件后，间隔触发 Tick 事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using Microsoft.VisualBasic; //使用 DateAndTime 所需DateTime dtNow, dtSet;private void Form3_Load(object sender, EventArgs e)&#123; timer1.Interval = 1000; //设置 timer1 计时器执行时间间隔 timer1.Enabled = true; //启动 timer1 计时器 = timer1.start; numericUpDown1.Value = DateTime.Now.Hour; numericUpDown2.Value = DateTime.Now.Minute; numericUpDown3.Value = DateTime.Now.Second; numericUpDown1.Maximum = 24; numericUpDown2.Maximum = 59; numericUpDown3.Maximum = 59;&#125;private void button1_Click(object sender, EventArgs e)&#123; if (button1.Text == &quot;设置&quot;) &#123; button1.Text = &quot;停止&quot;; timer2.Start(); &#125; else if (button1.Text == &quot;停止&quot;) &#123; button1.Text = &quot;设置&quot;; timer2.Stop(); label7.Text = &quot;已停止计时&quot;; &#125;&#125;private void timer1_Tick(object sender, EventArgs e)&#123; label2.Text = DateTime.Now.ToString(); dtNow = Convert.ToDateTime(label2.Text);&#125;private void timer2_Tick(object sender, EventArgs e)&#123; dtSet = Convert.ToDateTime(numericUpDown1.Value + &quot;:&quot; + numericUpDown2.Value + &quot;:&quot; + numericUpDown3.Value); long countdown = DateAndTime.DateDiff(DateInterval.Second, dtNow, dtSet, FirstDayOfWeek.Monday); if (countdown &gt; 0) label7.Text = &quot;倒计时&quot; + countdown + &quot;秒&quot;; else label7.Text = &quot;倒计时结束&quot;;&#125; ProgressBar：进度条 Value：获取进度条进度 Minimum：设置最小值 Maximum：设置最大值 Step：进度条递增值 PerformStep：按照上述属性递增进度 1234567progressBar1.Value = 0;progressBar1.Minimum = 0;progressBar1.Maximum = 100;progressBar1.Step = 1; //步长// 递增进度for (int i = 0; i &lt; progressBar1.Maximum; i++) progressBar1.PerformStep(); 由于该控件只能以水平方向显示，若想改变显示样式，可通过ProgressBarRender类实现。 DataGridView：数据表格控件，以表格形式显示数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//属性控制：不允许用户增加、删除行dataGridView1.AllowUserToAddRows = false; dataGridView1.AllowUserToDeleteRows = false;dataGridView1.RowHeadersVisible = false; //去除行表头列，默认是空白conn = new SqlConnection(strCon);sqlDataAdapter = new SqlDataAdapter(&quot;select * from tb1&quot;, conn);ds = new DataSet();sqlDataAdapter.Fill(ds);//int k = ds.Tables.Count;//var k = dataGridView1.Rows.Count;dataGridView1.DataSource = ds.Tables[0];//遍历所有行禁止按列排序for (int i = 0; i &lt; dataGridView1.Columns.Count; i++) dataGridView1.Columns[i].SortMode = DataGridViewColumnSortMode.NotSortable;//设置整行选中dataGridView1.SelectionMode = DataGridViewSelectionMode.FullRowSelect;//设置隔行不同色显示foreach (DataGridViewRow dgvRow in dataGridView1.Rows)&#123; if (dgvRow.Index % 2 == 0) dataGridView1.Rows[dgvRow.Index].DefaultCellStyle.BackColor = Color.LightSalmon; else dataGridView1.Rows[dgvRow.Index].DefaultCellStyle.BackColor = Color.LightGreen;&#125;dataGridView1.ReadOnly = true; //只读dataGridView1.DefaultCellStyle.SelectionBackColor = Color.LightSkyBlue; //选中行背景色//单击单元格任意部分发生事件private void dataGridView1_CellClick(object sender, DataGridViewCellEventArgs e)&#123; if (e.RowIndex &gt;= 0)//RowIndex 从0开始，如5行，则为 0~4 &#123; //获取选中行的第一个单元格中的值 int selectID = (int)dataGridView1.Rows[e.RowIndex].Cells[0].Value;//获取选中的行号 conn = new SqlConnection(strCon); //设置选中行显示在控件中 sqlDataAdapter = new SqlDataAdapter(&quot;select * from tb1 where id = &quot; + selectID + &quot;&quot;, conn); ds = new DataSet(); sqlDataAdapter.Fill(ds); if (ds.Tables[0].Rows.Count &gt; 0) &#123; textBox3.Text = ds.Tables[0].Rows[0][0].ToString(); textBox4.Text = ds.Tables[0].Rows[0][1].ToString(); &#125; &#125;&#125; 数据库访问SQLSQL 语言 不区分大小写 只识别一个空格 可换行 可写注释（/**/） SQL 语法 数据库、表的创建 12345create database db_name //创建数据库create table table_name( 列名1 数据类型, 列名2 数据类型,) 增删改查 假设我们已建数据库 db，建表 tb，表中有两个字段：id, name： 1234567insert into tb(id, name) values(1, &#x27;小李&#x27;)select * from tb where id = 1update tb set name = &#x27;小李&#x27; where id = 1delete from tb where id = 1 ADO.NET 对象模型对象模型 微软 .NET 数据库的访问框架 数据库应用程序和数据源之间的桥梁 对象模型： 数据源 Connection 对象：提供与数据库的链接功能 1234567891011string sqlstr = &quot;Server = LAPTOP-K9IFEVSM; DataBase = db2; uid = sa; pwd = 123&quot;;SqlConnection conn = new SqlConnection(sqlstr);conn.Open();if (conn.State == ConnectionState.Open) &#123; MessageBox.Show(&quot;SS On!&quot;); conn.Close();&#125;if (conn.State == ConnectionState.Closed) MessageBox.Show(&quot;SS Down!&quot;); Command 对象：返回数据、修改数据、运行存储过程、发送数据库命令等 用于对数据源进行增删改查等操作，SqlCommand 使用 Command 对象调用 sql 语句操作对象 1234567891011121314151617181920212223string sqlstr = &quot;Server = LAPTOP-K9IFEVSM; DataBase = db; uid = sa; pwd = 123&quot;;SqlConnection conn = new SqlConnection( sqlstr );string str_sql = &quot;insert into tb1(id, name) values(&quot; + Convert.ToInt16(textBox1.Text) + &quot;, &#x27;&quot; + textBox2.Text + &quot;&#x27;)&quot;;SqlCommand sqlcomm = new SqlCommand(str_sql, conn);conn.Open();int k = sqlcomm.ExecuteNonQuery(); //执行 SQL 语句并返回受影响的行数if (k &gt; 0) label1.Text = &quot;添加成功&quot;;else label1.Text = &quot;添加失败&quot;;conn.Close();string sqlstr = &quot;Server = LAPTOP-K9IFEVSM; DataBase = db; uid = sa; pwd = 123&quot;;SqlConnection sqlconn = new SqlConnection(sqlstr);string sqlstr1 = &quot;delete from tb1 where id = 15&quot;;SqlCommand sqcomm1 = new SqlCommand(sqlstr1, sqlconn);sqlconn.Open();int k = sqcomm1.ExecuteNonQuery();if (k &gt; 0) label1.Text = &quot;删除成功&quot;;else label1.Text = &quot;删除失败&quot;;sqlconn.Close(); 使用 Command 对象调用存储过程 在调用存储过程前，必须现在数据库中创建该过程 12345678910111213141516171819SqlConnection sqlconn = new SqlConnection(&quot;Server = LAPTOP-K9IFEVSM; DataBase = db; uid = sa; pwd = 123&quot;);//string str_sql = &quot;insert into tb1(id, name) values(&quot; + Convert.ToInt32(textBox1.Text) + &quot;, &#x27;&quot; + textBox2.Text + &quot;&#x27;)&quot;;SqlCommand sqlcmd = new SqlCommand();sqlcmd.Connection = sqlconn; //指定数据库连接对象sqlcmd.CommandType = CommandType.StoredProcedure; // 执行过程为存储过程sqlcmd.CommandText = &quot;proc_AddData&quot;; //假设已经在数据库中创建了该过程//存储过程的参数sqlcmd.Parameters.Add(&quot;@id&quot;, SqlDbType.Int).Value = Convert.ToInt64(textBox1.Text); sqlcmd.Parameters.Add(&quot;@name&quot;, SqlDbType.NVarChar, 50).Value = textBox2.Text;if(sqlconn.State == ConnectionState.Closed) sqlconn.Open();int k = sqlcmd.ExecuteNonQuery();if (k &gt; 0) label1.Text = &quot;OK&quot;;else label1.Text = &quot;NG&quot;;sqlconn.Close(); 存储过程较直接使用 SQL 语句快，且能保证数据的安全，推荐使用。 DataReader 对象：通过 Command 对象从数据库检索信息，只读、向前、快速的访问 读取数据时，必须保持与数据库的链接，故也称为连线模式 1234567891011121314SqlConnection sqlConnection = new SqlConnection(&quot;server = LAPTOP-K9IFEVSM; DataBase = db; uid = sa; pwd = 123&quot;);SqlCommand sqlcmd = new SqlCommand(&quot;select * from tb1 order by id desc&quot;, sqlConnection);sqlConnection.Open();SqlDataReader reader = sqlcmd.ExecuteReader();if(reader.HasRows)&#123; while (reader.Read()) &#123; //DataReader 对象的列索引获取读取到的值 richTextBox1.Text += reader[&quot;id&quot;] + &quot; &quot; + reader[&quot;name&quot;] + &quot;\\n&quot;; &#125;&#125;reader.Close(); //使用后关闭sqlConnection.Close(); DataAdapter 对象：链接数据集 DataSet 对象的桥梁，专门为 DataSet 对象服务（会自动打开数据库连接和关系） 通过 Command 对象执行 SQL 语句，从而从数据源中检索数据，并将检索到的结果集填充到 DataSet 对象中（Fill 方法） 1234567string strCon = &quot;server = LAPTOP-K9IFEVSM; DataBase = db; uid = sa; pwd = 123&quot;;SqlConnection sqlCon = new SqlConnection(strCon);string strSql = &quot;select * from tb1 order by id asc&quot;;SqlDataAdapter adapter = new SqlDataAdapter(strSql, sqlCon);DataSet ds = new DataSet();adapter.Fill(ds, &quot;tbtmp&quot;);dataGridView1.DataSource = ds.Tables[&quot;tbtmp&quot;]; 把用户对 DataSet 对象做出的更改写入到数据源中 DataSet 对象：数据库容器，包括 Data Table 对象 支持 ADO.NET 断开式、分布式数据方案的核心对象，是实现非连接数据查询的核心组件 是创建在内存中的一个小型关系数据库 一个 DataSet 对象包含一组 DataTable 对象和 DataRelation 对象，其中DataTable对象由 DataColumn、DataRow、Constraint 集合对象组成 数据访问命名空间 System.Data：提供对 ADO.NET 结构类的访问 System.Data.Common：包含各种 .NET 框架的共享类 System.Data.SqlClient：sql 服务器 .NET 框架数据提供程序，用于在托管空间中访问 SQL Server 数据库的类集合 System.Data.SqlTypes：提供 SQL Server 中本机数据类型的类 Entity Framework创建、增删改查 文件及数据流技术 命名空间：System.IO 文件基本操作File 类 支持对文件基本操作，包括提供用于创建、复制、删除、移动和打开文件的静态方法；并协助创建 FileStream 对象 若只执行一个操作， File 方法效率可能高于 FileInfo 实例方法 FileInfo 类 诸多方法和 File 类相同，但其没有静态方法，仅可用于实例化对象 判断文件存在与否12public static bool Exists(string path) //File 类public override bool Exists &#123;get;&#125; // FileInfo 类属性 123456bool isexists = File.Exists(@&quot;C:\\config.ini&quot;);Console.WriteLine(isexists);FileInfo fileInfo = new FileInfo(@&quot;C:\\config.ini&quot;);if (fileInfo.Exists) Console.WriteLine(&quot;OK&quot;); 创建文件12public static FileStream Create(string path) //File 类public FileStream Create() //FileInfo 类 123File.Create(@&quot;G:\\1.txt&quot;);FileInfo fileInfo1 = new FileInfo(@&quot;G:\\2.txt&quot;);fileInfo1.Create(); 复制文件12public static void Copy(string sourceFileName, string destFileName)//File类public FileInfo CopyTo(string DestFileName) //FileInfo 类 12File.Copy(&quot;G:\\\\1.txt&quot;, &quot;E:\\\\1.txt&quot;);fileInfo1.CopyTo(&quot;E:\\\\1.txt&quot;); 移动文件12public static void Move(string sourceFileName, string destFileName) //File类public void MoveTo(string destFileName) //FileInfo 类 12File.Move(&quot;G:\\\\1.txt&quot;, &quot;E:\\\\1.txt&quot;);fileInfo1.MoveTo(&quot;E:\\\\2.txt&quot;); 删除文件12public static void Delete(string path) //File类public override void Delete() //FileInfo 类 12File.Delete(&quot;E:\\\\1.txt&quot;);fileInfo1.Delete(); 获取文件信息 Name：获取文件名 FullName：获取文件完整目录，包括文件名 DirectoryName：获取文件完整路径 IsReadOnly：获取文件是否只读 CreationTime：获取文件创建时间 Length：获取文件大小 1234567891011121314151617private void button1_Click(object sender, EventArgs e)&#123; if(openFileDialog1.ShowDialog() == DialogResult.OK) &#123; textBox1.Text = openFileDialog1.FileName; FileInfo fileInfo = new FileInfo(textBox1.Text); if(fileInfo.Exists) &#123; string filename = fileInfo.Name; string filefullname = fileInfo.FullName; string filecreatetime = fileInfo.CreationTime.ToString(); long filesize = fileInfo.Length; string isreadonly = fileInfo.IsReadOnly.ToString(); MessageBox.Show($&quot;文件名：&#123;filename&#125; \\n 路径：&#123;filefullname&#125; \\n 创建时间：&#123;filecreatetime&#125; \\n 文件大小：&#123;filesize&#125; \\n 是否只读：&#123;isreadonly&#125;&quot;); &#125; &#125;&#125; 文件夹基本操作 Directory 类：静态类，文件夹的操作，复制、移动、重命名、创建、删除等，也可获取上述操作的 DateTime 信息 DirectoryInfo 类：实例化后使用，方法和 Directory 类类似，其常用属性如下： 判断文件夹是否存在12public static bool Exists(string path) //Directory 类public override bool Exists&#123;get;&#125; //DirectoryInfo 类 创建文件夹1234public static DirectoryInfo CreateDirectory(string path) //Directory 类//DirectoryInfo 类public void Create()public void Create(DirectrySecurity directorySecurity) //文件夹访问权限 移动文件夹移动时根目录必须一致，如 C 盘移动到 C 盘，不能移动到 D！ 12public static void Move(string sourceDirName, string destDirName)//Directory 类public void MoveTo(string destDirName) //DirectoryInfo 类 删除文件夹1234public static void Delete(string path)//Directory 类//DirectoryInfo 类public override void Delete()public void Delete(bool recurisive) //是否删除子文件夹 遍历文件夹 使用 DirectoryInfo 类 GetDirectories：返回当前目录的子目录 GetFiles：返回当前目录的文件列表 GetFileSystemInfos：检索表示当前目录的文件和子目录的强类型 FileSystemInfo 对象的数组 1234567891011121314151617181920212223242526listView1.Items.Clear();if (folderBrowserDialog1.ShowDialog() == DialogResult.OK) //文件夹浏览&#123; textBox1.Text = folderBrowserDialog1.SelectedPath; DirectoryInfo info = new DirectoryInfo(textBox1.Text); FileSystemInfo[] fileSystemInfos = info.GetFileSystemInfos();//返回数组 //FileInfo[] systemInfos = info.GetFiles(); //DirectoryInfo[] dirs = info.GetDirectories(); foreach (FileSystemInfo fsi in fileSystemInfos) &#123; if (fsi is DirectoryInfo)//是否是文件夹 &#123; DirectoryInfo dfo = new DirectoryInfo(fsi.FullName); listView1.Items.Add(dfo.Name); listView1.Items[listView1.Items.Count - 1].SubItems.Add(dfo.FullName); &#125; else &#123; FileInfo fileInfo = new FileInfo(fsi.FullName); listView1.Items.Add(fileInfo.Name); listView1.Items[listView1.Items.Count - 1].SubItems.Add(fileInfo.FullName); &#125; &#125;&#125; 文件流FileStream 类FileStream 类，常用属性及方法如下： 文本文件读写StreamWriter类和StreamReader类 网络编程技术网络协议 TCP UDP 反馈数据是否送达，可靠 无任何反馈，不可靠 需创建连接请求，连接成功后发数据，效率低 不创建连接请求，直接发数据，效率高 端口 port：类似办事大厅不同的窗口，实现分流 计算机端口的取值范围在 0~65535 之间，但一般写程序时取在 1024 以上，以下的留给较知名的网络服务和应用 IP 地址封装 IP地址格式（IPv4）：192.168.0.1（0.0.0.0~255.255.255.255） 本地回送地址：127.0.0.1（不进行网络传输，返回计算机本地） 命名空间：System.Net Dns 类类 Dns 是一个静态类，提供简单的域名解析功能 1public static class Dns 12345678910string hostName = Dns.GetHostName();Console.WriteLine(hostName);IPHostEntry iPHostEntry = Dns.GetHostEntry(hostName);string hostname = iPHostEntry.HostName;Console.WriteLine(hostname);IPAddress[] iPAddresses = iPHostEntry.AddressList;foreach (var item in iPAddresses)&#123; Console.WriteLine(item);&#125; IPAddress 类IPAddress类包含 IP 网络上的计算机的地址，提供 Internet 协议 (IP) 地址。 1public class IPAddress IPHostEntry 类类 IPHostEntry 将域名系统 (DNS) 主机名与别名数组和匹配的 IP 地址数组相关联，为 Internet 主机地址信息提供容器类。 1public class IPHostEntry 12IPHostEntry iph = Dns.GetHostEntry(&quot;baidu.com&quot;);Console.WriteLine(iph.AddressList.ElementAt(0)); 套接字 socket：提供给程序可以对外进行连接的接口，类似一个插座，程序调用其方法实现联网 命名空间：System.Net.Sockets Sockets 类Socket 类用于管理连接，实现 Berkeley 通信端套接字接口。提供了一组丰富的方法和属性。 TcpClient 类通过网络来连接、发送、接收流数据 TcpListener 类监听和接收传入的连接请求 UdpClient 类发送和接收无连接 UDP 数据报","categories":[{"name":"C#","slug":"C","permalink":"https://hbroad.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://hbroad.github.io/tags/C/"}]},{"title":"机器视觉—Halcon","slug":"图像处理/机器视觉—Halcon","date":"2023-05-15T13:03:05.000Z","updated":"2023-06-01T09:39:08.449Z","comments":true,"path":"halcon_mv/","link":"","permalink":"https://hbroad.github.io/halcon_mv/","excerpt":"","text":"参考课程：河南理工大学-苏波-机器视觉 ROI获取 可直接通过交互程序进行创建 通过程序创建 123read_image(Image, &#x27;printer_chip/printer_chip_01&#x27;)gen_rectangle1(Rectangle, 30, 20, 100, 200) * 绘制一个矩形reduce_domain(Image, Rectangle, ImageReduced) * 抠出给定矩形位置和大小的部分 也可通过交互式窗口，由用户决定绘制的位置： 1234567read_image(Image, &#x27;printer_chip/printer_chip_01&#x27;)get_image_size(Image, Width, Height)dev_open_window(0, 0, Width, Height, &#x27;black&#x27;, WindowHandle)dev_display(Image)draw_rectangle1(WindowHandle, Row1, Column1, Row2, Column2)gen_rectangle1(Rectangle, Row1, Column1, Row2, Column2)reduce_domain(Image, Rectangle, ImageReduced) dev_display() 显示图片时无需指定窗口句柄，但其保持就近原则，若同时打开了多个窗口，可通过 dev_set_window() 指定要显示窗口的句柄 reduce_domain() 计算原图与ROI的交集，但输出结果并未改变 ROI 的大小，即输出图像的大小和原图大小一致 图像的变换与校正几何变换理论 基本变换：平移、旋转、缩放 几种变换的直观解释 相似变换 变换过程中形状不变，大小、方向、位置可变 可分解为 等比例缩放、平移、旋转 的组合 \\begin{bmatrix} x’ \\\\y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} sR & t \\\\ 0 & 1\\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1\\\\\\end{bmatrix}仿射变换 变换过程中保持直线和平行线不变 可分解为 缩放、平移、旋转、切变 组合 \\begin{bmatrix} x’ \\\\y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} a & b & c \\\\ d & e & f \\\\ 0 & 0& 1\\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1\\\\\\end{bmatrix}投影变换 直线映射为直线，但不一定保证平行度 仿射变换是投影变换的特例 又叫单应性变换：是同一物体在不同视角，在像素坐标系下的变换 \\begin{bmatrix} x’ \\\\y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} A_{2\\times2} & T_{2\\times1}\\\\ V^T & s \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1\\\\\\end{bmatrix}式中，$A{2\\times2}$ 表示仿射变换，$T{2\\times1}$ 表示平移变换。 此外，$V^T=[v_1, v_2]$ 表示一种“变换后的边缘交点”关系， 如一个方形像素经过 $V^T=[v_1, v_2]$ 变换后不再是方形： $s$ 是一个与 $V^T$ 相关的缩放因子，其具体表达为： \\begin{bmatrix} 1 & 0 & 0\\\\ 0 & 1 & 0\\\\ v_1 & v_2 & s \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1\\\\\\end{bmatrix} = \\begin{bmatrix} x \\\\y \\\\ v_1x+v_2y+s \\end{bmatrix} \\Longleftrightarrow \\begin{bmatrix} \\frac{x}{v_1x+v_2y+s} \\\\ \\frac{y}{v_1x+v_2y+s} \\\\ \\end{bmatrix}单应性变换矩阵虽然有 9 个参数，但其实际自由度是 8。 由于一对同名点仅能确定两个方程，故 8 个未知数至少需要 4 组同名点，该矩阵的具体求解过程见课程。 Halcon 算子以下算子以 2D 为例，3D 只是齐次矩阵为 4*4，其他同理。 平移算子对一个 2D 齐次变换矩阵 HomMat2D 进行平移，返回平移后的结果 HomMat2DTranslate 1hom_mat2d_translate( : : HomMat2D, Tx, Ty : HomMat2DTranslate) 该函数的具体作用机理是，在一个单位变换矩阵中添加平移项（平移向量 $t = (T_x, T_y)$），可用公式表达为： \\text{HomMat2DTranslate} = \\begin{bmatrix}1 & 0 & T_x \\\\ 0 & 1 & T_y \\\\ 0 & 0 & 1\\end{bmatrix} \\text{HomMat2D}该函数是相对于世界坐标系（静态坐标系）的变换，若要相对于局部坐标系（动态坐标系）做变换，可使用 hom_mat2d_translate_local。 在 Halcon 中，齐次矩阵通过元祖按行存储，通常最后一行是不进行存储的（因为其是单位阵），如上述平移变换的矩阵实际存储为 $[1, 0, T_x, 0, 1, T_y]$。 旋转算子对一个 2D 齐次变换矩阵 HomMat2D 进行旋转，返回旋转后的结果 HomMat2DRotate 1hom_mat2d_rotate( : : HomMat2D, Phi, Px, Py : HomMat2DRotate) 该函数具体原理同前，旋转角度为 $\\phi$： \\text{HomMat2DRotate} = \\begin{bmatrix}cos\\phi & -sin\\phi & 0 \\\\ sin\\phi & cos\\phi & 0 \\\\ 0 & 0 & 1\\end{bmatrix} \\text{HomMat2D}该函数中的另外两个参数是一个定点，点 $(P_x, P_y)$ 在使用该函数变换时保持不变， 可以理解为绕哪个定点进行旋转，其具体原理是：先利用一个变换矩阵将该定点平移至世界坐标系原点，接着执行旋转过程，最后再将该定点移动至其原来的位置。（说白了就是不管你指定绕哪个点旋转，这个函数都会先移动到坐标系原点执行旋转，最后再回到指定的点），该过程可用变换链表示为： \\text{HomMat2DRotate} = \\begin{bmatrix}1 & 0 & +P_x \\\\ 0 & 1 & +P_y \\\\ 0 & 0 & 1\\end{bmatrix} \\begin{bmatrix}cos\\phi & -sin\\phi & 0 \\\\ sin\\phi & cos\\phi & 0 \\\\ 0 & 0 & 1\\end{bmatrix} \\begin{bmatrix}1 & 0 & -P_x \\\\ 0 & 1 & -P_y \\\\ 0 & 0 & 1\\end{bmatrix}\\text{HomMat2D}缩放算子对一个 2D 齐次变换矩阵 HomMat2D 进行缩放，返回缩放后的结果 HomMat2DScale 1hom_mat2d_scale( : : HomMat2D, Sx, Sy, Px, Py : HomMat2DScale) 该函数具体原理同前，在两方向上的缩放量为 $S_x$、$S_y$： \\text{HomMat2DScale} = \\begin{bmatrix}S_x & 0 & 0 \\\\ 0 & S_y & 0 \\\\ 0 & 0 & 1\\end{bmatrix} \\text{HomMat2D}定点 $(P_x, P_y)$ 含义同前。 仿射变换对图像进行任意 2D 仿射变换 1affine_trans_image(Image : ImageAffineTrans : HomMat2D, Interpolation, AdaptImageSize : ) 由于仿射变换是上述各类变换的组合，故仿射变换矩阵 HomMat2D 可通过上述变换组合得到。 此外，由于转换后的点落在像素坐标之间，可能不再是整数，因而需要选择合适的插值方式，将其转为整数输出，同时也可避免缩放图像导致的混叠现象（可理解为抗锯齿）。具体的插值方式有： 最近邻插值（nearest_neighbor）：由最近邻像素决定，质量低但快速 双线性插值（bilinear）：利用最邻近四个像素的双线性插值，质量和速度中等（若仿射变换包含缩放，且缩放因子 &lt;1，不会进行平滑滤波，可能会导致验证的锯齿现象） 双三次插值（bicubic）：4*4 邻域的双三次插值，放大质量高但慢（若仿射变换包含缩放，且缩放因子 &lt;1，不会进行平滑滤波，可能会导致验证的锯齿现象） 常数（constant）：双线性插值，质量和速度中等（缩放因子小于 1 时，采用均值滤波防止混叠现象） 加权：双线性插值，质量高但慢（采用高斯滤波） 插值的方式决定了输出图像和原始图像差别的大小，插值具体解释 投影变换使用给定的同名点对计算出齐次变换矩阵（可理解为多视几何中不同视角的同名点，左视角同名点*单应性矩阵 = 右视角下对应的同名点） 1hom_vector_to_proj_hom_mat2d( : : Px, Py, Pw, Qx, Qy, Qw, Method : HomMat2D) 若恰好给定了4 对同名点，则只用其求解；若多于 4 组，则该函数旨在最小化变换的误差，此时还需指定优化的方法，可选项为：normalized_dlt 和 dlt，前者通常更加，为函数默认值。但若给定坐标中的 $Q_w$ 或 $P_w$ 为 0，则必须选择 dlt。 \\begin{bmatrix} Q_x \\\\Q_y \\\\ Q_w\\end{bmatrix} = \\text{HomMat2D} \\begin{bmatrix} P_x \\\\P_y \\\\ P_w\\end{bmatrix}图像增强点运算 线性变换 分段线性变换 图像增强算子图像取反1invert_image(Image : ImageInvert : : ) 具体做法是： g' = 255 - g增加图像对比度1emphasize(Image : ImageEmphasize : MaskWidth, MaskHeight, Factor : ) 增强图像中高频的部分（如边和角），图像类似锐化的效果。其过程是：先进行低通滤波，再与原图像进行如下计算： \\text{res} = \\text{round}((\\text{orig} - \\text{mean}) * \\text{Factor}) + \\text{orig}因子 Factor 是对比度增强的度量，分频由滤波矩阵的大小决定，越大分频越低。 缩放图像灰度1scale_image(Image : ImageScaled : Mult, Add : ) 该算子对输入的图像进行如下变换： g' = g * \\text{Mult} + \\text{Add}该算子可用于将图像的灰度值，如位于区间 $[\\text{Gmin},\\text{GMax}]$，映射或扩展到最大区间 $[0,255]$，此时，参数的选取规则为： \\text{Mult} = \\frac{255}{\\text{GMax}-\\text{GMin}}\\\\ \\text{Add} = -\\text{Mult} * GMin值得一提的是，该函数中的两个数取值若为：$\\text{Mult} = -1$，$\\text{Add} = 255$，则等价于取反操作。 直方图修正 直方图均衡化 1equ_histo_image(Image : ImageEquHisto : : ) 直方图规定化 ​ 将原图像的直方图变成规定形状的直方图，可见直方图均衡化只是直方图规定化的一个特例。 图像平滑算子 高斯噪声 12gauss_distribution( : : Sigma : Distribution) * 产生高斯分布噪声add_noise_distribution(Image : ImageNoise : Distribution : ) * 为图像添加高斯噪声 椒盐噪声 1sp_distribution( : : PercentSalt, PercentPepper : Distribution) * 产生椒盐噪声 滤波算子 1mean_image(Image : ImageMean : MaskWidth, MaskHeight : ) * 均值滤波 图像锐化(边缘检测) 可用于增强边缘和轮廓 12sobel_amp(Image : EdgeAmplitude : FilterType, Size : )laplace(Image : ImageLaplace : ResultType, MaskSize, FilterMask : ) 频域处理 低频：灰度均匀的部分 高频：噪声、边缘、细节 具体步骤： 快速傅里叶变换 1fft_generic(Image : ImageFFT : Direction, Exponent, Norm, Mode, ResultType : ) 生成理想的低/高通滤波模型 12gen_lowpass( : ImageLowpass : Frequency, Norm, Mode, Width, Height : )gen_highpass( : ImageLowpass : Frequency, Norm, Mode, Width, Height : ) 在频域卷积图像 1convol_fft(ImageFFT, ImageFilter : ImageConvol : : ) 进行快速傅里叶反变换 1fft_generic(Image : ImageFFT : Direction, Exponent, Norm, Mode, ResultType : ) 同态滤波增强 把图像的照明反射模型作为频域处理的基础，将亮度范围压缩和对比度增强的频域处理方法。 可改善图像的照度不均 图像分割阈值分割 按图像像素灰度幅度进行分割的方法，把图像的灰度分成不同的等级，然后设置阈值确定有意义的区域或要分割物体的边界，该操作被定义为： S = \\{(r,c) \\in R |g_{\\text{min}} \\le f_{r,c} \\le g_{\\text{max}} \\}可见，阈值分割是将图像内灰度值处于某一指定灰度范围内全部点输出到区域 S 中。若光照能保持恒定，则阈值能在系统设置时被选定且不再被调整。 Halcon 算子： 1threshold(Image : Region : MinGray, MaxGray : ) 阈值选择的方法： 根据直方图谷底确定 1histo_to_thresh( : : Histogramm, Sigma : MinThresh, MaxThresh) 目前看到复习与阈值分割 相机标定——Halcon标定原理具体原理 标定流程 根据相机类型（面阵、线阵）创建相机参数（低精度除法（Division）模式、高精度多项式（Polynomia）模式 使用create_calib_data创建标定数据模型 CalibDataID 使用set_calib_cam_param设置相机参数 使用set_calib_data_calib_object设置标定板 设置标定板数据的路径，读取采集的标定板图像 使用find_calib_object、get_calib_data_observ_contours算子提取标定板图像的角点中心、轮廓信息，将其存储在 CalibDataID 中 使用calibrate_cameras算子对相机进行标定，计算相机的内外参数 使用get_calib_data获取参数，通过write_cam_par将参数保存到文件 利用获取的参数进行图像校正、测量等 标定为达到测量的最佳精度，必须进行精确的标定，因此，需要确定一个相机模型，该模型描述了三维世界中的点与图像中（亚）像素点之间的映射。Halcon 提供了大量的算子，实现了不同任务下的标定。 标定物标定物的几何尺寸必须精确已知，并从不同位姿进行拍摄。标定的精度高度依赖于标定物及采集的图像。 Halcon 提供了两种不同类型的标定板： 圆点蜂窝图案标定板 视场中出现至少一组即可正确识别，且不必完全可见。原点位于中心，Z 轴垂直标定板指向内部，X 轴向右，Y 轴向下。 若使用camera_calibration，则该标定板无法使用。 圆点阵列标定板 该标定板原点由方形包围，且一角有三角形的角标，因此该标定板在图像中必须全部可见，坐标系定义同前。 输入数据准备在开始标定之前，必须创建和采用标定数据模型，步骤如下： 使用create_calib_data算子创建标定数据模型 CalibDataID，设置所用相机、标定板的数量 使用set_calib_cam_param算子设置相机类型、相机内参初值 使用set_calib_data_calib_object算子设置标定板 使用find_calib_object、set_calib_data_observ_points算子提取标定板图像的角点中心，初步估计相机与标定板之间的位姿（外参） 标定过程参数选取，如使用set_calib_data算子从优化中排除某些参数，如某个参数是精确已知的，不需要参数优化的情况 标定及结果获取利用存储在标定数据模型中的所有数据，可以通过调用calibrate_cameras完成实际的标定。通过迭代优化内参初值、计算外参或标准差，最终得到真实的相机参数。为判断标定是够有效，可计算内参的标准差或协方差，以及重投影均方根误差（RRMSE）。标定结果可通过get_calib_data获取 。 对单相机的标定，若 RRMSE 在 0.1 像素内，表明标定结果较好；否则表示标定结果不佳，可能是由于图像质量不佳、标定板精度不高等。 相机参数相机参数可分为内参和外参。 内参内参描述了相机的特性，如传感器的尺寸以及所用镜头、相机和图像采集卡组合的投影特性。下面仅以倾斜镜头面阵相机为例进行说明。 123area_scan_tilt_division: [&#x27;area_scan_tilt_division&#x27;, Focus, Kappa, ImagePlaneDist, Tilt, Rot, Sx, Sy*, Cx, Cy, ImageWidth, ImageHeight]area_scan_tilt_polynomial: [&#x27;area_scan_tilt_polynomial&#x27;, Focus, K1, K2, K3, P1, P2, ImagePlaneDist, Tilt, Rot, Sx, Sy*, Cx, Cy, ImageWidth, ImageHeight] CameraType：相机类型 Focus：焦距，初值为镜头的标称焦距，如 8mm Kappa：用于模拟径向畸变的系数，仅适用于 division 模型，初值为 0.0 $m^{-2}$ K1, K2, K3, P1, P2: K1、K2、K3、P1、P2：畸变系数，仅适用于 polynomial 模型，初值均为 0.0 ImagePlaneDist：镜头出瞳到像平面的距离（光学知识，不太理解，看下图是镜头到传感器平面的距离） Tilt, Rot：倾角 tilt($0° \\le tilt \\le 90°$) 是光轴相对于传感器平面的倾斜角度，对应于绕 x 轴的旋转；旋转角 rot($0° \\le rot \\le 360°$) 是绕 Z 轴的旋转。（可以理解为镜头坐标系和传感器平面坐标系之间有倾斜和旋转） （ImagePlaneDist、Tilt、Rot 参数是镜头倾斜时才有的，若不倾斜，则无需考虑这三个参数） Sx, Sy：缩放因子，在针孔相机模型中求解过程中，保持 $S_y$ 不变 Cx, Cy：图像中心点坐标 ImageWidth, Image Height：图像宽高 外参 旋转+平移 相机坐标系的 X 轴和图像列坐标轴平行，Y 轴和行坐标轴平行 位姿元祖 tuple 还有一个额外的元素，表示位姿的类型，将参数按 OrderOfTransform（平移顺序）、OrderOfRotation（旋转顺序）、ViewOfTransform（点/坐标系的变换） 进行组合，参见create_pose。 使用 Halcon 标定板可通过find_calib_object确定所有参数的初值。 单位 参数 单位 外参 RotX, RotY, RotZ deg TransX, TransY, TransZ m 内参 Cx, Cy px Focus m ImagePlaneDist m ImageWidth, ImageHeight px K1, K2, K3 $m^{-2}、m^{-4}、m^{-6}$ Kappa $m^{-2}$ P1, P2 $m^{-1}$ Sx, Sy m/px Tilt, Rot deg 问题 相机 光圈、焦距、相机位置标定中、后均不能动，否则需重新标定 标定板 各个位姿应尽量覆盖整个视场 在各个方向均应有一定的倾角，建议 30~45° 对蜂窝形标定板，至少需要 6 张，其至少 4 张有倾斜） 对阵列性标定板，至少需要 15 张 图像 标定板分布 对蜂窝形标定板，至少需要一个标志点可见 对阵列性标定板，整个标定板均需可见，包括四周的方形轮廓 标志点直径 每张图中的标志点直径至少为 20 像素，对成功标定至关重要 对比度 明暗区域的对比度至少大于 100 灰度值 过曝 为避免图像过曝，应确保标定板亮的部分的灰度值不超过 240，特别是标志点邻域 光照 标定板应均匀光照，避免反光。根据经验，亮部灰度值范围不应超过 45 图像格式 图像格式应以未压缩的格式保存，应避免使用 JPG 格式及高压缩率的图像 标定图像不应被后处理，若图像对比度或焦距不满足要求，应重新调整相机而非处理图像 畸变模型 division模型：使用一个参数对径向畸变进行建模，该模型的优点是快速，尤其反向畸变，即从世界坐标转到图像坐标系时计算快速。此外，若标定图像较少或视场覆盖不完全，该模型的结果一般比 polynomial 模型稳定 polynomial 模型：该模型使用 5 个参数对径向畸变和切向畸变进行建模。由于采用了高阶项，故模型更精确。但在反向时没有解析解，只能迭代计算，因此速度较解析解慢 一般而言，因采用 division 模型，若标定精度不够高，可采用 polynomial 模型，但此时采集的图像应尽可能覆盖视场范围，否则在未覆盖的区域畸变模型会很不准确","categories":[],"tags":[{"name":"Halcon","slug":"Halcon","permalink":"https://hbroad.github.io/tags/Halcon/"}]},{"title":"Halcon从入门到入土","slug":"图像处理/Halcon入门到入土","date":"2023-05-13T12:42:38.000Z","updated":"2023-05-16T08:44:23.713Z","comments":true,"path":"halcon_learning/","link":"","permalink":"https://hbroad.github.io/halcon_learning/","excerpt":"","text":"本文所有内容源自 HDevelop User’s Guide——Chapter 8 HDevelop Language 参数基本类型 输入与输出严格分离 算子不会改变输入数据 参数基本类型 Iconic：image、region、XLD Control：string、int、real、handle 固定的参数顺序 1operator(input iconic : Output iconic : Input control : Output control) Halcon 数据类型 Iconic image region XLD（eXtended Line Description) Control string int real bool handle Tuple 非图标数据都是控制（Control）数据，由于 Halcon 算子“控制”图像处理时的行为或效果而得名。控制类型参数可以是算术或逻辑操作。 变量的具体类型只有赋值后才确定，具体类型显式（全局变量声明或参数定义）或隐式（代码赋值自动推断）确定。 输入控制参数表达式元祖运算一般特征（废话，看例子更容易理解）若元祖元素大于1，则大多数算子的运算规则为： 若其中一个元祖的长度为1，则其他元祖的所有元素均与该单个值作用 若两个元祖长度均大于1，则其长度必须相等（否则报 runtime error），在此基础上，两元祖按相同索引在给定的算子上作用 若其中一个元祖长度为0（即为[]），则报 runtime error 具体实例如下： Input Result 5 * 5 25 [5] * [5] 25 [1,2,3] * 2 [2,4,6] [1,2,3] * 2.1 + 10 [12.1,14.2,16.3] [1,2,3] * [1,2,3] [1,4,9] [1,2,3] * [1,2] runtime error ‘Text1’ + ‘Text2’ ‘Text1Text2’ 17 + ‘3’ ‘173’ ‘Text ‘ + 3.1 * 2 ‘Text 6.2’ 3.1 * (2 + ‘ Text’) runtime err 3.1 + 2 + ‘ Text’ ‘5.1 Text’ 3.1 + (2 + ‘ Text’) ‘3.12 Text’ 赋值赋值操作也当做算子看待， assign(Input, Result)，该操作符评估输入(赋值的右侧）并将其存储在结果(赋值的左侧）中，对应的语法为 Result := Input。 如 C 中赋值语句为： 1u = sin(x) + cos(y); 对应 Halcon 中的语法为： 1u := sin(x) + cos(y) 也可直接使用赋值算子（算子窗口）： 1assign (sin(x) + cos(y), u) 表达式的可直接作为任何算子的输入，即表达式的返回值不一定存入变量，除非该值需要被多次使用或变量必须初始化（如 for 循环）。 下面以元祖为例进行说明。 若要修改元祖元素： 1Result[Index] := Value 或使用赋值算子： 1assign_at (Index, Value, Result) 如：123Areas := [1,2,3]Areas[1] := 9* Areas 结果为 [1,9,3]. 通常，使用空的 Tuple 作为初值，使用 for 循环插入（元祖索引从0开始）： 1234Tuple := []for i := 0 to 5 by 1 Tuple[i] := sqrt(real(i))endfor 要在元祖中插入元素，还可通过以下两种方式： 若要将元素插入尾部或头部，可使用连接操作符 逗号。 123assign ([Tuple,NewVal],Tuple)* 对应代码Tuple := [Tuple, NewVal] * Tuple 和 NewVal 组成新值再存入 Tuple 若索引位置位于两者之间，则必须使用tuple_insert算子 12345* 在元祖 [1,2,3] 的位置 1 处插入元祖 [11, 12, 13]tuple_insert ([1,2,3], 1, [11,12,13], Result)* 或写为：Result := insert([1,2,3], 1, [11,12,13])* 结果为：[1,11,12,13,2,3] 基本元组操作 操作符 含义 HALCON 算子 t := [t1,t2] concatenate tuples tuple_concat i := &#124;t&#124; get number of elements of tuple t tuple_length v := t1[t2] select element t2 of tuple t1 tuple_select t := t1[t2,t3] select elements t2 and t3 of tuple t1 tuple_select t := t[i1:i2] select from element i1 to element i2 of tuple t tuple_select_range t := subset(t1,t2) select elements specified in t2 from t1 tuple_select t := firstn(t,i) select first elements from t up to index i tuple_first_n t := lastn(t,i) select elements from t from index i to the end tuple_last_n t := select_mask(t1,t2) select all elements from t1 where the corresponding mask value in t2 is greater than 0 tuple_select_mask t := remove(t,i) remove elements specified in i from t tuple_remove t := insert(t1,i,t2) insert elements from t2 at position i in t1 tuple_insert i := find(t1,t2) get indices of all occurrences of t2 within t1 (or -1 if no match) tuple_find i := replace(t1,t2,t3) replace elements tuple_replace i := find_first(t1,t2) get indices of the first occurrences of t2 within t1 (or -1 if no match) tuple_find_first i := find_last(t1,t2) get indices of the last occurrences of t2 within t1 (or -1 if no match) tuple_find_last t := uniq(t) discard all but one of successive identical elements from t tuple_uniq t := [i1:i2:i3] generate a sequence of values from i1 to i3 with an increment value of i2 tuple_gen_sequence t := [i1:i2] generate a sequence of values from i1 to i2 with an increment value of one tuple_gen_sequence t := gen_tuple_const(i,t) generate a tuple with i values set to t tuple_gen_const 值得注意的是，上述操作符不能应用于 Iconic 对象，但 Halcon 也为其提供了类似的算子： (表中 t 为 control 元祖，p、q 为 iconic 元祖) control iconic [] gen_empty_obj() [t1,t2] concat_obj(p1, p2, q) &#124;t&#124; count_obj(p, num) t[i] select_obj(p, q, i+1) t[i1:i2] copy_obj(p, q, i1+1, i2-i1+1) 类型操作符 用于测试或查询控制数据值的类型 Operation Meaning HALCON operator b := is_handle test for handle values tuple_is_handle b := is_int(t) test for integer values tuple_is_int b := is_mixed(t) test for mixed values tuple_is_mixed b := is_number(t) test for numerical values tuple_is_number b := is_real(t) test for real values tuple_is_real b := is_string(t) test for string values tuple_is_string b := is_valid_handle(t) test for valid handles tuple_is_valid_handle s := sem_type(t) get semantic type tuple_sem_type i := type(t) get type value tuple_type 也可查询元祖中每个元素的类型 Operation Meaning HALCON operator t := is_handle_elem elementwise test for handle values tuple_is_handle_elem t := is_int_elem(t) elementwise test for integer values tuple_is_int_elem t := is_nan_elem(t) elementwise test for NaNs tuple_is_nan_elem t := is_real_elem(t) elementwise test for real values tuple_is_real_elem t := is_string_elem(t) elementwise test for string values tuple_is_string_elem t := sem_type_elem(t) get semantic type elementwise tuple_sem_type_elem t := type_elem(t) get type value elementwise tuple_type_elem 基本算术操作符 Operation Meaning HALCON operator a1 / a2 division tuple_div a1 * a2 multiplication tuple_mult i1 % i2 modulus tuple_mod a1 + a2 addition tuple_add a1 - a2 subtraction tuple_sub -a negation tuple_neg 位操作符 操作数必须是整数 Operation Meaning HALCON operator lsh(i1,i2) left shift tuple_lsh rsh(i1,i2) right shift tuple_rsh i1 band i2 bitwise and tuple_band i1 bxor i2 bitwise xor tuple_bxor i1 bor i2 bitwise or tuple_bor bnot i bitwise complement tuple_bnot 字符串操作符 Operation Meaning HALCON operator v $ s convert v using specification s tuple_string v1 + v2 concatenate v1 and v2 tuple_add strchr(s1,s2) search character s2 in s1，返回值为索引 tuple_strchr strstr(s1,s2) search substring s2 in s1 tuple_strstr strrchr(s1,s2) search character s2 in s1 (reverse) tuple_strrchr strrstr(s1,s2) search substring s2 in s1 (reverse) tuple_strrstr strlen(s) length of string tuple_strlen str_firstn(s,i) cut the first characters of s up to position i tuple_str_first_n str_lastn(s,i) cut the characters of s from position i tuple_str_last_n s{i} select character at position i; 0 &lt;= i &lt;= strlen(s)-1 tuple_str_bit_select s{i1:i2} select substring from position i1 to position i2 tuple_substr split(s1,s2) split s1 in substrings at s2 tuple_split join(s1,s2) join substrings in s1 via separator in s2 tuple_join regexp_match(s1,s2) extract substrings of s1 matching the regular expression s2 tuple_regexp_match regexp_replace(s1,s2,s3) replace substrings of s1 matching the regular expression s2 with s3 tuple_regexp_replace regexp_select(s1,s2) select tuple elements from s1 matching the regular expression s2 tuple_regexp_select regexp_test(s1,s2) return how many tuple elements in s1 match the regular expression s2 tuple_regexp_test s1 =~ s2 return how many tuple elements in s1 match the regular expression s2 tuple_regexp_test 详细解释见文档 8.5.8 String Operations 集合操作符 Operation Meaning HALCON operator difference(t1,t2) 差集，只在 t1 而不在 t2中 tuple_difference intersection(t1,t2) 交集 tuple_intersection symmdiff(t1,t2) 异或，两个集合中不重复元素的集合（移除两个集合中都存在的元素） tuple_symmdiff union(t1,t1) 并集 tuple_union 比较运算符>、&lt;、&lt;=、&gt;=、==（=）、!=（#） == 和 = 在比较时等价 != 和 # 等价 按元素比较 两个元祖元素个数需相等或其中一个的元素个数为 1 1st Operand Operation 2nd Operand Result [1,2,3] [&lt;] [3,2,1] [1,0,0] [‘a’,’b’,’c’] [==] ‘b’ [0,1,0] [‘a’,’b’,’c’] [&lt;] [‘b’] [1,0,0] 布尔运算 Operation Meaning HALCON operator l1 and l2 logical ‘and’ tuple_and l1 xor l2 logical ‘xor’ tuple_xor l1 or l2 logical ‘or’ tuple_or not l negation tuple_not 三角函数 Operation Meaning HALCON Operator sin(a) sine of a tuple_sin cos(a) cosine of a tuple_cos tan(a) tangent of a tuple_tan asin(a) arc sine of a in the interval [ − π/2, π/2], a ∈ [ − 1, 1] tuple_asin acos(a) arc cosine a in the interval [ − π/2, π/2], a ∈ [ − 1, 1] tuple_acos atan(a) arc tangent a in the interval [ − π/2, π/2], a ∈ [ − ∞, + ∞] tuple_atan atan2(a1,a2) arc tangent a1/a2 in the interval [ − π, π] tuple_atan2 sinh(a) hyperbolic sine of a tuple_sinh cosh(a) hyperbolic cosine of a tuple_cosh tanh(a) hyperbolic tangent of a tuple_tanh asinh(a) inverse hyperbolic sine of a tuple_asinh acosh(a) inverse hyperbolic cosine of a tuple_acosh atanh(a) inverse hyperbolic tangent of a tuple_atanh 指数函数 Operation Meaning HALCON operator exp(a) exponential function $e^a$ tuple_exp exp2(a) base 2 exponential function $2^a$ tuple_exp2 exp10(a) base 10 exponential function $10^a$ tuple_exp10 log(a) natural logarithm $\\text{ln}(a)$, a &gt; 0 tuple_log log2(a) base 2 logarithm, $\\text{log}_2(a)$, a &gt; 0 tuple_log2 log10(a) base 10 logarithm, $\\text{log}_{10}(a)$, a &gt; 0 tuple_log10 pow(a1,a2) $a1^{a2}$ tuple_pow ldexp(a1,a2) $a1·2^{floor(a2)}$ tuple_ldexp tgamma(a) gamma function Gamma(a) tuple_tgamma lgamma(a) logarithm of the absolute value of the gamma function log(&#124;Gamma(a)&#124;) tuple_lgamma erf(a) error function erf(a) tuple_erf erfc(a) complementary error function erfc(a) tuple_erfc Gamma 函数的定义： \\Gamma(x) = \\int_0^\\infty t^{x-1}e^{-t}dt该函数为除非正整数以外的实数定义，对非负整数 $m$，有： \\Gamma(m+1)=m!更一般的，对所有的 $x$ 有： \\Gamma(x+1) = x\\Gamma(x)误差函数的定义： erf(x) = \\frac{2}{\\sqrt{\\pi}}\\int_0^\\infty e^{-t^2} dt互补误差函数的定义： 1-erf(x)上述函数的返回值通常是浮点数，则字符串均不支持以上函数。 算术函数 Operation Meaning HALCON operator min(t) minimum value of the tuple tuple_min min2(t1,t2) elementwise minimum of two tuples tuple_min2 max(t) maximum value of the tuple tuple_max max2(t1,t2) elementwise maximum of two tuples tuple_max2 sum(t) sum of all tuple elements or string concatenation tuple_sum mean(a) mean value tuple_mean deviation(a) standard deviation tuple_deviation cumul(a) cumulative sums of a tuple tuple_cumul median(a) median of a tuple tuple_median select_rank(a,i) element at rank i of a tuple tuple_select_rank sqrt(a) square root tuple_sqrt cbrt(a) cube root tuple_cbrt hypot(a,b) hypotenuse $\\sqrt{a^2+b^2}$ tuple_hypot deg(a) convert radians to degrees tuple_deg rad(a) convert degrees to radians tuple_rad real(a) convert integer to real tuple_real int(a) truncate real to integer tuple_int round(a) convert real to integer tuple_round abs(a) absolute value of a (integer or real) tuple_abs fabs(a) absolute value of a (always real) tuple_fabs ceil(a) smallest integer value not smaller than a tuple_ceil floor(a) largest integer value not greater than a tuple_floor fmod(a1,a2) fractional part of a1/a2, with the same sign as a1 tuple_fmod sgn(a) elementwise sign of a tuple tuple_sgn 辅助函数 Operation Meaning HALCON operator sort(t) sorting in increasing order tuple_sort sort_index(t) return index instead of values tuple_sort_index inverse(t) reverse the order of the values tuple_inverse number(v) convert string to a number tuple_number environment(s) value of an environment variable tuple_environment ord(a) convert strings of length 1 into character codes (Unicode or ANSI) tuple_ord chr(a) Inverse of ord(a) tuple_chr ords(s) convert strings into character codes (Unicode or ANSI) tuple_ords chrt(i) Inverse of ords(s) tuple_chrt rand(a) create random numbers tuple_rand 容器 vector各类容器的定义可用扩展巴科斯范式(EBNF)语法表示如下： 1234567vector = &quot;&#123;&quot; list &quot;&#125;&quot; ;list = tuplelist | objectlist | vectorlist ;tuplelist = tuple, &#123;&quot;,&quot;, tuple&#125; ;objectlist = object, &#123;&quot;,&quot;, object&#125; ;vectorlist = vector, &#123;&quot;,&quot;, vector&#125; ;tuple = &quot;[&quot; control &quot;]&quot; ;control = string | integer | real | boolean ; 容器的构造可见，vector 是由逗号分隔的列表初始化的： 1vectorT := &#123;[1], [2], [3]&#125; // one-dimensional vector 由于单个元素的元祖可不用方括号，故其等价于： 1vectorT := &#123;1, 2, 3&#125; // tuples of length 1 do not require square brackets 也可用变量名或表达式： 12t1 := 1vectorT := &#123;t1, t1 * 2, 3&#125; 二维容器可通过一维容器构造： 1vectorV := &#123;vectorT, &#123;[4,5,6,7], [8,9]&#125;&#125; 容器元素的列表也可为空： 1vectorV2 := &#123;&#123;1,2&#125;, &#123;&#125;&#125; 由于空容器没有具体的类型，故可赋值给其他容器（相当于.clear()）： 12345vectorT2 := vectorTvectorV2 := vectorVvectorT2 := &#123;&#125;vectorV2 := &#123;&#125; 容器的访问容器的元素通过.at 访问，多维容器通过 .at 的组合访问 123tuple := vectorT.at(0) // tuple := 1vector := vectorV.at(0) // vector := &#123;[1,2,3]&#125;tuple := vectorV.at(1).at(1) // tuple := [8, 9] .at 也可用于改变元素的值： 1vectorT.at(2) := 33 // vectorT := &#123;[1], [2], [33]&#125; Halcon 中允许往一个本不存在的容器中写入元素，如有必要，会自动填充为空： 1vectorE.at(4) := &#x27;text&#x27; // vectorE := &#123;[], [], [], [], &#x27;text&#x27;&#125; .at 操作也允许动态的构造容器： 123for i:= 0 to 5 by 1 vecT.at(i) := gen_tuple_const(i,5)endfor .insert 用于在指定位置插入元素，和 .at 类型，如有必要，会自动填充为空： 12vectorT.insert(1, 99) // vectorT := &#123;[1], [99], [2], [33]&#125;vectorNew.insert(2, 3) // vectorNew := &#123;[], [], [3]&#125; .remove 用于删除指定位置的元素 1vectorT.remove(2) // vectorT := &#123;[1], [99], [33]&#125; .concat 连接两个具有相同类型和维度的容器： 1vectorC := vectorT.concat(vectorNew) // vectorC := &#123;[1], [99], [33], [], [], [3]&#125; 容器元素数.length 获取元素的数量 123i := vectorT.length() // i := 3j := vectorV.length() // j := 2k := vectorV.at(0).length() // k := 3 容器的清空.clear 清空容器，但其仍保留了变量的类型 123vectorT.clear()* vectorT := vectorO // illegal: vectorT is a tuple vector* vectorT := vectorV // illegal: vectorT is one-dimensional 容器的修改.clear()、.insert()、.remove() 可直接修改容器，可通过级联的形式修改容器元素： 12v := &#123;1, 2, 3&#125;v.insert(1, 5).insert(2, 4).remove(0) // sets v to &#123;5, 4, 2, 3&#125; 容器元祖转换容器和元祖可相互转换 容器转元祖：将容器中的所有元祖连接后输出 元祖转容器：指定转换后容器的维度 12convert_vector_to_tuple (vectorV, T) // T := [1, 2, 3, 4, 5, 6, 7, 8, 9]convert_tuple_to_vector_1d (T, 1, V) // V := &#123;[1],[2],[3],[4],[5],[6],[7],[8],[9]&#125; 字典字典的初始化和访问有两种方式，动态语法表示和静态语法表示，前者运用更广。 动态语法表示 创建字典 1&lt;DictHandle&gt; := dict&#123;[&#x27;&lt;key&gt;&#x27;]: &lt;value&gt;&#125; 读取字典 1&lt;DictValue&gt; := &lt;DictHandle&gt;.[&#x27;&lt;key&gt;&#x27;] 写入字典 1&lt;DictHandle&gt;.[&#x27;&lt;key&gt;&#x27;] := &lt;NewDictValue&gt; 一个实例： 1234567* 添加数据DictHandle := dict&#123;[&#x27;SingleInteger&#x27;]: 27, [&#x27;MixedTuple&#x27;]: [&#x27;The answer&#x27;, 41]&#125;read_image (DictHandle.[&#x27;SingleImage&#x27;], &#x27;printer_chip/printer_chip_01&#x27;)* 访问字典元祖元素RightAnswer := DictHandle.[&#x27;MixedTuple&#x27;][1] + 1* 更新字典数据DictHandle.[&#x27;MixedTuple&#x27;] := [&#x27;The answer&#x27;,RightAnswer] 静态语法表示静态语法表示可用于简化动态语法表示的语法： 1&lt;DictHandle&gt; := dict&#123;&lt;key&gt;: &lt;value&gt;&#125; 前例可表示为： 1234567* 添加数据DictHandle := dict&#123;SingleInteger: 27, MixedTuple: [&#x27;The answer&#x27;, 41]&#125;read_image (DictHandle.SingleImage, &#x27;printer_chip/printer_chip_01&#x27;)* 访问字典元祖元素RightAnswer := DictHandle.MixedTuple[1] + 1* 更新字典数据DictHandle.MixedTuple := [&#x27;The answer&#x27;,RightAnswer] 动静语法区别虽然上例中两者的结果一致，但在某些功能只能通过动态语法实现。在静态语法表示中，&lt;key&gt; 总是被解释为字符串，这就意味着我们无法访问变量的值，为此要使用动态语法。此外，保留关键词也不能使用静态语法。 控制流算子if12345if (&lt;condition1&gt;) ...elseif (&lt;condition2&gt;) ...endif while123while (&lt;condition&gt;) ...endwhile 还有一个类似 do-while 的语句： 123repeat ...until (&lt;condition&gt;) for123for &lt;index&gt; := &lt;start&gt; to &lt;end&gt; by &lt;step&gt; ...endfor switch-case1234567891011121314151617switch (Grade) case 1: Result := &#x27;excellent&#x27; break case 2: Result := &#x27;good&#x27; break case 3: Result := &#x27;acceptable&#x27; break case 4: case 5: Result := &#x27;unacceptable&#x27; break default: Result := &#x27;undefined&#x27;endswitch 其他 continue、break stop：在算子执行后停止程序 exit：结束整个任务 try … catch … endtry：异常处理 throw：生成用户自定义的异常 异常处理 追踪返回值 dev_set_check 算子指定错误提示信息框是否显示，若不显示，可使用： 1dev_set_check(&#x27;~give_error&#x27;) 此时HDevelop会忽略程序中所有的错误，错误将有程序员自行处理。 调用任意算子将返回一个值（成功）或错误代码（失败），该错误代码可通过指定的错误变量来访问： 1dev_error_var(ErrorCode, 1) 该错误代码对应的错误信息可通过 get_error_text 获取。 异常处理 HDevelop 默认开启抛出异常。 123456789try * start block of watched program lines ...catch(Exception) * get error code ErrorCode := Exception[0] * react to errorendtry* program continues normally 图像获取助手相机主存——&gt;采集卡存储器——&gt;上位机内存 异步读取：图像从采集设备读取，非实时，取像与处理并行（从采集卡中读取） 同步读取：通过相机取像，实时，取像与处理串行，取像周期长","categories":[],"tags":[{"name":"Halcon","slug":"Halcon","permalink":"https://hbroad.github.io/tags/Halcon/"}]},{"title":"ChatGPT 类产品","slug":"AI资讯/chatgpt类产品","date":"2023-04-28T01:53:21.000Z","updated":"2023-05-26T11:28:58.258Z","comments":true,"path":"chatgptlike/","link":"","permalink":"https://hbroad.github.io/chatgptlike/","excerpt":"","text":"OpenAI 的 ChatGPT 问世以来让低迷的 AI 一下进入了寻常百姓家，但正如老马所说，OpenAI 不再 Open，逐渐走上了闭源盈利，目前，诸多类 ChatGPT 产品层出不穷，此处对可用产品做一分享。 商用模型 POE POE由海外知乎Quora开发，其集成了市面上诸多的 AI 对话机器人(最新的 ChatGPT4 依旧需要付费订阅)，但值得一提的是，该平台的生成速度惊人，一般的使用已经足够。 forefront forefront集成了 GPT3.5 和 GPT4，目前可免费使用，但后者使用人数较多时会有限制，该平台的亮点是内置了众多的“角色”，如爱因斯坦、乔布斯以及诸多动漫角色，你可以选择和他们进行对话；当然也有一个通用的角色 Help Assistant。此外，用户也可自行创建角色。也可以通过 #imagine prompts 的形式生成图片，但效果一般 开源模型 GPT4free GPT4free是一个逆向工程项目，对市面上现有的诸多产品进行了逆向，该项目在Github上的星标已达 13.1k，作者也开发了一个在线体验的端口，无需登录，可切换 GPT3.5 和 GPT4。 HuggingChat HuggingChat由Hugging Face基于 OpenAssistant 开发，目前完全开源且免费，与 ChatGPT 形成了对抗。 国产大模型 文心一言 国产大模型，但文生图的效果不是很好，希望国产迎头赶上 通义千问 暂未拿到内测资格 讯飞星火 暂未拿到内测资格 2023年5月5日拿到内测资格 星火大模型支持 语音输入，生成的文字也可朗读（有多个发音人可选），更多功能正在探索…… 天工AI 暂未拿到内测资格 2023年5月4日拿到测试，更多功能正在探索……","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"资讯","slug":"资讯","permalink":"https://hbroad.github.io/tags/%E8%B5%84%E8%AE%AF/"}]},{"title":"Python 从入门到放弃","slug":"Python/Python-从入门到放弃","date":"2023-04-19T13:07:56.000Z","updated":"2023-04-28T14:20:10.474Z","comments":true,"path":"Python_start2end/","link":"","permalink":"https://hbroad.github.io/Python_start2end/","excerpt":"","text":"课程：北理嵩天《Python语言程序设计》 turtle 库1234567891011121314151617import turtleturtle.setup(100, 200) # 设置屏幕显示坐标turtle.goto(100,100) #在窗体中坐标行走turtle.fd()turtle.bk()turtle.circle()# 角度坐标系turtle.seth(45) # 设置朝向为 45°，此时为绝对角度turtle.left(45) # 设置朝向为 45°，此时为海龟自身角度turtle.right()# RGB # 默认使用0~1表示颜色，可切换为 0~255turtle.mode(1.0) #255 1234567891011121314151617181920212223242526import turtle# from turtle import* # 此时可直接省略库名，直接使用函数名，容易导致函数与用户自定义函数重名# import turtle as t # 为防止函数重名，起个别名# 各参数单位均为像素turtle.setup(650,650,200,200)turtle.penup() # 画笔升起，即不绘制图案 = turtle.pu()turtle.fd(-250)turtle.pendown() # 画笔落下，即绘制图案 = turtle.pd()turtle.pensize(25) # 画笔宽度，= turtle.width()# 画笔颜色# 支持三种参数形式：# 颜色字符串 &quot;blue&quot;# RGB 小数值 0.1,0.2,0.3# RGB 元组值 (0.1,0.2,0.3)turtle.pencolor(&quot;blue&quot;)turtle.seth(-45)for i in range(4): # range 函数可接受1或2个参数，range(2,5) 即 2,3,4，不包括最后一个 turtle.circle(40, 80) # 绘制半径为 r, extent 角度的圆弧，默认圆心在海龟左侧 turtle.circle(-40, 80)turtle.circle(40, 80/2)turtle.fd(40)turtle.circle(16,180)turtle.fd(40 * 2/3)turtle.done() # 运行后程序不会自动结束，需手动退出 Python 数据类型基本类型 整型 浮点数 浮点数存在不确定尾数，正常，如 0.1 + 0.2 = 0.3， 但计算机中可能为 0.3000000000000004 这是由计算机数学计算实现决定的 可通过 round 函数辅助，round(x[,d])：对 x 四舍五入，d 是小数截取位数(可省略) Python 复数类型（独有） .img和.real 获取实部和虚部 数值计算 x / y 结果是浮点型，如 10/3 = 3.333333333333333 x // y 则是整数除，即 10 // 3 = 3 x ** y，幂运算，即x^y，但当 y 为小数时，则为开方运算，如 10 ** 0.5，表示根号10 数值运算函数：divmod(x,y) 输出商和余数，如 divmod(10,3) -&gt; (3,1) 1234567891011121314# 天天向上的力量def dayUp(du): day = 1.0 for i in range(365): if i % 7 in [6,0]: day *= 1 - 0.01 else: day *= 1 + du return daydayfactor = 0.001while dayUp(dayfactor) &lt; 37.68: dayfactor += 0.001print(&quot;dayup: &#123;:.05f&#125;&quot;.format(dayfactor)) 字符串类型及操作字符串表示 单行字符串：一对单引号或双引号 1&quot;请输入&quot; &#x27;C&#x27; 多行字符串：一对三单引号或三双引号(未赋值给任何变量时作为注释使用) 1234&#x27;&#x27;&#x27;Python Hello &#x27;&#x27;&#x27; 输出中显示单引号或双引号 12&quot;输出单引号(&#x27;)&quot;&#x27;输出双引号(&quot;)&#x27; 既输出单引号又输出双引号 1&#x27;&#x27;&#x27;输出单引号(&#x27;)和双引号(&quot;)&#x27;&#x27;&#x27; 字符串序号 正向递增序号 和 反向递减序号 字符串操作 索引：使用[]获取字符串中的一个或多个字符，返回字串中的单个字符，&lt;字串&gt;[M] 12&quot;输入字串：&quot;[0]str[-1] 切片：返回字串中的一段字符子串，str[0:-1] 12&quot;输入字串：&quot;[1:3]str[0:-1] 切片高级用法 &lt;str&gt;[M:N]，M 缺省表示至开头，N 缺省表示至结尾 “零一二三四五六七八九十” [:3]，结果为 “零一二” &lt;str&gt;[M: N: K]，根据步长对字符串切片 “零一二三四五六七八九十” [1: 8: 2]，结果为 “一三五七” 字符串逆序：[::-1]，M、N 缺省，表示从头至尾，步长 -1 表示从尾部逐一读取 1234Weeknum = eval(input(&quot;input the nummber(1-7):&quot;))Weekstr = &quot;星期一星期二星期三星期四星期五星期六星期日&quot;pos = (str - 1) * 3print(&quot;Today is:&quot;, Weekstr[pos: pos+3]) # 切片操作 eval 函数可将字符串两侧的引号去掉，使其变成可执行的语句 转义符：\\，表达特定字符的本意 “这里是个引号(\\“)” 结果为 “这里是个引号(“)” 常见：”\\n” “\\r” 操作符 x + y：字符串连接 n * x 或 x * n：将字串 x 复制 n 次 x in s：若 x 是 s 的子串，返回 True，否则为 False 123WeekNum = eval(input(&quot;input the num(1-7):&quot;))WeekStr = &quot;一二三四五六日&quot;print(&quot;星期&quot; + WeekStr[WeekNum - 1]) # 字符串的连接 字符串处理函数 len(x)：返回字串 x 的长度 1len(&quot;一二三456&quot;) # 6 str(x)：任意类型 x 转为字串形式（和 eval 相反） 12str(1.23) # &quot;1.23&quot;str([1,2]) # &quot;[1,2]&quot; hex(x)/oct(x)：整数 x 的十六进制 或 八进制小写形式字串 12hex(425) # &quot;0x1a9&quot;oct(425) # &quot;0o651&quot; 字符编码 chr(u)：u 为 Unicode 编码，返回其对应的字符 ord(x)：x 为 字符，返回其对应的 Unicode 编码 Python 使用 Unicode 编码 字符串处理方法 str.lower() / str.upper()：全部小写 或 全部大写 12str = &quot;A,B,C&quot;print(str.lower()) # a,b,c str.split(sep = None)：根据 sep 分割字串 12str = &quot;A,B,C&quot;print(str.split(&quot;,&quot;)) # [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] str.count(sub)：返回字串 sub 在 str 中出现的次数 12str = &quot;abcdefaads&quot;print(str.count(&quot;a&quot;)) # 3 str.replace(old, new)：old 字串被替换为 new 12str = &quot;abcdefaads&quot;print(str.replace(&quot;a&quot;, &quot;m&quot;)) # mbcdefmmds str.center(width[,fillchar])：str 根据 width 居中，多余部分用 fillchar 填充 12str = &quot;abcdefaads&quot;print(str.center(20, &quot;-&quot;)) # -----abcdefaads----- str.strip(chars)：从 str 中去掉 chars 中列出的在其左右侧的字符 12str = &quot; -----abcdefaads----- &quot;print(str.strip(&quot; -as&quot;)) # bcdefaad str.join(iter)：在 iter 变量每个元素后增加一个 str，最后一个元素除外 123str = &quot;abcdefaads&quot;str_seg = &quot;,&quot;print(str_seg.join(str)) # a,b,c,d,e,f,a,a,d,s 字符串格式化 &lt;模板字串&gt;.format(&lt;逗号分割的参数&gt;) 槽机制 字符串中的槽 {} 的默认顺序是 0 ，1，2，这与 format 函数中参数的顺序一致（0,1,2），但也可以直接指定槽中的顺序 12345678print(&quot;&#123;&#125;:当前&#123;&#125;占用内存为&#123;&#125;%&quot;.format(&quot;2023-04-20&quot;, &quot;Python&quot;, &quot;5&quot;))# 相当于print(&quot;&#123;0&#125;:当前&#123;1&#125;占用内存为&#123;2&#125;%&quot;.format(&quot;2023-04-20&quot;, &quot;Python&quot;, &quot;5&quot;)) ## 2023-04-20:当前Python占用内存为5%# 指定槽中数据print(&quot;&#123;1&#125;:当前&#123;0&#125;占用内存为&#123;2&#125;%&quot;.format(&quot;2023-04-20&quot;, &quot;Python&quot;, &quot;5&quot;))## Python:当前2023-04-20占用内存为5% format() 格式控制：{&lt;参数序号&gt;} : &lt;格式控制标记符&gt; 1234567891011# 填充、对齐、宽度# 输出长度为 20，居中对齐，空余部分使用 * 填充print(&quot;&#123;0:*^20&#125;&quot;.format(&quot;str&quot;)) # ********str*********print(&quot;&#123;0:*&lt;20&#125;&quot;.format(&quot;str&quot;)) # str*****************print(&quot;&#123;0:*&gt;20&#125;&quot;.format(&quot;str&quot;)) # *****************strprint(&quot;&#123;:10&#125;&quot;.format(&quot;str&quot;)) # 默认以空格填充 # 分位符、精度、类型print(&quot;&#123;0:,.2f&#125;&quot;.format(12356.7852)) # 12,356.79print(&quot;&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;&quot;.format(456)) # 110101001,Ʃ,425,651,1a9,1A9（二进制、字符、十进制、八进制、十六进制小写、十六进制大写）print(&quot;&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;&quot;.format(3.14)) # 3.140000e+00,3.140000E+00,3.140000,314.000000% （科学计数大小写、浮点、百分数） time 库Python 中处理时间的标准库 计算机时间的表达 获取系统时间并格式化输出 系统级精确计时功能，用于分析程序性能 123# time 库的使用import timetime.&lt;b&gt;() 时间获取 time()：获取当前时间戳，即计算机内部时间值，浮点数 1print(time.time()) # 1681981125.892314 (表示从 1970.01.01,00:00 开始至当下的时间，以 s 为单位) ctime()：获取当前时间并以可读形式表示，返回字串 1print(time.ctime()) # Thu Apr 20 16:58:45 2023 gmtime()：获取当前时间，表示为计算机可处理的时间格式 1print(time.gmtime()) # time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=9, tm_min=0, tm_sec=50, tm_wday=3, tm_yday=110, tm_isdst=0) 时间格式化 将时间以合理的方式展示 strftime(tpl, ts)：tpl 是格式化模板字串，定义输出效果；ts 是计算机内部时间类型变量（由时间获取得到） 12t = time.gmtime()time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, t) # 2023-04-20 09:07:34 ​ 具体格式化字串见Python strftime cheatsheet 将给定字串输出为指定格式的时间 strptime(str, tpl)：str 是字串形式的时间；tpl 是格式化模板字串 12timestr = &quot;2023-04-20 09:07:34&quot;print(time.strptime(timestr, &quot;%Y-%m-%d %H:%M:%S&quot;)) # time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=9, tm_min=7, tm_sec=34, tm_wday=3, tm_yday=110, tm_isdst=-1) 程序计时 测量时间 perf_counter()：返回一个 CPU 级别的精确时间计算值，单位为 s，需连续调用计算差值才有意义 1234start = time.perf_counter()Fun_execu…end = time.perf_counter()print(&quot;Loss time&quot;, end - start) 产生时间 sleep(s)：s 是拟休眠时间，单位为 s，可为浮点数 123def wait(): time.sleep(3.3)wait() # 程序等待 3.3s 后退出 文本进度条案例123456789101112import timescale = 50 # 总宽度print(&quot;执行开始&quot;.center(scale//2, &quot;-&quot;)) # 居中显示，空余以 - 填充start = time.perf_counter() # 开始计时for i in range(scale + 1): # 0~scale 循环 a = &quot;*&quot; * i # 输出 i 个 * b = &quot;.&quot; * (scale - i) # 输出 (scale - i) 个 . (总共 sclae, i个*，则剩余的.为(scale-i)) c = (i/scale) * 100 # 计算百分比 dur = time.perf_counter() - start # 计算耗时 print(&quot;\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c, a, b, dur), end = &quot;&quot;) # 格式化输出，end=&quot;&quot; 表示不换行 time.sleep(0.1)print(&quot;\\n&quot; + &quot;执行结束&quot;.center(scale//2, &quot;-&quot;)) 程序控制结构单分支结构12if &lt;条件&gt;: &lt;语句块&gt; 二分支1234if &lt;条件&gt;； &lt;语句块 1&gt;else: &lt;语句块 2&gt; 二分支可用紧凑形式表达，适用于简单表达式 1&lt;表达式 1&gt; if &lt;条件&gt; else &lt;表达式 2&gt; # 满足条件返回 表达式 1 多分支结构123456if &lt;条件&gt;: &lt;语句块 1&gt;elif: &lt;语句块 2&gt;else: &lt;语句块 3&gt; 条件判断 比较：&gt;、&lt;、&lt;=、&gt;=、==、!= 逻辑：and、or、not 异常处理1234try : # 非异常执行 &lt;语句块 1&gt;except &lt;异常类型[可选项]&gt; : # 抛出异常（注意 异常类型 的名字是系统定义的，不是变量，执行该类型时，只抛出该类型的异常 &lt;语句块 2&gt; 此外，Python 也提供了高级用法 12345678try : # 非异常执行 &lt;语句块 1&gt;except &lt;异常类型&gt; : &lt;语句块 2&gt;else: &lt;语句块 3&gt; # 无异常时执行finally： &lt;语句块 4&gt; # 一定被执行 程序循环结构遍历循环将遍历的结果获得的元素放入循环变量，并执行一次语句块 12for &lt;循环变量&gt; in &lt;遍历结构&gt;: &lt;语句块&gt; 计数循环12for i in range(n): # range 产生 0~n-1 之间的数 print(i) 123456789for i in range(M,N,K): # range 产生数字序列 [M,N)，以 K 为步长 &lt;语句块&gt; ## 实例 for i in range(1,6): print(i) # 1 2 3 4 5 for i in range(1,6,2): print(i) # 1 3 5 字串遍历循环123456for c in s: # s 为字串，c 为字串中的字符 &lt;语句块&gt; ## 实例for c in &quot;PythonHello&quot;: print(c, end =&quot;,&quot;) # P,y,t,h,o,n,H,e,l,l,o, 列表循环遍历123456for i in ls: &lt;语句块&gt; ## 实例for i in [123, &quot;phy&quot;, &#x27;H&#x27;]: print(i, end = &quot;,&quot;) # 123,phy,H, 文件遍历循环12for line in fi: # fi 是文件标识符，遍历文件每行 &lt;语句块&gt; 无限循环12while &lt;条件&gt;: &lt;语句块&gt; 结合 continue 和break使用 高级循环循环可与 else 保留字结合，扩展循环结构 当循环未遇到 break 时，执行 else 语句块，类似异常处理中的 else，即通过该扩展可判断主体中是否执行了 break，一旦使用了 break，将退出当前循环，else 语句块也不会执行 123456789101112131415161718192021# for 循环for &lt;循环变量&gt; in &lt;遍历结构&gt;: &lt;语句块 1&gt;else: &lt;语句块 2&gt;# while 循环while &lt;条件&gt;: &lt;语句块 1&gt;else: &lt;语句块 2&gt; ## 实例for i in &quot;Python&quot;: if i == &quot;t&quot;: continue # break print(i, end = &quot;&quot;)else: print(&quot;程序正常结束&quot;) # Pyhon程序正常结束 # Py（使用 break 时不执行） random 库 使用随机数的标准库，主要用于生成随机数 伪随机数：采用梅森旋转算法生成的伪随机序列中的元素 import random random 库函数基本随机数函数 随机数种子：给定随机数种子，经过梅森旋转算法，将会产生一系列随机序列，随机序列中的每个数即为随机数 ​ 下图为随机数种子为 10 时产生的随机序列（部分） seed(a=None)：初始化给定的随机种子，默认为当前系统时间 random()：生成一个 [0.0, 1.0) 之间的随机小数 123import randomrandom.seed(10) # 可选项，不设置随机种子时，默认为系统时间print(random.random()) # 以 10 为随机种子，产生的随机序列的第一个随机数一定是 0.5714025946899135，多次调用可依次产生 值得注意的是，若设置了随机数种子，则每次产生的随机序列是相同的，即该过程是可复现的；而若采用系统时间，则很难再次复现 扩展随机数函数常用的扩展随机函数如下表所示。 函数 描述 random.uniform(a,b) 生成一个指定范围 [a,b] 内的随机浮点数 random.randint(a, b) 生成一个 [a, b] 内的随机整数 random.randrange(m, n[,k]) 从指定区间 [m, n) 内，按指定的步长 k 序列递增的方式生成一个随机数 random.choice(seq) 从给定序列 seq 中随机选取一个元素 random.shuffle(seq) 随机打乱序列 seq，返回打乱后的序列 random.getrandbits(k) 生成一个 k 比特长的随机整数 1234567891011# 以下运行每次结果不一致print(random.getrandbits(16))print(random.uniform(10,15))print(random.randint(10,15))print(random.randrange(10,15))print(random.choice([1,3,5,7,9,13]))# random.shuffle(s) 函数返回的是 None，因其是原位打乱s = [1,2,3,4,5,6,7,8,9]random.shuffle(s)print(s) 实例123456789101112131415#蒙特卡罗法求解圆周率import randomimport timedarts = 1000 * 1000hits = 0.0start = time.perf_counter()for i in range(1, darts + 1): x, y = random.random(), random.random() r = pow(x ** 2 + y ** 2, 0.5) if r &lt;= 1.0: hits += 1 # 圆的面积pi = 4 * (hits/darts) print(&quot;计算时间：&#123;:.5f&#125;s&quot;.format(time.perf_counter() - start))print(&quot;圆周率为：&#123;&#125;&quot;.format(pi)) 函数和代码复用函数的定义与使用函数的定义 某种功能的抽象，用于表达特点功能 作用是降低编程难度及代码复用 123def &lt;函数名&gt;(参数（0个或多个）): &lt;函数体&gt; return &lt;返回值&gt; 函数的参数传递函数的参数 无参 含默认参数：默认参数在用户调用时是可选的，若用户指定，则使用其值，否则使用默认参数。Python 中规定所有的默认参数都放在必选参数的之后（即默认参数总是放在最后） 12345678def fact(n, m = 2): sum = 1 for i in range(1, n + 1): sum *= i return sum // ma = fact(10)print(a) # 1814400 可变参数：函数定义时可以设置可变数量的参数，即不确定参数的总数量 12345678910111213141516def &lt;函数名&gt;(&lt;参数&gt;, *b): # b 为变量名，可任意设置 &lt;函数体&gt; return &lt;返回值&gt;## 实例def fact_unknow(n, *b): sum = 1 for i in range(1, n + 1): sum *= i for j in b: sum *= j # sum 与用户传入的 b 中的多个值相乘 return sumprint(fact(10, 2)) # 7257600print(fact(10, 2, 3, 4)) # 87091200 函数参数传递方式 位置传递：按函数参数指定的位置传递 名称传递：按函数参数的名臣传递 123## 对前述函数 fact() 的两种参数传递方式fact(10, 2) # 位置传递fact(m = 2, n = 10) # 名称传递 函数的返回值 可以有 return，也可以没有 可以返回 0 个或任意多个 1234return s//m, n, m # 返回值是元组类型，显示为：(1200, 10, 5)# 接收时也可以用变量a, b, c = fact(10, 2) # 则将前述的元组中的每个数赋值给 a, b, c 全局、局部变量 可在函数内部通过 global 声明变量是全局的 若局部变量为组合数据类型，且之前未创建，则其等同于全局变量（如列表类型） 123456789ls = [&quot;A&quot;, &quot;C&quot;]def fun(a): # ls = [] # 若在内部真实创建，则为局部变量 ls.append(a) # 未用 global 声明，但在函数中未真实创建，又和全局变量重名，故作为全局变量 returnfun(&quot;D&quot;)print(ls) # [&#x27;A&#x27;, &#x27;C&#x27;, &#x27;D&#x27;] lambda 函数 匿名函数，没有名字 返回函数名 用于定义简单的，能在一行内表示的函数 12345678910&lt;函数名&gt; = lambda &lt;参数&gt;: &lt;表达式&gt;## 等同于 def……return 定义的函数## 定义了有两个参数 x, y 的函数 f，用于求解两数之和f = lambda x, y: x + yprint(f(10,20)) # 30## 定义无参 lambda 函数，用于输出给定的字串f = lambda : &quot;Hello Python&quot;print(f()) # Hello Python 需谨慎使用 lambda 函数 主要用作一些特定函数或方法的参数 有一些固定的使用方式 一般建议使用 def 定义的普通函数 代码复用与函数递归代码复用 函数 对象：属性 + 方法 模块化设计：模块内部紧耦合，模块之间松耦合（两个部分之间交流较少，可以独立存在），即希望各函数之间相互影响越小 函数递归 链条：数学归纳法，递归链条 基例：有一个值特例用于结束 12345678910# 字串符反转## 思想：将给定字串的第一个字符搬到最后，剩余字符重复上述操作def reversestr(str): if str == &quot;&quot;: return str else: return reversestr(str[1:]) + str[0] str = &quot;abcf&quot;print(reversestr(str)) # fcba PyInstaller 库 第三方库 将 .py 源代码转换成无需源代码的可执行文件，如 windows 下的 .exe 文件 123456789# cmd 指令pyinstaller -F &lt;文件名&gt;.py## 常见参数-h # 查看帮助--clean # 清理打包过程中的临时文件-D, --onedir # 默认值，生成 dist 文件夹-F, --onefile # 在 dist 文件夹中只生成独立的打包文件-i &lt;图标文件名.ico&gt; # 指定打包程序使用的图标（.ico）文件 组合数据类型集合 多个元素的无序组合 元素之间无序但唯一，不存在相同元素 集合元素不可更改，即不能是可变数据类型 —为什么要求是不可变数据类型？ —集合要求元素是唯一的，若其中的元素是可变的，则修改之后元素之间可能会重复，显然是不行的 集合类型的定义 必须用 {} 表示，元素之间用逗号分割 建立集合类型用 {} 或 set() 函数 建立空集合类型，必须使用 set() 函数 12345678A = &#123;&quot;python&quot;, &quot;hello&quot;, (&quot;World&quot;, 123)&#125;print(A) # &#123;(&#x27;World&#x27;, 123), &#x27;python&#x27;, &#x27;hello&#x27;&#125;B = set(&quot;ppytthon&quot;)print(B) # &#123;&#x27;t&#x27;, &#x27;o&#x27;, &#x27;y&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;p&#x27;&#125; ## 去重且无序C = &#123;&quot;Python&quot;, &quot;123&quot;, &quot;Python&quot;, &quot;123&quot;&#125;print(C) # &#123;&#x27;Python&#x27;, &#x27;123&#x27;&#125; ## 去重且无序 集合操作符 基本操作符 操作符及应用 描述 S &#124; T 返回一个新集合，包括在集合 S 和 T 中的所有元素（并集） S - T 返回一个新集合，包括在集合 S 但不在 T 中的元素（差集） S &amp; T 返回一个新集合，包括同时在集合 S 和 T 中的元素（交集） S ^ T 返回一个新集合，包括集合 S 和 T 中的非相同元素（补集） S &lt;= T 或 S &lt; T 返回 True/False，判断 S和 T 的子集关系 S &gt;= T 或 S &gt; T 返回 True/False，判断 S和 T 的包含关系 增强操作符 如 S |= T 等与 = 结合的操作符 集合的处理方法 操作函数或方法 描述 S.add(x) 如果 x 不在集合 S 中，将 x 增加到 S S.discard(x) 移除 S 中元素 x，如果 x 不在集合 S 中，不报错 S.remove(x) 移除 S 中元素 x，如果 x 不在集合 S 中，产生 KeyError 异常 S.clear() 移除 S 中所有元素 S.pop() 随机返回 S 的一个元素，更新 S，若 S 为空产生 KeyError 异常（取出的值在集合中被删掉） S.copy() 返回集合 S 的一个副本 len(S) 返回集合 S 的元素个数 x in S 判断 S 中元素 x，x 在集合 S 中，返回 True，否则返回 False x not in S 判断 S 中元素 x，x 不在集合 S 中，返回True，否则返回 False set(x) 将其他类型变量 x 转变为集合类型 集合类型应用场景 包含关系比较 1&quot;p&quot; in &#123;&quot;p&quot;, &quot;y&quot;, &quot;hello&quot;&#125; 数据去重 利用集合元素唯一性的特性 12345ls = [&quot;p&quot;, &quot;p&quot;, &quot;y&quot;, &quot;y&quot;, 123]s = set(ls) # 将列表转为集合，集合会自动去重lt = list(s) # 再将集合转为列表print(s) # &#123;123, &#x27;p&#x27;, &#x27;y&#x27;&#125;print(lt) # [123, &#x27;p&#x27;, &#x27;y&#x27;] 序列类型 序列 具有先后关系的一组元素 一维元素向量，元素类型可以不同 元素间由序列引导，可通过下标访问序列的特定元素 是基类类型，一般使用其衍生类型，如字串、元组、列表 序列类型通用操作符 操作符及应用 描述 x in s 如果 x 是序列 s 的元素，返回 True，否则返回 False x not in s 如果 x 是序列 s 的元素，返回 False，否则返回 True s + t 连接两个序列 s 和 t s * n 或 n * s 将序列 s 复制 n 次 s[i] 索引，返回 s 中的第 i 个元素，i 是序列的序号 s[i: j] 或 s[i: j: k] 切片，返回序列 s 中第 i 到 j 以 k 为步长的元素子序列 通用函数和方法 函数和方法 描述 len(s) 返回序列 s 的长度 min(s) 返回序列 s 的最小元素，s 中元素需要可比较 max(s) 返回序列 s 的最大元素，s 中元素需要可比较 s.index(x) 或 s.index(x, i, j) 返回序列 s 从 i 开始到位置中第一次出现元素 x 的位置 s.count(x) 返回序列 s 中出现 x 的总次数 元组 一旦创建就不能被修改 使用 () 或 tuple() 创建，元素间用逗号分割 可使用或不使用 () 12a = &quot;hello&quot;, &quot;python&quot;, &quot;整点语法&quot;print(a) # (&#x27;hello&#x27;, &#x27;python&#x27;, &#x27;整点语法&#x27;) 列表 创建后可随意修改 使用 [] 或 list() 创建，元素间用逗号分割 各元素类型可不同，无长度限制 1234ls = [&quot;cat&quot;, &quot;dog&quot;, &quot;lazy&quot;, 123]print(ls) # [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;lazy&#x27;, 123]lt = ls # 赋值时仅传递，并未新建一个列表，只有 [] 是新建列表print(lt) # [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;lazy&#x27;, 123] 列表的操作和方法 函数或方法 描述 ls[i] = x 替换列表 ls 第 i 元素为 x ls[i: j: k] = It 用列表 lt 替换 ls 切片后所对应元素子列表 del ls[i] 删除列表 ls 中第 i 元素 del ls[i: j: k] 删除列表 ls 中第 i 到第 j 以 k 为步长的元素 ls += lt 更新列表 ls，将列表 lt 元素增加到列表 ls 中 ls *= n 更新列表 ls，其元素重复 n 次 函数或方法 描述 ls.append(x) 在列表 ls 最后增加一个元素 x ls.clear() 删除列表 ls 中所有元素 ls.copy() 生成一个新列表，赋值 ls 中所有元素 ls.insert(i,x) 在列表 ls 的第i位置增加元素 x ls.pop(i) 将列表 ls 中第 i 位置元素取出并删除该元素 ls.remove(x) 将列表 ls中 出现的第一个元素 x 删除 ls.reverse() 将列表 ls 中的元素反转 序列应用场景 元组用于元素不改变的场景，更多用于固定搭配场景 列表更加灵活，最常用 数据遍历、 数据保护：将列表转为元组，起到保护作用 字典类型字典定义 映射：一种键（索引）和值（数据）的对应，由用户定义数据的索引 字典类型是映射的体现 键值对 键是数据索引的扩展 字典是键值对的集合，键值对之间无序 采用大括号 {} 和 dict() 创建，键值对用冒号表示 字典用法 通过键获得值 通过键赋值 123&lt;字典变量&gt; = &#123;&lt;键 1&gt;:&lt;值 1&gt;, &lt;键 2&gt;:&lt;值 2&gt;, &lt;键 3&gt;:&lt;值 3&gt;, …, &lt;键 n&gt;:&lt;值 n&gt;&#125;&lt;值&gt; = &lt;字典变量&gt;[键]&lt;字典变量&gt;[键] = &lt;值&gt; 可通过 d = {} 的方式生成空字典，故不能用该方式生成空集合（通过 set() 生成） 字典操作 函数或方法 描述 del d[k] 删除字典 d 中键 k 对应的数据值 k in d 判断键 k 是否在字典 d 中，如果在返回 True，否则 False d.keys() 返回字典 d 中所有的键信息 d.values() 返回字典 d 中所有的值信息 d.items() 返回字典 d 中所有的键值对信息 函数或方法 描述 d.get(k, &lt;default&gt;) 键 k 存在，则返回相应值，不在则返回 &lt;default&gt; 值 d.pop(k, &lt;default&gt;) 键 k 存在，则取出相应值，不在则返回 &lt;default&gt; 值 d.popitem() 随机从字典 d 中取出一个键值对，以元组形式返回 d.clear() 删除所有的键值对 len(d) 返回字典 d 中元素的个数 字典应用 映射表达：表达键值对数据并操作它们，如统计数据（键）出现次数（值） 元素遍历 jieba 库jieba 库简介jieba 优秀的中文分词第三方库 依赖于中文字库，确定汉字之间的关联概率，概率大的组成词组 主要提供三种分词模式： 精确模式：精确切分文本，不存在冗余单词 全模式：文本中所有可能的词语都扫描出来，有冗余 搜索引擎模式：在精确模式的基础上，对长词再次切分 jiaba 库函数 函数 描述 jieba.lcut(s) 精确模式，返回一个列表类型的分词结果 jieba.lcut(s, cut_all = True) 全模式，返回一个列表类型的分词结果，存在冗余 jieba.lcut_for_search(s) 搜索引擎模式，返回一个列表类型的分词结果，存在冗余 jieba.add_word(w) 向分词词典增加新词 w 文件和数据格式化 文件：数据的抽象和集合 数据格式化：使用、存储 文件的类型 文本文件 由单一特定编码组成的文件，如 UTF-8 编码 可看做是存储着的长字符串 适用于 .txt、.py 文件等 二进制文件（存储本质） 直接由 0 和 1 组成，没有统一字符编码 一般存在二进制 0 和 1 的组织结构，即文本格式 适用于 .png、.avi 文件等 文件打开关闭 文件打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回 FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回 FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 + 与 r/w/x/a 一同使用，在原功能基础上增加同时读写功能 123s = open(&quot;file.txt&quot;, &quot;rt&quot;)print(s.readlines())s.close() 文件内容读取 操作方法 描述 &lt;f&gt;.read(size=-1) 读入全部内容，若给出参数，读入前 size 长度 &lt;f&gt;.readline(size=-1) 读入一行内容，若给出参数，读入该行前 size 长度 &lt;f&gt;.readlines(hint=-1) 读入文件所有行，以每行为元素形成列表；若给出参数，读入前 hint 行 文件文本操作 遍历全文本：一次读入，统一处理；若文件较大，将耗时严重，故可采用按数量读入，逐步处理 一次读入，逐行处理 12345filename = input(&quot;请输入文件路径：&quot;)fo = open(filename, &quot;r&quot;)for lines in fo.readlines(): # 一次性读入 print(lines)fo.close() 分行读入，逐步处理 12345filename = input(&quot;请输入文件路径：&quot;)fo = open(filename, &quot;r&quot;)for lines in fo: # 逐行读入 print(lines)fo.close() 文件写入 操作方法 描述 f.write(s) 向文件写入一个字符串或字节流 f.writelines(lines) 将一个元素全为字符串的列表写入文件，直接拼接后写入 f.seek(offset) 改变当前文件操作指针的位置，0-文件开头；1-当前位置；2-文件末尾 若打开文件先写入，紧接着遍历输出问见内容，此时不会输出任何内容，因为文件的指针在写入内容的下一行，故需要通过 seek(0) 函数将文件指针设置到文件开头方可遍历 一维数据 由对等关系的有序或无序数据构成，采用线性方式组织 对应列表、数组、集合等 二维数据：由多个一维数据组成 高维数据：仅利用最基本的二元关系展示数据间的复杂结构 操作周期：存储、表示、操作 一维数据的表示 数据有序：使用列表类型，使用 for 循环遍历处理数据 数据无序：使用集合类型，使用 for 循环遍历处理数据 一维数据的存储 空格分隔：使用一个或多个空格分割，不换行；缺点是数据中不能存在空格 逗号分隔：使用英文半角逗号分隔，不换行；缺点是数据中不能有英文逗号 其他方式：使用其他符号或符号组合分隔，建议特殊符号；缺点同理 一维数据的处理 通过 split(&quot;分隔符&quot;)读取 123txt = open(&quot;file.txt&quot;).read()ls = txt.split(&quot; &quot;)print(ls) 通过&quot;分隔符&quot;.joint()分隔数据以存储 1234f = open(&quot;file.txt&quot;, &#x27;w&#x27;)ls = [&quot;Python&quot;,&quot;is&quot;, &quot;great&quot;]f.write(&quot;$&quot;.join(ls)) # 以 $ 符号分隔f.close #Python$is$great 二维数据二维数据表示 二维列表：一维列表内部也是一维列表 通过两层 for 循环遍历二维列表：ls[row][column]，一般遵循先行后列 CSV格式与数据存储逗号分隔表示一维，行分隔表示二维 读取至列表 1234567891011fo = open(&quot;file.csv&quot;, &quot;r&quot;)ls = [] # 定义一个空列表存储读入的数据for line in fo: # 按行读取 line = line.replace(&quot;\\n&quot;, &quot;&quot;) # 将每行末尾的换行符替换为空 ls.append(line.split(&quot;,&quot;)) # 以逗号分隔的数据添加到列表中fo.close()print(ls) # [[&#x27;A&#x27;, &#x27;300&#x27;, &#x27;100&#x27;], [&#x27;B&#x27;, &#x27;500&#x27;, &#x27;500&#x27;], [&#x27;C&#x27;, &#x27;100&#x27;, &#x27;800&#x27;]]for row in ls: for col in row: print(col) # 逐个打印 列表写至csv 12345ls = [[&quot;A&quot;, &quot;100&quot;, &quot;200&quot;], [&quot;B&quot;, &quot;800&quot;, &quot;700&quot;], [&quot;C&quot;, &quot;500&quot;, &quot;400&quot;]]fw = open(&quot;file.csv&quot;, &quot;w&quot;)for item in ls: fw.write(&quot;,&quot;.join(item) + \\n) # 对列表中的元素，用 , 分隔，每行末加换行符fw.close() 面向对象类类的定义及使用123456789class 类名: # 类的属性（成员变量） # 类的行为（成员方法） def 方法名(self, 形参1, 形参2……): 方法体## 创建对象对象名 = 类名() 方法定义中的 self 必须有，且在方法内部访问成员变量时必须使用，类似 C++ 中的 this 指针 123456789101112131415161718class Student: name = None age = None def get_ifo(self): print(&quot;Hi &#123;&#125;&quot;.format(self.name)) print(f&quot;Hi &#123;self.name&#125;&quot;) print(&quot;Hi&quot;, self.name) def get_ifo2(self, msg): print(&quot;Hi &#123;&#125; &#123;&#125;&quot;.format(self.name, msg)) print(f&quot;Hi &#123;self.name&#125; &#123;msg&#125;&quot;) print(&quot;Hi&quot;, self.name, msg)stu = Student()stu.name = &quot;LI&quot;stu.age = 20stu.get_ifo() # Hi LI\\n Hi LI\\n Hi LIstu.get_ifo2(&quot;GREAT&quot;) # Hi LI GREAT\\n Hi LI GREAT\\n Hi LI GREAT 类的构造方法 构造方法：__init__ 创建类对象时，会自动执行；或将传入参数自动传递给该方法使用 12345678910111213141516171819class Student: name = None # 可不写，若不写，会在 __init__ 中构造；若写，则构造方法中为赋值 age = None def __init__(self, name, age): self.name = name self.age = age print(&quot;Initial constru&quot;) def get_ifo(self): print(&quot;Hi &#123;&#125;&quot;.format(self.name)) print(f&quot;Your age is &#123;self.age&#125;&quot;) # print(&quot;Hi&quot;, self.name)stu = Student(&quot;Li&quot;, 20) stu.get_ifo()## 输出结果# Initial constru# Hi Li# Your age is 20 类内置方法类似函数重载 字符串方法：__str__ 控制类转换为字串的行为 默认是输出对象的内存地址 可自定义为想输出的内容 1234567891011121314151617class Student: name = None age = None def __init__(self, name, age): self.name = name self.age = age def __str__(self): return &quot;Hi &#123;&#125;, your age is &#123;&#125;&quot;.format(self.name, self.age)stu = Student(&quot;Li&quot;, 20)print(str(stu)) # 未自定义字串方法：&lt;__main__.Student object at 0x7f849c43d1f0&gt; # 自定义字串方法后：Hi Li, your age is 20 小于比较方法：__lt__ 直接比较两个对象是不行的 可以在类中自定义小于或大于比较方法 小于等于比较方法：__le__ 小于等于或大于等于 等于比较方法：__eq__ 不自定义默认比较两对象的地址 123456789101112131415161718192021222324252627class Student: name = None age = None def __init__(self, name, age): self.name = name self.age = age def __lt__(self, other): # self 和 other 是传入的两个对象 return self.age &lt; other.age def __le__(self, other): return self.age &lt;= other.age def __eq__(self, other): return self.age == other.age stu1 = Student(&quot;Li1&quot;, 28)stu2 = Student(&quot;Li2&quot;, 22)stu3 = Student(&quot;Li3&quot;, 22)print(stu1 &lt; stu2) # Falseprint(stu1 &gt; stu2) # Trueprint(stu2 &lt;= stu3) # Trueprint(stu2 &gt;= stu3) # Trueprint(stu2 == stu3) # True 封装 私有成员：只需在变量名或方法名前加 __ 即可 类对象无法访问私有成员 类中其他成员可以访问 继承 在已有的类中添加新功能，若不想添加新功能，可直接使用 pass 关键字作为占位符，保证方法或类定义的完整性，表示无内容或空 单继承 12class 子类名(父类名): # 新增功能 多继承 若成员属性或方法重名，则优先级取决于继承的顺序 123class 子类名(父类名1, 父类名2, ……): # 新增功能 pass 复写 子类中重新定义父类中同名的属性或方法 一旦复写，类对象就会调用子类中复写的属性或方法；若需使用被复写的父类，需要特殊的调用方式： 父类名.成员变量/方法(self) super().成员变量/方法 类型注解 类型注解有助于 IDE 进行类型推断，协助做代码提示 帮助开发者自身对变量进行类型解释 支持变量类型、函数/方法形参列表和返回值的类型注解 基础语法：变量名: 类型 一般只有在无法直接看出变量类型时会添加类型注解 注解只是建议，并非强制性语法 变量类型注解1234567891011121314151617181920# 基础类型a: int = 10b: float = 3.14# 类对象class Student: passstu: Student = Student()# 容器类型简易注解my_list: list = [1, 2, 3]my_tuple: tuple = (1, 2, 3)# 容器类型详细注解my_list2: list[int] = [1, 2, 3]my_tuple2: tuple[str, int, bool] = [&quot;python&quot;, 1, True] # 必须每个单独指定# 直接在注释中注解a = 10 # type: intb = 3.14 # type: float 函数／方法类型注解1234567# 形参注解def func(x: int, y: float): pass# 返回值注解def add(x: int, y: int) -&gt; int: return x + y Union类型及注解 主要用于混合数据类型的注解 123456from typing import Unionmy_list: list[Union[str, int]] = [1, 2, &quot;python&quot;]my_dict: dict[str, Union[str, int]] = &#123;&quot;name&quot;: &quot;python&quot;, &quot;age&quot;: 20&#125;def func(data: Union[str, int]) -&gt; Union[str, int]: pass","categories":[{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/tags/Python/"}]},{"title":"机器人手眼标定（OpenCV)","slug":"Vrep/机器人手眼标定（OpenCV","date":"2023-04-17T09:12:29.000Z","updated":"2023-05-26T09:39:39.746Z","comments":true,"path":"hec_opencv/","link":"","permalink":"https://hbroad.github.io/hec_opencv/","excerpt":"","text":"机器人手眼标定机器人手眼标定是机器人加工、抓取等的关键，视觉系统的安装方式主要可分为两种：一类是将视觉系统直接安装在机器人末端法兰盘上，构成“眼在手上（eye-in-hand）”的配置方式，该类配置下，视觉系统随着机器人移动，视觉系统与机器人末端工具坐标系之间的位姿固定不变；另一类则与之相反，即视觉系统固定在机器人外部，构成“眼在手外（eye-to-hand）”的配置，此配置下，视觉系统与机器人基坐标系之间的位姿保持不变。 手眼标定模型AX=XB利用机器人的相对位姿求解，如采集 20 个位姿，实际可用于求解有 19 组位姿 AX=ZB利用机器人的绝对位姿求解，如采集 20 个位姿，全部参与求解 手眼标定算法实现OpenCV4 已经实现了部分经典手眼标定算法，但其说明文档实在是一言难尽，经过论文对比和测试，本文对相关参数做一解释! AX=XB123456789void cv::calibrateHandEye( InputArrayOfArrays R_gripper2base, InputArrayOfArrays t_gripper2base, InputArrayOfArrays R_target2cam, InputArrayOfArrays t_target2cam, OutputArray R_cam2gripper, OutputArray t_cam2gripper, HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI ) 参数解释：[输入] R_gripper2base vector&lt;Mat&gt; 类型，机器人位姿旋转部分，可传入 3x3 旋转矩阵或 3x1 旋转向量[输入] t_gripper2base vector&lt;Mat&gt; 类型，机器人位姿平移部分，3x1 平移向量[输入] R_target2cam vector&lt;Mat&gt; 类型，每个位姿相机外参旋转部分，可传入 3x3 旋转矩阵或 3x1 旋转向量[输入] t_target2cam vector&lt;Mat&gt; 类型，每个位姿相机外参平移部分，3x1 平移向量[输出] R_cam2gripper 手眼矩阵旋转部分，3x3 旋转矩阵[输出] t_cam2gripper 手眼矩阵平移部分，3x1 平移向量[输入] method 手眼标定算法，详见cv::HandEyeCalibrationMethod 经测试，上述标定算法中，CALIB_HAND_EYE_HORAUD的精度最高 按照 OpenCV 官方文档解释，机器人末端与基坐标系之间的转换关系为： \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{b}\\textrm{R}_g & _{}^{b}\\textrm{t}_g \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix}可见该转换矩阵将末端位姿转换到了机器人基坐标系下（等号左边是转换后结果，右边是转换前），所以该部分输入可直接采用从上位机获取的机器人位姿。 机器人上相机与标定板之间的转换关系为： \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{c}\\textrm{R}_t & _{}^{c}\\textrm{t}_t \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_t\\\\ Y_t\\\\ Z_t\\\\ 1 \\end{bmatrix}该转换矩阵将标定板坐标转换到了相机坐标系下，故该部分可直接传入每个位姿的相机外参。 最终手眼矩阵输出的结果为： \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{g}\\textrm{R}_c & _{}^{g}\\textrm{t}_c \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix}可见输出的转换矩阵即为机器人末端与相机坐标系之间的位姿关系，无需求逆。 OpenCV 的示意图误导性严重，没有遵循坐标转换关系的标准写法（具体可参考《机器人学导论》）。 AX=ZB1234567891011void cv::calibrateRobotWorldHandEye( InputArrayOfArrays R_world2cam, InputArrayOfArrays t_world2cam, InputArrayOfArrays R_base2gripper, InputArrayOfArrays t_base2gripper, OutputArray R_base2world, OutputArray t_base2world, OutputArray R_gripper2cam, OutputArray t_gripper2cam, RobotWorldHandEyeCalibrationMethod method = CALIB_ROBOT_WORLD_HAND_EYE_SHAH ) 该部分实现了两种算法，分步法和同步法各一种，经测试，两者精度几乎无差别。 参数解释同前，OpenCV官方解释同样具有强烈误导性！！ 首先是传入的机器人位姿，文档给出的转换矩阵为： \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{g}\\textrm{R}_b & _{}^{g}\\textrm{t}_b \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix}可见其将基坐标系转到了末端法兰盘坐标系，而我们上位机直接获取的位姿是在机器人基坐标系下的，故这部分在传入时需求逆矩阵，对转换矩阵而言，其逆矩阵为： T^{-1}= \\begin{bmatrix} R^T & -R^Tt \\\\ 0^T & 1 \\end{bmatrix}对每个位姿的相机外参，从其转换矩阵可知无需求逆： \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{c}\\textrm{R}_w & _{}^{c}\\textrm{t}_w \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix}最坑的地方来了，从下式可知，最终求解的手眼矩阵是以相机坐标系为参考系的，而基坐标系与世界坐标系之间的关系是以后者为参考系的，但实际中我们需要的恰好是其逆矩阵。 \\begin{bmatrix} X_w\\\\ Y_w\\\\ Z_w\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{w}\\textrm{R}_b & _{}^{w}\\textrm{t}_b \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_b\\\\ Y_b\\\\ Z_b\\\\ 1 \\end{bmatrix} \\begin{bmatrix} X_c\\\\ Y_c\\\\ Z_c\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} _{}^{c}\\textrm{R}_g & _{}^{c}\\textrm{t}_g \\\\ 0_{1 \\times 3} & 1 \\end{bmatrix} \\begin{bmatrix} X_g\\\\ Y_g\\\\ Z_g\\\\ 1 \\end{bmatrix}综上，对于部分输入输出参数必须求逆，否则计算结果完全错误，重投影误差显著增大！！！","categories":[{"name":"Robot","slug":"Robot","permalink":"https://hbroad.github.io/categories/Robot/"}],"tags":[{"name":"UR5","slug":"UR5","permalink":"https://hbroad.github.io/tags/UR5/"},{"name":"HEC","slug":"HEC","permalink":"https://hbroad.github.io/tags/HEC/"}]},{"title":"C++ 指针","slug":"CPP/C++ 指针","date":"2023-03-29T16:00:00.000Z","updated":"2023-05-26T09:37:57.797Z","comments":true,"path":"cpp_pointer/","link":"","permalink":"https://hbroad.github.io/cpp_pointer/","excerpt":"","text":"重温指针，参考油管大神，13年的视频，经典经久不衰！ 内存结构内存结构可大致分为四块，各司其职，具体可参考 Code(Text)区：该区域存储程序代码，相关文本 Static/Global区：存储静态变量及全局变量 Static区：栈区，存储局部变量，负责程序运行过程中状态存取（函数调用执行信息） 该区域由 main 函数开始存储，遇到函数调用时，会在内部重新开辟一块内存，在新的内存中执行子函数（可认为是入栈），执行完毕后子函数生命周期结束，内存被释放（可认为是出栈），返回主函数继续执行 由编译器自动分配，自动清理 Heap区：堆区，动态内存 该区并不等同于数据结构中的堆，而是一块动态内存，所有动态内存的分配均在此区域进行，如 C 中的 malloc + free，C++ 中的 new + delete 由程序员自己负责释放，如不释放，在程序结束后由系统自动回收 动态内存分配C malloc：void* malloc(size_t size) 该函数接受一个参数，该参数告知需要分配内存的具体大小，并返回通用指针类型 void*，因而在实际使用中还需类型转换 该函数只会分配指定大小的内存，并不会初始化其中的值 12int* p = (int*)malloc(sizeof(int));//sizeof(int) 获取了基本类型 int 的单位大小，如若需要更大的尺寸，可直接用元素数量整数相乘即可，如 20*sizeof(int) calloc：void* calloc(size_t num, size_t size) 与 malloc 不同的是，该函数接受两个参数，一个元素数量，另一个和 malloc 一致；即将 malloc 中整数相乘的部分作为参数 该函数会初始化内存中的值为 0 1int* p = (int*)calloc(20, sizeof(int)); realloc：void* realloc(void* ptr, size_t size) 若已动态分配了内存，需要更改内存的大小（或重新分配），可通过该函数 第一个参数指向现有内存块的首地址，第二个参数是需新分配的大小 如果需要扩充现有内存，该函数会将现有内存中的全部内容复制到新的内存中 在现有内存上扩展的前提是系统能在现有内存后找到可扩展的连续空间，否则会直接分配一块新的内存 1int* p_ = (int*)realloc(p, n*sizeof(int)); free：所有分配的内存必须通过 free 释放，如若不释放，则分配的内存依然被占用，假若每次都不释放，内存终究会被消耗完 即使释放后，内存可是可访问和修改的，但其中的值是随机的，所以使用内存之前一定要申请内存 c++new + delete 内存泄漏正常情况下，函数的调用均在栈区进行，每调用一次，被调函数生命周期结束返回到主函数时，被调函数的内存被释放，等到下一次调用时重新分配，这个过程由编译器自动进行。 但若我们从堆区动态申请内存，而不手动释放，且由于编译器并不会自动释放，程序运行一段时间后最终会导致内存耗完，而这些未释放的内存不能被别的程序使用，成为了“垃圾”，这种垃圾的不断增加就是内存泄漏。 如若申请使用后释放，效果就和栈区一样。 Java 和 C# 中会自动释放堆区内存，但 C/C++ 不会。 指针与函数指针作为函数返回值假设我们需要通过调用函数实现两数之和，最简单的场景是： 12345678910111213#include &lt;iostream&gt;using namespace std;int Add(int a, int b)&#123; int c = a + b; return c;&#125;int main()&#123; int a = 2, b = 4; int c = Add(a, b); cout &lt;&lt; c;&#125; 若通过指针作为参数来实现上述过程： 12345678910111213#include &lt;iostream&gt;using namespace std;int Add(int* a, int* b)&#123; int c = *a + *b; return c;&#125;int main()&#123; int a = 2, b = 4; int c = Add(&amp;a, &amp;b); cout &lt;&lt; c;&#125; 假若我们将函数的返回值通过指针带回，可以写为： 1234567891011121314#include &lt;iostream&gt;using namespace std;int* Add(int* a, int* b)&#123; int c = *a + *b; return &amp;c;&#125;int main()&#123; int a = 2, b = 4; int* ptr = Add(&amp;a, &amp;b); cout &lt;&lt; &quot;sum&quot; &lt;&lt; *ptr;&#125; 运行该代码完全看运气，或许偶尔能得到正确的值，这是一个典型的逻辑错误，分析如下： 程序从主函数开始，在栈区开辟一段内存，并存储三个局部变量 函数执行到12行时，在栈顶开辟一块新内存存储 Add 函数及其局部变量，由于 Add 函数中的 a、b 指针分别指向 main 函数中的 a、b，故其中存储主函数中局部变量的地址，求和后存储在变量 c 中 Add 函数最终返回了 c 的地址，由主函数中的指针 ptr 接受，Add 函数结束，其内存被自动释放（若有其他函数，则会被其他函数占用），此时在主函数中输出返回值，结果自然是错误的，因为 ptr 指向的内存已被抹去，指针为 NULL了 如何解决呢？ 既然栈区是编译器自动分配与释放，那自然想到堆区（或静态/全局区），由程序员自己申请和释放，只要自己不释放，在程序周期内一直存在 123456789101112131415#include &lt;iostream&gt;using namespace std;int* Add(int* a, int* b)&#123; int* c = new int; //动态申请，不释放，存在直到程序结束 *c = *a + *b; return c;&#125;int main()&#123; int a = 2, b = 4; int* ptr = Add(&amp;a, &amp;b); cout &lt;&lt; *ptr;&#125; 如下图所示，在栈区存储的 Add 函数中，向堆区动态申请了一块内存，也就是栈区的 c 指向了堆区，求和的结果存储在堆区，Add 函数返回了堆区的地址，由于堆区需要手动释放，所以主函数可通过返回的地址获取求和的结果。 函数指针核心含义 顾名思义，指针指向函数 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int Add(int a, int b)&#123; int c = a + b; return c;&#125;int main()&#123; int a = 2, b = 4; int (*p)(int, int); //声明一个指针，该指针指向一个带有两个 int 型参数的函数// p = &amp;Add; //和下述同义// int c = (*p)(a, b); p = Add; int c = p(a, b); cout &lt;&lt; c;&#125; 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void print()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;&#125;void print_name(char* name)&#123; cout &lt;&lt; &quot;Hello &quot; &lt;&lt; name;&#125;int main()&#123; void (*p)(); p = print; p(); //函数指针调用其指向的函数（可直接作为函数名进行调用） void (*pn)(char*); pn = print_name; pn(&quot;Duke&quot;); //可接受函数参数&#125; 注意和 int* p(int, int) 的区别，这是定义了一个函数 p，其返回值为指向 int 的指针 函数指针与回调函数函数指针是可以作为函数参数的 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void print()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;&#125;void print2(void (*p)())&#123; p();&#125;int main()&#123; void (*p)() = print; print2(p); // 等价于下面的 print2(print);&#125; 这段代码中通过函数指针，实现了对另一个函数的回调，但这种显然没有实际意义。 考虑这样一个场景，我们需要对用户输入的一组数进行排序，但升序和降序由用户决定，简单的做法是写升序和降序两段代码，但显然不利于代码的维护，此时便可通过函数指针作为函数参数，通过由用户定义的回调函数，判断升降排序。以冒泡排序为例： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;//回调函数，控制比较的机制int compare(int a, int b)&#123; if(a &gt; b) return 1; //定义规则，此时为升序，改为 -1 即为降序 else return -1;&#125;void bubbleSort(int* A, int n, int (*compare)(int, int))&#123; int i, j, tmp; for (i = 0; i &lt; n; ++i) for (j = 0; j &lt; n-1; ++j)&#123;// if(A[j] &gt; A[j + 1]) if (compare(A[j], A[j+1]) &gt; 0)&#123; //若为 true，则交换，否则保持原顺序 tmp = A[j]; A[j] = A[j + 1]; A[j + 1] = tmp; &#125; &#125;&#125;int main()&#123; int A[] = &#123;2,5,1,4,3,6&#125;;// bubbleSort(A, 6); bubbleSort(A,6,compare); for(auto a : A) cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125; 该程序定义了回调函数 compare()，其对输入序列中的相邻两个值进行比较，实现升降排序，通过这种方式可完全隐藏函数内部实现，由用户定义自己的排序机制。 这在 C/C++ 标准库中有诸多体现，如快排 qsort，该函数可以对任意类似的数组进行排序，故其需要定义排序的逻辑： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdlib&gt; //qsortusing namespace std;//回调函数，控制比较的机制int compare(const void* a, const void* b)&#123;// int A = *(int*)a; //强制类型转换// int B = *(int*)b;// return A - B; return (*(int*)a - *(int*)b); //也可用 if 语句&#125;int main()&#123; int A[] = &#123;2,5,1,4,3,6&#125;; qsort(A, 6, sizeof(int), compare); for(auto a : A) cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125; 由于 qsort 是通用的排序方法，故其回调函数是通用指针 void*，在该函数内部，首先转为所需类型的指针，再解引用参与计算。 此外，回调函数另一常见的使用场景是 事件处理（MFC、OpenCV 等中的按钮事件）。","categories":[{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"}]},{"title":"C++ 小知识点","slug":"CPP/C++常用","date":"2023-03-12T16:00:00.000Z","updated":"2023-04-17T14:37:33.779Z","comments":true,"path":"cpp_useful_sugar/","link":"","permalink":"https://hbroad.github.io/cpp_useful_sugar/","excerpt":"旨在记录一些常见、易错点","text":"旨在记录一些常见、易错点 浮点数的比较 如何比较两个浮点数是否相等 FLT_EPSILON 表示计算机能表示的最小的浮点数 不能直接使用 a==b 判断浮点数是否相等 1234if (fabs(a - b) &lt; FLT_EPSILON) &#123; // a 和 b 被认为是相等的&#125;// double DBL_EPSILON","categories":[{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"}]},{"title":"UR5_Vrep 仿真","slug":"Vrep/UR5_VREP仿真","date":"2022-11-17T16:00:00.000Z","updated":"2023-05-26T09:34:52.495Z","comments":true,"path":"ur5_vrep_simu/","link":"","permalink":"https://hbroad.github.io/ur5_vrep_simu/","excerpt":"UR5 结合 Coppeliasim（旧Vrep） 的仿真相关操作记录","text":"UR5 结合 Coppeliasim（旧Vrep） 的仿真相关操作记录 逆运动学dummy dummy 解释 参考 dummy 的添加 添加一个dummy，dummy在V-REP 中是最简单的模型。然后调整其位置到（-3.7658e-1，+0e+0，+1.0013e+0），注意此时我们假设你的UR的坐标是（+0e+0，+0e+0，+1.4650e-2）。如果你调整的UR的位置，那么这个dummy的位置也需要左相应的调整。当然也没有这么死板，只要将其放在你认为的夹持器工作中心即可。然后将其重命名为 UR5_tip。 所以demo 中的 UR5_Tip 在夹爪中心的原因是其平移过去而非直接与夹爪相连 逆运动学计算方法：伪逆（不稳定但快速）、DLS（稳定但慢） vrep 中编辑 path 时可能出现部分视角看不到完整路径的情况，可新建一场景，编辑后再导入，注意不要更改其位置 Vrep 仿真小问题 仿真开始时部分位置会显示一个紫色球体，这是由于添加了 Blob to 3D position 相机的原因，紫色球体即为相机在场景中检测到的物体(参考)，可在脚本中将 addDrawingObject 注释 编辑路径时，路径上控制点过大，导致编辑看不清，可在属性中设置大小 Geomagic 提取模型合模线 分别选择两个平面拟合平面特征（也可直接选择探测特征，但效果一般） 选择 特征-平面-两平面平均 创建合模线所在平面 选择 曲线-从截面创建，创建平面所经过的曲线，即为合模线 选择 曲线-创建点，合模线离散为点，后续用于路径规划 2023年2月21日19:08:34 导入模型后，首先将CAD模型的坐标系移动到合适的位置，这个过程使用 对象移动器，通过主矢可直接对齐坐标系 在选择选项卡下，更改选择为矩形 选择两平面拟合 Geomagic 点云数据导出 不同的格式对应不同的单位 pcd 文件对应的单位：m obj 文件对应的单位：mm（导出到该格式的点可能和源文件的有差异，下图左为导出后顺序，右为原点云顺序） asc文件格式数据和原点云一致，只需更换点云描述头 Geomagic 与 Vrep 数据转换 Vrep 模型导入（图源） 由 Vrep 导出后，导入到 Geomagic 中时选择单位必须为 m，否则轨迹不正确 关于模型的缩放（当下不需要了，直接在导入时选择单位） 先将扫描得到的 CAD 模型直接导入到 Vrep，可以观察到大小完全不是一个等级，这时候就要缩放，缩放因子设置为 $0.5^n$，这里需要不断调节直到合适的大小 缩放的验证：比如设置缩放因子为 $0.5^8$，此即为将原模型缩放了 256 $(1/0.5^8)$倍， 选取轨迹上两点并测量其距离，距离的缩放应满足该倍数关系 关于最终轨迹的生成 首先将原模型导入，通过设置位置坐标将其移动到机器人基坐标系下（这里可直接输入机器人的基坐标系位置） 设置缩放因子缩放到合适的大小，并旋转到合适的位置 导出上述缩放后的模型（记住导出的轴哪个向上），并重新导入（注意选择与导出时相同的向上轴），再次导出作为最终的模型，此时的模型重新导入时坐标方向是一致的（原因未知） 导入 Geomagic，选择并拟合两个平面，通过拟合的两平面建立中间的平面（即合模线所在平面），通过截面创建曲线，生成点，删除多余的点 拟合两个平面： 取合模线所在平面： 截面创建轨迹： 轨迹线转为点： 导出的点是无序的，可以将数据在 Origin 中画出来，按顺序排好后再导入到 Vrep，此时的轨迹和前述的模型应当是匹配的，在 Vrep 中可以将其设置为模型的从属 无序点（显示的标签为行号）： 排序结果： Geomagic 模型切半 将点集封装成多边形 点击裁剪，按平面，选择好平面 点击下面的平面截面，选择要删除的选区，删除即可 模型轨迹在实际机器人基坐标系下的位姿 按前述将模型导入 Vrep 后，Vrep 自动生成该模型在基坐标系下的位姿 将该模型导出，再导入，再导出作为最终模型使用 提取导出模型的合模线，按前述创建轨迹（该轨迹是和模型同处于机器人基坐标系下的） ，导入到 Vrep 指定每个控制点的方向后导出得到最终的轨迹 注意此时导出的轨迹是 $x,y,z,\\alpha,\\beta,\\gamma$，单位是 $m$ 和 $°$ 测量点云与导出模型（作为CAD模型）配准，得到转换矩阵 轨迹点位姿与转换矩阵相乘，得到转换到实际机器人基坐标系下的轨迹，该轨迹包含位姿 在轨迹点与转换矩阵相乘前，需要将其转换为矩阵的形式，转换顺序为：原始轨迹点——单位转换为mm——欧拉角转旋转矩阵——合并为转换矩阵 vrep 导出模型时单位为 m，需乘 1000 转为 mm，导出的模型作为 CAD 与测量点云配准","categories":[{"name":"Robot","slug":"Robot","permalink":"https://hbroad.github.io/categories/Robot/"}],"tags":[{"name":"UR5","slug":"UR5","permalink":"https://hbroad.github.io/tags/UR5/"},{"name":"Simulation","slug":"Simulation","permalink":"https://hbroad.github.io/tags/Simulation/"},{"name":"Coppeliasim/Vrep","slug":"Coppeliasim-Vrep","permalink":"https://hbroad.github.io/tags/Coppeliasim-Vrep/"}]},{"title":"C++ 学习笔记","slug":"CPP/C++","date":"2022-08-22T16:00:00.000Z","updated":"2023-04-17T14:35:13.146Z","comments":true,"path":"cpp_learning/","link":"","permalink":"https://hbroad.github.io/cpp_learning/","excerpt":"C++ 学习笔记上传（研） 原链接","text":"C++ 学习笔记上传（研） 原链接 小概念集锦 外存储器的容量大， 大部分可移动，便于在不同计算机之间进行信息交流。其只有被读入内存储器后才可被CPU读取，即CPU不能直接访问外存储器 进程是可以并发执行的程序的执行过程 循环队列是顺序存储结构 拷贝构造函数： 程序中需要新建立一个对象，并用另一个对象去初始化 函数的参数为类的对象 函数的返回值是类的对象 类外同名的变量赋值，不能改变类内的静态变量值 程序中的 typename 都可以替换为 class NULL 与 nullptr NULL 在 C 中表示 void，即指向任意类型的指针，C 中会完成隐式类型转换，但 C++ 中是强制类型转换，导致 void 不能隐式转换为其他类型 起初 C++ 用 0 代替空指针，但其在函数重载时发生二义性，后续直接用 nullptr，而 NULL 表示 0 CPP小概念基本框架结构化程序设计框架 函数是程序的基本单元 面向对象程序设计框架 类是程序的基本组成单元 数据类型 单精度不能超过 7 位有效数字，双精度不能超过 15 位 一个字符串常量在存储时在给定的字符序列后再加一个空字符（‘\\0’），而字符常量不加 任一种进制的整数，可添加后缀字母 U 或 L，表示无符号整型（usigned int）和长整型（long int），也可同时添加两者，无排序要求，如：55L，100LU 变量 变量的存储类属性 auto（自动变量）：默认存储类别，占用空间的分配和释放由系统自动完成 register（寄存器变量）：寄存器虽然快，但其数量有限，当其不够时，仍然按照 auto 处理 static（静态变量）：任何静态变量的生存期将延续到整个程序的终止；编译器为其分配的空间在整个程序运行期间不会释放；若未赋初值，系统自动赋值为 0 extern（外部变量）：声明为外部变量后，该变量可被其他文件引用，可避免为其重复分配内存 typedef 类型 给现有的数据类型起一个别名 符号常量 概念：用 const 修饰的标识符 原则：先声明，后使用 声明：const int i = 1； 用 const 声明的常量只能被读取，故在声明时需初始化，且其值在程序中无法改变 可用预处理命令 #define 定义符号常量：#define PI 3.14 运算符和表达式运算符 单目 双目 三目：?:（C++只此一个） 运算类型 赋值运算：可一次性给多变量赋值：x=y=z=1; 其从右往左依次赋值，即 z=1，接着将 z=1 赋给 y，得 y=z=1，最后得 x=y=z=1 自增运算 a++：先参与运算，运算后再 +1 ++a：先 +1，再参与到运算中 逻辑运算符 ！ &amp;&amp; || 优先级依次递减 其他运算符 条件运算符：?: a&gt;b ? 1:0；若a&gt;b，返回1 ，否则0 逗号运算符：返回最后表达式的值 (a = 3 * 5, a * 4), a + 5; // a = 15，表达式结果为 20 sizeof运算符：取得任何变量和类型在内存中占用的字节数 sizeof(int); //4 #include &lt;cmath&gt; // C++ 数学函数 指针指针和地址 指针：变量的地址就是该变量的指针 指针变量：存放地址的变量 指针运算 指针变量和整型量加减 = 指向下一元素 相同的指针变量类型之间可以赋值 两个指向同一类型的指针变量进行逻辑运算，实质是地址的比较 两指向同一数组成员的指针变量可减运算，结果为两指针之间相差的元素个数 指针和数组 数组名即为该数组首元素的地址，即指针 数组名是常量指针，而指针是指针变量 1234567891011int a[10];int *p;//首元素的地址给指针p = &amp;a[0];p = a;//取首元素a[0];*p;*a; 字符串常量可以赋给指针变量，会将前者第一个字符的指针给后者 引用 引用即为变量起别名 既然是起别名，在定义时就要初始化，即指定给谁起别名 既然是别名，那么对引用的操作就是对变量本身的操作 引用就是两个变量使用的是同一块内存单元 12int i = 1;int &amp;j = i; // 给 i 起别名为 j &amp;只是标识符，非取地址符 一旦引用被初始化，不可更改为另一变量的引用 动态存储分配 静态存储分配是在编译阶段确定变量占据的空间，而部分程序只有在运行时才能确定，即为动态内存分配 new 申请，delete 释放 1234567891011121314151617//对某种数据类型分配空间，赋初值10int *a;a = new int(10);//或int *a = new int;*a = 10;//释放delete a;// 对数组int *b;b = new int[10]; // 元素个数可以是变量，这是与一般的数组声明最大的区别//释放delete[] a; 动态内存分配是在堆内存或自由存储区，数量有限，当耗尽时再申请会返回空指针 NULL，故在分配空间后，可做判断如下： 12if (a == NULL) exit(0); //正常结束程序 动态分配后的内存需显式的释放，由 new 申请，则必须由 delete 释放 函数函数及声明 函数不能嵌套，即函数内部不能定义其他函数 函数原型声明的两种形式（注意是声明不是定义） 123double sort(int a[], int b);//或省略形参变量名double sort(int [], int); 函数参数参数的传递方式 值传递 实参不变，将实参复制一份给形参 虽不会改变实参的值，但当传递参数的大型的类对象时，空间和时间开销过大 传地址 传地址之后将改变实参的值 引用传递 隐式的传地址 参数声明为引用时，调用时编译器将自动传递实参的地址给被调用函数 一般情况下，当传递大型的数组或类对象时，采取传递指针的方式，因为任意类型的指针大小是一样的（32位下为 4 字节，64 位下为 8 字节），相比复制传递的方式，空间开销小很多。 建议传地址时使用引用代替指针 指针和引用的区别 定义和性质的不同 指针是地址，引用只是变量的别名，与原变量共用一块地址 函数传参时的区别 指针传参可以直接操作实参的地址，对实参进行改变 引用传参是直接传递实参本身，节约时间空间 默认参数 默认参数 缺省的实参只能用于替换函数调用中缺少的尾部实参，即函数调用是按位置依次赋值的，不是按照参数的类型匹配的，即实参的类型要和形参的顺序一致 12345int default_n(int a = 1, int b = 2, char c = &#x27; &#x27;);//调用default_n(, , &#x27;&lt;&lt;&#x27;); // 该调用并不等价于 default_n(1, 2, &#x27;&lt;&lt;&#x27;);defaulr_n(&#x27;&lt;&lt;&#x27;); //同上 函数重载参数个数/参数类型不同 内联函数 为取代预处理宏函数 inline 关键字放在函数定义中的函数类型之前 内联函数和宏函数 宏函数由预处理器进行替换，而内联函数由编译器实现，是真正的函数 但内联函数调用时像宏一样展开，执行效率更高 内联函数和普通函数 普通函数的调用将控制转移给被调用函数，从而调用有一定的时间和空间开销 内联函数直接将被调用函数复制一份到调用的地方，效率更高 但该优点也是缺点，即内联函数的函数体不能太大，结构也不能太复杂，否则编译器将放弃内联方式转而采用普通方式调用 递归函数类和对象类 数据成员：属性 类中数据成员的类型任意，包括另一个类的对象 虽自身类的对象不能作为数据成员（因为类还没定义完成，该类型没法分配存储空间），但自身类的指针或引用可以（任意类型的指针大小是确定的） 类体内不能对数据初始化，初始化由构造函数完成 成员函数：行为 在类内定义的成员函数皆为内联函数 类外也可定义函数，通过类名+作用域运算符::来表明函数属于哪个类 成员函数可重载，参数可设置默认值 类成员的访问控制 私有成员只能被自己所属类中的成员函数及友元函数访问 对象 对象的定义 可定义一般类对象、对象数组、对象指针、对象引用 1234class c1;class c2[10];class *c3;class &amp;c4 = c1; 对象的成员及其访问 . 运算符：访问一般对象的成员（数据成员或成员函数），也可访问对象引用或对象数组的成员，方法一致 123456789class Time&#123; public: int hour; void settime();&#125;;Time T1;T1.hour;T1.settime(); -&gt;运算符：访问一个指针变量所指向的对象成员，等价于 (*对象指针名).成员 12345678Time T1;Time* T2 = T1;//对象指针变量 T2 的成员访问T2 -&gt; hour;T2 -&gt; settime();//或(*T2).hour;(*T2).settime; 构造函数和析构函数 构造函数的作用：用于新建对象的初始化工作 析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等 每当创建对象，需要对该对象完成初始化时，则需要定义自己的构造函数；而对象撤销，需要自己添加清理工作代码时，则需要定义自己的析构函数 共同特点： 类体中说明的两种成员函数 没有返回值，void也不行 构造函数可带参数，可重载；析构函数都不能 构造函数 函数名与类名相同 函数体可在体内/体外 一般声明为公有函数 在定义对象时被系统直接调用，用户不能直接调用构造函数 构造函数初始化对象：类名 对象名 (参数表)，如：class c1 (1,2,3); 运算符 new + 构造函数： class * c2 = new class () 定义对象数组时只能调用没有参数或所有参数都有默认值的参数 定义对象指针时不会调用构造函数，因为指针变量还未实例化 析构函数 ~ 类名 函数体可在体内/外 在对象生存期即将结束时由系统自动调用，之后对象消失，内存空间被释放 一个类只能定义一个析构函数 delete 运算符和析构函数一起使用 默认构造/析构函数 不带参数 函数与类名相同 参数为空或所有参数带默认值 用户未定义时系统自动建立 拷贝构造函数 只有一个参数，类型是本类对象的引用 每个类必须要有，若没有则编译系统自动生成一个公有的 被调用的 3 种情况： 用类的已知的对象去初始化另一对象 对象作为函数的实参传递给函数形参 对象作为函数的返回值 形式： Copy_ConsFun_Name(const class_name &amp;obj_name) 自由存储对象 由堆运算符 new 和 delete 建立和删除 new 创建单个对象：根据参数调用构造函数 new 创建对象数组：调用默认构造函数 delete 删除对象：调用析构函数 new 或 delete 是显式的调用构造函数，调用的顺序取决于 new 和 delete 的顺序，析构的顺序不一定与构造的顺序相反，但对象数组中各个元素的构造和析构仍然是相反的 delete 删除对象和对象数组时各调用一次析构函数 this 指针 对象创建后，对象的每个成员函数都含有一个系统自动生成的隐含指针，用于保存该对象的地址 “指向本对象的指针” 成员函数所属的对象指针，指向类对象的地址 成员函数可以通过该指针知道自己属于哪个类 this -&gt; 成员变量 可用于区分形参变量和对象成员变量（形参变量和成员变量标识符一致时更加明显） 一般不写，系统默认设置，但要注意： 只能在类的成员函数中使用，指向该函数被调用的对象，一般用于返回当前对象本身 静态成员函数没有 this 指针 编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。 友元函数没有 this 指针 （因为友元函数不属于任何类） 静态成员类中的非静态成员，每个类对象都有一个拷贝（副本），相互独立；而静态成员便是解决同一类的不同对象之间的数据和函数共享问题的，即不管该类拥有多少对象，其静态成员都只有一个副本，该副本被所有对象共享。 表示整个类范围的信息，以 static声明 静态数据成员 静态数据成员的值对所有对象都是一样的，但每个对象可以更新其值 必须初始化，格式为：数据类型 类名 :: 静态数据成员名 = 值 初始化在类体外进行，且前面不加 static，以免与一般静态变量或对象相混淆 初始化时使用作用域运算符来表明所属的类，因静态数据成员是类的成员 初始化时不加该成员的访问权限控制符 若静态数据成员为 public，可在程序中引用该成员：类名 :: 静态数据成员，此时若未初始化，编译系统会自动赋值 0 也即：静态成员变量既可以通过对象名引用（obj.static_memb），也可通过类名引用（class_name::static_memb） 静态成员函数 用于访问类中保护或私有成员的公有接口 以 static 声明，属于类，由所有对象共享 可在类内/外定义，类外定义时不加 static 对对象的访问： 可直接访问类中说明的静态成员，但不能是非静态成员 非静态成员需通过参数传递的方式得到对象后再通过对象访问 main() 函数中对静态函数的调用：类名 :: 静态成员函数名 (参数可选)或 对象名.静态成员函数名 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） 常成员对于既需要共享，又不希望其值被改变的数据，可定义为常成员进行保护，保证其在整个程序运行期间不可改变，用 const修饰符定义 常对象使用 const 关键字修饰的对象 类名 const 对象名 或 const 类名 对象名 常对象必须有初值，且不能被更新 常对象只能调用类中的常成员函数 常成员函数使用 const 关键字说明的成员函数 返回类型 成员函数名 (参数) const 函数实现部分也要带有 const 关键字：type class_name :: memb_fun(argu) const 不能更新对象的数据成员，也不能调用类中没有用 const 修饰的函数 const 关键字可用于对重载函数的区分 常数据成员使用 const 关键字修饰的数据成员 const type name 定义必须出现在类体中 必须通过构造函数的成员初始化列表进行初始化（唯一的方法），且不能被更新，格式： 类名 :: 类名(形参) ：常数据成员 (赋值) 123456789101112class VLA&#123;private: const int m_len; int *m_arr;public: VLA(int len);&#125;;//必须使用初始化列表来初始化 m_lenVLA::VLA(int len): m_len(len)&#123; m_arr = new int[len];&#125; 友元 解决类外访问类的私有和保护成员 友元机制允许一个类授权其他的函数访问其非公有成员，减小开销，提高程序运行效率 友元声明 关键字： friend 只能在类的声明中出现 友元函数 在类体中以 friend 声明，独立于当前类的外部函数 可以是不属于任何类的非成员函数，也可以是其他类的成员函数，可访问该类中的私有成员 friend 数据类型 友元函数名 (形参) 在类定义时声明，一般在类外定义友元函数（类中声明，类外定义） 普通友元函数（即类的非成员函数）引用类的私有成员时，需通过对象，即对象名.的形式，因普通友元函数不是类的成员函数 一个函数可被多个类声明为友元函数 友元类类B为A的友元类，则： B 中的所有成员函数都是 A 的友元函数，可访问 A 的所有成员 friend 类名 友元类不具有对称性：B是A的友元类，但A不是B的 友元类不具有传递性：A是B的友元类，B是C的友元类，不代表A是C的友元类 对象数组 数组元素是对象，且每个元素是同一个类的对象 定义：类名 数组名 (元素个数可选) 访问：数组名[下标可选].成员名 创建类的对象数组的条件： 没有给出构造函数，调用系统默认构造函数 有一个不带参数的构造函数 一个构造函数的参数全是默认参数 对象数组的生命周期结束时，默认给每个元素调用一次析构函数，也可通过 delete 强制调用,，构造同理 若定义对象数组时没有使用初始化列表进行初始化，则会为每个对象调用默认构造函数 若初始化项少于数组中的对象，则对剩余的对象调用默认构造函数 成员对象 一个类的成员是另一个类的对象 class c &#123; c1 obj1; c2 obj2; &#125;; 类中有成员对象时，该类的构造函数要调用这些成员对象所在类的构造函数，并采用初始化列表进行初始化 构造函数的调用顺序取决于类中的说明顺序，析构的调用相反 只能调用成员对象的公有函数或变量 继承与派生基本概念 继承：在现有类的基础上创建新类，新类得到已有类已经具备的特性 派生：从已有类（基类）产生一个子类（派生类） 单继承、多继承 基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样 派生类将基类的所有成员全部接收过来，除了构造和析构函数 派生类可对基类初始化 派生类对基类的访问 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 基类中的私有成员在派生类中不可访问，只能在基类访问 派生类中可访问基类中的公有和保护成员 派生类的析构和构造函数基类的构造和析构不能被继承，故派生类的构造函数须调用基类的构造函数以初始化，同理，对派生对象的清理也需要新的析构函数 派生类的构造函数 问题： 考虑新增成员的初始化 考虑基类成员的初始化 解决： 执行派生类的构造函数时，调用基类的构造，注意是调用基类的构造函数，不是声明 执行顺序： 调用基类的构造函数：按照定义派生类时基类的声明顺序进行，而与派生类构造函数的成员初始化列表给出的顺序无关 12class son_class:public dad_class1(x), dad_class2(x1) &#123;&#125;//调用构造函数时先调用基类 dad_class1 的构造，接着调用 dad_class2 的 调用成员对象的构造函数：派生类中有多个成员对象时，按照派生类中声明成员对象的顺序进行，同样与初始化列表无关 1234567class son_class:public dad_class1(x), dad_class2(x1) &#123; dad_class2 c2; dad_class1 c1; …&#125;//调用构造函数时先调用基类 dad_class2 的构造，接着调用 dad_class1 的 执行派生类构造函数体中的内容，完成对派生类的初始化 派生类中既有对基类的声明，又有成员对象时，先调用基类的构造函数，再调用成员对象所属类的构造函数，最后调用派生类自己的构造 1234567class son_class:public dad_class1(x)&#123; dad_class2 c2; son_class(……) &#123;……&#125; …&#125;//先调用基类 dad_class1 的构造，接着调用 dad_class2 的，最后调用自身的 派生类的析构函数调用过程与构造相反 对派生类普通成员清理 调用成员对象的析构，对派生类新增的成员对象清理 调用基类析构，对基类清理 多继承与虚基类多继承中的二义性 一个派生类有两个或多个基类 在派生类中对基类的访问应该是唯一的 在多继承情况下，派生类对基类中某个成员的访问出现不唯一的情况，即产生二义性 产生二义性问题的两种情况： 多继承中，有两个或两个以上的基类存在同名成员，采用对象名.函数名直接调用时无法判断属于哪个类 解决方法有二： 通过作用域运算符进行限定，指定是哪个基类的函数 对象名.基类名 :: 成员函数名() 在派生类中定义同名成员以屏蔽基类中二义性的成员，但此时仍然可通过 :: 指定访问 一个派生类从多个基类派生，且这些基类有一个共同的基类时，派生类访问该共同基类的成员时产生二义性 解决方法同上，但更优的方法是虚基类 虚基类（虚继承）http://c.biancheng.net/view/2280.html 解决二义性问题，将共同基类定义为虚基类，方式如下 定义 class c_name : virtual 继承方式 基类名 class c_name : 继承方式 virtual 基类名 注意 虚基类是在声明派生类时，指定继承方式时声明的 虚基类派生的类，只产生一个虚基类子对象 （可以理解为在派生类中只保留了一份共同基类的成员，这样就不会产生歧义了） 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 虚基类的构造函数 虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。 虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。 直接或间接继承虚基类的派生类，其构造函数的成员初始化列表中，都列出了对虚基类构造函数的调用，而在最后的派生类中，除了对直接基类的初始化，还要对虚基类初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;//虚基类Aclass A&#123;public: A(int a);protected: int m_a;&#125;;A::A(int a): m_a(a)&#123; &#125;//直接派生类Bclass B: virtual public A&#123;public: B(int a, int b);public: void display();protected: int m_b;&#125;;B::B(int a, int b): A(a), m_b(b)&#123; &#125; // B 的直接继承中调用了A 的构造void B::display()&#123; cout&lt;&lt;&quot;m_a=&quot;&lt;&lt;m_a&lt;&lt;&quot;, m_b=&quot;&lt;&lt;m_b&lt;&lt;endl;&#125;//直接派生类Cclass C: virtual public A&#123;public: C(int a, int c);public: void display();protected: int m_c;&#125;;C::C(int a, int c): A(a), m_c(c)&#123; &#125; // C 的直接继承中调用了A 的构造void C::display()&#123; cout&lt;&lt;&quot;m_a=&quot;&lt;&lt;m_a&lt;&lt;&quot;, m_c=&quot;&lt;&lt;m_c&lt;&lt;endl;&#125;//间接派生类Dclass D: public B, public C&#123;public: D(int a, int b, int c, int d);public: void display();private: int m_d;&#125;;// D 的间接继承中调用了直接继承 B、C 的构造，以及间接继承 A 的构造D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d)&#123; &#125;void D::display()&#123; cout&lt;&lt;&quot;m_a=&quot;&lt;&lt;m_a&lt;&lt;&quot;, m_b=&quot;&lt;&lt;m_b&lt;&lt;&quot;, m_c=&quot;&lt;&lt;m_c&lt;&lt;&quot;, m_d=&quot;&lt;&lt;m_d&lt;&lt;endl;&#125;int main()&#123; B b(10, 20); b.display(); C c(30, 40); c.display(); D d(50, 60, 70, 80); d.display(); return 0;&#125; 子类型关系（向上转型）类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。 虚函数与多态性多态 同一接口为不同的对象服务 分类 编译时的多态：通过函数重载和模板实现，在编译阶段确定调用哪个函数，实现机制称为“静态绑定” 运行时的多态：只有在运行时才知道是哪个函数，“动态绑定” 多态是通过虚函数实现的 虚函数 指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数 通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数 而虚函数允许在派生类中定义与基类同名的函数，且可用基类的指针或引用访问基/派生类中的同名函数 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism） C++中虚函数的唯一用处就是构成多态，有了多态，只需要一个指针变量就可以调用所有派生类的虚函数 虚函数可以是另一个类的友元函数，但不能是静态成员函数、内联函数、构造函数 派生类中可以重新定义从基类继承下来的虚函数，也可以不需要。但在派生类中重新定义虚函数时，函数名、形参表、返回值类型必须保持不变 换句话说，虚函数使得派生类可以更改（其实是覆盖）基类中的同名函数 若基类声明了虚函数，则在派生类中凡与该函数同名，同类型，同参数个数的均为虚函数 虚析构函数 一般情况下，清理派生类的对象时先调用派生类的析构，再调用基类的析构 但若用 new 建立了临时对象，如果基类中有析构，且定义了一个指向基类的指针变量，那么程序在用带指针参数的 delete 撤销对象时，系统只调用基类的析构 故若要调用派生类的析构函数，就要将其声明为虚函数，即虚析构函数 纯虚函数 在基类中给派生类预留一个虚函数的名，但基类不知道拿这个函数干嘛，留给派生类补充函数体 即基类无法确定一个虚函数的具体操作方式或者内容，只能靠派生类提供该虚函数的具体实现方式，即为纯虚函数 virtual 类型 函数名 (参数表) = 0； 纯虚函数没有函数体 “=0” 并不是返回值为 0，只是告诉编译系统这是纯虚函数 是声明语句，所以句尾要有分号 将一函数声明为纯虚函数，仍可以有函数体，即纯虚函数的标志是 “=0”，而不是有无函数体 纯虚函数不得声明为内联函数 抽象类 拥有纯虚函数的类称为抽象类（一般为基类） 抽象类不能用来定义对象 若抽象类的派生类没有重新定义来自基类的纯虚函数，则该函数在派生类中亦是纯虚函数，派生类也为抽象类，而派生类可将重定义纯虚函数的任务转交给自己的派生类 几点说明： 只要基类包含一个或多个纯虚函数，就是抽象类，抽象类不能用于定义对象 在类的层次结构中，顶层或上面几层皆可为抽象基类，抽象基类是各类的共性 抽象基类是本类族的公共接口 抽象类可以实现多态，道理同虚函数 只有类中的虚函数才能声明为纯虚函数，普通的函数不能 12345678//顶层函数不能被声明为纯虚函数void fun() = 0; //compile errorclass base&#123;public : //普通成员函数不能被声明为纯虚函数 void display() = 0; //compile error&#125;; 运算符重载概念 运算符重载是多态的体现 C++ 把重载的运算符看做特殊的函数，称为运算符函数，故运算符重载就是函数重载的一种 运算符重载是对现有运算符的重载，不能利用重载创造新的运算符 不能重载的运算符：. 、·* 、-&gt;* 、:: 、?: 不得为运算符函数设置默认值，故在调用时不能省略实参 任何运算符在作为成员函数重载时不得重载为静态成员函数，new 和 delete 除外 只能作为成员函数重载：=、[]、()、-&gt;以及所有的类型转换运算符 关键字：operator 返回类型 operator 运算符 (参数表) &#123;&#125; 返回类型不能是 void 运算符重载函数也是函数，满足函数的一切性质 运算符重载的两种形式成员函数形式和友元函数形式，都可以访问类的私有成员 成员函数形式 定义：返回类型 operator 运算符 (参数表) 可将 operator 运算符部分看做是一个函数名 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class complex&#123;public: complex(); complex(double real, double imag);public: //声明运算符重载 complex operator+(const complex &amp;A) const; void display() const;private: double m_real; //实部 double m_imag; //虚部&#125;;complex::complex(): m_real(0.0), m_imag(0.0)&#123; &#125;complex::complex(double real, double imag): m_real(real), m_imag(imag)&#123; &#125;//实现运算符重载complex complex::operator+(const complex &amp;A) const&#123; complex B; B.m_real = this-&gt;m_real + A.m_real; B.m_imag = this-&gt;m_imag + A.m_imag; return B;&#125;void complex::display() const&#123; cout&lt;&lt;m_real&lt;&lt;&quot; + &quot;&lt;&lt;m_imag&lt;&lt;&quot;i&quot;&lt;&lt;endl;&#125;int main()&#123; complex c1(4.3, 5.8); complex c2(2.4, 3.7); complex c3; c3 = c1 + c2; c3.display(); return 0;&#125;//结果 6.7 + 9.5i 执行 c3 = c1 + c2时，编译器检测到 +左边是一个 complex 的对象，故会调用成员函数 operator +()，将该式转换为 c3 = c1.operator(c2)，即对象 c3 调用重载的成员函数，该函数的参数是 c2。 所以说，重载为成员函数时，由于具有隐含的 this 指针，一般参数只有一个。对双目运算符如上述的 + 运算符，一般参数是第二个操作数；而对单目运算符，参数表为空。 友元函数形式 定义：friend 返回类型 operator 运算符 (参数表) 注意： 友元函数没有 this 指针，故对双目运算符，友元函数有两个参数；对单目运算符有一个参数 典型运算符的重载重载负运算符 “-” 一元运算符，作为成员函数重载时，参数为空，存在默认的 this 指针；以友元函数重载时，参数为1个。 重载加运算符 “+” 同前例子 重载自增/减运算符 “++/- - ” 作为类的成员函数重载 前缀运算：返回类型 operator ++ () 后缀运算：返回类型 operator ++ (int) 作为类的友元函数重载 前缀运算：friend 返回类型 operator ++ (参数 1) 后缀运算：friend 返回类型 operator ++ (参数 1，int) 为了与前缀运算符区别，c++ 编译器设定在后缀运算符重载函数中增加一个实际并不使用的整形参数，以示区别 以自增为例，前缀自增是先增1，用增 1 后的值参与运算，故返回的是增1之后运算的值，内部也增 1；后缀自增是先参与运算，运算完毕之后再增 1，故返回的是对象本身，内部依然增 1 重载类型转换运算符 “long” 必须作为成员函数重载 类型名就是返回值类型，故不需要声明返回值类型 operator long（参数表） 重载赋值运算符 “=” 必须作为成员函数重载 类中出现指向动态空间的指针时重载 注意： 返回值应声明为引用，但在函数体中通常使用return * this；语句返回 若参数被声明为指针或引用，一般应加上 const 修饰 一般拷贝函数也会同时出现 重载复合赋值运算符 “+/-/*=” 两种重载形式均可 当重载为友元函数时，需要两个参数，且第一个参数应声明为引用 重载关系运算符 “&gt;、&lt;、==” 返回逻辑值，即返回类型为 bool 重载下标访问运算符 “[]” 只能重载为成员函数 返回类型 operator [] (下标形参，一般为整型) 重载 C++ 流运算符 “&gt;&gt; / &lt;&lt;” 只能重载为非成员函数，一般为友元函数 friend istream&amp; operator &gt;&gt; (istream&amp;, 类名&amp;) friend ostream&amp; operator &lt;&lt; (ostream&amp;, 类名&amp;) 之所以返回 i/ostream 类对象的引用，是为了能够连续读取/输出 模板函数模板概念 一系列相关函数的模型或样板，这些函数的源代码相同，只是针对不同的数据类型 对函数模板而言，数据类型是其参数，故是一种参数化 类型 的函数 格式：template &lt;模板形参表声明&gt; 函数声明 模板形参表声明可以是多个，中间用逗号隔开 模板形参的形式： typename 参数名 class 参数名 类型修饰 参数名 关键字 typename 与 class 完全等价，两者声明的参数为 虚拟类型参数，即指定这个参数名是一种类型，而这种类型只有实例化时才知道是什么类型，其即可做函数的返回值，也可做形参的类型，还可做函数体内变量的类型；而 类型修饰 声明的参数为常规参数，形式上与普通函数的声明相同。 123456template&lt;typename T&gt; //此处可换行，但不能有分号void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125; 模板函数的实例化 函数模板中声明的函数称为 模板函数 编译系统生成函数模板的某个具体版本的过程称为函数模板的实例化 模板实参的省略 模板函数的调用格式：模板函数名 &lt;模板实参表&gt;（函数实参表） 调用一个模板函数时，编译系统需要足够的信息判断每个虚拟类型参数对应的实际参数，主要从 模板实参表 和 函数实参表 中获取信息，且后者优先于前者，如从后者获取的信息足够判断虚拟类型的具体参数，而它们恰好是参数表中最后的若干参数，则模板实参中的那几个参数可以省略，若都被省略，则 &lt;&gt; 为空，也可省略 12345//如上例，调用可分几种：Swap&lt;int, int&gt;(&amp;a, &amp;b);Swap&lt;int&gt;(&amp;a, &amp;b);Swap&lt;&gt;(&amp;a, &amp;b);Swap(&amp;a, &amp;b); 不能省略模板实参的情况： 从模板实参表获得的信息有矛盾 若一个函数实参中获得的是 int，另一个则是 float，显然 T 不能同时为 int 和 float，为此，可将其中一个显示的给出 T 的类型 123int a = 10;float b = 1;Swap&lt;int&gt;(&amp;a, &amp;b); //将 float 强制转为 int 需要获得特定的返回值，而不管参数的类型如何 123int a = 10;float b = 1;Swap&lt;double&gt;(&amp;a, &amp;b); //将 int，float 强制转为 double 虚拟参数类型没有出现在模板函数的形参表中 函数模板含有常规实参 类模板概念 类模板就一系列相关类的模板，只是类型不同 模板类的声明：template &lt;模板参数表声明&gt; 类声明 类模板的成员函数可在类体内或类体外定义，在类外定义模板类（需要带上模板头）： template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; 返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表) &#123;函数体&#125; 类模板的实例化 两种方式： 类名 &lt;模板实参表&gt; 对象名 类名 &lt;模板实参名&gt; 对象名(构造函数实参表) 注意： 使用类模板定义对象时，实参不能省略，即类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。 123Point&lt;int, int&gt; p1(10, 20);Point&lt;int, float&gt; p2(10, 15.5);Point&lt;float, char*&gt; p3(12.4, &quot;东经180度&quot;); 除了对象变量，我们也可以使用对象指针的方式来实例化 12Point&lt;float, float&gt; *p1 = new Point&lt;float, float&gt;(10.6, 109.3);Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;(&quot;东经180度&quot;, &quot;北纬210度&quot;); 需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的： 1234//赋值号两边的数据类型不一致Point&lt;float, float&gt; *p = new Point&lt;float, int&gt;(10.6, 109);//赋值号右边没有指明数据类型Point&lt;float, float&gt; *p = new Point(10.6, 109); C++流12const int p = 1; // 应在声明时初始化，否则变量的值不确定且无法修改const int * pt;//指向常量的指针，即指针 *pt 是指向 const int 的，即 *pt 是 const的，不能修改","categories":[{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"}]},{"title":"力扣专题刷题","slug":"力扣刷题/专题刷题","date":"2022-08-19T16:00:00.000Z","updated":"2023-05-26T09:28:41.645Z","comments":true,"path":"Leetcode_group/","link":"","permalink":"https://hbroad.github.io/Leetcode_group/","excerpt":"","text":"发现菜的不行，按专题来吧，学一点是一点 参考 参考 链表203. 移除链表元素 思路一：若头结点已经是要删除的值，直接让头结点指向下一个即为删除头结点；若头结点非目标，则定义一个临时指针遍历链表，若该指针的下一节点是目标，则直接让其指向下下个节点 123456789101112131415161718192021222324252627282930class SolutionQ &#123;public: ListNodeQ* removeElements(ListNodeQ* head, int val) &#123; while(head-&gt;next != nullptr &amp;&amp; head-&gt;val == val) //头结点即相等的特殊情况 &#123; ListNodeQ *tmp = head; head = head-&gt;next; delete tmp; //C++不会自动释放内存，力扣不会报错 &#125; //头结点非相等情况 ListNodeQ *p; p = head; while(p != nullptr &amp;&amp; p-&gt;next != nullptr) &#123; if (p-&gt;next-&gt;val == val) &#123; ListNodeQ *tmp = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; delete p; &#125; else &#123; p = p-&gt;next; &#125; &#125; return head; &#125;&#125;; 思路二：创建一个节点作为虚拟头结点，让其指向头结点，那包括头结点在内的所有节点的删除方式就都一致了 1234567891011121314151617class SolutionQ2 &#123;public: ListNodeQ* removeElements(ListNodeQ* head, int val) &#123; ListNodeQ *dummy_head = new ListNodeQ; //new出来的是虚拟的头节点 dummy_head-&gt;next = head;//让虚拟头结点指向头结点 ListNodeQ *cur = dummy_head; while(cur-&gt;next) &#123; if (cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; &#125; return dummy_head-&gt;next; &#125;&#125;; 707. 设计链表 包含了链表的增删改查等常见操作，采用虚拟头结点的方式，统一操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//// Created by MQRoad on 2022/08/21.//#include &lt;iostream&gt;using namespace std;class MyLinkedList&#123;public: struct LinkNode &#123; int val; LinkNode *next; LinkNode(): val(0), next(nullptr) &#123;&#125; //默认构造函数 LinkNode(int x): val(x), next(nullptr) &#123;&#125; //带单参数的构造函数 LinkNode(int x, LinkNode *next): val(x), next(next) &#123;&#125; //双参数构造 &#125;; MyLinkedList() //链表的初始化 &#123; dummyhead = new LinkNode; size = 0; //链表的长度 &#125; int get(int index) &#123; LinkNode *cur = dummyhead-&gt;next; if (index &lt; 0 || index &gt; size - 1)//本题头结点是第0个 return -1; while(index) //查找第i个值，也就是让临时指针移动i次， &#123; cur = cur-&gt;next; index--; &#125; return cur-&gt;val; &#125; //头插法 void addAtHead(int val) &#123; LinkNode *p = new LinkNode; p-&gt;val = val; //赋值 p-&gt;next = dummyhead-&gt;next;//新节点的后继是旧的头结点 dummyhead-&gt;next = p; //新节点的前驱是虚拟节点 size++; //链表长度+1 &#125; //尾插法 void addAtTail(int val) &#123; LinkNode *p = new LinkNode(val); //需要遍历得到最后一个节点的位置 LinkNode *cur = dummyhead; //临时指针用于遍历链表 while(cur-&gt;next) &#123; cur = cur-&gt;next; &#125;//循环结束cur指向最后一个节点 cur-&gt;next = p;// p-&gt;next = nullptr; //new节点的时候已经初始化了没必要再写 size++; &#125; //任意位置插入 void addAtIndex(int index, int val) &#123; LinkNode *p = new LinkNode(val); LinkNode *cur = dummyhead; if (index &lt; 0 || index &gt; size) return; while(index--) &#123; cur = cur-&gt;next; &#125; p-&gt;next = cur-&gt;next; //该程序也满足头部插入，如 n=0 位置前插入，循环不执行，其他亦满足条件 cur-&gt;next = p; size++; &#125; //删除节点 void deleteAtIndex(int index) &#123; LinkNode *cur = dummyhead; if (index &lt; 0 || index &gt;= size) return; while(index--) cur = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; size--; &#125; //打印链表 void printLinkedList() &#123; LinkNode *cur = dummyhead; while (cur-&gt;next) &#123; cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; &quot; &quot;; cur = cur-&gt;next; &#125; &#125;private: LinkNode *dummyhead; //虚拟头结点 int size; //链表长度&#125;;int main()&#123; MyLinkedList *obj = new MyLinkedList; for (int i = 0; i &lt; 10; i += 2) &#123; obj-&gt;addAtTail(i); &#125;// obj-&gt;addAtIndex(-1,2); obj-&gt;printLinkedList(); int param = obj-&gt;get(2);// cout &lt;&lt; param;&#125; 206. 反转链表 反转链表并不是说将数据 5 移动到 2 的位置，而是将链表本身反转，可参考 思路一：双指针法：利用两个指针交替完成 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *pre = nullptr; ListNode *cur = head; while(cur) &#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by MQRoad on 2022/08/21.//#include &lt;iostream&gt;using namespace std;struct mynode&#123; int val; mynode *next; mynode(int x): val(x), next(nullptr) &#123;&#125;&#125;;mynode* ini()&#123; mynode *node = new mynode(0); mynode *head = node; for (int i = 1; i &lt;= 5; ++i) &#123; node-&gt;next = new mynode(i); node = node-&gt;next;// newnode = nullptr; //构造函数已赋值 &#125; return head;&#125;//反转链表mynode* reverseLL(mynode *head)&#123; mynode *pre = nullptr; mynode *cur = head; mynode *tmp; while(cur) &#123; tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre;&#125;void printmynode(mynode *head)&#123; mynode *cur = head; while (cur) &#123; cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;; //无虚拟头结点 cur = cur-&gt;next; &#125;&#125;int main()&#123; mynode *head = ini(); printmynode(head); cout &lt;&lt; endl; mynode *newhead = reverseLL(head); printmynode(newhead);&#125; 24. 两两交换链表中的节点 思路：链表题，老老实实画图吧 为方便操作，仍然定义一个虚拟头结点 总体流程：为了让 1 2 两节点交换，先让节点 2 成为头结点的后驱，再让节点 1 成为节点 2 的后驱，最后让节点 3 成为节点 1 的后驱，后续节点依次重复，如下图： 要注意的是，在完成第一步后，cur 的指向已经变化，所以无法进行第 2-3步，因而需要在操作前保存 cur 原来的指向 1-2 完成的情况如下图： 即第三步是在前两步基础上的 cur-&gt;next-&gt;next-&gt;next 最后将 cur 后移两位，进行下一轮的交换 代码： 1234567891011121314151617181920212223242526272829303132333435//// Created by MQRoad on 2022/08/22.//#include &lt;iostream&gt;using namespace std;struct ListNode204&#123; int val; ListNode204 *next; ListNode204(int x): val(x), next(nullptr) &#123;&#125;&#125;;class sol204&#123;public: ListNode204* swappairs(ListNode204 *head) &#123; ListNode204 *dummynode = new ListNode204(0); dummynode-&gt;next = head; ListNode204 *cur = dummynode; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123; ListNode204 *tmp1 = cur-&gt;next; ListNode204 *tmp2 = cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; //步骤一 cur-&gt;next-&gt;next = tmp1; //步骤二 cur-&gt;next-&gt;next-&gt;next = tmp2; //步骤三 cur = cur-&gt;next-&gt;next; //指针后移 &#125; return dummynode-&gt;next; &#125;&#125;; 19. 删除链表的倒数第 N 个结点 思路：利用快慢指针。首先，要删除一个结点，就需要知道其前一个结点，让前一个结点指向待删除结点的下一个结点即可。如何定位到待删除结点的前一位置呢？ 同样利用虚拟头结点，并定义快慢两个指针，初始时同时指向虚拟头结点，如我们要删除倒数第二个结点： 快指针用于遍历，慢指针最终指向待删除结点的前一个结点。因此，要删掉第 n 个结点，需快指针移动 n + 1 位 然后两者同时移动直至快指针指向为空: 代码 1234567891011121314151617181920212223class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy_node = new ListNode(0); dummy_node-&gt;next = head; ListNode* slow = dummy_node; ListNode* fast = dummy_node; while(n-- &amp;&amp; fast-&gt;next) fast = fast-&gt;next; fast = fast-&gt;next; while(fast) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy_node-&gt;next; &#125;&#125;; 哈希表242. 有效的字母异位词 思路一：字母异位词指的是两个字串中每个字符出现的次数相同，那么两个字串的长度肯定相等，其次，若将字串排序，那么两字串必定相等 代码 123456789101112131415161718192021//// Created by MQRoad on 2022/09/02.//#include &lt;bits/stdc++.h&gt;using namespace std;class Solution&#123;public: bool isAnagram(string s, string t) &#123; if (s.size() != t.size()) return false; sort(s.begin(), t.end()); sort(t.begin(), t.end()); return s == t; &#125;&#125;; 思路二：哈希表：维护一个哈希表，先遍历 s 中的字符，将 s 中字符出现的次数纳入其中（因为字符只有26 个字母，故让出现的字母相对于字母 a 的位置作为哈希函数），接着遍历 t，如有相同的字符出现，减去其次数，最后哈希表为空，说明满足；否则不是。 代码： 123456789101112131415161718192021222324class Solutionana&#123;public: bool isAnagram(string s, string t) &#123; char hashtable[26] = &#123;&#125;; for (int i = 0; i &lt; s.size() ; ++i) &#123; hashtable[s[i] - &#x27;a&#x27;]++; &#125; for (int j = 0; j &lt; t.size(); ++j) &#123; hashtable[t[j] - &#x27;a&#x27;]--; &#125; for(auto k : hashtable) &#123; if(k) return false; &#125; return true; &#125;&#125;; 349. 两个数组的交集 思路：两个数组中有相同的元素，异或结果为 0，那就依次异或，但相同的元素导致输出重复，再调 STL 去重 代码： 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; num; // int tmp; for(int i = 0; i &lt; nums1.size(); i++) &#123; for(int j = 0; j &lt; nums2.size(); j++) &#123; if((nums1[i] ^ nums2[j]) == 0) num.push_back(nums1[i]); &#125; &#125; set&lt;int&gt; s(num.begin(), num.end()); num.assign(s.begin(), s.end()); return num; &#125;&#125;; 代码优化： 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; // vector&lt;int&gt; num; // int tmp; set&lt;int&gt; num; for(int i = 0; i &lt; nums1.size(); i++) &#123; for(int j = 0; j &lt; nums2.size(); j++) &#123; if((nums1[i] ^ nums2[j]) == 0) num.insert(nums1[i]); &#125; &#125; return vector&lt;int&gt; result(num.begin(), num.end()); &#125;&#125;; 思路：哈希表。同样的逻辑，数据模拟哈希表，让两个输入数组的值作为哈希表的下标，遍历完第一个数组，再去遍历第二个数组，只要查到有数组1中的值，说明是两者公有的。 代码： 1234567891011121314151617181920class Solution&#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt;&amp; nums2) &#123; int a[1001] = &#123;&#125;; set&lt;int&gt; num; for(int i = 0; i &lt; nums1.size(); i++) &#123; a[nums1[i]] = 1; &#125; for (int i = 0; i &lt; nums2.size(); ++i) &#123; if (a[nums2[i]] == 1) num.insert(nums2[i]); &#125; return vector&lt;int&gt;(num.begin(), num.end()); &#125;&#125;; 202. 快乐数 思路：哈希表，快乐数的计算过程中，各位数的平方和可能一直循环而无法收敛到 1，无序查找的问题，使用无序集合，如果本次求和的结果已经存在了，就无需再计算了，因其已经进入了循环。 代码： 1234567891011121314151617181920212223242526272829303132class Solutionidhappy&#123;public: int getSum(int n) //各位数求和 &#123; int sum = 0; while(n) &#123; sum += (n % 10) * (n % 10); n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; unordered_set&lt;int&gt; setn; while(true) &#123; int sum = getSum(n); if(sum == 1) return true; if(setn.find(sum) != setn.end()) // find函数找到时返回位置，找不到返回end() return false; else setn.insert(sum); //平方和结果保存 n = sum; &#125; &#125;&#125;; 1. 两数之和 思路：暴力，遍历数组，两两相加，找到与目标值相等的保存其位置，并结束遍历（找到就不要遍历后续了） 代码 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; a; for(int i = 0; i &lt; nums.size(); i++) &#123; for(int j = i + 1; j &lt; nums.size(); j++) &#123; if(nums[i] + nums[j] == target) &#123; a.push_back(i); a.push_back(j); break; &#125; &#125; &#125; return a; &#125;&#125;; 思路：既然数组中的两数之和为目标值，则 target - i 的值一定在数组中，找到该值即可，相同的数异或为 0 代码： 12345678910111213141516171819202122class Solutionsum&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; a; for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = i + 1; j &lt; nums.size(); ++j) &#123; if (((target - nums[i]) ^ nums[j]) == 0) &#123; a.push_back(i); a.push_back(j); break; &#125; &#125; &#125; return a;&#125;; 思路：哈希表。本题不仅需要知道元素是否存在，还需要知道该元素对应的下标。set 没法存储下标，选择 map 结构，又无需有序，选择效率更高的 unordered_map，具体过程如下（图源见水印） 代码 1234567891011121314151617Class Solution&#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; map; for(int i = 0; i &lt; nums.size(); i++) &#123; auto k = map.find(target - nums[i]); if(k != map.end()) return &#123;k-&gt;second, i&#125;; // map.insert(pair&lt;int, int&gt;(nums[i], i)); key 存储数组的值，value存储数组的下标 map[nums[i]] = i; &#125; return &#123;&#125;; &#125; &#125;; 454. 四数相加 II 思路：哈希法。和两数之和类似，首先进行分块，将前两个数组求和并记录和出现的次数。然后另外两个数组求和，由于总和为 0，则 0 - 该和的结果一定在哈希表中，如果查找到了，计数即可。值得注意的是，由于前两个数组求和时已经有相应的计数了，所以后续的计数是直接在前者的基础上进行迭代而非每次加 1。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by MQRoad on 2022/09/05.////#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;class Solution4sum &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; unmap; int count = 0; for(int a : nums1) for(int b : nums2) unmap[a + b]++; //该操作会查找unmap 中是否存在 (a+b),存在则对应的value++，否则 insert (a+b) for(int c : nums3) &#123; for (int d: nums4) &#123; auto k = unmap.find(0 - (c+d)); if ( k != unmap.end()) &#123; count += k-&gt;second; &#125; &#125; &#125; return count; &#125;&#125;;int main()&#123; Solution4sum sum4nums; vector&lt;int&gt; nums1 = &#123;1,2&#125;; vector&lt;int&gt; nums2 = &#123;-2,-1&#125;; vector&lt;int&gt; nums3 = &#123;-1,2&#125;; vector&lt;int&gt; nums4 = &#123;0, 2&#125;; int k = sum4nums.fourSumCount(nums1, nums2, nums3, nums4); cout &lt;&lt; k; return 0;&#125; 383. 赎金信 思路：暴力。遍历两个字串，如果 rans 中的字符和 mag 中有相等的，删掉该字符，再判断下一个是否存在。直至 rans 为空 代码： 123456789101112131415161718192021class Solution&#123;public: bool canConstruct(string ransomNote, string magazine) &#123; for (int i = 0; i &lt; magazine.size(); ++i) &#123; for (int j = 0; j &lt; ransomNote.size(); ++j) &#123; if (ransomNote[j] == magazine[i]) &#123; ransomNote.erase(ransomNote.begin() + j); break; &#125; &#125; &#125; if (ransomNote.size() == 0) return true; return false; &#125;&#125;; 思路：哈希法。字母的个数是有限的，用数组模拟哈希比较划算。统计 mag 中各字符出现的次数，再遍历 rans，次数递减，次数 &lt;0 即为失败。此外，当 rans 的长度大于 mag 时，显然是不满足的 代码： 12345678910111213141516171819202122class Solution&#123;public: bool canConstruct(string ransomNote, string magazine) &#123; int hash[26] = &#123;&#125;; if (ransomNote.size() &gt; magazine.size()) return false; for(char m : magazine) hash[m - &#x27;a&#x27;]++; for(char r : ransomNote) &#123; hash[r - &#x27;a&#x27;]--; if (hash[r - &#x27;a&#x27;] &lt; 0) return false; &#125; return true; &#125;&#125;; 字符串344. 反转字符串 思路：双指针原地反转 代码： 123456789101112131415161718192021class SolutionreverseString &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; //reverse(s.begin(),s.end()); reverse() int left = 0; int right = s.size() - 1; while (left &lt; right) &#123; char tmp; tmp = s[left]; s[left] = s[right]; s[right] = tmp; //swap(s[left],s[right]); left++; right--; &#125; &#125;&#125;; 541. 反转字符串 II 思路：按题目要求模拟 代码： 123456789101112131415class Solution &#123;public: string reverseStr(string s, int k) &#123; for(int i = 0; i &lt; s.size(); i += 2*k) &#123; if(i + k &lt;= s.size()) reverse(s.begin() + i, s.begin() + i + k); //注意 该函数反转区间是左闭右开，即不包括右边上限 else reverse(s.begin() + i, s.end()); &#125; return s; &#125;&#125;; 剑指 Offer 05. 替换空格 思路：定位空格，替换 代码： 1234567891011121314151617181920class Solution &#123;public: string replaceSpace(string s) &#123; // string str = &quot;%20&quot;; // while(1) // &#123; // if(s.find(&quot; &quot;) == string::npos) // break; // auto k = s.find(&quot; &quot;); // s.erase(k,1); // s.insert(k, str); // &#125; // return s; while(s.find(&quot; &quot;) != string::npos) s.replace(s.find(&quot; &quot;), 1, &quot;%20&quot;); //位置，长度，要替换的字串 return s; &#125;&#125;; 思路：双指针法，原地替换。两点注意：一是替换为 “%20” 后新的字串长度，二是从后往前遍历，这样就是不用考虑元素平移的问题。（因为从前面遍历替换后，后续位置的元素需全部往后移，效率低） ​ 图源及详解 代码： 1234567891011121314151617181920212223242526272829303132class Solutionreplace &#123;public: string replaceSpace(string s) &#123; int count = 0; int len = s.size(); for (int i = 0; i &lt; len; ++i) //确定空格的数量 &#123; if(s[i] == &#x27; &#x27;) count++; &#125; //确定新的数组长度 s.resize(len + 2 * count); //定义双指针，一个指向旧的数组尾部，一个指向新的数组尾部 int i = len - 1; int j = s.size() - 1; for (; i != j; i--, j--) &#123; if (s[i] != &#x27; &#x27;) s[j] = s[i]; else &#123; s[j - 2] = &#x27;%&#x27;; s[j - 1] = &#x27;2&#x27;; s[j] = &#x27;0&#x27;; j -= 2; &#125; &#125; return s; &#125;&#125;; 151. 反转字符串中的单词 思路：暴力？先找空格，按空格提取出单词放入容器，再反向遍历 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by MQRoad on 2022/09/09.//#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;using namespace std;class Solutionreverse &#123;public: string reverseWords(string s) &#123; vector&lt;string&gt; str_vec; while(1) &#123; if(s.find(&quot; &quot;) == string::npos)//找不到空格 &#123; if (s == &quot;&quot;) //特殊情况，最后一个是空格，分割后不能当做单词放入 break; else &#123; str_vec.push_back(s);//最后一个单词也要保存 break; &#125; &#125; string tmp = s.substr(0, s.find(&quot; &quot;)); if(tmp != &quot;&quot;) //单个单词 str_vec.push_back(tmp); s = s.substr(s.find(&quot; &quot;) + 1); &#125; string result; for (int i = str_vec.size() - 1; i &gt;= 0 ; i--) &#123; if (i == 0) result += str_vec[i]; else result += str_vec[i] + &quot; &quot;; &#125; return result; &#125;&#125;;int main()&#123; string s = &quot; hello world &quot;; Solutionreverse obj; cout &lt;&lt; obj.reverseWords(s); return 0;&#125; 思路：先去掉空格，再整体反转，反转后单词也被反转，故再反转单词即可 代码： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void reverse(string&amp; s, int start, int end)&#123; //翻转，区间写法：左闭又闭 [] for (int i = start, j = end; i &lt; j; i++, j--) &#123; swap(s[i], s[j]); &#125; &#125; void removeExtraSpaces(string&amp; s) &#123;//去除所有空格并在相邻单词之间添加空格, 快慢指针。 int slow = 0; //整体思想参考https://programmercarl.com/0027.移除元素.html for (int i = 0; i &lt; s.size(); ++i) &#123; // if (s[i] != &#x27; &#x27;) &#123; //遇到非空格就处理，即删除所有空格。 if (slow != 0) s[slow++] = &#x27; &#x27;; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格(第一个单词前面无需空格) while (i &lt; s.size() &amp;&amp; s[i] != &#x27; &#x27;) &#123; //补上该单词，遇到空格说明单词结束（这里是分割出单个单词的循环 s[slow++] = s[i++]; &#125; &#125; &#125; s.resize(slow); //slow的大小即为去除多余空格后的大小。 &#125; string reverseWords(string s) &#123; removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。 reverse(s, 0, s.size() - 1); int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。 for (int i = 0; i &lt;= s.size(); ++i) &#123; if (i == s.size() || s[i] == &#x27; &#x27;) &#123; //到达空格或者串尾，说明一个单词结束。进行翻转。 reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。 start = i + 1; //更新下一个单词的开始下标start &#125; &#125; return s; &#125;&#125;; 参考","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"力扣Top100","slug":"力扣刷题/力扣Top100","date":"2022-08-13T16:00:00.000Z","updated":"2023-04-17T12:18:47.047Z","comments":true,"path":"leetcode_top_100/","link":"","permalink":"https://hbroad.github.io/leetcode_top_100/","excerpt":"Leetcode Top 100","text":"Leetcode Top 100 ……","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"力扣每日一题","slug":"力扣刷题/力扣每日一题","date":"2022-08-03T16:00:00.000Z","updated":"2023-04-17T12:18:42.295Z","comments":true,"path":"Leetcode_once_day/","link":"","permalink":"https://hbroad.github.io/Leetcode_once_day/","excerpt":"刷的太少，思路只局限在暴力","text":"刷的太少，思路只局限在暴力 1422. 分割字符串的最大得分 思路：（暴力）对输入的字串分割成左右两个非空字串，再遍历左字串中字符 0 个数，由字串中字符 1 的个数；依次循环分割输入的字串，将对应的个数存入左右两个容器，遍历完所有的可能后，求和，再求最大值 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: int maxScore(string s) &#123; string strl, strr; vector&lt;int&gt; l, r; int l_tmp = 0, r_tmp = 0; for(int i = 1; i &lt; s.size(); i++) &#123; strl = s.substr(0, i); strr = s.substr(i); for(int j = 0; j &lt; strl.size(); j++) &#123; if(strl[j] == &#x27;0&#x27;) l_tmp++; &#125; l.push_back(l_tmp); l_tmp = 0; //注意累加器置0 for(int k = 0; k &lt; strr.size(); k++) &#123; if(strr[k] == &#x27;1&#x27;) r_tmp++; &#125; r.push_back(r_tmp); r_tmp = 0; &#125; vector&lt;int&gt; maxsum; for(int n = 0; n &lt; l.size(); n++) &#123; int a = l[n] + r[n]; maxsum.push_back(a); &#125; return *max_element(maxsum.begin(), maxsum.end()); //取最大值 &#125;&#125;;int main()&#123; Solution sol; string s = &quot;1111&quot;; cout &lt;&lt; sol.maxScore(s);&#125; 540. 有序数组中的单一元素 思路，根据异或运算的性质，两个相同的数异或为0，让数组元素依次异或，结果一定是只出现一次的数（代码中是依次一个一个异或，便于理解，推导过程中利用结合律、交换律，相同的数字先异或结果为0） 代码 123456789101112131415161718192021222324252627//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution3 &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = 0; int sum = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; sum ^= nums[i]; &#125; return sum; &#125;&#125;;int main()&#123; Solution3 sol3; vector&lt;int&gt; nums = &#123;1,1,2,3,3,4,4,8,8&#125;; cout &lt;&lt; sol3.singleNonDuplicate(nums); return 0;&#125; 268. 丢失的数字 思路：给定的范围是[0,n]，可求得该范围内所有数的和，用和减去现有数组中的数，结果即为缺失的数 代码 123456789101112131415161718192021222324252627282930//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int n = nums.size(); sum = (0 + n) * (n + 1)/2; //求和 for(int i = 0; i &lt; n; i++) &#123; sum -= nums[i]; //将现有元素全部减掉 &#125; return sum; &#125;&#125;;int main()&#123; Solution sol; vector&lt;int&gt; nums = &#123;9,6,4,2,3,5,7,0,1&#125;; cout &lt;&lt; sol.missingNumber(nums); return 0;&#125; https://flamsteed.github.io/tags/#HUAWEI 第一阶段: 练习字符串、数组、链表的基本操作，熟悉语言和编码手感 参考题目： 字符串，简单 1154，125，344，20，392，409，859，14，1694，551 数组，简单 1，169，53，1502，88，594，643，463， 链表，简单 234，21，141，83 第二阶段: 练习较为复杂的字符串，数组的处理 字符串，中等 468，692，151，686，1764 数组，中等56，229，347 第三阶段: 算法练习 字符串，中等，回溯93 数组，中等，回溯 39，90，46，78 数组，中等，深度优先，广度优先，417，994，385 数组，中等，滑动窗口，713 字符串，中等，滑动窗口424 动态规划，简单70 动态规划，中等64 数组，中等，双指针 16 字符串，中等，双指针15， 数组，中等，栈150","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"}]},{"title":"华为机试（牛客）","slug":"华为机试/华为机试","date":"2022-07-30T16:00:00.000Z","updated":"2023-04-17T12:31:54.861Z","comments":true,"path":"HuaWei_no_way/","link":"","permalink":"https://hbroad.github.io/HuaWei_no_way/","excerpt":"放弃啦，简历都过不了 华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了 （知道自己菜，没想到这么菜）","text":"放弃啦，简历都过不了 华为机考刷题记录，初次刷题，想法不成熟，大多直接暴力解决了 （知道自己菜，没想到这么菜） 参考1 参考2 https://oi-wiki.org/ HJ1 题目：查找输入字符串最后一个单词的长度 思路：字符串由空格分隔，找到最后一个空格，用整体的长度减去空格及空格前的长度，剩余的即为所求 代码： 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; getline(cin,str); // size_t len = str.size(); //总长度 // size_t found = str.rfind(&quot; &quot;); //最后空格的位置 // size_t found = str.find_last_of(&quot; &quot;); cout &lt;&lt; str.size() - str.rfind(&quot; &quot;) - 1;&#125; 分析：关键有二： 字符串的获取 cin：遇空格或制表符即停，显然无法满足 getline：可连续读取输入并存入字符串 1istream&amp; getline (istream&amp; is, string&amp; str); 最后空格的定位 find_last_of()：给定待查找的字符，从后开始查找并返回其位置 123size_t find_last_of (const char* s, size_t pos = npos) const;//可以指定从何处开始查找，即指定第二个参数//注意字符串从0开始编号 find 家族辨析：参考 1234567891011//搜索指定位置开始的第一个完全匹配的字符（串），即与指定字串完全匹配时才返回，且是第一个size_t find (const string&amp; str, size_t pos = 0); //从前往后找size_t rfind (const string&amp; str, size_t pos = npos); //从后往前找//搜索指定位置开始的第一个匹配的字符（串），只需有一个字符满足即可size_t find_first_of (const string&amp; str, size_t pos = 0); //从前往后找size_t find_last_of (const string&amp; str, size_t pos = npos); //从后往前找 //查找与指定字串不匹配的字符（串）size_t find_first_not_of (const string&amp; str, size_t pos = 0) ;size_t find_last_not_of (const string&amp; str, size_t pos = npos) ; HJ2 题目：计算某字符出现的次数 思路：读入到两个变量中，遍历字串，是否和目标字符相等，若相等则 count 增1，再判断大小写的问题，大写和小写分别判断 代码：（低质量代码） 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str,str2; //读入两行内容 getline(cin, str); getline(cin, str2); //如相等则计数器k自增1 int k = 0; for(int i = 0; i &lt; str.size(); i++) &#123; if(str[i] == str2[0]) &#123; k++; //考虑大小写一致 for(int i = 0; i &lt; str.size(); i++) &#123; if(str2[0] &lt;= &#x27;Z&#x27; &amp;&amp; str2[0] &gt;= &#x27;A&#x27;) //如目标字符是大写，则再判断其对应的小写是否有相等的 &#123; if(str[i]+0 == str2[0] + 32) k++; &#125; else if (str2[0] &lt;= &#x27;z&#x27; &amp;&amp; str2[0] &gt;= &#x27;a&#x27;) //如目标字符是小写，则再判断其对应的大写是否有相等的 &#123; if(str[i]+0 == str2[0] - 32) k++; &#125; &#125; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl;&#125; 分析： 新手，想法简单粗暴 HJ3 题目：输入随机数个数及随机数，去重排序后按行输出 思路一：（排名第一的思路，非本人想法）先确定随机数的个数（直接cin），定义一个数组，然后每次将读入的数作为数组的下标，值填充为1，然后输出数组值不为0的下标 核心：只要有重复值，对应到数组的下标还是同一个，达到既降重又排序的目的；转换思路，输入的值是下标而非数组的值 缺点：一是必须指定数组的大小是题目给定的范围，而不能动态的设置为输入随机数的个数；二是数组必须初始化，否则其中的垃圾数据会造成输入错误 代码： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; int N, n; while (cin &gt;&gt; N) &#123; int a[1001] = &#123; 0 &#125;; while (N--) &#123; cin &gt;&gt; n; a[n] = 1; &#125; for (int i = 0; i &lt; 1001; i++) if (a[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 123456789101112131415161718192021//按上述思路重写了一下，比较容易理解和看懂#include &lt;iostream&gt;using namespace std;int main()&#123; int N, n; cin &gt;&gt; N; //读入数组的大小 int a[1001] = &#123;0&#125;; //指定大小并初始化（不管数组多小，都开辟了这么多空间） for(int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; n; a[n] = 1; //以读入的数作为下标，有多少重复都无所谓（填充值非零均可） &#125; for(int i = 0; i &lt; 1001; i++) &#123; if(a[i]) cout &lt;&lt; i &lt;&lt; endl; //输出数组值非零的下标 &#125; return 0;&#125; 思路二：调用 STL，去重排序一步到位 12345678910111213141516171819#include&lt;iostream&gt;#include &lt;set&gt; //包含集合setusing namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; set&lt;int&gt; s;//自动实现去重和排序 for(int i=0;i&lt;n;i++) &#123; int x; cin&gt;&gt;x; s.insert(x); &#125; for(auto i:s) cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 分析： STL 中的 set（集合）自动将插入元素放入合适的位置（排序），同时对重复元素忽略，可以插入删除但不能更改 HJ4 题目：字符串的分割，以8为长度分割输入的字符串 思路：考虑 ==8 、8 三种情况，利用容器，把分割后的字串存入其中，最后遍历容器输出，主要利用 substr 进行字串的分割 复盘：既然以 8 为单位分割，那只要不为 8 的倍数就要补 0，用余数判断一下需要补 0 的个数，利用 append 插入，再分割输出（另外本题没有给出输出的格式，我以为是空格，结果提交发现是换行） 代码：初次写的代码，重复代码太多了，自愧不如，简单问题复杂化了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;string&gt; str; string str_tmp; cin &gt;&gt; str_tmp; int n = str_tmp.size(); if(n % 8 == 0) &#123; //按8分割 for(int i = 0; i &lt; str_tmp.size();) &#123; str.push_back(str_tmp.substr(i, 8)); i += 8; &#125; &#125; else if(n &lt; 8) &#123; for(int j = 0; j &lt; 8-n; j++) &#123; str_tmp.push_back(&#x27;0&#x27;); //小于8时判断补 0 的个数 &#125; str.push_back(str_tmp); &#125; else(n &gt; 8) &#123; int k = n / 8; //有几段以 8 为长度的 //需要补几个0 for(int j = 0; j &lt; 8 - n % 8; j++) &#123; str_tmp.push_back(&#x27;0&#x27;); &#125; //按8分割 for(int i = 0; i &lt; str_tmp.size();) &#123; str.push_back(str_tmp.substr(i, 8)); i += 8; &#125; &#125;//遍历输出 for(int i = 0; i &lt; str.size(); i++) //注意这里是补 0 后新的大小 &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125;&#125; 复盘后改进的代码：简便多了 12345678910111213141516171819202122#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; int n = str.size(); if(n % 8 != 0) &#123; str.append(8 - n % 8, &#x27;0&#x27;); //不足8位的补0 &#125; //按8分割 for(int i = 0; i &lt; str.size();) //注意这里的 size 是补 0 后新的大小 &#123; cout &lt;&lt; str.substr(i, 8) &lt;&lt; endl; i += 8; &#125;&#125; 分析： substr 的用法 单参数：从该位置开始取到末尾 双参数：从该位置开始取到指定的长度 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; string s = &quot;time&quot;; cout &lt;&lt; &quot;单参数：&quot; &lt;&lt; s.substr(2) &lt;&lt; endl; //返回 me（从位置 2 截取到尾） cout &lt;&lt; &quot;双参数：&quot; &lt;&lt; s.substr(1, 3) &lt;&lt; endl; //返回 ime（从位置1开始，截取长度3）&#125; append 的用法 向 string 后面追加字符或字符串 1234str.append(4, &#x27;0&#x27;); //在 str 后追加 4 个字符 0str.append(c); //追加 char 类型字串 cstr.append(str_tmp); //追加 string 字串str.append(str_tmp, 5, 3); //追加从位置 5 开始的长度为 3 的字串（包括位置 5） HJ5 题目：输入十六进制字串，将其转为十进制数输出（华为肯定不会考这种题） 思路：（笨人笨方法啊）先把输入的前缀0x截掉，剩下的部分依次遍历，如是字符0-9，则转为数字0-9；如是字母A-F，则转为10~15 代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; //截掉前缀 string str_tmp; str_tmp = str.substr(2); //进制转换 int n = 0; int j = (str_tmp.size() - 1); //控制幂次 for (int i = 0; i &lt; str_tmp.size(); i++) &#123; //遍历每一位 if (str_tmp[i] &gt;= &#x27;0&#x27; &amp;&amp; str_tmp[i] &lt;= &#x27;9&#x27;) //判断是否是数字 &#123; n += int(str_tmp[i] - &#x27;0&#x27;)*pow(16, j); //转为0~9 &#125; else if (str_tmp[i] &gt;= &#x27;A&#x27; &amp;&amp; str_tmp[i] &lt;= &#x27;F&#x27;)//判断是否是字母 &#123; n += (str_tmp[i] - 55)*pow(16, j); //A是65，减55是转为10~15 &#125; j--; &#125; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 其实可以直接调库的 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; int main()&#123; string str; while(cin&gt;&gt;str) &#123; cout &lt;&lt; stoi(str,0,16) &lt;&lt; endl; // 将str从位置 0 开始到末尾的 16 进制转为 十进制 &#125;&#125; HJ6 题目：质数因子，给定一个整数，输出该数的所有质数因子，包括重复值 思路：质数从 2 开始，让给定值从 2 开始遍历，能整除则继续，否则 +1 后再判断是否能整除，这样提交后内存超限 看了题解，一个数至少有一个质数因子不会超过其平方根，这样就可以从 2 遍历到其平方根，再判断是否是因子。需要注意该值本身就是质数的情况 代码： 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; long n; cin &gt;&gt; n; for(long i = 2; i &lt;= sqrt(n) &amp;&amp; i &lt;= n; i++)&#123; //从小到大的质因子，质因子不会超过它的平方根 while(n % i == 0)&#123; //所有的质数前面全部除掉，后续就不会有合因子 cout &lt;&lt; i &lt;&lt; &quot; &quot;; n /= i; //除掉质因子 &#125; &#125; if(n - 1) //前面已经除掉了所有因子，故在此判断该值是否是 1 ，不是就说明自己本身就是质数 cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;&#125; HJ7 输入浮点数，四舍五入 思路：都说了入门题了 代码： 1234567891011121314#include &lt;iostream&gt;//#include &lt;cmath&gt;using namespace std;int main()&#123; float a; cin &gt;&gt; a; // cout &lt;&lt; round(a); if(a - int(a) &gt;= 0.5) cout &lt;&lt; int(a) + 1; else cout &lt;&lt; int(a);&#125; HJ8 题目：合并表记录：给定索引及对应的值，将相同索引的值求和，并按索引升序排序输出 思路一：（题目本意是考察哈希表，这里直接暴力解决）首先读入键值对数，再将键值对存入个vector，接着遍历并判断索引号是否相等，如若相等则加到第一个上，同时将另一个清除；新建一个vector，将不为空的复制进去，调用 sort 排序再输出 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int a, b, c; vector&lt;vector&lt;int&gt;&gt; v; vector&lt;vector&lt;int&gt;&gt; v_F; vector&lt;int&gt; v_tmp; cin &gt;&gt; a; for(int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; b &gt;&gt; c; v_tmp.push_back(b); v_tmp.push_back(c); v.push_back(v_tmp); v_tmp.clear(); //注意清空 &#125; for(int i = 0; i &lt; v.size(); i++) &#123; for(int j = i+1; j &lt; v.size(); j++) &#123; if(v[i][0] == v[j][0]) &#123; v[i][1] += v[j][1]; // v[j].clear(); v[j].erase(v[j].begin(), v[j].end()); //清除元素 &#125; &#125; if(v[i].empty() == false) v_F.push_back(v[i]); //非空存入新的容器 &#125; sort(v_F.begin(), v_F.end()); //排好序 for(int i = 0; i &lt; v_F.size(); i++) &#123; cout &lt;&lt; v_F[i][0] &lt;&lt; &quot; &quot; &lt;&lt; v_F[i][1] &lt;&lt; endl; &#125;&#125; 思路二：调用 STL 的 map，其自动建立 key - value 的对应，且其中的数据是有序的，map 是一个模板类，需要 key value 两个参数，关键字 key 只能在 map 中存在一次，其增删改和容器类似，通过 pair 插入，迭代器访问，注意迭代器返回值是变化的 代码： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; //输入键值对的个数 map&lt;int, int&gt; m; //使用map容器，自带键值对数据结构 map&lt;int, int&gt;::iterator it; //map类型的迭代器 for(int i = 0; i &lt; n; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; //每行输入一个键值对 it = m.find(a); //查找键 a 是否存在，是返回所在位置，否返回 end 位置， if(it != m.end()) //如果存在，对键相同的单元的值部分求和 &#123; m[a] = it-&gt;second + b; &#125; else //若不存在生成新的键值对 &#123; m[a] = b; &#125; &#125; for(it = m.begin(); it != m.end(); it++) &#123; //遍历输出 cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0;&#125; HJ10 题目：字符个数统计，输入一个字符串，输入该字串中不重复的字符个数 思路一：利用集合set的自动降重功能，将字符串拆分成字符插入其中，再求集合的 size 即可（需要遍历整个字串，耗时） 代码： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; string str_tmp; set&lt;char&gt; str; while(getline(cin, str_tmp)) &#123; for(int i = 0; i &lt; str_tmp.size(); i++) &#123; str.insert(str_tmp[i]); &#125; &#125; cout &lt;&lt; str.size();&#125; 思路二：哈希表，待补充 HJ11 题目：数字颠倒，将输入的整数以字符串的形式逆序输出 思路：将整数转为字串类型，再利用函数翻转输出 代码： 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; string str; str = to_string(n); //int2string转换 reverse(str.begin(),str.end()); //逆序 cout &lt;&lt; str;&#125; HJ12 题目：反转字符串 思路：同HJ11 代码： 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; reverse(str.begin(), str.end()); cout &lt;&lt; str;&#125; HJ13 题目：句子逆序，给定一个句子，逆序输出（非逆序字母） 思路：遍历字串找到空格，找到一个空格后，空格前的分割出来存下，空格后的分割出来继续找空格，循环直至字串中没有空格 代码： 12345678910111213141516171819202122232425262728293031323334353637//// Created by MQRoad on 2022/08/15.//#include&lt;iostream&gt;#include&lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; string str; getline(cin, str); int n = str.size(); vector&lt;string&gt; str_vec; for(int i = 0; i &lt; n; i++) &#123; if(str.find(&quot; &quot;) != string::npos) //有空格时 &#123; str_vec.push_back(str.substr(0,str.find(&quot; &quot;))); str = str.substr(str.find(&quot; &quot;) + 1); n = str.size(); //分割后新字串长度 i = 0; //新的字串从头开始 &#125; else &#123; str_vec.push_back(str); //最后一个单词也存一下 break; &#125; &#125; //输出 for (int i = str_vec.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; str_vec[i] &lt;&lt; &quot; &quot;; &#125;&#125; HJ14 题目：字符串按字典序列排序 思路：偷个懒，直接调库函数排序吧 代码： 123456789101112131415161718192021222324252627282930313233//// Created by MQRoad on 2022/08/15.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;string&gt; str; string str_tmp; int n; cin &gt;&gt; n; while(n) &#123; cin &gt;&gt; str_tmp; str.push_back(str_tmp); n--; &#125; sort(str.begin(),str.end()); for (auto k: str) &#123; cout &lt;&lt; k &lt;&lt; endl; &#125; // vector&lt;string&gt;::iterator it; // for(it = str.begin(); it &lt; str.end(); it++) // &#123; // cout &lt;&lt; *it &lt;&lt; endl; // &#125;&#125; HJ15 题目：int型整数的二进制中1的个数 思路一：笨人笨办法，先转成二进制，二进制顺序无所谓，再数 1 的个数 代码： 12345678910111213141516171819202122232425262728//// Created by MQRoad on 2022/08/15.//#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; string str; cin &gt;&gt; n; vector&lt;int&gt; k; int j = 0; while(n) //转二进制 &#123; k.push_back(n%2); n /= 2; &#125; for (int i = 0; i &lt; k.size(); ++i) &#123; if (k[i] == 1) j++; &#125; cout &lt;&lt; j;&#125; 思路二：用STL，bitset 代码： 1234567891011121314151617181920//// Created by MQRoad on 2022/08/15.//#include&lt;bitset&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; bitset&lt;32&gt; set(n); //题目要求大小不超过32// for (int i = 0; i &lt; set.size(); ++i)// &#123;// cout &lt;&lt; set[i];// &#125; cout &lt;&lt; set.count(); //直接返回 1 的个数&#125; 思路三：位运算：将整数对应的二进制数的每一位与 1 进行位与运算，为此，每次将该数右移 1 位 代码： 123456789101112131415161718192021//// Created by MQRoad on 2022/08/15.//#include&lt;bitset&gt;#include&lt;iostream&gt;using namespace std;//位与运算int main()&#123; int n; cin &gt;&gt; n; int count= 0; while(n) &#123; if (n &amp; 1) count++; n &gt;&gt;= 1; //右移一位 &#125; cout &lt;&lt; count;&#125; 思路三：（我反正是想不到）位与运算还有一个性质：n&amp;n-1结果会去掉n最末尾的1。比如1110&amp;1101=1100，直接就去掉了111011101110最后的1，我们依照这个性质，不断去掉n末尾的1，直到结果为全0，去掉过程中统计去掉过多少次，即1出现的次数 123456789101112131415#include&lt;iostream&gt;using namespace std; int main()&#123; int n; cin &gt;&gt; n; int count = 0; while(n)&#123; count++; //统计+1 n &amp;= (n - 1); //去掉末尾的1 &#125; cout&lt;&lt; count &lt;&lt; endl; return 0;&#125; HJ17 题目：坐标移动，ADWS，给定的数字表示移动距离 思路一：（纯纯暴力）和HJ13类似，先把给定的字串按 “;” 分割出来，再判断分割后的首位是 ADWS 的哪位，分类讨论，小类中再判断数字是否合理 代码：（垃圾代码，真的垃圾） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// Created by MQRoad on 2022/08/16.//#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;//#include &lt;set&gt;using namespace std;int main()&#123; string str = &quot;S87;S7;W56;S75;A8;S84;W23;W19;W40;D73;S87;A39;W97;W78;A53;D16;D15;A50;W41;S87;D47;W56;D56;A23;A91;S25;D61;D53;D58;W88;W58;S61;D69;W74;D89;A92;D39;D62;S78;W72;W73;W35;S76;W35;S36;W39;A4;&quot;;// getline(cin,str); vector&lt;string&gt; str_vec; for(int i = 0; i &lt; str.size(); i++) &#123; if ((str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;A&quot; || (str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;D&quot; || (str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;W&quot; || (str.substr(0, str.find(&quot;;&quot;))).substr(0,1) == &quot;S&quot; )//首位不是ADWS的就不要了 &#123; str_vec.push_back(str.substr(0, str.find(&quot;;&quot;))); &#125; str = str.substr(str.find(&quot;;&quot;) + 1); i = 0; &#125; int x = 0, y = 0; for (int i = 0; i &lt; str_vec.size(); ++i) &#123; if(str_vec[i][0] == &#x27;A&#x27;) &#123; if (str_vec[i].size() == 3) //分割后的是不是有3位，是的话说明数字有两位，两位都要判断是不是数字 &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) x -= stoi(str_vec[i].substr(1)); //字串转int &#125; else if(str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) x -= stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == &#x27;D&#x27; ) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) x += stoi(str_vec[i].substr(1)); &#125; else if(str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) x += stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == &#x27;W&#x27; ) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) y += stoi(str_vec[i].substr(1)); &#125; else if(str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) y += stoi(str_vec[i].substr(1)); &#125; else if (str_vec[i][0] == &#x27;S&#x27;) &#123; if (str_vec[i].size() == 3) &#123; if (str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27; &amp;&amp; str_vec[i][2] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][2] &lt;= &#x27;9&#x27;) y -= stoi(str_vec[i].substr(1)); &#125; else if( str_vec[i][1] &gt;= &#x27;0&#x27; &amp;&amp; str_vec[i][1] &lt;= &#x27;9&#x27;) y -= stoi(str_vec[i].substr(1)); &#125;// else// continue;// str_vec[i].size() == 2 &amp;&amp; &#125; cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y; return 0;&#125; 看了排行一的代码，思路和我一样，但是代码简洁多了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; while(cin &gt;&gt; str) &#123; //初始化坐标 int x = 0, y = 0; //存储单步操作 vector&lt;string&gt; steps; //把字符串拆分 int wordlen = 0; for(int i = 0; i &lt; str.size(); ++i) &#123; while(str[i] != &#x27;;&#x27;) wordlen ++, i ++; steps.push_back(str.substr(i - wordlen, wordlen)); wordlen = 0; &#125; //分解成功 //for(auto x : steps) cout &lt;&lt; x &lt;&lt; endl; //对单个steps执行坐标变换 for(int i = 0; i &lt; steps.size(); ++i) &#123; int num = 0; //长度3 A10 if(steps[i].length() == 3 &amp;&amp; steps[i][1] &lt;= &#x27;9&#x27; &amp;&amp; steps[i][1] &gt;= &#x27;0&#x27; &amp;&amp; steps[i][2] &lt;= &#x27;9&#x27; &amp;&amp; steps[i][2] &gt;= &#x27;0&#x27;) num = (steps[i][1] - &#x27;0&#x27;) * 10 + steps[i][2] - &#x27;0&#x27;; //长度2 A5 if(steps[i].length() == 2 &amp;&amp; steps[i][1] &lt;= &#x27;9&#x27; &amp;&amp; steps[i][1] &gt;= &#x27;0&#x27;) num = steps[i][1] - &#x27;0&#x27;; switch(steps[i][0])//ASDW &#123; case &#x27;A&#x27;: x -= num; break; case &#x27;D&#x27;: x += num; break; case &#x27;W&#x27;: y += num; break; case &#x27;S&#x27;: y -= num; break; default: break; &#125; &#125; cout &lt;&lt; x &lt;&lt; &#x27;,&#x27; &lt;&lt; y &lt;&lt; endl; &#125; return 0;&#125; HJ20 题目：密码合格验证：大于8位；大小写、数字、其他符号中的至少三种；不能有三个字符重复 思路：分类判断：一是判断是否有三种类型，二是判断是否有重复 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by MQRoad on 2022/08/17.//#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int is3kind(string str)&#123; int count[4]=&#123;0&#125;; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;) count[0] = 1; else if (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) count[1] = 1; else if (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) count[2] = 1; else count[3] = 1; &#125; return count[0] +count[1] + count[2] + count[3];&#125;bool isrepet(string str)&#123; for (int i = 0; i+3 &lt; str.size(); ++i) //i+3超过str长度就无需判断了 &#123; if(str.find(str.substr(i,3), i + 3) != string::npos) //每次将输入字串截取3个，判断3个之后是否有相同 return true; &#125; return false;&#125;int main()&#123; string str; while(cin &gt;&gt; str) &#123; if (str.size() &lt;= 8||is3kind(str)&lt;3|| isrepet(str)) cout &lt;&lt; &quot;NG&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl; &#125;&#125; HJ21 题目：密码转换：按手机键盘九键，将小写字母转为对应的数字，大写字母转为对应小写的后一位，Z的直接转为a再转为数字 思路：（笨办法，暴力）先将小写字母转为数字，再将大写转为数字 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str; cin &gt;&gt; str; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;c&#x27;) str[i] = &#x27;2&#x27;; else if (str[i] &gt;= &#x27;d&#x27; &amp;&amp; str[i] &lt;= &#x27;f&#x27;) str[i] = &#x27;3&#x27;; else if (str[i] &gt;= &#x27;g&#x27; &amp;&amp; str[i] &lt;= &#x27;i&#x27;) str[i] = &#x27;4&#x27;; else if (str[i] &gt;= &#x27;j&#x27; &amp;&amp; str[i] &lt;= &#x27;l&#x27;) str[i] = &#x27;5&#x27;; else if (str[i] &gt;= &#x27;m&#x27; &amp;&amp; str[i] &lt;= &#x27;o&#x27;) str[i] = &#x27;6&#x27;; else if (str[i] &gt;= &#x27;p&#x27; &amp;&amp; str[i] &lt;= &#x27;s&#x27;) str[i] = &#x27;7&#x27;; else if (str[i] &gt;= &#x27;t&#x27; &amp;&amp; str[i] &lt;= &#x27;v&#x27;) str[i] = &#x27;8&#x27;; else if (str[i] &gt;= &#x27;w&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) str[i] = &#x27;9&#x27;; else if (str[i] == &#x27;0&#x27;) str[i] = &#x27;0&#x27;; else if (str[i] == &#x27;1&#x27;) str[i] = &#x27;1&#x27;;// cout &lt;&lt; str[i]; &#125; for (int i = 0; i &lt; str.size(); ++i) &#123; if (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Y&#x27;) str[i] += 32 + 1; if (str[i] == &#x27;Z&#x27;) str[i] = &#x27;a&#x27;; cout &lt;&lt; str[i]; &#125;&#125; 优化代码：上述代码遍历了两次，优化如下 1234567891011121314151617181920212223242526272829303132333435//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; for(int i = 0; i &lt; s.size(); i++) &#123; if(s[i] &lt;= &#x27;9&#x27; &amp;&amp; s[i] &gt;= &#x27;0&#x27;) cout &lt;&lt; s[i]; else if(s[i] &lt; &#x27;Z&#x27; &amp;&amp; s[i] &gt;= &#x27;A&#x27;) &#123; s[i] = s[i] + 33; cout &lt;&lt; s[i]; &#125; else if(s[i] == &#x27;Z&#x27;) cout &lt;&lt; &quot;a&quot;; else if(s[i] &lt;= &#x27;z&#x27; &amp;&amp; s[i]&gt;= &#x27;a&#x27;) &#123; if(s[i] &lt;= &#x27;c&#x27; &amp;&amp; s[i] &gt;= &#x27;a&#x27;) cout &lt;&lt; &quot;2&quot;; if(s[i] &lt;= &#x27;f&#x27; &amp;&amp; s[i] &gt;= &#x27;d&#x27;) cout &lt;&lt; &quot;3&quot;; if(s[i] &lt;= &#x27;i&#x27; &amp;&amp; s[i] &gt;= &#x27;g&#x27;) cout &lt;&lt; &quot;4&quot;; if(s[i] &lt;= &#x27;l&#x27; &amp;&amp; s[i] &gt;= &#x27;j&#x27;) cout &lt;&lt; &quot;5&quot;; if(s[i] &lt;= &#x27;o&#x27; &amp;&amp; s[i] &gt;= &#x27;m&#x27;) cout &lt;&lt; &quot;6&quot;; if(s[i] &lt;= &#x27;s&#x27; &amp;&amp; s[i] &gt;= &#x27;p&#x27;) cout &lt;&lt; &quot;7&quot;; if(s[i] &lt;= &#x27;v&#x27; &amp;&amp; s[i] &gt;= &#x27;t&#x27;) cout &lt;&lt; &quot;8&quot;; if(s[i] &lt;= &#x27;z&#x27; &amp;&amp; s[i] &gt;= &#x27;w&#x27;) cout &lt;&lt; &quot;9&quot;; &#125; &#125; return 0;&#125; HJ22 题目：汽水瓶，3个空的换一瓶汽水，可以向老板要一个空瓶，但必须还给老板 思路：（看了题解我TM，这就是个智力题）3个换一个，有2个的话可以找老板要一下空的，换一瓶，喝完了还给老板，所以不管有多少空瓶，就看你有多 2，反正有 2 就可以换一瓶 代码： 1234567891011121314151617//// Created by MQRoad on 2022/08/17.//#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while ( cin &gt;&gt; n ) &#123; if(n == 0) continue; cout &lt;&lt; n/2 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"}]},{"title":"数据结构","slug":"数据结构/数据结构","date":"2022-07-29T13:20:49.000Z","updated":"2023-04-28T08:57:31.843Z","comments":true,"path":"data_structure/","link":"","permalink":"https://hbroad.github.io/data_structure/","excerpt":"","text":"宝藏级+保姆级课程-数据结构与算法基础-青岛大学-王卓老师 油管大神 时间复杂度时间复杂度：各条指令执行的时间之和 大O表示法 表示算法执行的渐进上限 性质： 任意常数 $c &gt;0$，$O(f(n))=O(cf(n))$ 常数乘以某个运算，不改变其时间复杂度（函数正的常系数可忽略等同于1） 任意常数$a&gt;b&gt;0$，$O(n^a+n^b)=O(n^a)$ 因 $a&gt;b$，故前者的影响大于后者，在整个过程中便可忽略后者的影响（低次项可忽略，保留最高次项） 空间复杂度 不计入输入本身 其他各方面消耗都计入 复杂度分析 常数时间复杂度 $O(1)$ 对数时间复杂度 $O(logn)$ 对数多项式复杂度 线性 $O(1)$ 哈希表哈希表用于判断一个元素是否出现在集合中，原理及问题 线性数据结构链表 链表结构由指针域+数据域组成 循环链表 尾部指针域指向头结点 一般使用带尾指针的循环链表 比较单链表为何在插入和删除上优于数组：对插入单个元素而言，两者并无明显优势，但若一次插入多个元素，对单链表而言，只需一次遍历，后续只需进行指针赋值等操作，故为 $O(1)$；而对数组而言，每个元素的插入和删除，伴随着插入位置后所有点的移动，为 $O(n)$。 栈 一种后入先出（LIFO）的结构 可通过数组或链表实现 主要可用于判断括号的匹配、程序中表达式是否正确 括号是否匹配：程序中的括号是否是一一对应的，比如 {[()]} 是一一对应且是正确的匹配，为了判断是否匹配，可从左至右遍历字符串，若遇到左括号，压入栈，遇到右括号时查看其与栈中的左括号是否匹配，匹配则将栈中元素弹出，否则说明括号不匹配 表达式检测：实际计算机检测时并非按我们写的表达式进行检测，其实际将其转换成前缀表示法或后缀表示法，具体参考 队列 一种先入先出（FIFO）的结构 可通过数组或链表实现 主要应用于服务请求中，如多个人同时请求打印机打印资料，此时打印机可根据请求的顺序排队，依次打印 字符串KMP算法参考 字符串匹配的快速算法，相交于暴力算法，去除了回溯（主串遇到不匹配字符时不再返回，而是一直前行），减小了时间复杂度，为$O(m+n)$，其中，$m$ 为主串长度，$n$ 为模式串长度 非线性数据结构树 一种非线性结构 典型应用： 存储分层数据：文件系统（文件和文件夹的层次结构） 快搜、增、删数据：如二叉数搜索 拼接检查：一种特殊的树 trie 网络路由算法 最常见的是二叉树 每个结点最多有两个子结点 可通过链表实现，每个节点由三部分组成，中间存储数据，左右分别存储左右子节点的地址","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://hbroad.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数字图像处理","slug":"图像处理/数字图像处理","date":"2022-07-17T03:00:47.000Z","updated":"2023-05-26T09:21:47.415Z","comments":true,"path":"digital_image_process/","link":"","permalink":"https://hbroad.github.io/digital_image_process/","excerpt":"数字图像处理基础理论（待补充） (通俗易懂的计算机视觉优质课程)北京邮电大学计算机学院-鲁鹏 参考:CS 543/ECE 549: Computer Vision （文中所有图片均摘自上述课程）","text":"数字图像处理基础理论（待补充） (通俗易懂的计算机视觉优质课程)北京邮电大学计算机学院-鲁鹏 参考:CS 543/ECE 549: Computer Vision （文中所有图片均摘自上述课程） 图像去噪（滤波）常见噪声 卷积 卷积：把相关运算的核旋转180° 线性：F(f1+f2) = F(f1)+F(f2) 平移不变形：F(S(f)) = S(F(f)) 满足线性平移不变性的操作均可定义为卷积 满足交换律、结合律、分配律 卷积时边缘的处理：边界填充 卷积核的特性导致卷积后的图像和原图不一样大 零填充（常用） 复制边缘 镜像边缘 常见核 单位脉冲核 平移核 平滑核 锐化操作 高斯卷积 平均卷积核的问题 中心与邻域的权重一致，导致振铃现象（卷积后图像出现的条状） 解决：根据邻域像素与中心的远近程度分配权重，离中心越近，权重越大 高斯卷积的生成 ​ 归一化即为 3 中各个位置权重值/总的权重值 参数的选取 大标准差或者大尺寸卷积核平滑能力强 小标准差或者小尺寸卷积核平滑能力弱 解释： 大标准差，对应的是核中中心元素的权重低于周围元素，即占比低，从而被平滑的越厉害（其实，$\\sigma$ 就是模板的模糊半径，该值越大，对应的圆越大，自然模糊的越厉害） 大尺寸，在标准差不变时，高斯函数值相等，但在归一化后，大尺寸的权重比小尺寸的小，平滑的越厉害 经验法则: 将卷积核的半窗宽度设置为 3𝜎，最终卷积模板尺寸为 2 × 3𝜎 + 1 即：只要指定一个参数 $\\sigma$ ，就可直接得到窗口大小，从而不用两个参数单独指定 为什么是 $3\\sigma$，因为大于该值以后，高斯值为 0，没有意义 高斯核特性说明 高斯核是低通滤波器，滤除图像中的高频成分 两个高斯卷积核卷积后得到的还是高斯卷积核 使用多次小方差卷积核连续卷积，可以得到与大方差卷积核相同的结果 使用标准差为 $\\sigma$ 的高斯核进行两次卷积与使用标准差 $\\sqrt 2 \\sigma$ 的高斯核进行一次卷积相同 高斯核 1 为 $f$，高斯核 2 为 $g$，两者卷积： $f$ $g$ $f\\star g$ 均值 $m_f$ $m_g$ $m_f + m_g$ 标准差 $\\sigma_f$ $\\sigma_g$ $\\sigma_f + \\sigma_g$ 可分离特性 大卷积核可分为两个一维高斯的乘积 降低计算复杂度 如 $m \\times m$ 的核卷积 $n \\times n$ 的图像 无分离时，复杂度为：$O(n^2m^2)$ 分离后，复杂度为：$O(n^2m)$ 中值滤波 用于去除椒盐噪声、脉冲噪声 使用邻域升序排列的中值作为中心像素的值 中值滤波的灰度值始终是原图像中的灰度值 卷积与边缘提取边缘图像中亮度明显而急剧变化的点（灰度不连续） 边缘种类 边缘检测 图像中灰度急剧变化的地方，其导数变化明显 图像求导 差分代替一般导数 一般2D函数的偏导为： \\frac{ \\partial f(x,y) }{\\partial x} = \\lim_{\\epsilon \\to 0} \\frac{f(x+\\epsilon) - f(x,y)}{\\epsilon} 但在数字图像中，$\\epsilon$ 不能为0，其最小单位为一个像素，故有： \\frac{ \\partial f(x,y) }{\\partial x} \\approx \\frac{f(x+1) - f(x,y)}{1} X 方向的导数提取了 Y 方向的特征， Y 同理 图像梯度 指向灰度变换最快的方向 X 方向的梯度与 Y 方向的边缘垂直，其他同理；即梯度方向与边缘垂直。具体可参考 可见，梯度向量与边缘垂直，故也称为边缘法线 梯度幅值的大小衡量了该点处是否是边的可能性的大小，越小，就说明 x 和 y 方向变换不明显，即接近平坦区域 需要对角边缘时，即需要二维核，Robert 算子采用对角性能（详见数字图像处理第四版P516） 上述核的功能在于其考虑了周围更多的邻域，减少了噪声的敏感性，以 Soble 算子为例，其可以分解为两个一维核： \\begin{bmatrix} 1 \\\\ 2 \\\\ 1 \\end{bmatrix} * \\begin{bmatrix} -1 & 0 & 1 \\end{bmatrix}可见，Sobel 是进行了高斯滤波，再进行边缘提取，故受噪声的影响较低。 注意： $3 \\times 3$ 的核：最小的中心对称核，考虑了中心对侧数据的性质 Soble 算子能够更好的平滑噪声 上图中所有的算子，权重和为 0，即在恒定灰度区域的响应为 0 （恒定区域灰度值相等，与核相乘相加为0） 梯度幅值的实现 实际中，使用平方及平方根的开销大，一般使用绝对值近似 M(x,y) \\approx |{g_x}| + |g_y| 虽计算简单，但使得滤波器不再具有各向同性（即旋转不变性） 实际情况但实际中，由于噪声的影响，求导的结果也无法得出边缘的位置 因而在求导前先平滑滤波处理 由于微分求导也是卷积，卷积具有结合性，故原图的高斯卷积与可求导结合（高斯一阶偏导核），最后和原图卷积，从而可节省一次卷积操作 高斯一阶偏导核 高斯与一阶偏导的对比 高斯核 消除高频成分（低通滤波器） 卷积核中的权值不可为负数（倒扣钟型） 权值总和为1（恒定区域不受卷积影响） 高斯一阶偏导核 高斯的导数 卷积核中的权值可以为负 权值总和是0（恒定区域无响应，急剧变化的地方响应大） 高对比度点的响应值大 Canny 检测算子 经过两个方向上高斯一阶导，得到梯度幅值图，可见，边缘较宽，这是因为在灰度斜坡上一阶导不为 0，如何得到更为准确的边缘？ 非极大值抑制 实质：规定梯度方向（边缘法线）的多个离散方向，如定义为水平、垂直、+45°、-45° 四个方向（一条边缘有正负两条边缘法线），即所有可能得边缘量化为这四个方向，但显然，边缘法线方向可能是任意的，故需要定义某个范围，落在该范围内就认为是哪个方向，该定义方式如下图所示（详见数字图像数字图像处理第四版 P526） 流程： 对任意一点，求该点的梯度幅值 $K$ 和方向 $\\alpha$ 在四种边缘法线中找到最接近梯度方向 $\\alpha$ 的，记为 $d_k$ 在 $d_k$ 方向上取一个或两个邻点，若 $K$ 小于所取点的梯度幅值，则令 $g_N(x,y) = 0$ （即抑制），否则为 $g_N(x,y) = K$（$g_N(x,y)$ 为非极大值抑制后的图像） 双阈值法 阈值过高导致细节丢失，过低则边缘杂乱 双阈值：先利用高阈值筛选出主要的边缘，再利用低阈值将这些边缘连接起来（低阈值虽然会引入噪声引起的假边，但是这种假边不会和高阈值筛选出的主要边缘有连接） Canny 整体流程： 用高斯一阶偏导核卷积图像 计算每个点的梯度幅值和方向 非极大值抑制： 将宽的“边缘”细化至单个像素宽度 连接与阈值（滞后）： 定义两个阈值：低和高 使用高阈值开始边缘曲线，使用低阈值继续边缘曲线 拟合引例在获得边缘后，接下来的问题是，对于图中的特征如何进行描述，即选择参数模型进行拟合，但实际中，面临三个问题： 噪声 局外点的影响 遮挡导致的数据丢失 为此，针对不同的情况需要不同的方法 如若知道所有点都属于一条直线，该如何找到这条最优直线？ 最小二乘 若存在外点呢？ 鲁棒最小二乘、RANSAC 若这些点属于多条直线呢？ 投票机制：RANSAC、Hough 变换 更一般的情况，不确定其是否是直线？ 模型筛选 最小二乘“垂直”最小二乘如图，对于 $n$ 个点，若其直线方程为 $y = mx + b$ ，则要使每个点到该直线的垂直距离最小化，方可说明这些点在该直线上 于是，可建立能量函数（目标函数），并使其最小化： E=\\sum_{i=1}^n (y_i -mx_i -b)^2这里之所以取平方，是因为我们只关心点到直线的距离，不关心正负。 对 $n$ 个点，有 \\begin{cases} y_1 = mx_1 + b \\\\\\\\ y_2 = mx_2 + b \\\\\\\\ \\vdots \\\\\\\\ y_n = mx_n + b \\end{cases}写成矩阵形式： Y = XB Y=\\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{bmatrix} \\qquad X=\\begin{bmatrix} x_1 & 1\\\\ x_2 & 1\\\\ \\vdots & \\vdots \\\\ x_n & 1 \\end{bmatrix} \\qquad B=\\begin{bmatrix} m \\\\ b \\\\ \\end{bmatrix}到此，前述的能量函数变为（平方和即为模）： E = ||Y-XB||^2$B$ 为待求项，$||X||$ 为向量的模，是内部元素的平方和开根号，这也是能量函数取平方的另一个好处。对一个向量 $A = \\begin{bmatrix} a_1\\\\ a_2 \\\\a_3 \\end{bmatrix} $，有： ||A|| ^2 = a_1^2 +a_2^2 + a_3^2 = A^TA故能量函数可写为： \\begin{align} E & = ||Y-XB||^2 = (Y-XB)^T(Y-XB) \\\\ & \\overset{展开}{=} (Y^T-B^TX^T)(Y-XB) \\\\ & = Y^TY - Y^TXB-B^TX^TY + B^TX^TXB \\\\ & = Y^TY-2(XB)^TY+(XB)^TXB \\end{align}为求 $B$，自然想到让 $E$ 对 $B$ 求导： \\frac{dE}{dB} = -2X^TY + 2X^TXB = 0从而求得： B = (X^TX)^{-1}X^TY 问题： 当直线垂直 x 轴时，方法失效 即不满足旋转不变性，直线转动到垂直时无法求解 全最小二乘 目的：解决垂直最小二乘的失效情况 原理 假设一点$(x_i,y_i)$ 和一直线 $ax+by=d$ （满足 $a^2+b^2=1$)，则该点到该直线的距离为 |ax_i+by_i-d|要拟合直线，即找到合适的 $(a,b,d)$ 使得所有的点到该直线的距离最小，即最小化能量函数： E=\\sum^n_{i=1}(ax_i+by_i-d)^2 \\tag{*}该函数对 $d$ 求导可得： \\frac{\\partial E}{\\partial d} = \\sum^n_{i=1} -2(ax_i+by_i-d) =0整理得： d = \\frac{a}{n}\\sum^n_{i=1} x_i + \\frac{b}{n}\\sum^n_{i=1} y_i = a\\bar{x} + b\\bar{y} \\tag{**}将其代入 (*) 式可得： E=\\sum^n_{i=1}(a(x_i-\\bar{x}) + b(y_i-\\bar{y}))^2 = || \\begin{bmatrix} x_1 - \\bar{x} & y_1 - \\bar{y} \\\\ \\vdots & \\vdots \\\\ x_n - \\bar{x} & y_n - \\bar{y} \\end{bmatrix} \\begin{bmatrix} a \\\\ b \\end{bmatrix} ||^2 = (UN)^T(UN)为求得 N，可求导： \\frac{dE}{dN}=2(U^TU)N= (U^TU)N =0根据特征值与特征向量的关系，对 $AN=\\lambda N$，要使其为 0，只能是 $\\lambda = 0$，故该方程的解为最小特征值对应的特征向量 事实上，上述的 $U^TU$ 矩阵为二阶矩矩阵，如下图，由前述(**)式可知点 $(\\bar{x},\\bar{y})$ 在该直线上，从几何角度来看，使得能量方程最小化的点即为使得任意点与该点的向量在该直线的法线上的分量最小。 鲁棒估计（鲁棒核函数）如图是最小二乘拟合的结果，可见，当出现外点（即噪声）的影响时，拟合的准确性很差 这是因为最小二乘要确保所有的点都使得能量函数最小化，所以直线朝着外点倾斜，外点距离真实直线的距离很远，拟合时所占的比重很大，为缩小这种外点的比重，引入了鲁棒估计 鲁棒估计引入鲁棒核函数 $\\rho$ ，该函数有一个缩放因子参数 $\\sigma$，通过该值可调整权重，其和距离类似，不同的是，当距离超过一定限度时，该值不再增加。以图中 $\\sigma = 0.1$ 为例，当横坐标值大于 4 时，值都为1。换句话说，对一点而言，不论该点距离直线的距离是1k还是1w，对能量函数而言其比重都为 4，这样就在一定程度上避免了外点占比过大，导致拟合精度差的问题。 缩放因子参数 $\\sigma$ 选取不同的拟合结果（一般取平均残差的1.5倍）： 合适/ 过小/ 过大 需注意的是，鲁棒拟合是一个非线性问题，须通过迭代求解，而迭代需要一个良好的初值，前述的最小二乘便可提供该初值。 RANSAC若无特殊说明，以下均以简单的直线拟合为例。 基本思想RANSAC是一种通用的模型估计思想，主要有四步： 在已有点中随机选择足够拟合某类形状的点（如拟合一条直线需要2点） 利用所选的点拟合该形状 查找剩余点，保留距离该形状较近的点，剔除外点 重复上述过程，直至找到最佳的形状 参数选择所需参数可见，我们需要指定一些参数才能使用该方法 初始点数 $s$：拟合形状所需的最小点数 距离阈值 $t$：该参数指定范围内的点是内点 采样次数 $N$：即迭代的次数 若外点率为 $e$，拟合的正确率为 $p = 0.99$，则拟合错误的概率为 $(1-p)$，内点率为 $(1-e)$，由于选择 $s$ 个进行拟合，故内点率为 $(1-e)^s$，则采样一次的错误率为 $1-(1-e)^s$，采样 $N$ 次为 $(1-(1-e)^s)^N$，从而 (1-(1-e)^s)^N=1-p对左右同时取对数： N = \\text{log}(1-p)/\\text{log}(1-(1-e)^s) 下图表显示了拟合不同的模型，当外点率不同时，要达到 0.99 的正确率所需的迭代次数 一致性点集 $d$：最终模型的内点数，应当和设置的内点率相适应，可通过设置该阈值选择保留哪些拟合结果 自适应参数选取实际使用中，我们可能压根不知道点集中的外点率，这时就需要自适应的参数选择 起初我们不知道要迭代多少次，就直接假设我们要迭代无穷次，设置一个迭代计数器（sample_count）记录迭代的次数，首次迭代时，可以计算出外点率 $e$，由外点率可计算出迭代的次数 $N$，据此便可迭代。 但在实际实验中，我们还是会指定迭代的次数，如指定 1k 或 1w，避免耗时过长。 优缺点分析 优势 简单，通用 通常能得到很好的结果 缺点 需要指定的参数多 内点率较低时，效果不好（迭代过多甚至失败） 并不总是能得到很好的初始化 实际中，在通过 RANSAC 方法获得内点后，还可继续对这些内点使用最小二乘拟合，以得到更为精确的拟合结果。 不难看出，RANSAC 实际是一种暴力的方法，通过随机选取点进行拟合，利用剩余的点进行投票，再通过设置一个阈值，只要大于这个阈值，就认为是正确的，这在匹配中应用广泛。 Hough 变换使用条件 是一种投票机制 噪声点对任何模型的投票均不具备一致性 丢失数据不影响，只要剩余的点足够拟合 整体思想 将图像空间离散化为霍夫参数空间 每个特征点都在参数空间中进行投票 投票最多的点即为所求 图像空间中的一条直线，对应参数空间中的一点（参数空间的横纵坐标是直线的参数） 图像空间中的一点，对应参数空间中的一条直线（参数空间中自变量和因变量变化了） 则对于图像空间中的两点（确定一条直线），在霍夫参数空间中对应两条直线，这两条直线的交点，即为投票最多的点 $(m^,b^)$，即为所要拟合直线的参数。换句话说，图像空间中这条直线上的所有点都经过参数空间中的交点。 但当直线是垂直线时，即 $x=a$，该直线上的所有点在参数空间中对应的直线是平行的，即没有交点，方法失效，参数空间无边界 改进方法通过极坐标表示，解决垂直直线的问题。（详见《数字图像处理》P531） 直线的极坐标参数化方程为 x\\text{cos}\\theta+y\\text{sin}\\theta=\\rho因而，图像空间中过一点的直线簇对应参数空间中的正弦曲线，交点 $(\\rho’,\\theta’)$ 即为图像空间中的直线，下图右边是参数空间划分的多个累加单元，初始时将其设为 0，对图像空间中的每个点，利用参数空间中的每个可能的 $\\theta$，计算出 $\\rho$。实际中，如果选择的 $\\theta_q$ 得到解 $\\rho_q$，则累加器增1（可以理解为给这个点头了一票），最终输出累加器最大的结果即为所求。 具体算法流程如下： 噪声的影响当存在噪声时，霍夫空间投票的结果就不再是聚焦于一点，还是一个区域，如下图 如何处理噪声? 恰当的离散化网格 既然噪声让聚焦点变成了区域，那么放大划分的网格，就让这块区域落在这一块网格中，即当做同一直线处理 但网格划分过大，会导致本来不是直线投票也被包含进来 同理，划分过细，导致本来属于一条直线的投票被去除 增加邻域投票（软投票） 类似高斯核，根据周围邻域到中心点的距离不同，投不同的票数，离得越近占比越大，中心始终占比最大 去除不相关的点 只使用梯度幅值较大的边缘点，即对每个点，通过计算其梯度方向确定角度，然后只是在该角度范围内投票 Hough 圆根据圆的方程 (x-u)^2+(y-v)^2=r^2可知，圆有三个参数 $(u,v,r)$，则霍夫空间为三维。 对于一个点，若已知半径 $r$，且圆过该点，则该圆可能的圆心是在该点梯度方向两侧，对应霍夫参数空间中的两点。 不同的半径对应不同的两点，经过投票，霍夫空间中存在一个立方体小空间，该空间中票数最高，对应的三个参数即为所求。 广义 HoughHough 变换可以推广到识别，比如下图的示例中，通过各组件与中心的方向与距离确定一个模板，在一堆混乱的组件中识别其中心，可根据模板中确定的组件方向和距离投票，最终得到票数最多的点即为中心点。实际使用中如由两车轮定位车辆中心。 优缺点 优点 不受非局部或遮挡影响 可检测多个模型 一定程度上不受噪声影响：可认为噪声点的投票不具有一致性 缺点 高维时参数空间复杂，搜索时间指数级增加 非目标模型在参数空间也可能产生极值点 参数空间的划分较难（较难确定一个比较好的划分方法） 特征检测为何提取需要提取特征？多视角拼接 特征提取特征的要求 可重复性：即使有几何变换等的影响，该特征仍能在多视角中找到 独特性：每个特征应当是独特的，否则难以匹配 高效性：考虑计算的高效性 局部性：特征只是局部的 Harris 角点原理详述见《数字图像处理》P627 角点：在各个方向移动时窗口内灰度变化大 平坦区域：各方向无变化 边：沿着边缘方向无变化 可见，为了检测角点，只需使用一个窗口进行滑动，判断窗口移动前后窗口区域内的灰度变化，如何从数学角度量化？ 如下图，红色实线框为移动前，绿色虚线框为移动后，$E(u,v)$ 表示移动前后差的平方的加权和，$\\text{w(x,y)}$ 为加权函数，主要有两种：盒式滤波器（窗口内为1，外为0）、高斯滤波器（根据距离远近分配权值） 然而，上述公式操作起来比较麻烦（每次移动后都要取像素），我们更希望有一种关系可以直接表达移动 $(u,v)$ 时两者与 $E(u,v)$ 的关系，为此，我们对上式在 $(0,0)$ 点进行泰勒展开（只保留二阶以下的项），每一项求导的结果如下： 上式可以简化为如下的矩阵形式：其中 $M$ 是二阶矩矩阵，可通过图像梯度求得 此时 $E(u,v)$ 可由 $M$ 确定，假设 $M = \\begin{bmatrix}\\lambda_1 &amp; 0 \\\\ 0 &amp; \\lambda_2 \\end{bmatrix}$，$E(u,v)=\\text{const}$ ，即： \\begin{bmatrix} u & v \\end{bmatrix} \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\tag{c1} \\frac{u^2}{(\\frac{1}{\\lambda_1})^2}+\\frac{v^2}{(\\frac{1}{\\lambda_2})^2} = \\text{const} \\tag{c2}可见结果为椭圆。 现在考虑这样一种情况，梯度方向是水平或者垂直的（即沿 x 或 y 方向的导数为 0，即 $\\lambda_1 = 0$ 或 $\\lambda_2 = 0$），那么窗口沿着垂直于梯度的方向运动时，另一个方向是不会变化的，也就是边的情况。换句话说，只要 $\\lambda_1$ 和 $\\lambda_2$ 任意一个接近于 0，那就不是角点；再者说，角点就是两者都比较大的地方。这就对前述的过程进行了量化。 如果角点是本节第一张图所示的样子，根据上述推导，易知其椭圆是一个正椭圆，但实际中显然不可能都是正椭圆，这时候就需要先对其进行旋转，旋转可由旋转矩阵表示，也就是说，如果有旋转， $M$ 的元素不再是 0，但其是一个实对称矩阵，由线代知识，可将其分解为 M= R^{-1} \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\tag{c3}根据旋转矩阵的性质：$R^{-1}=R^T$，将上式带入 (c1)式可得： \\begin{align} \\begin{bmatrix} u & v \\end{bmatrix} R^{-1} \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\\\ \\Rightarrow \\begin{bmatrix} u & v \\end{bmatrix} R^T \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\\\ \\Rightarrow (R \\begin{bmatrix} u \\\\ v \\end{bmatrix} )^T \\begin{bmatrix} \\lambda_1 & 0 \\\\ 0 & \\lambda_2 \\end{bmatrix} R \\begin{bmatrix} u \\\\ v \\end{bmatrix} =\\text{const} \\end{align} \\tag{c4}$R$ 即为旋转矩阵，可见旋转到正椭圆后，就可只关注 $\\lambda$ 了 。 那么，$\\lambda$ 跟椭圆有什么关系呢？根据式(c2)可知，$\\lambda$ 越大，对应椭圆的短轴，且在该方向上梯度变化快，反之亦反之。 也就是说， $\\lambda$ 决定了椭圆的轴长，即决定了梯度变化的快慢，旋转矩阵 $R$ 则决定了其姿态 。 对 $M$ 进行可视化如下图，结果如上述推导，梯度变化的快慢决定了椭圆的形状。 也就是说，我们只需要关注 $\\lambda$ 的大小就可知是否是角点 而在实际中，研究者觉得，要两个 $\\lambda$ 比较麻烦，实际过程中使用 $R$，通过该值判断，具体如下： 步骤 对每个像素计算高斯一阶导 在高斯窗口内计算每个像素的二阶矩矩阵 $M$ 计算角点响应函数 $R$ 设置 $R$ 的阈值 非极大值抑制以找到局部最大值（主要考虑到一块区域内存在多个在阈值范围内的极大值，可通过抑制保留最大的那个） 不变性分析 不变性(Invariance)：图像角度、光照的变化不影响角点的提取，即 $F(T(\\text{img}))=F(\\text{img})$ 协变性(covariance)：图像变换后需要经过相应的变换才能匹配，即 $F(T(\\text{img}))=T’F(\\text{img})$ 说白了，不变性就是不论图像怎么变，都能找到角点，而协变性是图像变了之后虽然能找到，但是经过相应的变换之后才能匹配。 灰度仿射变换 仅灰度是具有不变性的，对同一点，增加其灰度和减小其灰度，求导后其趋势不变 但灰度缩放导致部分点超过阈值，缩放前后不满足不变性 即灰度仿射变换满足部分不变性 说明：$I{out} = aI{in}+b$，$a$ 控制图像的对比度（即白的更白，黑的更黑），$b$ 控制其亮度的增减 图像平移变换满足协变性 平移之后角点的位置变化了，需要通过一个变换 $T$ 才能得到平移前的角点 图像旋转变换满足协变性 如下图，图像旋转之后，二阶矩矩阵对应的椭圆发生了旋转，但椭圆的轴未变，和平移类似，都能找到角点，但要经过旋转变换才能得到原来的点 不满足尺度不变性 对缩放这种尺度变换而言，放大后，角点就已经检测不到了，所有的点都会检测为边 Harris角点无法检测尺度变化的角点，那有没有尺度不变的检测算法呢，答案是肯定的！ 斑点（Blob）检测拉普拉斯核前述提到的 Harris 角点检测算法尺度缩放后无法检测，我们需要一种算法满足尺度协变性，即：不论图像中的特征被放大还是缩小，该算法都可以准确的检测该特征。 高斯一阶导可用于检测边缘，这里引出高斯二阶导： 高斯函数的一般形状为： G(x,y)=e^{-\\frac{x^2+y^2}{2\\sigma^2}}对高斯二阶导： \\begin{align} \\nabla^2G(x,y) & = \\frac{\\partial^2G(x,y)}{\\partial x^2}+\\frac{\\partial^2G(x,y)}{\\partial y^2} \\notag\\\\ & = \\frac{\\partial}{\\partial x}(\\frac{-x}{\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}})+\\frac{\\partial}{\\partial y}(\\frac{-y}{\\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma^2}}) \\notag\\\\ & = (\\frac{x^2}{\\sigma^4}-\\frac{1}{\\sigma^2})e^{-\\frac{x^2+y^2}{2\\sigma^2}}+(\\frac{y^2}{\\sigma^4}-\\frac{1}{\\sigma^2})e^{-\\frac{x^2+y^2}{2\\sigma^2}} \\notag \\\\ & = (\\frac{x^2+y^2-2\\sigma^2}{\\sigma^4})e^{-\\frac{x^2+y^2}{2\\sigma^2}} \\notag \\end{align}此即为 高斯拉普拉斯（LoG）函数，其长相如下：草帽 上述推导部分详见《数字图像处理》P521 尺度选择拉普拉斯核（差分表示的高斯二阶导）同样可以用于检测边缘（过零点即为边缘的位置），但 LoG 可用于尺度的检测。 高斯二阶导与信号卷积，如果两者相“匹配”，那么在斑点中心除便会产生极值 在实际使用中，我们无法知道信号和什么样的拉普拉斯核匹配，但是我们可以给定一堆核，让信号与其卷积，能得到极值的那个便是所需的核，然而现实往往很骨感：随着 $\\sigma$ 的变化，信号被衰减直至消失，这是为啥呢？ 为了搞清这个问题，我们以高斯一阶导为例，如下图，高斯偏导核与信号卷积时，卷积结果为 $\\frac{1}{\\sigma\\sqrt{2\\pi}}$，可见，随着 $\\sigma$ 的增大，相同的信号，卷积的结果不断减小。如何让卷积结果（尺度）恒定不变呢，当然是把 $\\sigma$ 去除，即 $\\frac{1}{\\sigma\\sqrt{2\\pi}}*\\sigma = \\frac{1}{\\sqrt{2\\pi}} $。那同理，对高斯二阶导而言，就需要乘 $\\sigma^2$。这个过程称为尺度归一化。 在尺度归一化后，信号在一堆拉普拉斯核中有一个极大值响应 即实际使用时进行尺度归一化： \\begin{align} \\nabla^2_{norm}g & = \\sigma^2\\nabla^2G(x,y) \\notag \\\\ & = (\\frac{x^2+y^2-2\\sigma^2}{\\sigma^2})e^{-\\frac{x^2+y^2}{2\\sigma^2}} \\tag{*} \\end{align}现在的问题是，拉普拉斯核在什么情况下相应才会最大呢？以二值圆形信号为例说明： 不难看出，只有当拉普拉斯核的零截面与信号对齐时（恰好卡住），响应值最大。 而对齐时，(*)式结果为0，则只能是 $x^2+y^2-2\\sigma^2 = r^2-2\\sigma^2 = 0$，即 $r=\\sqrt{2}\\sigma$，也即最大响应出现在 $\\sigma = r/\\sqrt{2}$ 处。 直观来看，只有当拉普拉斯核与二值圆形信号的圆一样大时，两者卷积的结果才最大（因为卷积就是信号的圆形区域与模板的圆形区域相差相加），只有两者完全重合时，卷积结果最大。 尺度空间前面我们一直在说，通过不同的 $\\sigma$ 进行尺度选择，不同的 $\\sigma$ 会形成不同的图像，这些不同的图像属于同一个尺度空间，即灰度图像 $f(x,y)$ 的尺度空间 $L(x,y,\\sigma)$ 是 $f$ 与一个可变尺度的高斯核 $G(x,y,\\sigma)$ 卷积的结果： L(x,y,\\sigma) = G(x,y,\\sigma) \\star f(x,y)其中，$\\sigma$ 控制尺度，$f$ 依次与标准差为 $\\sigma、k\\sigma、k^2\\sigma、k^3\\sigma、\\dots$ 的高斯核卷积，便可生成一堆由常量因子 $k$ 分隔的高斯平滑图像（如下图），即模糊程度不断变化，能模拟人眼由近到远时目标在视网膜上的形成过程。 $\\sigma$ 连续变化时，便可形成该图像的一个尺度空间（Lindeberg等人已证明高斯卷积核是实现尺度变换的唯一变换核，并且是唯一的线性核） 尺度空间中，只比较上下两个相邻的尺度空间，即比较相邻 27 个点，保留最大的那个（非极大值抑制） 如前述所述，需要不同的尺度空间，随着 $\\sigma$ 的增大，高斯核半径增大，计算量（乘法和加法）增加，显然效率不会很高。 SIFT原理我们已经知道了拉普拉斯函数，其计算较为复杂，但前辈们发现，该函数可用 高斯差分(DoG) 近似： LoG： L=\\sigma^2(G_{xx}(x,y,\\sigma)+G_{yy}(x,y,\\sigma))DoG： DoG=G(x,y,k\\sigma)-G(x,y,\\sigma)实验证明，对 LoG 进行一定的校正就可以通过 DoG 近似，性能基本相同。 DoG=G(x,y,k\\sigma)-G(x,y,\\sigma) \\approx (k-1)\\sigma^2 \\nabla^2G(x,y) 使用高斯差分近似的一大好处是，高斯核是可分离的，大的卷积核卷积的结果可以由两个小的卷积核完成。这样一来，我们不用让不同的核都与原图卷积，而是可以在现有卷积的基础上继续卷积。 举个例子： 这样做的好处显而易见，如果所有尺度都与原图卷积，随着尺度增大，计算量不断增大，如果在已有的结果上卷积，显然模糊半径小，这是 SIFT 特征检测的关键之一，即提速。 为了构建尺度空间，利用高斯金字塔实现，包括对原图像在多尺度下高斯卷积及降采样得到。其中，相同的分辨率的图像组成一个尺度空间（作者采用了每个尺度空间 6 张递增的高斯卷积结果图），每个尺度空间称为一个组（Octave），下一组的最底层图像由上一层的倒数第三张图下采样得到（一般是间隔采样，即隔离一个像素取一个，即缩小一半），从而形成了高斯差分金字塔。这是关键之二，这里的核心在于，对原图用 $\\sigma$ 卷积，和 将原图缩小一半，再用 $\\sigma$ 卷积，结果 *2 一致。 举个例子，原图中 10 mm 的圆，我用同样大小的 $\\sigma$ 卷积；另一种方案是，原图缩小一半，即待检测的圆只有 5mm 了，我仍然用前述的 $\\sigma$ 卷积，卷积后的结果是 5mm 的圆，*2 后就是原图中 10mm 的圆。这样做的好处在于，同样的核，但图像缩小了，速度也就上来了。 如上图所示，第一组有 5 层，可生成 4 层 DoG 尺度空间，这 4 层经过非极大值抑制可得到 2 个尺度，其他组同理。问题是，如何让不同组（Octave）的尺度形成连续的尺度空间？ 经过研究发现，只有当输出的尺度图像数与 k 之间的关系为 $k=s^{\\frac{1}{2}}$ 时，方可形成连续尺度空间。 以上图为例，第一组经过非极大值抑制后得到 $k\\sigma$、$k^2\\sigma$，同理第二组为 $2k\\sigma$、$2k^2\\sigma$，输出 2 张尺度图像，即 $k=2^{\\frac{1}{2}}$，带入可发现其形成了连续的尺度空间 $\\sqrt{2}\\sigma、2\\sigma、2\\sqrt{2}\\sigma、4\\sigma$。还可发现，要是最终输出 $s$ 张尺度图像，就得有 $s+2$ 张 DoG，$s+3$ 张 LoG。 前述中你可能会问为什么下一组的第一张图示上一组的倒数第三张下采样得到的？看完上面这个例子就显而易见了，我们最终输出 2 张尺度图像，对应的 DOG 有 4 层，4 层中的最底层不能参与特征值的提取，而 DOG 的最底层对应高斯尺度空间的最下面两层，也就是这两层，所以本尺度空间的关键信息点均在倒数第三层 上述即为 SIFT 的所有内容，下面进行总结。 不变性分析 拉普拉斯响应满足（旋转、缩放）不变性：即不论特征点有无缩放、旋转，都能检测到 特征的定位满足（旋转、缩放）协变性：特征都能检测到，但是匹配需要经过旋转、平移等操作 视角变化如何（仿射适应性） 如图，SIFT 只能输出图中的白色圆特征，但是右图视角变化后，很明显白色圈中的内容发生了变化，这样会导致后续匹配出问题，因而我们希望 SIFT 输出的是黄色圈，这样即使视角变化，其检测的特征还是一致的，匹配更有利。 如何实现这样的效果呢？ 回顾 Harris 角点检测的部分，其利用了二阶矩矩阵判断梯度变化，二阶矩矩阵的特征值的大小表征了两个方向上梯度变化的快慢。设想这样一种情况，如果左右图像检测到的特征完全一致的话，对应的二阶矩矩阵的椭圆应该是圆形的，因为其在两个方向上的梯度变化是一致的。 换句话说，以上左图黄色圈为例，其在椭圆长短轴方向的梯度变化基本是一致的了（图中头部），此时对应到二阶矩矩阵的椭圆就是圆了。 为了达到黄色椭圆的效果（说白了就是抠图扣得准确一点），可以先计算出二阶矩矩阵的特征值，然后将梯度方向变化小的反向向内收缩，直至其变成圆，达到各个方向梯度变化一致，此时 SIFT 输出的就是上图黄色椭圆部分。 注意：这里所说的是二阶矩矩阵的椭圆变成了圆，不是 SIFT 的特征输出了圆 SIFT 特征描述子现在我们有了仿射适应性，如何知道输出的特征是否是一致的呢？即如何对两幅图像检测到的特征进行比对？ 在尺度变化后，我们在两幅图像上检测到了大小不同的特征，为方便比较，我们进行归一化操作，即将特征转为大小一致的单位圆 归一化后，角度还是不一致，为了匹配，必须将其转到一致的方向，即消除旋转。 为此，提出梯度方向直方图的方法。具体做法是：我们在归一化后的窗口内，计算梯度幅值和方向，将 $0-360°$ 的方向划分为 8 份（下图画错了，只有 7 份），幅值是多少，直方图的值就加多少，给哪个块投票由方向角度决定（例如，某一像素点的梯度方向为17.856 度，那么这个点应该归入10-19 度这一区域），选取直方图中最大的方向作为主方向。 这个主方向与水平方向的夹角就是需要旋转的角度，对两张图都旋转到水平方向，从而消除旋转角度。 到此，我们完成尺度、旋转、角度的检测， 还剩下一个光照变化如何应对？SIFT 将经过前述变换的结果综合成为一个特征描述符，形成一个更加鲁棒的特征检测器。具体做法是：将检测特征圆区域划分成 16 个小区域，在每个小区域里面统计前述的梯度方向直方图，量化为 8 份的话，就会有 8 个方向，作为该小区域的描述子，故总共为 $16*8=128$ 维的描述符，两幅图像都如此，在比对时只需计算对应位置的 $L2$ 距离来判断相似性。 至于为什么划分为 16 块小区域，直方图 8 份，这就是作者实验的结果了，不过我们可以直观的理解，和 Harris 参数空间的划分类似，过大过小都不是好事。 邻域方向性信息联合的思想即增强了SIFT 算法的抗噪声能力，同时又对含有定位误差的特征匹配提供了很好 的容错性 实时性不高 有时特征点较少 对边缘光滑的目标无法准确提取特征点 对模糊的图像和边缘平滑的图像，检测出的特征点过少，对圆更是无能为力。近来不断有人改进，其中最著名的有SURF和CSIFT。 步骤SIFT 的实现包括以下几个步骤 构建高斯多尺度金字塔 检测尺度空间的极值点：上下26个点中最大才保留 精确定位极值点：局部的极值点不一定是全局的极值，拟合二次函数精确定位 选取特征点方向：前述是尺度不变，这里开始旋转不变 首先计算每一个特征点邻域内像素的梯度方向和幅值，然后选择在特征点邻域内最突出的方向赋给这个特征点，以此作为该特征点的主方向 统计直方图统计邻域内像素的梯度和方向，直方图中的最大值可认为是关键点的主方向 生成关键点描述子 金字塔保证特征点的空间不变性， 严格删选保证了特征点的准确性， 方向信息保证了特征点的旋转不变性 每一个关键点都拥有三个信息：位置、尺度以及方向 接下来需要为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变。描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 将坐标轴旋转为关键点的方向，以确保旋转不变性 选取一个大小为16×16的窗口，中心放在关键点上，这个16×16窗口中每一个又被分成4×4的小窗口，在每一个4×4的小窗口中分别计算其梯度幅值和方向 纹理纹理相关任务 纹理中估计形状：从图像的纹理估计表面方向或形状 利用纹理进行分割或分类：分析、表示纹理特征，将具有一致性的纹理分类 合成：生成新的纹理特征 定义及表示定义 纹理即重复出现的局部特征或模式 通常表示了材料属性 重要的外观线索，特别是形状相似时 表示既然纹理具有重复的模式，那么问题是： 如何找到这种模式： 使用和模式类似的滤波器（点状、条状、块状……） 考虑滤波器的响应幅值 局部窗口中观察其统计特性： 均值、标准差 直方图 比如我们使用高斯偏导核对一张图卷积，并统计每个窗口中两个方向上导数的均值。 根据统计的结果绘图如下，由此可进行简单的分类：$x,y$ 方向上都方向变化比较小，说明是平坦区域；$x$ 方向变化大而 $y$ 方向变化小，说明主要是竖直方向的特征（图中竖直的沟渠）；两方向都变化较大，说明是图中的绿草区域。 为了表示各类特征之间的相似性，可使用 $L2$ 距离。 当前我们假设已知了选取窗口的大小，但实际中我们是不知道该取多大的窗口才能分类。为此，我们可以尝试多个窗宽大小，选择区域内特征变化稳定（即不再变化）时对应的窗口大小。 滤波器组前面我们使用 x y 方向的偏导核对图像卷积，得到了局部特征，于是我们就想，如果我们找一堆的滤波器，形成一个滤波器组（Filter Banks)，这个滤波器组尽可能的包含更多的特征，如此一来卷积后得到的特征是否会更多更全呢？ 以下图为例，该滤波器组包含了尺度、方向以及不同类型的模式 Matlab code available for these examples 之前我们使用的高斯核都是一维或二维的，这里介绍一下多维高斯核，其形状如下图所示，$\\Sigma$ 是协方差矩阵，不同的 $\\Sigma$ 对应不同的高斯核。其中，45° 方向上的值不为 0 时表示 x y 方向上是相关的，即一方增大另一方亦增大。 据此可以结合多维高斯核，从不同尺度、方向出发，构建滤波器组 我们利用上述滤波器组对下图卷积：可以发现，随着卷积核的尺度越大，维度越高，所提取的特征也越发抽象。 同样，由滤波器组的均值响应向量可以确定纹理（下图的七维响应向量 A B C 是卷积核对图像卷积后再对卷积结果取平均，且越亮表示图像中主要是该类特征） 上述过程采用了均值响应，但也可以采用直接对每个点都使用 7 维的向量。 举例：假设原图为 $H\\times W$，滤器组有 $n$ 维，一种方式是每个点都让滤波器组卷积，即每个点都对应 $n$ 维，则卷积后的响应为 $H\\times W \\times n$ ；另一种是采用统计结果，如取均值，则每张图像对应一个响应结果。 上述观点十分重要，因为卷积神经网络的基本思想就是如此，所不同的是，上述的滤波器组是人为设置的，而卷积神经网络的滤波器组则是网络自己学习的，我们可以想象的是，神经网络学习了超强的滤波器组，从而完成相应的任务。 上述过程可用于分类任务，比如利用滤波器组卷积后得到响应结果，与数据库中的结果进行比对（L2距离)，根据相似性便可完成分类。 图像分割分割的目标 将相似的像素分为一组：是自底向上、无监督的过程，即不知道如何分，只根据像素的相似性分割 分割为“物体”，比如人和背景分开 诚然，终极目标是不断要分割出单个物体，还要从整体出发，理解某个个体组成的整体的内容。 比如下图，计算机可能只能分割出局部的特征，但对人类而言，还能观察到这些局部特征组成的整体特征。 更准确的说： 语义分割：只分割出目标 实例分割：不仅分割出目标，还需指出一类目标中谁是谁 K-Means 聚类分割 相似像素聚类：K-Means 聚类，比如基于灰度或者颜色，以彩色分割结果为例，图中相同颜色表示同类，这便是语义分割；但这种分割没法知道图中的两个辣椒是不一样的，而要指出这两个辣椒是不同的，就是实例分割。 为了达到实例分割的目的，还需要额外的约束，观察不难发现，两个辣椒的位置明显不同，于是我们在 RGB 的基础上增加 位置坐标 X Y，便可初步进行分割。但问题是，如下图红圈所示，都是背景，但由于位置不同导致分成了不同的类。 K-Means 聚类分割优缺点 简单、局部收敛 需要指定参数 K（即分为几类） 对初值、外点敏感 只适用于“球形”聚类 Mean Shift 聚类分割均值漂移算法的思想是在特征空间中寻找密度的局部最大值 主要过程是：随机选取一个 ROI，计算该 ROI 的重心，然后将该 ROI 向重心偏移，不断重复，最终找到密度的最大值 不论从哪个方向出发，最终都会导向密度最大的地方 具体思路如下： 给定特征，如颜色、梯度、纹理等 初始化特征点的窗口 进行均值漂移直至收敛 将具有相同峰值的（密度最大，三维角度看如下图）窗口合并为一类 优缺点分析 优点 无需假设是球形聚类（不同于 K-Means) 只需指定一个参数：窗宽 可找到不同的多个类别 对外点鲁棒 缺点 分割结果依赖于窗宽大小（太小容易局部收敛，导致过分割，太大则欠分割） 计算量大（基本上每个像素都要计算，因为要计算重心） 高维度下不适用 图割法图割思想 每个像素作为节点 每对像素之间的连线作为边，边由两个节点的相似度的权值决定（也即边决定两个像素是否相似） ​ 而分割的过程就是找到一种切割的方法切开图（断开边），要求断开的边的权重最小（也即最不相似的删掉） 既然图割依赖于相似性，那么该如何衡量相似性呢？ 假设每个像素可以用一个特征向量 $x$ 表示（可以是 rgb, x,y），再定义适合的距离函数（如 L2 距离）；然后可借助广义高斯核将两个特征向量之间的距离转为相似性度量： exp(-\\frac{1}{2\\sigma^2} \\text{dist}(x_i,x_j)^2)这样，相似性就由 $\\sigma$ 决定，其值越小，表明距离越近的点越相似（即距离我比较小的和我同类）；其值越大，表明即使距离很大，也有可能和我同类。下图中的右下三张图可看作是邻接矩阵的示意，邻接矩阵行和列的角点表示对应像素的相似性，不难发现，该矩阵是一个对称矩阵，因为像素 1-2 和像素 2-1 的相似度是一样的。 据此我们可知图割即： 去除一些边，使得图断开连接 图割的代价：去除边的权重之和 通过图割可以完成分割 如何得到一个“好”的图割结果？ 图割实现如之前所说，我们需要找到使得切掉边的所有的权重之和最小的情况，即最小割情形（这里涉及图论知识，菜鸡未深入接触） 但这种图割的方法存在的问题是：对于一些孤立的元素，容易形成很多独立的小区域，这是因为独立的点与其他的点连接边只有一个，自然权重最小 为了避免上述情况，也即我们希望 AB 中的元素更多一点，而不仅仅是单个元素，因而在实际中我们使用的是归一化的图割，其代价函数为： \\frac{\\text{w}(A,B)}{\\text{w}(A,V)} + \\frac{\\text{w}(A,B)}{\\text{w}(B,V)}其中，$\\text{w}(A,B)$ 是 $A$ 和 $B$ 之间所有边的权重之和，$\\text{w}(A,V)$ 同理。 可以这么理解上述公式：假设 A 只有一个元素，即上图的情况，此时上式中的 $\\text{w}(A,V)$ 就会很小（即 A 与其他边连接的很少），故 $\\frac{\\text{w}(A,B)}{\\text{w}(A,V)}$ 就会很大，这样整体的权重就大了，自然不会选择分割，就不会出现上图单元素分割的情况。 上式经过一系列推导（详见J. Shi and J. Malik. Normalized cuts and image segmentation. PAMI 2000），最终可得到下式： \\frac{y^T(D-W)y}{y^TDy}式中：$W$ 是图的邻接矩阵，$D(i,i)=\\Sigma_j(i,j)$，是一个对角矩阵，其元素是同一行元素的和。 至此，问题转为求解使得上式最小时的 $y$ 向量，该向量是元素不是 0 和 1，元素属于这个类就是 1，否则就是 0,（即归一化的图割只区分为两类）。 上式的求解采用的是拉格朗日法，转换为求解：$ (D − W)y = λDy$，该问题的解 $y$ 是次最小特征值对应的特征向量。 求解出 $y$ 后，可能会发现该向量并不是 0 或 1，而是带有小数，为此可设置阈值，归一化为 0 和 1（类似二值化）。 归一化的图割只能分为两类，如何实现多类分割呢？有两种方法： 在现有分割的基础上迭代 现有分割的基础上使用 K-Means 值得注意的是，前述中对图像进行描述时使用了 rgb,x,y 的形式，但对于纹理特征难以用其描述时，可采用纹理一节中提到的滤波器组。 优缺点分析 适用于众多不同的特征，比如选择不同的描述形式、不同的距离计算方式 计算耗时耗内存（所有像素参与） 倾向于均分为两类 图像增强 低照度图像增强算法-RetinexRetinex 理论模型 该算法的理论基础是光的三色理论和颜色恒常性 物体的颜色是由物体对长波（红）、中波（绿）、短波（蓝）的反射能力决定的，而不是由反射强度的绝对值决定的。此外，物体的颜色不受光照不均匀性的影响，具有一致性，也就是颜色恒常性。 不同于传统的线性、非线性图像增强方式只能增强某一类的特征，Retinex 可以在动态范围压缩、边缘增强、颜色恒常三个方面达到平横，可对各种不同类型的图像进行自适应增强。 Retinex 理论的基本假设是：原始图像 $S$ 是由光照图像 (照度图像) $L$、反射图像 $R$ 组成，前者是物体的入射分量的信息，表示为 $L(x,y)$，后者是物体的反射部分，表示为 $R(x,y)$，所以图像 $S$ 可表示为： S(x,y)=R(x,y)L(x,y)Retinex 增强的目的就是从原始图像 $S$ 中估计出 $L$，从而分解出 $R$，消除光照不均的影响，以改善图像的视觉效果。由于人眼感受亮度的过程与对数形式的变换相似，所以将上式转到对数域，这样做的一个好处是将复杂的乘法转为了加法： \\begin{align} logS & = log(RL) \\notag \\\\ & = logR+logL \\notag \\end{align}可见，如若估计得到 $L$，就可求得 $R$。 关键是如何得到 $L$ 呢？该值显然不能直接求得，那就只能近似。Retinex 的提出者认为，$L$ 可由原始图像和高斯核卷积得到，即： logR=logS-logS * G$G$ 即为高斯卷积核。 一般还需对 $R$ 量化映射到 $[0,255]$ 上，这里一般不会直接通过指数映射从 $logR$ 得到 $R$，一般取线性映射，方法是计算 $logR$ 的最大值 $Max$ 和 最小值 $Min$，然后对每一个 $Value$ 进行线性量化： R(x,y)=\\frac{Value-min}{Max-min}*255多尺度的原理类似，只是采用不同的尺度（由 $\\sigma$ 控制尺度空间），生成不同的高斯核与图像进行卷积，然后对这个尺度按权重计算，为了兼顾长中短三种波（即 RGB），通常取等权重（即 $\\omega_1=\\omega_2=\\omega_3=1/3$），注意权重和为 1。 直方图均衡化直方图均衡化是图像增强的一种方式，其结果是让过亮或过暗的图像灰度分布更加均匀，其主要是通过累积分布函数进行计算，提高图像的对比度。 颜色空间HSV圆锥模型空间 H：色相：具体是哪种颜色（角度表示） S：饱和度：颜色的深浅（0~1） V：亮度：颜色的明暗（0~1） YUVYUV是通过亮度-色差来描述颜色的颜色空间。 亮度信号经常被称作Y，色度信号是由两个互相独立的信号组成。视颜色系统和格式不同，两种色度信号经常被称作UV或PbPr或CbCr。这些都是由不同的编码格式所产生的，但是实际上，他们的概念基本相同。在DVD中，色度信号被存储成Cb和Cr（C代表颜色，b代表蓝色，r代表红色）。 空间滤波空间相关与卷积 相关：图像上移动核的中心，求每个位置的乘积之和 只满足分配律 卷积：把相关运算的核旋转180° 线性：F(f1+f2) = F(f1)+F(f2) 平移不变形：F(S(f)) = S(F(f)) 满足线性平移不变性的操作均可定义为卷积 满足交换律、结合律、分配律 卷积时边缘的处理：边界填充 卷积核的特性导致卷积后的图像和原图不一样大 零填充 复制边缘 镜像边缘 可分离核 可分离核：能够表示为两个向量外积的矩阵 $m \\times n$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v{m \\times 1}w{n \\times 1}^T$ $m \\times m$ 的核 $\\text{w}$ 可分离为：$\\text{w} = v{m \\times 1}v{m \\times 1}^T$ 优势：减少计算量，大核分离为小核计算 判断是否可分离：矩阵的秩为 1（矩阵论：一列向量与一行向量的乘积的矩阵，秩为 1） 空间滤波器的构建","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"}]},{"title":"点云+PCL学习笔记","slug":"图像处理/点云+PCL学习笔记","date":"2022-07-16T16:00:00.000Z","updated":"2023-05-26T02:44:30.915Z","comments":true,"path":"point_cloud_pcl/","link":"","permalink":"https://hbroad.github.io/point_cloud_pcl/","excerpt":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充）","text":"研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充） 点云 分布在 N 维空间中的离散点集 是对物体表面信息的离散采样 点云库 三维处理算法：滤波、特征估计、表面重建等 PointT 类型PointXYZ 包含 x y z 坐标的点数据类型 成员变量 float x, y, z points[i].x 访问 多余的一个变量用来填充位置以满足存储对齐（?） 12345678910union&#123; float data[4]; struct &#123; float x; float y; float z; &#125;;&#125;; Point XYZI 包含 x y z 坐标及 intensity PointXYZRGBA rgba 单独作为一个整型变量（unit32_t） PCD 文件 包含文件头：声明存储点云数据的特性，必须用 ASCII 编码 123456789101112131415# .PCD v.7 - Point Cloud Data file formatVERSION .7 # 指定PCD文件版本FIELDS x y z rgb # 指定每个点可以有的每一个维度或字段的名字SIZE 4 4 4 4 # 用字节数指定 FIELDS 中每一个维度的大小TYPE F F F F # 用一个字符指定 FILEDS 中每一个维度的类型COUNT 1 1 1 1 # 指定每一个维度包含的元素数目WIDTH 213 # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目） 列HEIGHT 1 # 用点的数量表示点云数据集的高度；同 WIDTH 行 VIEWPOINT 0 0 0 1 0 0 0 # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）POINTS 213 # 数据集中点的总数 DATA ascii # 存储点云数据的数据类型：ASCII 或 二进制0.93773 0.33763 0 4.2108e+060.90805 0.35641 0 4.2108e+060.81915 0.32 0 4.2108e+060.97192 0.278 0 4.2108e+06 DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开 DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法 K-d tree理论 按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。 在 k-d tree 中查找距离查询点 $\\overline x$ 最近点的，意味着遍历整个树，找到包含 $\\overline x$ 的子节点。 实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。 两种查询方式（详见博士论文 P40） PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型： ==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点） ==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点 r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。 上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \\vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\\vec{q}$ ，但以 $ \\vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\\vec{q}’$ 。 另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 正确尺度因子 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。 如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。 所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。 Octree(八叉树) 一个根节点包含八个子节点 若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归 除近邻搜索外，可用于碰撞检测 点云连接点连接 需确保类型和维度相等 12cloud_c = cloud_a;cloud_c += cloud_b; 字段连接 需确保数目相等 1pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c); 点云滤波原因 噪声点：设备精度、操作者经验、环境因素等 离群点：外界干扰如障碍物等，产生离主体点云较远的离散点 双边滤波 通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果 有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征 直通滤波器 去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点） 123456pcl::PassThrough&lt;pcl::PointXYZ&gt; pass; // 创建直通滤波器对象pass.setInputCloud(cloud); // 输入pass.setFilterFieldName(&quot;z&quot;); // 设置滤波字段，此处为 z 轴pass.setFilterLimits(0.0, 200.0); // 设置滤波范围，超出则滤除pass.setFilterLimitsNegative (true); // 默认为 false，设为 ture 则返回被滤除点pass.filter(*cloud_filtered); // 执行滤波，并将滤波结果存储在 cloud_filtered VoxelGrid（体素化网格）滤波器 实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变 VoxelGrid 三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体== 通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示== 对所有体素处理后得到过滤后的点云 缺点：慢，比体素中心逼近法更慢 1234pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor; // 创建体素栅格滤波对象sor.setInputCloud(cloud); // 读入点云设置为输入sor.setLeafSize(0.01f, 0.01f, 0.01f); // 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米sor.filter(*cloud_filtered); // 执行滤波并存储到 cloud_filtered 滤波结果 &lt;img src=&quot;F:\\AFIGHT\\笔记\\PCL\\assets\\滤波前.png&quot; alt=&quot;滤波前&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;img src=&quot;F:\\AFIGHT\\笔记\\PCL\\assets\\滤波后.png&quot; alt=&quot;滤波后&quot; style=&quot;zoom:50%;&quot; /&gt; &lt;/center&gt; 统计滤波 （详见博士论文 P40） 用于去除离群点 基于对近邻点集 $P^k$ 的统计分析 计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\\overline d$ 计算点云 $P$ 在平均距离上的分布，并估计平均值 $\\mu_k$ 及标准差 $\\sigma_k$ 对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离 去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。 假设第一次扫描 $Pi$ 和随后的 $P{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \\in Pi$，搜索其对应的近邻点 $p \\in P{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。 1234567pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor; // 创建统计滤波对象sor.setInputCloud(cloud); // 设置输入点云sor.setMeanK(50); // 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）sor.setStddevMulThresh(1.0); // 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点sor.filter(*cloud_filtered); // 执行并存储滤波结果sor.setNegative(true); // 获取离群点（此值默认为 false） 滤波结果 参数化模型投影点云 点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0 PCL 中有特意存储常见模型系数的数据结构 12345678910111213// Create a set of planar coefficients with X=Y=0,Z=1 pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients()); // 创建 模型系数 对象coefficients-&gt;values.resize(4); // 参数个数置为 4coefficients-&gt;values[0] = coefficients-&gt;values[1] = 0; // 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Ycoefficients-&gt;values[2] = 1.0;coefficients-&gt;values[3] = 0;// Create the filtering objectpcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj; // 设置投影滤波对象 proj.setModelType(pcl::SACMODEL_PLANE); // 设置对象对应的投影模型类型，此处为平面模型proj.setInputCloud(cloud); // 设置输入proj.setModelCoefficients(coefficients); // 设置模型系数为前述定义系数proj.filter(*cloud_projected); // 执行并保存 从一个点云中提取一个子集 基于 ExtractIndices 滤波器（基于分割算法） 12345pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; // 创建分割对象extract.setInputCloud(cloud_filtered); // 设置输入点云 extract.setIndices(inliers); // 设置分割后的内点为需要提取的点击（分割部分略）extract.setNegative(false); // 指定提取内点extract.filter(*cloud_p); // 执行并存储 RadiusOutlierRemoval / ConditionalRemoval 移除离群点RadiusOutlierRemoval 删除输入点云一定范围内没有达到足够多近邻的所有数据点 人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。 12345678pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem; // 创建半径滤波对象// build the filteroutrem.setInputCloud(cloud); // 设置输入点云outrem.setRadiusSearch(0.8); // 设置搜索半径为 0.8outrem.setMinNeighborsInRadius(2); // 设置所需近邻点数为 2outrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)// apply filteroutrem.filter(*cloud_filtered); // 执行滤波并保存 ConditionalRemoval 如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个 123456789101112pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::Ptr range_cond(new pcl::ConditionAnd&lt;pcl::PointXYZ&gt;()); // 创建条件定义对象range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(&quot;z&quot;, pcl::ComparisonOps::GT, 0.0))); // 添加比较算子：z 字段上大于 0.0 range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(new pcl::FieldComparison&lt;pcl::PointXYZ&gt;(&quot;z&quot;, pcl::ComparisonOps::LT, 0.8))); // 添加比较算子：z 字段上小于 0.8 // build the filterpcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem; // 初始化条件滤波condrem.setCondition(range_cond); // 设置条件为指定的比较算子condrem.setInputCloud(cloud); // 设置输入点云condrem.setKeepOrganized(true); // 设置将被滤除点保留但置为 NaN// apply filtercondrem.filter(*cloud_filtered); // 执行滤波并保存 CropHull 任意多边形内部点云提取 CropHull 滤波器得到 2D 封闭多边形内 / 外的点云 深度图像（Range/Depth Images） 将图像采集器到场景中各点的距离（深度）值作为像素值的图像（距离是相机到场景点的垂直距离，不是连线距离） 直接反映景物可见表面的几何状态 物体的三维表示形式，可通过立体相机或 TOF 相机获取 深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据 英文中常见的等价表述：range image，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles 注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息 从点云创建深度图像 主要函数为 createFromPointCloud，声明 9 个参数填充即可 12345678910111213141516171819202122232425void pcl::RangeImage::createFromPointCloud ( const PointCloudType &amp; point_cloud,float angular_resolution = pcl::deg2rad (0.5f),float max_angle_width = pcl::deg2rad (360.0f),float max_angle_height = pcl::deg2rad (180.0f),const Eigen::Affine3f &amp; sensor_pose = Eigen::Affine3f::Identity (),RangeImage::CoordinateFrame coordinate_frame = CAMERA_FRAME,float noise_level = 0.0f,float min_range = 0.0f,int border_size = 0 ) //Create the depth image from a point cloud./*Parameter EX:point_cloud the input point cloudangular_resolution the angular difference (in radians) between the individual pixels in the imagemax_angle_width an angle (in radians) defining the horizontal bounds of the sensormax_angle_height an angle (in radians) defining the vertical bounds of the sensorsensor_pose an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )coordinate_frame the coordinate frame (defaults to CAMERA_FRAME)noise_level - The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.min_range the minimum visible range (defaults to 0)border_size the border size (defaults to 0)*/ 从深度图像提取边界 边界：前景跨越到背景的位置 物体边界（黑）、阴影边界（绿）、Veil 点集（红） 若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘 关键点 兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集 数量比原始点云或图像的数据量小很多 组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性 利于加快后续的处理速度 关键概念及算法NARF 关键点*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608. 从深度图像识别物体 步骤 遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测； 遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向； 根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定； 对兴趣值进行平滑过滤； 进行无最大值压缩找到最终的关键点，即为 NARF 关键点。 简化步骤* 给定深度图像，进行边缘提取 表面变化基于边界和曲率原则”评分“ 设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多 Harris关键点 通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点 若 Harris 矩阵特征的两个特征值都很大，则为关键点 对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测 3D Harris 关键点检测使用的是点云表面法向量的信息（2D 使用的是图像梯度） PCL 中的 keypoints深度图像提取 NARF 关键点12345678pcl::RangeImageBorderExtractor range_image_border_extractor; // 创建对象，用于边缘提取pcl::NarfKeypoint narf_keypoint_detector(&amp;range_image_border_extractor); // 创建对象，传入上述提取出的深度图像边缘narf_keypoint_detector.setRangeImage(&amp;range_image); // 传入深度图像narf_keypoint_detector.getParameters().support_size = support_size; // 设置支持范围(搜索空间球体的半径，邻域范围)//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;pcl::PointCloud&lt;int&gt; keypoint_indices; // 创建点云对象，存储检测到的点云narf_keypoint_detector.compute(keypoint_indices); // 计算 SIFT 关键点提取参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客 参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客 参考：SIFT（3）——-尺度空间极值检测_姗姗本人的博客-CSDN博客 注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。 ​ ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向 ​ ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 尺度不变性 局部特征描述子 12345678pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift; // 创建sift关键点检测对象pcl::PointCloud&lt;pcl::PointWithScale&gt; result; // 存储查询结果sift.setInputCloud(cloud_xyz); // 设置输入点云pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());sift.setSearchMethod(tree); // 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快sift.setScales(min_scale, n_octaves, n_scales_per_octave); // 设置限制关键点检测的阈值sift.compute(result); // 执行sift关键点检测，保存结果在result 123456789101112131415// setScales 函数原型void pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::setScales ( float min_scale,int nr_octaves,int nr_scales_per_octave ) 用于指定搜索关键点的尺度范围 // Specify the range of scales over which to search for keypoints.// Parameters 设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）// min_scale the standard deviation of the smallest scale in the scale space 高斯金字塔中组（octaves）的数目// nr_octaves the number of otaves (i.e. doublings of scale) to compute 每组计算的尺度数目// nr_scales_per_octave the number of scales to compute within each octave Harris 关键点提取123456789//harris_detector-&gt;setNonMaxSupression(true);harris_detector-&gt;setRadius(r_normal); // 设置法向量估计的半径harris_detector-&gt;setRadiusSearch(r_keypoint); // 设置关键点估计的近邻搜索半径harris_detector-&gt;setInputCloud (input_cloud);//harris_detector-&gt;setNormals(normal_source);//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);harris_detector-&gt;compute (*Harris_keypoints);cout&lt;&lt;&quot;Harris_keypoints的大小是&quot;&lt;&lt;Harris_keypoints-&gt;size()&lt;&lt;endl;writer.write&lt;pcl::PointXYZI&gt; (&quot;Harris_keypoints.pcd&quot;,*Harris_keypoints,false); 特征描述与提取特征描述 局部特征描述 + 全局特征描述 特征描述子三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有形状描述子（shape descriptors）、几何特征（gometric features）、点特征表示（point feature representations）等。 理论（详见博士论文 P23，37） 给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为： ||p_i^k-p_q||_x \\leq d_m \\tag{1.1}式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见范数）。 此外，$P^k$ 中近邻点的个数可被限制为给定值 k。 点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围： F(p_q,P^k)=\\{x_1,x_2,···,x_n\\}式中，$x_i$ , $i \\in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。 比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\\Gamma$ 为描述这两点之间差异的相似性度量，$d$ 为距离度量，则有： \\Gamma = d(F_1,F_2)当 $d$ 趋向于某个最小值时，即 $d \\to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。 个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。 通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。 理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣： 刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有旋转平移不变性 不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有抗密度干扰性 噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有鲁棒性 也就是说，一个点特征表示满足上述条件才可以说是好的表示法 邻域的概念确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方： ||X||_2 = \\sqrt{\\sum_{i=1}^n x_i^2}可用于度量两个向量间的差异，如平方差和： SSD(x_1,x_2) = \\sum_{i=1}^n(x_{1i}-x_{2i})^2也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。 但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。 特征提取输入点云的调用 输入点云调用函数主要有： setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量 setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算 setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间 后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208） 经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。 估计点云的表面法线（详见博士论文 P45） 描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线 一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②直接从点云数据集中近似推断表面法线 对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数 12345// PCL 中估计一点集对应的协方差矩阵Eigen::Matrix3f covariance_matrix; // 定义每个表面小块的 3×3 协方差矩阵的存储对象Eigen::Vector4f xyz_controid; // 定义一个表面小块的质心坐标16字节对其存储对象compute3DCentroid(cloud, xyz_controid); // 估计质心坐标computeCovarianceMatrix(cloud, xyz_controid, covariance_matrix); // 计算 3×3 协方差矩阵 一个平面可用一个点 $x$ 和 一个法向量 $\\overline n$ 表示，则一个点 $p_i \\in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \\overline n$ 。 $x$ 和 $\\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \\in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？） 设 x = \\overline p = \\frac{1}{k}· \\sum_{i=1}^{k}p_i为 $P^k$ 的质心，而 $\\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \\in R^{3 \\times 3}$ 的特征值和特征向量得到，其表达式如下： C = \\frac{1}{k} \\sum_{i=1}^{k} \\xi_i · (p_i - \\overline p)·(p_i - \\overline p)^T , \\ C· \\overline v_i = \\lambda_i· \\overline v_j , \\ j \\in \\{0,1,2\\}式中，$\\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\\lambda_j \\in R$ ，特征向量 $\\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \\le \\lambda_0 \\le \\lambda_1 \\le \\lambda_2$ ，则特征向量 $\\overline v_0$ 对应的最小特征值 $\\lambda_0$ 就是 $+ \\overline n = {n_x,n_y,n_z}$ 或 $ - \\overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\\overline n$ 可由球坐标中的一对角 $(\\phi,\\theta)$ 表示如下： \\phi = \\arctan \\frac{n_z}{n_y}, \\ \\theta = \\arctan\\frac{\\sqrt{(n_y^2+n_z^2)}}{n_x}问题是，这种主成分分析法（PCA）对方向仍然是模糊的。 表面曲率（详见博士论文P48） 方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\\lambda_0 = min(\\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\\overline n$ 的变化可使用下式估计： \\sigma_p = \\frac{\\lambda_0}{\\lambda_0+\\lambda_1+\\lambda_3} 该最小特征值与特征值之和的比值 $\\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。 source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998 法线的定向问题 没有数学方法可以解决法线的正负向问题 法线球体描述了点云中所有法线的方向 对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向 1234567// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）flipNormalTowardsViewpoint ( const PointCloud &amp; cloud,float vp_x,float vp_y,float vp_z,Normals &amp; normals ) 但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \\cdot n_j = 1$。 点特征直方图（PFH）（详见博士论文P51和PCL书P213） bin 可理解为分格的大小，就是直方图每一个柱子的宽度 理论通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。 一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。 为形成新的特征空间，引入 双环邻域 的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \\in P$ 有双环邻域的条件是： (\\exists)r_1,r_2 \\in R, \\ r_1","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"}]},{"title":"毕设：链片条复合模CAD系统使用须知","slug":"毕设/链片条复合模CAD系统使用须知","date":"2020-05-25T16:00:00.000Z","updated":"2023-05-26T02:42:47.098Z","comments":true,"path":"Graduate_2/","link":"","permalink":"https://hbroad.github.io/Graduate_2/","excerpt":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！","text":"由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！ 已知错误1：数据库引擎本系统采用 ACCESS 作为数据库，经测试（虚拟机测试），win7 等系统上会出现 “未在本地计算机上注册‘Microsoft. ACE. OLEDB. 12. 0’提供程序”类似的提示。 解决1：安装数据库引擎即可，点击下方“下载”，下载完成后安装，提示安装成功后尝试再次运行本系统。 下载","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"毕设：链片条复合模CAD系统","slug":"毕设/链片条复合模CAD系统使用说明","date":"2020-05-24T16:00:00.000Z","updated":"2023-05-26T02:41:51.650Z","comments":true,"path":"Graduate_/","link":"","permalink":"https://hbroad.github.io/Graduate_/","excerpt":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖","text":"毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制指导老师：谌霖霖 开发平台系统环境：Windows 10 2004 专业版开发环境：VB.NET数据库：ACCESSS 365软件平台：VS 2010 系统简介该复合模 CAD 系统主要包含以下功能： 用户登录 参数输入 设计计算 主界面 设计结果 标准件库 建模装配 关于系统 用户登录首先，用户在打开系统后，会出现登录界面，该界面四个按钮的功能如下：1.登录：如若账号密码均正确，通过此按钮即可进入下一界面；2.取消：如用户输入时出错，想直接清空输入框，可使用此按钮；3.注册：新用户可通过注册后再登录；4.退出：退出系统。 参数输入用户登录后将进入该界面，在该界面由用户输入需要的尺寸值，也可使用默认值，点击开始设计，并选择模具的最小闭合高度，在确定之后即可开始设计计算。 主界面系统主界面下可进行设计结果的查询、标准件的尺寸查询、三维建模与装配（调用同组同学 GRIP 程序）、查看仿真动画、系统信息及帮助文档 此外，在查询结果菜单下，用户可通过点击零件图纸查看零件的三维模型。 剩余界面较为简单，这里不再赘述！ （密码：姓名拼音的首字母大写） 系统演示视频","categories":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"}],"tags":[{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"}]},{"title":"全国性哀悼活动","slug":"悼念日","date":"2020-04-04T10:49:31.000Z","updated":"2023-04-17T12:01:52.090Z","comments":true,"path":"ChinaIsTheBest/","link":"","permalink":"https://hbroad.github.io/ChinaIsTheBest/","excerpt":"","text":"据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。","categories":[],"tags":[{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"}]},{"title":"开天辟地","slug":"hello-world","date":"2020-04-02T09:03:42.485Z","updated":"2023-04-28T07:59:46.489Z","comments":true,"path":"hexo_new/","link":"","permalink":"https://hbroad.github.io/hexo_new/","excerpt":"","text":"这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/tags/Hexo/"}]}],"categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://hbroad.github.io/categories/SQL-Server/"},{"name":"C#","slug":"C","permalink":"https://hbroad.github.io/categories/C/"},{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/categories/Python/"},{"name":"Robot","slug":"Robot","permalink":"https://hbroad.github.io/categories/Robot/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/categories/C/"},{"name":"刷题","slug":"刷题","permalink":"https://hbroad.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"笔记","slug":"笔记","permalink":"https://hbroad.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/categories/%E6%AF%95%E8%AE%BE/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/categories/Hexo/"}],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://hbroad.github.io/tags/SQL-Server/"},{"name":"C#","slug":"C","permalink":"https://hbroad.github.io/tags/C/"},{"name":"Halcon","slug":"Halcon","permalink":"https://hbroad.github.io/tags/Halcon/"},{"name":"人工智能","slug":"人工智能","permalink":"https://hbroad.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"资讯","slug":"资讯","permalink":"https://hbroad.github.io/tags/%E8%B5%84%E8%AE%AF/"},{"name":"Python","slug":"Python","permalink":"https://hbroad.github.io/tags/Python/"},{"name":"UR5","slug":"UR5","permalink":"https://hbroad.github.io/tags/UR5/"},{"name":"HEC","slug":"HEC","permalink":"https://hbroad.github.io/tags/HEC/"},{"name":"Interview","slug":"Interview","permalink":"https://hbroad.github.io/tags/Interview/"},{"name":"C++","slug":"C","permalink":"https://hbroad.github.io/tags/C/"},{"name":"Simulation","slug":"Simulation","permalink":"https://hbroad.github.io/tags/Simulation/"},{"name":"Coppeliasim/Vrep","slug":"Coppeliasim-Vrep","permalink":"https://hbroad.github.io/tags/Coppeliasim-Vrep/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://hbroad.github.io/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hbroad.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DIP","slug":"DIP","permalink":"https://hbroad.github.io/tags/DIP/"},{"name":"PCL","slug":"PCL","permalink":"https://hbroad.github.io/tags/PCL/"},{"name":"Point Cloud","slug":"Point-Cloud","permalink":"https://hbroad.github.io/tags/Point-Cloud/"},{"name":"点云","slug":"点云","permalink":"https://hbroad.github.io/tags/%E7%82%B9%E4%BA%91/"},{"name":"毕设","slug":"毕设","permalink":"https://hbroad.github.io/tags/%E6%AF%95%E8%AE%BE/"},{"name":"Commemorate","slug":"Commemorate","permalink":"https://hbroad.github.io/tags/Commemorate/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hbroad.github.io/tags/Hexo/"}]}