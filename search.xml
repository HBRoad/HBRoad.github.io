<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣每日一题</title>
      <link href="/2022/08/14/Leetcode_once_day/"/>
      <url>/2022/08/14/Leetcode_once_day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>刷的太少，思路只局限在暴力</p><a id="more"></a><p><a href="https://flamsteed.github.io/tags/#HUAWEI" target="_blank" rel="noopener">https://flamsteed.github.io/tags/#HUAWEI</a></p><p>第一阶段:</p><p>练习字符串、数组、<a href="https://www.nowcoder.com/jump/super-jump/word?word=链表" target="_blank" rel="noopener">链表</a>的基本操作，熟悉语言和编码手感</p><p>参考题目：</p><p>字符串，简单 1154，125，344，20，392，409，859，14，1694，551</p><p>数组，简单 1，169，53，1502，88，594，643，463，</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=链表" target="_blank" rel="noopener">链表</a>，简单 234，21，141，83</p><p>第二阶段:</p><p>练习较为复杂的字符串，数组的处理</p><p>字符串，中等 468，692，151，686，1764</p><p>数组，中等56，229，347</p><p>第三阶段:</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>练习</p><p>字符串，中等，回溯93</p><p>数组，中等，回溯 39，90，46，78</p><p>数组，中等，深度优先，广度优先，417，994，385</p><p>数组，中等，滑动窗口，713</p><p>字符串，中等，滑动窗口424</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=动态规划" target="_blank" rel="noopener">动态规划</a>，简单70</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=动态规划" target="_blank" rel="noopener">动态规划</a>，中等64</p><p>数组，中等，双指针 16</p><p>字符串，中等，双指针15，</p><p>数组，中等，栈150</p><h4 id="1422-分割字符串的最大得分"><a href="#1422-分割字符串的最大得分" class="headerlink" title="1422. 分割字符串的最大得分"></a><a href="https://leetcode.cn/problems/maximum-score-after-splitting-a-string/" target="_blank" rel="noopener">1422. 分割字符串的最大得分</a></h4><ul><li><p>思路：（暴力）对输入的字串分割成左右两个非空字串，再遍历左字串中字符 0 个数，由字串中字符 1 的个数；依次循环分割输入的字串，将对应的个数存入左右两个容器，遍历完所有的可能后，求和，再求最大值</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> strl, strr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r;</span><br><span class="line">        <span class="keyword">int</span> l_tmp = <span class="number">0</span>, r_tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            strl = s.substr(<span class="number">0</span>, i);</span><br><span class="line">            strr = s.substr(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strl.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strl[j] == <span class="string">'0'</span>)</span><br><span class="line">                    l_tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            l.push_back(l_tmp);</span><br><span class="line">            l_tmp = <span class="number">0</span>;<span class="comment">//注意累加器置0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; strr.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strr[k] == <span class="string">'1'</span>)</span><br><span class="line">                     r_tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            r.push_back(r_tmp);</span><br><span class="line">            r_tmp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxsum;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; l.<span class="built_in">size</span>(); n++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> a = l[n] + r[n];</span><br><span class="line">           maxsum.push_back(a);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(maxsum.<span class="built_in">begin</span>(), maxsum.<span class="built_in">end</span>());<span class="comment">//取最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"1111"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.maxScore(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣Top100</title>
      <link href="/2022/08/14/leetcode_top_100/"/>
      <url>/2022/08/14/leetcode_top_100/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Leetcode Top 100</p><a id="more"></a><p><a href="https://blog.csdn.net/m0_46663240/article/details/125679183?spm=1001.2014.3001.5502" target="_blank" rel="noopener">参考1</a></p><p><a href="https://blog.csdn.net/weixin_38815609/article/details/125658519?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165949738016782390555769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165949738016782390555769&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-125658519-null-null.142^v39^pc_rank_34_ecpm25&utm_term=%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83%E9%A2%98&spm=1018.2226.3001.4187" target="_blank" rel="noopener">参考2</a></p><h2 id="HJ1"><a href="#HJ1" class="headerlink" title="HJ1"></a>HJ1</h2><ul><li><p>题目：查找输入字符串最后一个单词的长度</p></li><li><p>思路：字符串由空格分隔，找到最后一个空格，用整体的长度减去空格及空格前的长度，剩余的即为所求</p></li><li><p>代码：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="comment">// size_t len = str.size();//总长度</span></span><br><span class="line"><span class="comment">// size_t found = str.rfind(" ");//最后空格的位置</span></span><br><span class="line">     <span class="comment">// size_t found = str.find_last_of(" ");</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.<span class="built_in">size</span>() -  str.rfind(<span class="string">" "</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分析：关键有二：</p><ul><li><p>字符串的获取</p><ul><li><p>cin：遇空格或制表符即停，显然无法满足</p></li><li><p>getline：可连续读取输入并存入字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>最后空格的定位</p><ul><li><p>find_last_of()：给定待查找的字符，从后开始查找并返回其位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_of</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//可以指定从何处开始查找，即指定第二个参数</span></span><br><span class="line"><span class="comment">//注意字符串从0开始编号</span></span><br></pre></td></tr></table></figure></li><li><p>find 家族辨析：<a href="https://cplusplus.com/reference/string/string/find/" target="_blank" rel="noopener">参考</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索指定位置开始的第一个完全匹配的字符（串），即与指定字串完全匹配时才返回，且是第一个</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span></span>;<span class="comment">//从前往后找</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">rfind</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span></span>;<span class="comment">//从后往前找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索指定位置开始的第一个匹配的字符（串），只需有一个字符满足即可</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span></span>;<span class="comment">//从前往后找</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span></span>;<span class="comment">//从后往前找</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//查找与指定字串不匹配的字符（串）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_not_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_not_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span> </span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="HJ2"><a href="#HJ2" class="headerlink" title="HJ2"></a>HJ2</h2><ul><li><p>题目：计算某字符出现的次数</p></li><li><p>思路：读入到两个变量中，遍历字串，是否和目标字符相等，若相等则 count 增1，再判断大小写的问题，大写和小写分别判断</p></li><li><p>代码：（低质量代码）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str,str2;</span><br><span class="line">    <span class="comment">//读入两行内容</span></span><br><span class="line">    getline(<span class="built_in">cin</span>, str);</span><br><span class="line">    getline(<span class="built_in">cin</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如相等则计数器k自增1</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str2[<span class="number">0</span>])</span><br><span class="line">        &#123;       </span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">//考虑大小写一致</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;          </span><br><span class="line">                <span class="keyword">if</span>(str2[<span class="number">0</span>] &lt;= <span class="string">'Z'</span> &amp;&amp; str2[<span class="number">0</span>] &gt;= <span class="string">'A'</span>)<span class="comment">//如目标字符是大写，则再判断其对应的小写是否有相等的</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(str[i]+<span class="number">0</span> == str2[<span class="number">0</span>] + <span class="number">32</span>)</span><br><span class="line">                       k++;</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str2[<span class="number">0</span>] &lt;= <span class="string">'z'</span> &amp;&amp; str2[<span class="number">0</span>] &gt;= <span class="string">'a'</span>)<span class="comment">//如目标字符是小写，则再判断其对应的大写是否有相等的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i]+<span class="number">0</span> == str2[<span class="number">0</span>] - <span class="number">32</span>)</span><br><span class="line">                       k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<ul><li>新手，想法简单粗暴</li></ul></li></ul></li></ul><h2 id="HJ3"><a href="#HJ3" class="headerlink" title="HJ3"></a>HJ3</h2><ul><li><p>题目：输入随机数个数及随机数，去重排序后按行输出</p></li><li><p>思路一：（排名第一的思路，非本人想法）先确定随机数的个数（直接cin），定义一个数组，然后每次将读入的数作为数组的下标，值填充为1，然后输出数组值不为0的下标</p><ul><li>核心：只要有重复值，对应到数组的下标还是同一个，达到既降重又排序的目的；转换思路，输入的值是下标而非数组的值</li><li>缺点：一是必须指定数组的大小是题目给定的范围，而不能动态的设置为输入随机数的个数；二是数组必须初始化，否则其中的垃圾数据会造成输入错误</li></ul></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">            a[n] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i])</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按上述思路重写了一下，比较容易理解和看懂</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;<span class="comment">//读入数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//指定大小并初始化（不管数组多小，都开辟了这么多空间）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        a[n] = <span class="number">1</span>;<span class="comment">//以读入的数作为下标，有多少重复都无所谓（填充值非零均可）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出数组值非零的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：调用 STL，去重排序一步到位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;//包含集合set</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//自动实现去重和排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析：</p><ul><li>STL 中的 set（集合）自动将插入元素放入合适的位置（排序），同时对重复元素忽略，可以<code>插入删除但不能更改</code></li></ul></li></ul><h2 id="HJ4"><a href="#HJ4" class="headerlink" title="HJ4"></a>HJ4</h2><ul><li><p>题目：字符串的分割，以8为长度分割输入的字符串</p></li><li><p>思路：考虑 ==8 、&lt;8 、&gt;8 三种情况，利用容器，把分割后的字串存入其中，最后遍历容器输出，主要利用 substr 进行字串的分割</p><ul><li>复盘：既然以 8 为单位分割，那只要不为 8 的倍数就要补 0，用余数判断一下需要补 0 的个数，利用 append 插入，再分割输出（<del>另外本题没有给出输出的格式，我以为是空格，结果提交发现是换行</del>）</li></ul></li><li><p>代码：初次写的代码，重复代码太多了，自愧不如，简单问题复杂化了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">    <span class="built_in">string</span> str_tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str_tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = str_tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按8分割</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  str_tmp.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            str.push_back(str_tmp.substr(i, <span class="number">8</span>));</span><br><span class="line">            i += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>-n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            str_tmp.push_back(<span class="string">'0'</span>);<span class="comment">//小于8时判断补 0 的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">          str.push_back(str_tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>(n &gt; <span class="number">8</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = n / <span class="number">8</span>;<span class="comment">//有几段以 8 为长度的</span></span><br><span class="line">        <span class="comment">//需要补几个0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span> - n % <span class="number">8</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            str_tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按8分割</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            str.push_back(str_tmp.substr(i, <span class="number">8</span>));</span><br><span class="line">            i += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)<span class="comment">//注意这里是补 0 后新的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复盘后改进的代码：简便多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">8</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str.append(<span class="number">8</span> - n % <span class="number">8</span>, <span class="string">'0'</span>);    <span class="comment">//不足8位的补0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按8分割</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>();)<span class="comment">//注意这里的 size 是补 0 后新的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;  str.substr(i, <span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        i += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分析：</p><ul><li><p>substr 的用法</p><ul><li><p>单参数：从该位置开始取到末尾</p></li><li><p>双参数：从该位置开始取到指定的长度</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"time"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"单参数："</span> &lt;&lt; s.substr(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//返回 me（从位置 2 截取到尾）</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"双参数："</span> &lt;&lt; s.substr(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//返回 ime（从位置1开始，截取长度3）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>append 的用法</p><ul><li>向 string 后面追加字符或字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.append(<span class="number">4</span>, <span class="string">'0'</span>); <span class="comment">//在 str 后追加 4 个字符 0</span></span><br><span class="line">str.append(c);<span class="comment">//追加 char 类型字串 c</span></span><br><span class="line">str.append(str_tmp); <span class="comment">//追加 string 字串</span></span><br><span class="line">str.append(str_tmp, <span class="number">5</span>, <span class="number">3</span>);<span class="comment">//追加从位置 5 开始的长度为 3 的字串（包括位置 5）</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="HJ5"><a href="#HJ5" class="headerlink" title="HJ5"></a>HJ5</h2><ul><li><p>题目：输入十六进制字串，将其转为十进制数输出（华为肯定不会考这种题）</p></li><li><p>思路：（笨人笨方法啊）先把输入的前缀0x截掉，剩下的部分依次遍历，如是字符0-9，则转为数字0-9；如是字母A-F，则转为10~15</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="comment">//截掉前缀</span></span><br><span class="line"><span class="built_in">string</span> str_tmp;</span><br><span class="line">str_tmp = str.substr(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//进制转换</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = (str_tmp.<span class="built_in">size</span>() - <span class="number">1</span>);<span class="comment">//控制幂次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历每一位</span></span><br><span class="line"><span class="keyword">if</span> (str_tmp[i] &gt;= <span class="string">'0'</span> &amp;&amp; str_tmp[i] &lt;= <span class="string">'9'</span>)<span class="comment">//判断是否是数字</span></span><br><span class="line">&#123;</span><br><span class="line">n += <span class="keyword">int</span>(str_tmp[i] - <span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">16</span>, j);<span class="comment">//转为0~9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str_tmp[i] &gt;= <span class="string">'A'</span> &amp;&amp; str_tmp[i] &lt;= <span class="string">'F'</span>)<span class="comment">//判断是否是字母</span></span><br><span class="line">&#123;</span><br><span class="line">n += (str_tmp[i] - <span class="number">55</span>)*<span class="built_in">pow</span>(<span class="number">16</span>, j);<span class="comment">//A是65，减55是转为10~15</span></span><br><span class="line">&#125;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以直接调库的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stoi(str,<span class="number">0</span>,<span class="number">16</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 将str从位置 0 开始到末尾的 16 进制转为 十进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ6"><a href="#HJ6" class="headerlink" title="HJ6"></a>HJ6</h2><ul><li><p>题目：质数因子，给定一个整数，输出该数的所有质数因子，包括重复值</p></li><li><p>思路：质数从 2 开始，让给定值从 2 开始遍历，能整除则继续，否则 +1 后再判断是否能整除，这样提交后内存超限</p><ul><li>看了题解，一个数至少有一个质数因子不会超过其平方根，这样就可以从 2 遍历到其平方根，再判断是否是因子。需要注意该值本身就是质数的情况</li></ul></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n) &amp;&amp; i &lt;= n; i++)&#123;  <span class="comment">//从小到大的质因子，质因子不会超过它的平方根</span></span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123; <span class="comment">//所有的质数前面全部除掉，后续就不会有合因子</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            n /= i; <span class="comment">//除掉质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n - <span class="number">1</span>) <span class="comment">//前面已经除掉了所有因子，故在此判断该值是否是 1 ，不是就说明自己本身就是质数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ7"><a href="#HJ7" class="headerlink" title="HJ7"></a>HJ7</h2><ul><li><p>输入浮点数，四舍五入</p></li><li><p>思路：都说了入门题了</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cmath&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">   <span class="comment">// cout &lt;&lt; round(a);</span></span><br><span class="line">    <span class="keyword">if</span>(a - <span class="keyword">int</span>(a) &gt;= <span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(a) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ8"><a href="#HJ8" class="headerlink" title="HJ8"></a>HJ8</h2><ul><li><p>题目：合并表记录：给定索引及对应的值，将相同索引的值求和，并按索引升序排序输出</p></li><li><p>思路一：（题目本意是考察哈希表，这里直接暴力解决）首先读入键值对数，再将键值对存入个vector，接着遍历并判断索引号是否相等，如若相等则加到第一个上，同时将另一个清除；新建一个vector，将不为空的复制进去，调用 sort 排序再输出</p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v_F;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b &gt;&gt; c;</span><br><span class="line">       </span><br><span class="line">        v_tmp.push_back(b);</span><br><span class="line">        v_tmp.push_back(c);</span><br><span class="line">        v.push_back(v_tmp);</span><br><span class="line">        v_tmp.<span class="built_in">clear</span>();<span class="comment">//注意清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][<span class="number">0</span>] == v[j][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                v[i][<span class="number">1</span>] += v[j][<span class="number">1</span>]; </span><br><span class="line"><span class="comment">//                 v[j].clear();</span></span><br><span class="line">                v[j].erase(v[j].<span class="built_in">begin</span>(), v[j].<span class="built_in">end</span>());<span class="comment">//清除元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(v[i].empty() == <span class="literal">false</span>)</span><br><span class="line">            v_F.push_back(v[i]);<span class="comment">//非空存入新的容器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(v_F.<span class="built_in">begin</span>(), v_F.<span class="built_in">end</span>());<span class="comment">//排好序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_F.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; v_F[i][<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v_F[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：调用 STL 的 map，其自动建立 key - value 的对应，且其中的数据是有序的，map 是一个模板类，需要 key value 两个参数，关键字 key 只能在 map 中存在一次，其增删改和容器类似，通过 pair 插入，迭代器访问，<code>注意迭代器返回值是变化的</code></p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;    <span class="comment">//输入键值对的个数</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;    <span class="comment">//使用map容器，自带键值对数据结构</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;    <span class="comment">//map类型的迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;        <span class="comment">//每行输入一个键值对</span></span><br><span class="line">        it = m.<span class="built_in">find</span>(a);    <span class="comment">//查找键 a 是否存在，是返回所在位置，否返回 end 位置，</span></span><br><span class="line">        <span class="keyword">if</span>(it != m.<span class="built_in">end</span>())  <span class="comment">//如果存在，对键相同的单元的值部分求和</span></span><br><span class="line">        &#123;   </span><br><span class="line">            m[a] = it-&gt;second + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若不存在生成新的键值对</span></span><br><span class="line">        &#123;       </span><br><span class="line">            m[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;    <span class="comment">//遍历输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ10"><a href="#HJ10" class="headerlink" title="HJ10"></a>HJ10</h2><ul><li><p>题目：字符个数统计，输入一个字符串，输入该字串中不重复的字符个数</p></li><li><p>思路一：利用集合set的自动降重功能，将字符串拆分成字符插入其中，再求集合的 size 即可（需要遍历整个字串，耗时）</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str_tmp;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, str_tmp))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           str.insert(str_tmp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：哈希表，待补充</p></li></ul><h2 id="HJ11"><a href="#HJ11" class="headerlink" title="HJ11"></a>HJ11</h2><ul><li><p>题目：数字颠倒，将输入的整数以字符串的形式逆序输出</p></li><li><p>思路：将整数转为字串类型，再利用函数翻转输出</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    str = to_string(n);<span class="comment">//int2string转换</span></span><br><span class="line">    reverse(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//逆序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ12"><a href="#HJ12" class="headerlink" title="HJ12"></a>HJ12</h2><ul><li><p>题目：反转字符串</p></li><li><p>思路：同HJ11</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为机试（牛客）</title>
      <link href="/2022/07/31/HuaWei/"/>
      <url>/2022/07/31/HuaWei/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://www.nowcoder.com/exam/oj/ta?page=1&tpId=37&type=37" target="_blank" rel="noopener">华为机考</a>刷题记录，初次刷题，想法不成熟，大多直接暴力解决了</p><p><del>（知道自己菜，没想到这么菜）</del></p><a id="more"></a><p><a href="https://blog.csdn.net/m0_46663240/article/details/125679183?spm=1001.2014.3001.5502" target="_blank" rel="noopener">参考1</a></p><p><a href="https://blog.csdn.net/weixin_38815609/article/details/125658519?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165949738016782390555769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165949738016782390555769&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-125658519-null-null.142^v39^pc_rank_34_ecpm25&utm_term=%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83%E9%A2%98&spm=1018.2226.3001.4187" target="_blank" rel="noopener">参考2</a></p><h2 id="HJ1"><a href="#HJ1" class="headerlink" title="HJ1"></a>HJ1</h2><ul><li><p>题目：查找输入字符串最后一个单词的长度</p></li><li><p>思路：字符串由空格分隔，找到最后一个空格，用整体的长度减去空格及空格前的长度，剩余的即为所求</p></li><li><p>代码：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>,str);</span><br><span class="line"><span class="comment">// size_t len = str.size();//总长度</span></span><br><span class="line"><span class="comment">// size_t found = str.rfind(" ");//最后空格的位置</span></span><br><span class="line">     <span class="comment">// size_t found = str.find_last_of(" ");</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.<span class="built_in">size</span>() -  str.rfind(<span class="string">" "</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分析：关键有二：</p><ul><li><p>字符串的获取</p><ul><li><p>cin：遇空格或制表符即停，显然无法满足</p></li><li><p>getline：可连续读取输入并存入字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>最后空格的定位</p><ul><li><p>find_last_of()：给定待查找的字符，从后开始查找并返回其位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_of</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//可以指定从何处开始查找，即指定第二个参数</span></span><br><span class="line"><span class="comment">//注意字符串从0开始编号</span></span><br></pre></td></tr></table></figure></li><li><p>find 家族辨析：<a href="https://cplusplus.com/reference/string/string/find/" target="_blank" rel="noopener">参考</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索指定位置开始的第一个完全匹配的字符（串），即与指定字串完全匹配时才返回，且是第一个</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span></span>;<span class="comment">//从前往后找</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">rfind</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span></span>;<span class="comment">//从后往前找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索指定位置开始的第一个匹配的字符（串），只需有一个字符满足即可</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span></span>;<span class="comment">//从前往后找</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span></span>;<span class="comment">//从后往前找</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//查找与指定字串不匹配的字符（串）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_not_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_last_not_of</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = npos)</span> </span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="HJ2"><a href="#HJ2" class="headerlink" title="HJ2"></a>HJ2</h2><ul><li><p>题目：计算某字符出现的次数</p></li><li><p>思路：读入到两个变量中，遍历字串，是否和目标字符相等，若相等则 count 增1，再判断大小写的问题，大写和小写分别判断</p></li><li><p>代码：（低质量代码）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str,str2;</span><br><span class="line">    <span class="comment">//读入两行内容</span></span><br><span class="line">    getline(<span class="built_in">cin</span>, str);</span><br><span class="line">    getline(<span class="built_in">cin</span>, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如相等则计数器k自增1</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str2[<span class="number">0</span>])</span><br><span class="line">        &#123;       </span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">//考虑大小写一致</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;          </span><br><span class="line">                <span class="keyword">if</span>(str2[<span class="number">0</span>] &lt;= <span class="string">'Z'</span> &amp;&amp; str2[<span class="number">0</span>] &gt;= <span class="string">'A'</span>)<span class="comment">//如目标字符是大写，则再判断其对应的小写是否有相等的</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(str[i]+<span class="number">0</span> == str2[<span class="number">0</span>] + <span class="number">32</span>)</span><br><span class="line">                       k++;</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str2[<span class="number">0</span>] &lt;= <span class="string">'z'</span> &amp;&amp; str2[<span class="number">0</span>] &gt;= <span class="string">'a'</span>)<span class="comment">//如目标字符是小写，则再判断其对应的大写是否有相等的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i]+<span class="number">0</span> == str2[<span class="number">0</span>] - <span class="number">32</span>)</span><br><span class="line">                       k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<ul><li>新手，想法简单粗暴</li></ul></li></ul></li></ul><h2 id="HJ3"><a href="#HJ3" class="headerlink" title="HJ3"></a>HJ3</h2><ul><li><p>题目：输入随机数个数及随机数，去重排序后按行输出</p></li><li><p>思路一：（排名第一的思路，非本人想法）先确定随机数的个数（直接cin），定义一个数组，然后每次将读入的数作为数组的下标，值填充为1，然后输出数组值不为0的下标</p><ul><li>核心：只要有重复值，对应到数组的下标还是同一个，达到既降重又排序的目的；转换思路，输入的值是下标而非数组的值</li><li>缺点：一是必须指定数组的大小是题目给定的范围，而不能动态的设置为输入随机数的个数；二是数组必须初始化，否则其中的垃圾数据会造成输入错误</li></ul></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) &#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">            a[n] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i])</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按上述思路重写了一下，比较容易理解和看懂</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;<span class="comment">//读入数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//指定大小并初始化（不管数组多小，都开辟了这么多空间）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        a[n] = <span class="number">1</span>;<span class="comment">//以读入的数作为下标，有多少重复都无所谓（填充值非零均可）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出数组值非零的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：调用 STL，去重排序一步到位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;//包含集合set</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//自动实现去重和排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析：</p><ul><li>STL 中的 set（集合）自动将插入元素放入合适的位置（排序），同时对重复元素忽略，可以<code>插入删除但不能更改</code></li></ul></li></ul><h2 id="HJ4"><a href="#HJ4" class="headerlink" title="HJ4"></a>HJ4</h2><ul><li><p>题目：字符串的分割，以8为长度分割输入的字符串</p></li><li><p>思路：考虑 ==8 、&lt;8 、&gt;8 三种情况，利用容器，把分割后的字串存入其中，最后遍历容器输出，主要利用 substr 进行字串的分割</p><ul><li>复盘：既然以 8 为单位分割，那只要不为 8 的倍数就要补 0，用余数判断一下需要补 0 的个数，利用 append 插入，再分割输出（<del>另外本题没有给出输出的格式，我以为是空格，结果提交发现是换行</del>）</li></ul></li><li><p>代码：初次写的代码，重复代码太多了，自愧不如，简单问题复杂化了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">    <span class="built_in">string</span> str_tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str_tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = str_tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按8分割</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  str_tmp.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            str.push_back(str_tmp.substr(i, <span class="number">8</span>));</span><br><span class="line">            i += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>-n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            str_tmp.push_back(<span class="string">'0'</span>);<span class="comment">//小于8时判断补 0 的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">          str.push_back(str_tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>(n &gt; <span class="number">8</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = n / <span class="number">8</span>;<span class="comment">//有几段以 8 为长度的</span></span><br><span class="line">        <span class="comment">//需要补几个0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span> - n % <span class="number">8</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            str_tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按8分割</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            str.push_back(str_tmp.substr(i, <span class="number">8</span>));</span><br><span class="line">            i += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)<span class="comment">//注意这里是补 0 后新的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复盘后改进的代码：简便多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">8</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str.append(<span class="number">8</span> - n % <span class="number">8</span>, <span class="string">'0'</span>);    <span class="comment">//不足8位的补0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按8分割</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>();)<span class="comment">//注意这里的 size 是补 0 后新的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;  str.substr(i, <span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        i += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分析：</p><ul><li><p>substr 的用法</p><ul><li><p>单参数：从该位置开始取到末尾</p></li><li><p>双参数：从该位置开始取到指定的长度</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"time"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"单参数："</span> &lt;&lt; s.substr(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//返回 me（从位置 2 截取到尾）</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"双参数："</span> &lt;&lt; s.substr(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//返回 ime（从位置1开始，截取长度3）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>append 的用法</p><ul><li>向 string 后面追加字符或字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.append(<span class="number">4</span>, <span class="string">'0'</span>); <span class="comment">//在 str 后追加 4 个字符 0</span></span><br><span class="line">str.append(c);<span class="comment">//追加 char 类型字串 c</span></span><br><span class="line">str.append(str_tmp); <span class="comment">//追加 string 字串</span></span><br><span class="line">str.append(str_tmp, <span class="number">5</span>, <span class="number">3</span>);<span class="comment">//追加从位置 5 开始的长度为 3 的字串（包括位置 5）</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="HJ5"><a href="#HJ5" class="headerlink" title="HJ5"></a>HJ5</h2><ul><li><p>题目：输入十六进制字串，将其转为十进制数输出（华为肯定不会考这种题）</p></li><li><p>思路：（笨人笨方法啊）先把输入的前缀0x截掉，剩下的部分依次遍历，如是字符0-9，则转为数字0-9；如是字母A-F，则转为10~15</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="comment">//截掉前缀</span></span><br><span class="line"><span class="built_in">string</span> str_tmp;</span><br><span class="line">str_tmp = str.substr(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//进制转换</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = (str_tmp.<span class="built_in">size</span>() - <span class="number">1</span>);<span class="comment">//控制幂次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历每一位</span></span><br><span class="line"><span class="keyword">if</span> (str_tmp[i] &gt;= <span class="string">'0'</span> &amp;&amp; str_tmp[i] &lt;= <span class="string">'9'</span>)<span class="comment">//判断是否是数字</span></span><br><span class="line">&#123;</span><br><span class="line">n += <span class="keyword">int</span>(str_tmp[i] - <span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">16</span>, j);<span class="comment">//转为0~9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str_tmp[i] &gt;= <span class="string">'A'</span> &amp;&amp; str_tmp[i] &lt;= <span class="string">'F'</span>)<span class="comment">//判断是否是字母</span></span><br><span class="line">&#123;</span><br><span class="line">n += (str_tmp[i] - <span class="number">55</span>)*<span class="built_in">pow</span>(<span class="number">16</span>, j);<span class="comment">//A是65，减55是转为10~15</span></span><br><span class="line">&#125;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以直接调库的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stoi(str,<span class="number">0</span>,<span class="number">16</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 将str从位置 0 开始到末尾的 16 进制转为 十进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ6"><a href="#HJ6" class="headerlink" title="HJ6"></a>HJ6</h2><ul><li><p>题目：质数因子，给定一个整数，输出该数的所有质数因子，包括重复值</p></li><li><p>思路：质数从 2 开始，让给定值从 2 开始遍历，能整除则继续，否则 +1 后再判断是否能整除，这样提交后内存超限</p><ul><li>看了题解，一个数至少有一个质数因子不会超过其平方根，这样就可以从 2 遍历到其平方根，再判断是否是因子。需要注意该值本身就是质数的情况</li></ul></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n) &amp;&amp; i &lt;= n; i++)&#123;  <span class="comment">//从小到大的质因子，质因子不会超过它的平方根</span></span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123; <span class="comment">//所有的质数前面全部除掉，后续就不会有合因子</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            n /= i; <span class="comment">//除掉质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n - <span class="number">1</span>) <span class="comment">//前面已经除掉了所有因子，故在此判断该值是否是 1 ，不是就说明自己本身就是质数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ7"><a href="#HJ7" class="headerlink" title="HJ7"></a>HJ7</h2><ul><li><p>输入浮点数，四舍五入</p></li><li><p>思路：都说了入门题了</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cmath&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">   <span class="comment">// cout &lt;&lt; round(a);</span></span><br><span class="line">    <span class="keyword">if</span>(a - <span class="keyword">int</span>(a) &gt;= <span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(a) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ8"><a href="#HJ8" class="headerlink" title="HJ8"></a>HJ8</h2><ul><li><p>题目：合并表记录：给定索引及对应的值，将相同索引的值求和，并按索引升序排序输出</p></li><li><p>思路一：（题目本意是考察哈希表，这里直接暴力解决）首先读入键值对数，再将键值对存入个vector，接着遍历并判断索引号是否相等，如若相等则加到第一个上，同时将另一个清除；新建一个vector，将不为空的复制进去，调用 sort 排序再输出</p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v_F;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b &gt;&gt; c;</span><br><span class="line">       </span><br><span class="line">        v_tmp.push_back(b);</span><br><span class="line">        v_tmp.push_back(c);</span><br><span class="line">        v.push_back(v_tmp);</span><br><span class="line">        v_tmp.<span class="built_in">clear</span>();<span class="comment">//注意清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][<span class="number">0</span>] == v[j][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                v[i][<span class="number">1</span>] += v[j][<span class="number">1</span>]; </span><br><span class="line"><span class="comment">//                 v[j].clear();</span></span><br><span class="line">                v[j].erase(v[j].<span class="built_in">begin</span>(), v[j].<span class="built_in">end</span>());<span class="comment">//清除元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(v[i].empty() == <span class="literal">false</span>)</span><br><span class="line">            v_F.push_back(v[i]);<span class="comment">//非空存入新的容器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(v_F.<span class="built_in">begin</span>(), v_F.<span class="built_in">end</span>());<span class="comment">//排好序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_F.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; v_F[i][<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; v_F[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：调用 STL 的 map，其自动建立 key - value 的对应，且其中的数据是有序的，map 是一个模板类，需要 key value 两个参数，关键字 key 只能在 map 中存在一次，其增删改和容器类似，通过 pair 插入，迭代器访问，<code>注意迭代器返回值是变化的</code></p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;    <span class="comment">//输入键值对的个数</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;    <span class="comment">//使用map容器，自带键值对数据结构</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;    <span class="comment">//map类型的迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;        <span class="comment">//每行输入一个键值对</span></span><br><span class="line">        it = m.<span class="built_in">find</span>(a);    <span class="comment">//查找键 a 是否存在，是返回所在位置，否返回 end 位置，</span></span><br><span class="line">        <span class="keyword">if</span>(it != m.<span class="built_in">end</span>())  <span class="comment">//如果存在，对键相同的单元的值部分求和</span></span><br><span class="line">        &#123;   </span><br><span class="line">            m[a] = it-&gt;second + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若不存在生成新的键值对</span></span><br><span class="line">        &#123;       </span><br><span class="line">            m[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;    <span class="comment">//遍历输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ10"><a href="#HJ10" class="headerlink" title="HJ10"></a>HJ10</h2><ul><li><p>题目：字符个数统计，输入一个字符串，输入该字串中不重复的字符个数</p></li><li><p>思路一：利用集合set的自动降重功能，将字符串拆分成字符插入其中，再求集合的 size 即可（需要遍历整个字串，耗时）</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str_tmp;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; str;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, str_tmp))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           str.insert(str_tmp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：哈希表，待补充</p></li></ul><h2 id="HJ11"><a href="#HJ11" class="headerlink" title="HJ11"></a>HJ11</h2><ul><li><p>题目：数字颠倒，将输入的整数以字符串的形式逆序输出</p></li><li><p>思路：将整数转为字串类型，再利用函数翻转输出</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    str = to_string(n);<span class="comment">//int2string转换</span></span><br><span class="line">    reverse(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//逆序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ12"><a href="#HJ12" class="headerlink" title="HJ12"></a>HJ12</h2><ul><li><p>题目：反转字符串</p></li><li><p>思路：同HJ11</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> 华为机考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/07/29/data_structure/"/>
      <url>/2022/07/29/data_structure/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数据结构理论</p><p><a href="https://www.bilibili.com/video/BV1nJ411V7bd?spm_id_from=333.999.0.0" target="_blank" rel="noopener">宝藏级+保姆级课程-数据结构与算法基础-青岛大学-王卓老师</a></p><a id="more"></a><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度：各条指令执行的时间之和</p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><ul><li>表示算法执行的渐进上限</li><li>性质：<ul><li>任意常数 $c &gt;0$，$O(f(n))=O(cf(n))$<ul><li>常数乘以某个运算，不改变其时间复杂度（函数正的常系数可忽略等同于1）</li></ul></li><li>任意常数$a&gt;b&gt;0$，$O(n^a+n^b)=O(n^a)$<ul><li>因 $a&gt;b$，故前者的影响大于后者，在整个过程中便可忽略后者的影响（低次项可忽略，保留最高次项）</li></ul></li></ul></li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul><li>不计入输入本身</li><li>其他各方面消耗都计入</li></ul><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>常数时间复杂度 $O(1)$</p></li><li><p>对数时间复杂度 $O(logn)$</p><ul><li>对数多项式复杂度</li></ul></li><li><p>线性 $O(1)$</p></li></ul><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><ul><li>尾部指针域指向头结点</li><li>一般使用带尾指针的循环链表</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理</title>
      <link href="/2022/07/17/digital_image_process/"/>
      <url>/2022/07/17/digital_image_process/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数字图像处理基础理论（待补充）</p><a id="more"></a><h1 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h1><h2 id="空间相关与卷积"><a href="#空间相关与卷积" class="headerlink" title="空间相关与卷积"></a>空间相关与卷积</h2><ul><li><p>相关：图像上移动核的中心，求每个位置的乘积之和</p><ul><li>只满足分配律</li></ul></li><li><p>卷积：把相关运算的<code>核旋转180°</code></p><ul><li>满足交换律、结合律、分配律</li></ul></li><li><p>可分离核</p><ul><li>可分离核：能够表示为两个向量外积的矩阵</li><li>$m \times n$ 的核 $\text{w}$ 可分离为：$\text{w} = v_{m \times 1}w_{n \times 1}^T$</li><li>$m \times m$ 的核  $\text{w}$ 可分离为：$\text{w} = v_{m \times 1}v_{m \times 1}^T$</li><li>优势：减少计算量，大核分离为小核计算</li><li>判断是否可分离：矩阵的秩为 1（矩阵论：一列向量与一行向量的乘积的矩阵，秩为 1）</li></ul></li><li><p>空间滤波器的构建</p><ul><li></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点云+PCL学习笔记</title>
      <link href="/2022/07/17/point_cloud_pcl/"/>
      <url>/2022/07/17/point_cloud_pcl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客</p><p>（注：部分图片未上传至图床，抽空补充）</p><a id="more"></a><h2 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h2><ul><li><p>分布在 N 维空间中的离散点集</p></li><li><p>是对物体表面信息的离散采样</p></li></ul><h2 id="点云库"><a href="#点云库" class="headerlink" title="点云库"></a>点云库</h2><ul><li>三维处理算法：滤波、特征估计、表面重建等</li></ul><h2 id="PointT-类型"><a href="#PointT-类型" class="headerlink" title="PointT 类型"></a>PointT 类型</h2><h3 id="PointXYZ"><a href="#PointXYZ" class="headerlink" title="PointXYZ"></a>PointXYZ</h3><ul><li><p>包含 x y z 坐标的点数据类型</p></li><li><p>成员变量 float x, y, z</p></li><li><p>points[i].x 访问</p></li><li><p>多余的一个变量用来填充位置以满足存储对齐（?）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">float</span> data[<span class="number">4</span>];</span><br><span class="line">   <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">      <span class="keyword">float</span> x;</span><br><span class="line">      <span class="keyword">float</span> y;</span><br><span class="line">      <span class="keyword">float</span> z;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Point-XYZI"><a href="#Point-XYZI" class="headerlink" title="Point XYZI"></a>Point XYZI</h3><ul><li>包含 x y z 坐标及 intensity</li></ul><h3 id="PointXYZRGBA"><a href="#PointXYZRGBA" class="headerlink" title="PointXYZRGBA"></a>PointXYZRGBA</h3><ul><li>rgba 单独作为一个整型变量（unit32_t）</li></ul><h2 id="PCD-文件"><a href="#PCD-文件" class="headerlink" title="PCD 文件"></a>PCD 文件</h2><ul><li>包含文件头：声明存储点云数据的特性，必须用 ASCII 编码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># .PCD v<span class="number">.7</span> - Point Cloud Data file format</span><br><span class="line">VERSION <span class="number">.7</span>                     # 指定PCD文件版本</span><br><span class="line">FIELDS x y z rgb               # 指定每个点可以有的每一个维度或字段的名字</span><br><span class="line">SIZE <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span>                   # 用字节数指定 FIELDS 中每一个维度的大小</span><br><span class="line">TYPE F F F F                   # 用一个字符指定 FILEDS 中每一个维度的类型</span><br><span class="line">COUNT <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>                  # 指定每一个维度包含的元素数目</span><br><span class="line">WIDTH <span class="number">213</span>                      # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目）  列</span><br><span class="line">HEIGHT <span class="number">1</span>                       # 用点的数量表示点云数据集的高度；同 WIDTH                                      行 </span><br><span class="line">VIEWPOINT <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>        # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）</span><br><span class="line">POINTS <span class="number">213</span>                     # 数据集中点的总数 </span><br><span class="line">DATA ascii                     # 存储点云数据的数据类型：ASCII 或 二进制</span><br><span class="line"><span class="number">0.93773</span> <span class="number">0.33763</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.90805</span> <span class="number">0.35641</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.81915</span> <span class="number">0.32</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.97192</span> <span class="number">0.278</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br></pre></td></tr></table></figure><ul><li>DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开</li><li>DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法</li></ul><h2 id="K-d-tree"><a href="#K-d-tree" class="headerlink" title="K-d tree"></a>K-d tree</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><center class="half">    <img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/KdTree.png" alt="KdTree"  style="zoom:20%;" />    <img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/Kdtree_2d.png" alt="KdTree"  style="zoom:30%;" /></center><p>按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。</p><p>在 k-d tree 中查找距离查询点 $\overline x$ 最近点的，意味着遍历整个树，找到包含 $\overline x$ 的子节点。</p><p>实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。</p><h3 id="两种查询方式"><a href="#两种查询方式" class="headerlink" title="两种查询方式"></a>两种查询方式</h3><p>（详见博士论文 P40）</p><p>PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型：</p><ul><li>==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点）</li><li>==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点</li></ul><p>r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。</p><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144959.jpg" alt="r 搜索实例"></p><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144728.png" alt="K-d tree最近邻搜索"></p><p>上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\vec{q}$ ，但以 $ \vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\vec{q}’$ 。</p><p>另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 <code>正确尺度因子</code> 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。</p><p>如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。</p><center class="half">    <img src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface normals.jpg" alt="估计表面法线"  style="zoom:25%;" />    <img src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface curvatures.jpg" alt="估计表面曲率"  style="zoom:27%;" /></center><p>所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。</p><h2 id="Octree-八叉树"><a href="#Octree-八叉树" class="headerlink" title="Octree(八叉树)"></a>Octree(八叉树)</h2><ul><li>一个根节点包含八个子节点</li><li>若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归</li><li>除近邻搜索外，可用于碰撞检测</li></ul><img src="F:\AFIGHT\笔记\PCL\assets\Octree.png" alt="八叉树" style="zoom: 33%;" /><h2 id="点云连接"><a href="#点云连接" class="headerlink" title="点云连接"></a>点云连接</h2><h3 id="点连接"><a href="#点连接" class="headerlink" title="点连接"></a>点连接</h3><ul><li>需确保类型和维度相等</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloud_c = cloud_a;</span><br><span class="line">cloud_c += cloud_b;</span><br></pre></td></tr></table></figure><h3 id="字段连接"><a href="#字段连接" class="headerlink" title="字段连接"></a>字段连接</h3><ul><li>需确保数目相等</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c);</span><br></pre></td></tr></table></figure><h2 id="点云滤波"><a href="#点云滤波" class="headerlink" title="点云滤波"></a>点云滤波</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>噪声点：设备精度、操作者经验、环境因素等</li><li>离群点：外界干扰如障碍物等，产生离主体点云较远的离散点</li></ul><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><ul><li>通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果</li><li>有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征</li></ul><h3 id="直通滤波器"><a href="#直通滤波器" class="headerlink" title="直通滤波器"></a>直通滤波器</h3><ul><li><p>去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt; pass; <span class="comment">// 创建直通滤波器对象</span></span><br><span class="line">pass.setInputCloud(cloud);<span class="comment">// 输入</span></span><br><span class="line">pass.setFilterFieldName(<span class="string">"z"</span>);<span class="comment">// 设置滤波字段，此处为 z 轴</span></span><br><span class="line">pass.setFilterLimits(<span class="number">0.0</span>, <span class="number">200.0</span>);<span class="comment">// 设置滤波范围，超出则滤除</span></span><br><span class="line">pass.setFilterLimitsNegative (<span class="literal">true</span>);<span class="comment">// 默认为 false，设为 ture 则返回被滤除点</span></span><br><span class="line">pass.filter(*cloud_filtered);<span class="comment">// 执行滤波，并将滤波结果存储在 cloud_filtered</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="VoxelGrid（体素化网格）滤波器"><a href="#VoxelGrid（体素化网格）滤波器" class="headerlink" title="VoxelGrid（体素化网格）滤波器"></a>VoxelGrid（体素化网格）滤波器</h3><ul><li><p>实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变</p></li><li><p>VoxelGrid</p><ul><li>三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体==</li><li>通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示==</li><li>对所有体素处理后得到过滤后的点云</li><li>缺点：<code>慢</code>，比体素中心逼近法更慢</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;<span class="comment">// 创建体素栅格滤波对象</span></span><br><span class="line">sor.setInputCloud(cloud);   <span class="comment">// 读入点云设置为输入</span></span><br><span class="line">sor.setLeafSize(<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);    <span class="comment">// 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米</span></span><br><span class="line">sor.filter(*cloud_filtered);   <span class="comment">// 执行滤波并存储到 cloud_filtered</span></span><br></pre></td></tr></table></figure><ul><li>滤波结果</li></ul><center class="half">    <img src="F:\AFIGHT\笔记\PCL\assets\滤波前.png" alt="滤波前"  style="zoom:50%;" />    <img src="F:\AFIGHT\笔记\PCL\assets\滤波后.png" alt="滤波后"  style="zoom:50%;" /></center>### 统计滤波</li></ul><p>（详见博士论文 P40）</p><ul><li><p>用于去除离群点</p></li><li><p>基于对近邻点集 $P^k$ 的统计分析</p><ul><li>计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\overline d$ </li><li>计算点云 $P$ 在平均距离上的分布，并估计平均值 $\mu_k$ 及标准差 $\sigma_k$ </li></ul></li><li><p>对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离</p></li></ul><p>去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。</p><p><strong>假设第一次扫描 $P_i$ 和随后的 $P_{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \in P_i$，搜索其对应的近邻点 $p \in P_{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;<span class="comment">// 创建统计滤波对象</span></span><br><span class="line">sor.setInputCloud(cloud);  <span class="comment">// 设置输入点云</span></span><br><span class="line">sor.setMeanK(<span class="number">50</span>);    <span class="comment">// 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）</span></span><br><span class="line">sor.setStddevMulThresh(<span class="number">1.0</span>);<span class="comment">// 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点</span></span><br><span class="line">sor.filter(*cloud_filtered);  <span class="comment">// 执行并存储滤波结果</span></span><br><span class="line"></span><br><span class="line">sor.setNegative(<span class="literal">true</span>);  <span class="comment">// 获取离群点（此值默认为 false）</span></span><br></pre></td></tr></table></figure><ul><li>滤波结果</li></ul><center class="half">    <img src="F:\AFIGHT\笔记\PCL\assets\统计滤波结果.png" alt="统计滤波结果"  style="zoom:50%;" />    <img src="F:\AFIGHT\笔记\PCL\assets\统计滤波离群点.png" alt="统计滤波离群点"  style="zoom:50%;" /></center><h3 id="参数化模型投影点云"><a href="#参数化模型投影点云" class="headerlink" title="参数化模型投影点云"></a>参数化模型投影点云</h3><ul><li><p>点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0</p></li><li><p>PCL 中有特意存储常见模型系数的数据结构</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a set of planar coefficients with X=Y=0,Z=1  </span></span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients())</span></span>;<span class="comment">// 创建 模型系数 对象</span></span><br><span class="line">coefficients-&gt;values.resize(<span class="number">4</span>);<span class="comment">// 参数个数置为 4</span></span><br><span class="line">coefficients-&gt;values[<span class="number">0</span>] = coefficients-&gt;values[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Y</span></span><br><span class="line">coefficients-&gt;values[<span class="number">2</span>] = <span class="number">1.0</span>;</span><br><span class="line">coefficients-&gt;values[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the filtering object</span></span><br><span class="line">pcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj;<span class="comment">// 设置投影滤波对象</span></span><br><span class="line">proj.setModelType(pcl::SACMODEL_PLANE);<span class="comment">// 设置对象对应的投影模型类型，此处为平面模型</span></span><br><span class="line">proj.setInputCloud(cloud);   <span class="comment">// 设置输入</span></span><br><span class="line">proj.setModelCoefficients(coefficients);<span class="comment">// 设置模型系数为前述定义系数</span></span><br><span class="line">proj.filter(*cloud_projected);   <span class="comment">// 执行并保存</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="从一个点云中提取一个子集"><a href="#从一个点云中提取一个子集" class="headerlink" title="从一个点云中提取一个子集"></a>从一个点云中提取一个子集</h3><ul><li>基于 ExtractIndices 滤波器（基于分割算法）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; <span class="comment">// 创建分割对象</span></span><br><span class="line">extract.setInputCloud(cloud_filtered);     <span class="comment">// 设置输入点云 </span></span><br><span class="line">extract.setIndices(inliers);      <span class="comment">// 设置分割后的内点为需要提取的点击（分割部分略）</span></span><br><span class="line">extract.setNegative(<span class="literal">false</span>);      <span class="comment">// 指定提取内点</span></span><br><span class="line">extract.filter(*cloud_p);     <span class="comment">// 执行并存储</span></span><br></pre></td></tr></table></figure><h3 id="RadiusOutlierRemoval-ConditionalRemoval-移除离群点"><a href="#RadiusOutlierRemoval-ConditionalRemoval-移除离群点" class="headerlink" title="RadiusOutlierRemoval / ConditionalRemoval  移除离群点"></a>RadiusOutlierRemoval / ConditionalRemoval  移除离群点</h3><h4 id="RadiusOutlierRemoval"><a href="#RadiusOutlierRemoval" class="headerlink" title="RadiusOutlierRemoval"></a>RadiusOutlierRemoval</h4><ul><li>删除输入点云一定范围内没有达到足够多近邻的所有数据点</li><li>人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。</li></ul><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Cradius_outlier.png" alt="RadiusOutlierRemoval "></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem;<span class="comment">// 创建半径滤波对象</span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">outrem.setInputCloud(cloud);<span class="comment">// 设置输入点云</span></span><br><span class="line">outrem.setRadiusSearch(<span class="number">0.8</span>);<span class="comment">// 设置搜索半径为 0.8</span></span><br><span class="line">outrem.setMinNeighborsInRadius(<span class="number">2</span>);<span class="comment">// 设置所需近邻点数为 2</span></span><br><span class="line">outrem.setKeepOrganized(<span class="literal">true</span>);   <span class="comment">// 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">outrem.filter(*cloud_filtered);<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure><h4 id="ConditionalRemoval"><a href="#ConditionalRemoval" class="headerlink" title="ConditionalRemoval"></a>ConditionalRemoval</h4><ul><li>如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">range_cond</span><span class="params">(<span class="keyword">new</span> pcl::ConditionAnd&lt;pcl::PointXYZ&gt;())</span></span>;<span class="comment">// 创建条件定义对象</span></span><br><span class="line">range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(<span class="keyword">new</span></span><br><span class="line">pcl::FieldComparison&lt;pcl::PointXYZ&gt;(<span class="string">"z"</span>, pcl::ComparisonOps::GT, <span class="number">0.0</span>)));  <span class="comment">// 添加比较算子：z 字段上大于 0.0 </span></span><br><span class="line">range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(<span class="keyword">new</span></span><br><span class="line">pcl::FieldComparison&lt;pcl::PointXYZ&gt;(<span class="string">"z"</span>, pcl::ComparisonOps::LT, <span class="number">0.8</span>)));  <span class="comment">// 添加比较算子：z 字段上小于 0.8 </span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">pcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem; <span class="comment">// 初始化条件滤波</span></span><br><span class="line">condrem.setCondition(range_cond);<span class="comment">// 设置条件为指定的比较算子</span></span><br><span class="line">condrem.setInputCloud(cloud);<span class="comment">// 设置输入点云</span></span><br><span class="line">condrem.setKeepOrganized(<span class="literal">true</span>);<span class="comment">// 设置将被滤除点保留但置为 NaN</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">condrem.filter(*cloud_filtered);<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure><h3 id="CropHull-任意多边形内部点云提取"><a href="#CropHull-任意多边形内部点云提取" class="headerlink" title="CropHull 任意多边形内部点云提取"></a>CropHull 任意多边形内部点云提取</h3><ul><li>CropHull 滤波器得到 2D 封闭多边形内 / 外的点云</li></ul><h2 id="深度图像（Range-Depth-Images）"><a href="#深度图像（Range-Depth-Images）" class="headerlink" title="深度图像（Range/Depth Images）"></a>深度图像（Range/Depth Images）</h2><ul><li>将图像采集器到场景中各点的距离（深度）值作为像素值的图像（<strong>距离是相机到场景点的垂直距离，不是连线距离</strong>）</li><li>直接反映景物可见表面的几何状态</li><li>物体的三维表示形式，可通过<code>立体相机或 TOF 相机</code>获取</li><li>深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据</li><li>英文中常见的等价表述：<code>range image</code>，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles</li></ul><p>注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息</p><h3 id="从点云创建深度图像"><a href="#从点云创建深度图像" class="headerlink" title="从点云创建深度图像"></a>从点云创建深度图像</h3><ul><li><p>主要函数为 createFromPointCloud，声明 9 个参数填充即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pcl::RangeImage::createFromPointCloud(<span class="keyword">const</span> PointCloudType &amp; point_cloud,</span><br><span class="line"><span class="keyword">float</span> angular_resolution = pcl::deg2rad (<span class="number">0.5f</span>),</span><br><span class="line"><span class="keyword">float</span> max_angle_width = pcl::deg2rad (<span class="number">360.0f</span>),</span><br><span class="line"><span class="keyword">float</span> max_angle_height = pcl::deg2rad (<span class="number">180.0f</span>),</span><br><span class="line"><span class="keyword">const</span> Eigen::Affine3f &amp; sensor_pose = Eigen::Affine3f::Identity (),</span><br><span class="line">RangeImage::CoordinateFrame coordinate_frame = CAMERA_FRAME,</span><br><span class="line"><span class="keyword">float</span> noise_level = <span class="number">0.0f</span>,</span><br><span class="line"><span class="keyword">float</span> min_range = <span class="number">0.0f</span>,</span><br><span class="line"><span class="keyword">int</span> border_size = <span class="number">0</span> </span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Create the depth image from a point cloud.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameter EX:</span></span><br><span class="line"><span class="comment">point_cloudthe input point cloud</span></span><br><span class="line"><span class="comment">angular_resolutionthe angular difference (in radians) between the individual pixels in the image</span></span><br><span class="line"><span class="comment">max_angle_widthan angle (in radians) defining the horizontal bounds of the sensor</span></span><br><span class="line"><span class="comment">max_angle_heightan angle (in radians) defining the vertical bounds of the sensor</span></span><br><span class="line"><span class="comment">sensor_posean affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )</span></span><br><span class="line"><span class="comment">coordinate_framethe coordinate frame (defaults to CAMERA_FRAME)</span></span><br><span class="line"><span class="comment">noise_level- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.</span></span><br><span class="line"><span class="comment">min_rangethe minimum visible range (defaults to 0)</span></span><br><span class="line"><span class="comment">border_sizethe border size (defaults to 0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="从深度图像提取边界"><a href="#从深度图像提取边界" class="headerlink" title="从深度图像提取边界"></a>从深度图像提取边界</h3><ul><li>边界：前景跨越到背景的位置</li><li>物体边界（黑）、阴影边界（绿）、Veil 点集（红）</li></ul><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Crange_image_border_points.png" alt="边界点集分类"></p><ul><li>若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li><p>兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集</p></li><li><p>数量比原始点云或图像的数据量小很多</p></li><li><p>组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性</p></li><li><p>利于加快后续的处理速度</p></li></ul><h3 id="关键概念及算法"><a href="#关键概念及算法" class="headerlink" title="关键概念及算法"></a>关键概念及算法</h3><h4 id="NARF-关键点"><a href="#NARF-关键点" class="headerlink" title="NARF 关键点"></a>NARF 关键点</h4><p>*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608.</p><ul><li>从深度图像识别物体</li><li>步骤<ul><li>遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测；</li><li>遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向；</li><li>根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定；</li><li>对兴趣值进行平滑过滤；</li><li>进行无最大值压缩找到最终的关键点，即为 NARF 关键点。</li></ul></li><li>简化步骤*<ul><li>给定深度图像，进行边缘提取</li><li>表面变化基于边界和曲率原则”评分“</li><li>设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多</li></ul></li></ul><h4 id="Harris关键点"><a href="#Harris关键点" class="headerlink" title="Harris关键点"></a>Harris关键点</h4><ul><li>通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点</li><li>若 Harris 矩阵特征的两个特征值都很大，则为关键点</li><li>对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测</li><li>3D Harris 关键点检测使用的是<code>点云表面法向量的信息</code>（2D 使用的是图像梯度）</li></ul><h4 id="PCL-中的-keypoints"><a href="#PCL-中的-keypoints" class="headerlink" title="PCL 中的 keypoints"></a>PCL 中的 keypoints</h4><h5 id="深度图像提取-NARF-关键点"><a href="#深度图像提取-NARF-关键点" class="headerlink" title="深度图像提取 NARF 关键点"></a>深度图像提取 NARF 关键点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RangeImageBorderExtractor range_image_border_extractor;<span class="comment">// 创建对象，用于边缘提取</span></span><br><span class="line"><span class="function">pcl::NarfKeypoint <span class="title">narf_keypoint_detector</span><span class="params">(&amp;range_image_border_extractor)</span></span>; <span class="comment">// 创建对象，传入上述提取出的深度图像边缘</span></span><br><span class="line">narf_keypoint_detector.setRangeImage(&amp;range_image);   <span class="comment">// 传入深度图像</span></span><br><span class="line">narf_keypoint_detector.getParameters().support_size = support_size;    <span class="comment">// 设置支持范围(搜索空间球体的半径，邻域范围)</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;</span></span><br><span class="line">pcl::PointCloud&lt;<span class="keyword">int</span>&gt; keypoint_indices;<span class="comment">// 创建点云对象，存储检测到的点云</span></span><br><span class="line">narf_keypoint_detector.compute(keypoint_indices);  <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure><h5 id="SIFT-关键点提取"><a href="#SIFT-关键点提取" class="headerlink" title="SIFT 关键点提取"></a>SIFT 关键点提取</h5><p><a href="https://blog.csdn.net/dcrmg/article/details/52561656" target="_blank" rel="noopener">参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_43653930/article/details/104651907?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-5&spm=1001.2101.3001.4242" target="_blank" rel="noopener">参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40293648/article/details/82836998" target="_blank" rel="noopener">参考：SIFT（3）—–尺度空间极值检测_姗姗本人的博客-CSDN博客</a></p><p>注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。</p><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Csift%E7%AE%97%E5%AD%90-DOG%E5%B0%BA%E5%BA%A6%E7%A9%BA%E9%97%B4.png" alt="DOG尺度空间关键点确定"></p><p>​           ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向</p><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CDOG%E5%B0%BA%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%85%B3%E9%94%AE%E7%82%B9%E6%96%B9%E5%90%91%E7%A1%AE%E5%AE%9A.png" alt="关键点方向确定"></p><p>​            ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 </p><img src="F:\AFIGHT\笔记\PCL\assets\DOG尺度空间关键点描述子.png" alt="关键点描述子" style="zoom:67%;" /><ul><li><p>尺度不变性</p></li><li><p>局部特征描述子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift;<span class="comment">// 创建sift关键点检测对象</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointWithScale&gt; result;  <span class="comment">// 存储查询结果</span></span><br><span class="line">sift.setInputCloud(cloud_xyz); <span class="comment">// 设置输入点云</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">sift.setSearchMethod(tree);<span class="comment">// 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象</span></span><br><span class="line"><span class="comment">// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快</span></span><br><span class="line">sift.setScales(min_scale, n_octaves, n_scales_per_octave); <span class="comment">// 设置限制关键点检测的阈值</span></span><br><span class="line">sift.compute(result);    <span class="comment">// 执行sift关键点检测，保存结果在result</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setScales 函数原型</span></span><br><span class="line"><span class="keyword">void</span> pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::setScales(<span class="keyword">float</span> min_scale,</span><br><span class="line"><span class="keyword">int</span> nr_octaves,</span><br><span class="line"><span class="keyword">int</span> nr_scales_per_octave </span><br><span class="line">)</span><br><span class="line">   用于指定搜索关键点的尺度范围 </span><br><span class="line"><span class="comment">// Specify the range of scales over which to search for keypoints.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters</span></span><br><span class="line">      设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）</span><br><span class="line"><span class="comment">// min_scalethe standard deviation of the smallest scale in the scale space</span></span><br><span class="line">   高斯金字塔中组（octaves）的数目</span><br><span class="line"><span class="comment">// nr_octavesthe number of otaves (i.e. doublings of scale) to compute</span></span><br><span class="line">       每组计算的尺度数目</span><br><span class="line"><span class="comment">// nr_scales_per_octavethe number of scales to compute within each octave</span></span><br></pre></td></tr></table></figure><img src="F:\AFIGHT\笔记\PCL\assets\高斯金字塔sift算子关键点.png" alt="高斯金字塔sift算子关键点" style="zoom: 50%;" /></li></ul><h5 id="Harris-关键点提取"><a href="#Harris-关键点提取" class="headerlink" title="Harris 关键点提取"></a>Harris 关键点提取</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//harris_detector-&gt;setNonMaxSupression(true);</span></span><br><span class="line">harris_detector-&gt;setRadius(r_normal);<span class="comment">// 设置法向量估计的半径</span></span><br><span class="line">harris_detector-&gt;setRadiusSearch(r_keypoint);<span class="comment">// 设置关键点估计的近邻搜索半径</span></span><br><span class="line">harris_detector-&gt;setInputCloud (input_cloud);</span><br><span class="line"><span class="comment">//harris_detector-&gt;setNormals(normal_source);</span></span><br><span class="line"><span class="comment">//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);</span></span><br><span class="line">harris_detector-&gt;compute (*Harris_keypoints);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Harris_keypoints的大小是"</span>&lt;&lt;Harris_keypoints-&gt;size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">writer.write&lt;pcl::PointXYZI&gt; (<span class="string">"Harris_keypoints.pcd"</span>,*Harris_keypoints,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="特征描述与提取"><a href="#特征描述与提取" class="headerlink" title="特征描述与提取"></a>特征描述与提取</h2><h3 id="特征描述"><a href="#特征描述" class="headerlink" title="特征描述"></a>特征描述</h3><ul><li>局部特征描述 + 全局特征描述</li></ul><h3 id="特征描述子"><a href="#特征描述子" class="headerlink" title="特征描述子"></a>特征描述子</h3><p>三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有<strong>形状描述子（shape descriptors）</strong>、<strong>几何特征（gometric features）</strong>、<strong>点特征表示（point feature representations）</strong>等。</p><h4 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文 P23，37）</p><p>给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为：<br>$$<br>||p_i^k-p_q||_x \leq d_m \tag{1.1}<br>$$<br>式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见<a href="https://blog.csdn.net/skybirdhua1989/article/details/17584797" target="_blank" rel="noopener">范数</a>）。</p><p>此外，$P^k$ 中近邻点的个数可被限制为给定值 k。</p><p>点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围：<br>$$<br>F(p_q,P^k)={x_1,x_2,···,x_n}<br>$$<br>式中，$x_i$ , $i \in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。</p><p>比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\Gamma$ 为描述这两点之间差异的<strong>相似性度量</strong>，$d$ 为<strong>距离度量</strong>，则有：<br>$$<br>\Gamma = d(F_1,F_2)<br>$$<br>当 $d$ 趋向于某个最小值时，即 $d \to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。</p><p><em>个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。</em></p><p>通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。</p><p>理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣：</p><ul><li>刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有<strong>旋转平移不变性</strong></li><li>不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有<strong>抗密度干扰性</strong></li><li>噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有<strong>鲁棒性</strong></li></ul><p><em>也就是说，一个点特征表示满足上述条件才可以说是好的表示法</em></p><h4 id="邻域的概念"><a href="#邻域的概念" class="headerlink" title="邻域的概念"></a>邻域的概念</h4><p>确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方：<br>$$<br>||X||<em>2 = \sqrt{\sum</em>{i=1}^n x_i^2}<br>$$<br><em>可用于度量两个向量间的差异</em>，如平方差和：<br>$$<br>SSD(x_1,x_2) = \sum_{i=1}^n(x_{1i}-x_{2i})^2<br>$$<br>也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。</p><p>但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。</p><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><h4 id="输入点云的调用"><a href="#输入点云的调用" class="headerlink" title="输入点云的调用"></a>输入点云的调用</h4><ul><li><p>输入点云调用函数主要有：</p><ul><li><p>setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量</p></li><li><p>setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算</p></li><li><p>setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间</p></li><li><p>后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208）</p></li></ul><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Cfeatures_input_explained.png" alt="输入点云调用习惯">                </p><ul><li>经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。</li></ul></li></ul><h4 id="估计点云的表面法线"><a href="#估计点云的表面法线" class="headerlink" title="估计点云的表面法线"></a>估计点云的表面法线</h4><p>（详见博士论文 P45）</p><ul><li><p>描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线</p></li><li><p>一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②<code>直接从点云数据集中近似推断表面法线</code></p></li><li><p>对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中估计一点集对应的协方差矩阵</span></span><br><span class="line">Eigen::Matrix3f covariance_matrix;<span class="comment">// 定义每个表面小块的 3×3 协方差矩阵的存储对象</span></span><br><span class="line">Eigen::Vector4f xyz_controid;<span class="comment">// 定义一个表面小块的质心坐标16字节对其存储对象</span></span><br><span class="line">compute3DCentroid(cloud, xyz_controid);<span class="comment">// 估计质心坐标</span></span><br><span class="line">computeCovarianceMatrix(cloud, xyz_controid, covariance_matrix);<span class="comment">// 计算 3×3 协方差矩阵</span></span><br></pre></td></tr></table></figure></li></ul><p>一个平面可用一个点 $x$ 和 一个法向量 $\overline n$ 表示，则一个点 $p_i \in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \overline n$ 。 $x$ 和  $\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？）</p><p>设<br>$$<br>x = \overline p = \frac{1}{k}· \sum_{i=1}^{k}p_i<br>$$<br>为 $P^k$ 的质心，而 $\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \in R^{3 \times 3}$ 的特征值和特征向量得到，其表达式如下：<br>$$<br>C = \frac{1}{k} \sum_{i=1}^{k} \xi_i · (p_i - \overline p)·(p_i - \overline p)^T , \ C· \overline v_i = \lambda_i· \overline v_j ,  \  j \in {0,1,2}<br>$$<br>式中，$\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\lambda_j \in R$ ，特征向量 $\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \le \lambda_0 \le \lambda_1 \le \lambda_2$ ，则特征向量 $\overline v_0$ 对应的最小特征值 $\lambda_0$ 就是 $+ \overline n = {n_x,n_y,n_z}$ 或 $ - \overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\overline n$ 可由球坐标中的一对角 $(\phi,\theta)$ 表示如下：<br>$$<br>\phi = \arctan \frac{n_z}{n_y}, \ \theta =  \arctan\frac{\sqrt{(n_y^2+n_z^2)}}{n_x}<br>$$<br>问题是，这种主成分分析法（PCA）对方向仍然是模糊的。</p><h4 id="表面曲率"><a href="#表面曲率" class="headerlink" title="表面曲率"></a>表面曲率</h4><p>（详见博士论文P48）</p><p>方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\lambda_0 = min(\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\overline n$ 的变化可使用下式估计：<br>$$<br>\sigma_p = \frac{\lambda_0}{\lambda_0+\lambda_1+\lambda_3}<br>$$<br> 该最小特征值与特征值之和的比值 $\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。</p><p>source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998</p><h4 id="法线的定向问题"><a href="#法线的定向问题" class="headerlink" title="法线的定向问题"></a>法线的定向问题</h4><ul><li><p>没有数学方法可以解决法线的正负向问题</p></li><li><p>法线球体描述了点云中所有法线的方向</p></li><li><p>对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）</span></span><br><span class="line">flipNormalTowardsViewpoint(<span class="keyword">const</span> PointCloud &amp; cloud,</span><br><span class="line"><span class="keyword">float</span> vp_x,</span><br><span class="line"><span class="keyword">float</span> vp_y,</span><br><span class="line"><span class="keyword">float</span> vp_z,</span><br><span class="line">Normals &amp; normals </span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><ul><li>但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \cdot n_j = 1$。</li></ul><h3 id="点特征直方图（PFH）"><a href="#点特征直方图（PFH）" class="headerlink" title="点特征直方图（PFH）"></a>点特征直方图（PFH）</h3><p>（详见博士论文P51和PCL书P213）</p><p>bin 可理解为分格的大小，就是直方图每一个柱子的宽度</p><h4 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h4><p>通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。</p><p>一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。</p><p>为形成新的特征空间，引入 <em>双环邻域</em>  的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \in P$ 有双环邻域的条件是：<br>$$<br>(\exists)r_1,r_2 \in R, \ r_1 &lt;r_2,  \ \begin{cases} r_1  \Rightarrow P^{k_1} \ r_2 \Rightarrow P^{k_2}\end{cases}, \ 0&lt;k_1&lt;k_2<br>$$<br>两个半径 $r_1$ 和 $r_2$ 用于确定点 $p_i$ 的两个不同的特征表示层：第一层表示的是查询点处的法线，从邻域集 $p^{k_1}$ 的主成分分析中获得，第二层即为 PFH。</p><p>PFH 是基于 $P_{k_2} $ 中的点及其法线之间的关系的，即通过参数化查询点与邻域点之间的空间差异，形成一个多维直方图对点的 k 邻域几何属性进行描述。直方图所在的高维超空间为特征表示提供了一个可度量的信息空间，对点云对应曲面的 6 维姿态来说它具有不变性，并且在不同的采样密度或邻域的噪音等级下具有鲁棒性。简言之，<strong>它考虑估计法线方向之间所有的相互作用，来尽可能捕获采样表面的变化</strong>。故合成的超空间依赖于每个点表面法线估计的质量。（人话就是：PFH 结果的优劣，取决于法线估计的好坏，这也说明，计算 PFH 的第一步就是表面法线的估计）</p><p>为计算两点 $p_i$ 和 $p_j$ 之间的相对差以及它们的法线 $n_i$ 和 $n_j$，在其中一点上定义了一个固定的局部坐标系。为使坐标系被唯一定义，做如下规定： 令 $p_{ji} = p_j - p_i, \ p_{ij} = p_i - p_j$ ，<br>$$<br>if \quad \arccos(\overline n_i \cdot \overline p_{ji}) \le \arccos(\overline n_j \cdot \overline p_{ij})<br>\ then \begin{cases} p_s = p_i,\ n_s =n_i \ p_t = p_j, \ n_t = n_j  \end{cases}<br>\ else \begin{cases} p_s = p_j,\ n_s =n_j \ p_t = p_i, \ n_t = n_i  \end{cases}<br>$$<br>定义 $p_s$ 为源点，$p_t$ 为目标点，源点的选择使其法线与连接两点的直线之间的夹角最小。然后，可以在 $p_s$ 处将局部坐标系的原点定义为：<br>$$<br>\begin{cases} u = n_s \ v= u \times \frac{(p_t - p_s)}{||p_t - p_s||_2} \ w = u \times v\end{cases}<br>$$<br>在该 uvw 坐标系下，两个法线 $n_s$ 和 $n_t$ 之间的差可以表示为一组角度特征，如下:<br>$$<br>\begin{cases} \alpha = v \cdot n_t \ \phi = u \cdot \frac{(p_t-p_s)}{d} \ \theta = \arctan(w \cdot n_t,u \cdot n_t)\end{cases}<br>$$<br>式中，d 为欧氏距离，$d= ||p_t-p_s||_2$ 。</p><p>这样，就只需计算近邻点集 $P^{k_2}$ 中每一对点的特征组成的四个参数 $&lt;\alpha,\phi,\theta,d&gt;$ （将其称为四元组），将原来的12（一个点有 $x,y,z,n_x,n_y,n_z$ (坐标及法线)）个参数减少到了4个。(在一般的实际问题中，d 往往不计在内，实验证明，不计在内效果更好)</p><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CPFH%E5%B1%80%E9%83%A8%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="PFH坐标系"></p><p>下图是计算查询点 $p_q$ 的 PFH 时的影响区域图，查询半径（图中虚线，2D 中圆，3D中球）为 $r$ ，可见其 k 近邻点用网格完全互连。</p><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CPFH%E5%8C%BA%E5%9F%9F%E5%BD%B1%E5%93%8D%E5%9B%BE.png" alt="PFH影响区域图"></p><p>为创建查询点 $p_i$ 的 PFH 表示，先将所有的四元组放进直方图，这个过程将每个特征的取值范围划分为 b 个子区域，并统计每个子区间中的特征出现次数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每一对点估计 PFH 四元组</span></span><br><span class="line">computePairFeatures (<span class="keyword">const</span> pcl::PointCloud&lt;PointInT&gt; &amp; cloud, <span class="keyword">const</span> pcl::PointCloud&lt; PointNT &gt; &amp; normals,</span><br><span class="line"><span class="keyword">int</span> p_idx,</span><br><span class="line"><span class="keyword">int</span> q_idx,</span><br><span class="line"><span class="keyword">float</span> &amp; f1,</span><br><span class="line"><span class="keyword">float</span> &amp; f2,</span><br><span class="line"><span class="keyword">float</span> &amp; f3,</span><br><span class="line"><span class="keyword">float</span> &amp; f4 </span><br><span class="line">)</span><br><span class="line">Compute the <span class="number">4</span>-tuple representation containing the three angles <span class="keyword">and</span> one distance between two points represented by Cartesian coordinates <span class="keyword">and</span> normals.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters 参照上图的坐标系理解</span></span><br><span class="line">[in]cloudthe dataset containing the XYZ Cartesian coordinates of the two points <span class="comment">//输入点云</span></span><br><span class="line">[in]<span class="function">normalsthe dataset containing the surface <span class="title">normals</span> <span class="params">(assuming normalized vectors)</span> at each point in cloud <span class="comment">//法线</span></span></span><br><span class="line">[in]p_idxthe index of the first point (source)  // 源点</span><br><span class="line">[in]<span class="function">q_idxthe index of the second <span class="title">point</span> <span class="params">(target)</span> <span class="comment">// 目标点</span></span></span><br><span class="line">[out]f1the first angular feature (angle between the projection of nq_idx and u) // θ</span><br><span class="line">[out]<span class="function">f2the second angular <span class="title">feature</span> <span class="params">(angle between nq_idx <span class="keyword">and</span> v)</span><span class="comment">// α</span></span></span><br><span class="line">[out]f3the third angular feature (angle between np_idx and |p_idx - q_idx|) // Φ</span><br><span class="line">[out]<span class="function">f4the distance <span class="title">feature</span> <span class="params">(p_idx - q_idx)</span>  <span class="comment">// d 距离</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PFH 特征估计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the PFH estimation class, and pass the input dataset+normals to it</span></span><br><span class="line">pcl::PFHEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PFHSignature125&gt; pfh; <span class="comment">//125是3个角特征量，每个又分为5个区间，故5^3</span></span><br><span class="line"><span class="comment">// 这里的 125 是默认值，也就是直接忽略了 d 的</span></span><br><span class="line">pfh.setInputCloud (cloud);</span><br><span class="line">pfh.setInputNormals (normals);</span><br><span class="line"><span class="comment">// 若点云类型是 PointNormal, pfh.setInputNormals (cloud);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an empty kdtree representation, and pass it to the PFH estimation object.</span></span><br><span class="line"><span class="comment">// Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">pfh.setSearchMethod (tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output datasets</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PFHSignature125&gt;::<span class="function">Ptr <span class="title">pfhs</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PFHSignature125&gt; ())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use all neighbors in a sphere of radius 5cm</span></span><br><span class="line"><span class="comment">// IMPORTANT: the radius used here has to be larger than the radius used to estimate the surface normals!!!</span></span><br><span class="line">pfh.setRadiusSearch (<span class="number">0.05</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the features</span></span><br><span class="line">pfh.compute (*pfhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pfhs-&gt;size () should have the same size as the input cloud-&gt;size ()*，即每个点对应一个 PFH特征向量</span></span><br><span class="line"><span class="comment">// 实质上，该函数只是执行了以下步骤：</span></span><br><span class="line">对点云 P 中的每个点 p</span><br><span class="line">（<span class="number">1</span>）得到p点的最近邻元素</span><br><span class="line">（<span class="number">2</span>）对于邻域内的每对点，计算其三个角度特征参数值</span><br><span class="line">（<span class="number">3</span>）将所有结果统计到一个输出直方图中</span><br></pre></td></tr></table></figure><h3 id="快速点特征直方图（FPFH）"><a href="#快速点特征直方图（FPFH）" class="headerlink" title="快速点特征直方图（FPFH）"></a>快速点特征直方图（FPFH）</h3><p>PFH 在计算中的复杂度用大O表示法表示的话为 $O(n k^2)$ ，不利于实时应用，需优化，FPFH 将复杂度降低为 $O(nk)$ ，同时保留了前者的识别特性。</p><h4 id="理论-3"><a href="#理论-3" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文P57和PCL书P217）</p><p>首先，对每个查询点 $p_q$ ，计算该点及其近邻点的元组 $&lt;\alpha,\phi,\theta&gt;$ ，这一步称为简化点特征直方图（SPFH），图中红线表示；</p><p>接着，重新确定每个点（这个点已经是 $p_q$ 的近邻点）的 k 近邻点，使用近邻点的 SPFH 值作为权重计算查询点 $p_q$ 的最终直方图，即为 FPFH：<br>$$<br>FPFH(p_q) = SPFH(p_q) + \frac{1}{k} \sum_{i=1}^{k} \frac{1}{\omega_k} \cdot SPFH(p_k)<br>$$<br>式中，权重 $\omega_k$ 表示在给定的度量空间中，查询点 $p_q$ 与近邻点 $p_k$ 之间的距离，用于评价点对 $(p_q,p_k)$ ，其影响区域图如下士，每个查询点(红色)只与它的k近邻点(由灰色圈包围)相连。每个直接近邻点又与自己的近邻点相连，所得到的直方图与查询点的直方图进行加权，形成FPFH。用粗线画出的是对 FPFH 计算了两次。</p><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CFPFH%E5%8C%BA%E5%9F%9F%E5%BD%B1%E5%93%8D%E5%9B%BE.png" alt="FPFH区域影响图"></p><p>人话翻译：确定一个查询点，接着找出该查询点的近邻点，计算其参数元组（三个角度参数），（这个过程为 SPFH）然后对找到的所有近邻点，重新作为查询点，找到其近邻点，计算其 SPFH，然后使用上式进行加权，得到 FPFH。</p><p>关于 FPH 和 FPFH 的区别，这里略。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>与 FPH 不同的是，FPFHEstimation 类的默认特征是将四个角特征量每个分为11个区间，分别计算后合并，形成有 33 个元素的特征向量。</p><h2 id="点云配准"><a href="#点云配准" class="headerlink" title="点云配准"></a>点云配准</h2><ul><li>各个视角得到的点集合并到一个统一的坐标系下，形成完整的点云数据的过程 / 操作</li><li>实质：不同坐标系中测到点云之间的<code>坐标变换</code> （寻找 R T 的过程）(==错==)</li><li>实质是：同一坐标系下不同视角的点云之间的配准，即测量设备始终是同一个，得到的点云在同一个坐标下</li></ul><p>点云配准的过程是一个寻找刚性变换矩阵的过程，对于两个点云，一个为源点云 $P_s$ ，另一个为目标点云 $P_t$ ，将源点云通过一定的旋转（R）和平移（t）与目标点云配准（就是让它们完全重合），这个过程可表述为：<br>$$<br>P_t = P_s \cdot R + t<br>$$</p><h3 id="一对点云的配准（两两配准）"><a href="#一对点云的配准（两两配准）" class="headerlink" title="一对点云的配准（两两配准）"></a>一对点云的配准（两两配准）</h3><ul><li>应用一个估计得到一个变换矩阵（R T）使两者完美配准</li><li>步骤：<ul><li><strong>从两个点云提取关键点，注意使用相同的标准</strong></li><li><strong>对所有关键点建立其特征描述子</strong></li><li>估计对应关系，结合特征描述子在两个数据集中的坐标位置等进行</li><li>如含噪声，则去除对配准有影响的对应点</li><li>用剩下的正确点对估计刚体变换，完成配准</li></ul></li></ul><img src="F:\AFIGHT\笔记\PCL\assets\block_diagram_single_iteration.jpg" alt="一对点云配对" style="zoom: 67%;" /><h3 id="对应估计"><a href="#对应估计" class="headerlink" title="对应估计"></a>对应估计</h3><ul><li>找到相似特征，确定数据重叠部分，进行配准</li><li>使用不同方法来搜索特征之间的对应关系<ul><li>点匹配（即只使用xyz坐标作为特征值）：穷举配准、k-d tree 最近邻查询、有序点云的图像空间查找、无序点云的索引空间查找</li><li>特征匹配（如法向量、形状直方图等）：穷举配准、k-d tree 最近邻查询</li></ul></li><li>分类<ul><li>直接对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点，确认为最终的对应点对（这是默认的估计方式）</li><li>相互对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点；接着对对点云 B 中的每个点，都找到其在点云 A 中的对应点，然后取它们的交集作为最终的对应点对</li></ul></li></ul><h3 id="错误对应关系的去除"><a href="#错误对应关系的去除" class="headerlink" title="错误对应关系的去除"></a>错误对应关系的去除</h3><p>实际中存在着噪声等影响，会导致产生的对应关系不一定是正确的（就是虽然算法找到了对应点对，但其在实际中可能并不是对应的），这些会对最终变换矩阵的估算产生影响，须去除它们，可以提高配准精度和速度。</p><p>去除方法：随机采样一致性（RANSAC）等</p><p>一对多 的情况：只取距离最近的对应点</p><h3 id="ICP算法"><a href="#ICP算法" class="headerlink" title="ICP算法"></a>ICP算法</h3><h4 id="理论-4"><a href="#理论-4" class="headerlink" title="理论"></a>理论</h4><p>无序点云最经典的配准算法——ICP 算法（ Iterative Closest Point ）：通过最小化重叠区域之间的欧氏距离误差度量，来寻找两数据集之间的最优变换。ICP 算法假定两数据集的每个点都有相应的匹配，并使用待匹配与模型之间最近的点做对应。但问题是，两个点云之间不可能是完全的一一对应关系，所以要建立稳定的对应关系显得尤为重要。</p><p>ICP 的核心是不断的去寻找源点云和目标点云中点对的最小距离，并不断缩小这个距离，对变换后的点云继续重复该过程，也就是迭代的过程；该过程用数学表达就是求出 R 和 t ,使误差函数取得最小值：<br>$$<br>E(R,t) = \frac{1}{n} \sum_{i=1}^{n} ||P_t^i -(R \cdot P_s^i+t)||^2<br>$$<br>式中，n 是点对的个数，也就是说，这个目标函数是所有点对之间的欧氏距离的平方和。</p><p>==ICP 选择点对原则：对于源点云中的每个点，其对应点是目标点云中的最近邻点（按欧氏距离计算）==</p><p>主要步骤：[1]解则晓, 徐尚. 三维点云数据拼接中ICP及其改进算法综述[J]. 中国海洋大学学报(自然科学版).</p><ul><li>对原始点云数据采样</li><li>确定初始对应点集</li><li>去除错误对应点对</li><li>求解坐标变换</li></ul><p>ICP的主要问题在于搜索近邻点，这个过程耗时严重，为加速该过程，一般将目标点云存储到 k-d tree 结构中。</p><h4 id="简单ICP代码"><a href="#简单ICP代码" class="headerlink" title="简单ICP代码"></a>简单ICP代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp; <span class="comment">// 创建ICP 对象</span></span><br><span class="line">icp.setInputSource(cloud_in);<span class="comment">// 设置一个输入点云作为 源点云</span></span><br><span class="line">icp.setInputTarget(cloud_out);<span class="comment">// 设置一个输入点云作为 目标点云</span></span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt; Final;<span class="comment">// 存储最终的匹配结果</span></span><br><span class="line">icp.align(Final);  <span class="comment">// 执行匹配</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"has converged:"</span> &lt;&lt; icp.hasConverged() &lt;&lt; <span class="string">" score: "</span> &lt;&lt; <span class="comment">// 匹配是否正确，返回值为 1 则为正确</span></span><br><span class="line">icp.getFitnessScore() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 理解为对 配准的评分</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; icp.getFinalTransformation() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 获取转换矩阵</span></span><br></pre></td></tr></table></figure><h4 id="逐步匹配多幅点云"><a href="#逐步匹配多幅点云" class="headerlink" title="逐步匹配多幅点云"></a>逐步匹配多幅点云</h4><p>按输入的顺序两两匹配，得到最终的效果，结果是最终转换到第一个点云的坐标系下</p><h4 id="交互式ICP"><a href="#交互式ICP" class="headerlink" title="交互式ICP"></a>交互式ICP</h4><p>通过可视化界面实现用户敲空格键时，进行配准，需在内部设置 ICP 迭代次数</p><p><a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/interactive_icp.html#interactive-icp" target="_blank" rel="noopener">详见Interactive Iterative Closest Point — Point Cloud Library 0.0 documentation (pcl.readthedocs.io)</a></p><h3 id="正态分布变换配准（NDT）"><a href="#正态分布变换配准（NDT）" class="headerlink" title="正态分布变换配准（NDT）"></a>正态分布变换配准（NDT）</h3><ul><li>适用于大型点云数据集</li><li>配准过程不使用对应点的特征计算及匹配，速度快</li><li>NDT 算法中，在目标点云对应的体素网格数据结构的统计计算中不使用单个点，而是使用包含在每个体素单元格中的点的统计数据</li><li>使用体素化数据结构 + More-Thuente 搜索</li></ul><p>NDT 核心：</p><ul><li><p>将空间划分为网格（2D 中为正方形，3D 中为立方体）</p><p>基于网格内的点分布，计算每个网格的概率密度分布（PDF）。每个网格中的 PDF 可理解为每个网格内曲面上的点 $\overline x$ 的生成过程；也就是说，假设 $\overline x$ 的位置是由 D 维的正态随机过程生成的</p></li></ul><h4 id="理论-5"><a href="#理论-5" class="headerlink" title="理论"></a>理论</h4><p>（详见：Magnusson M. The three-dimensional normal-distributions transform: an efficient representation for registration, surface analysis, and loop detection[D]. Örebro universitet, 2009. 从P55开始</p><p><a href="https://blog.csdn.net/banzhuan133/article/details/103350049?spm=1001.2014.3001.5501" target="_blank" rel="noopener">两种常见的点云配准方法ICP&amp;NDT_banzhuan133的博客-CSDN博客_ndt点云配准</a>）</p><p>对于一个随机（多维）变量，若其满足正态分布，则其对应的 PDF 为：（对应于点云：将目标点云网格化，然后计算每个网格内的多维正态分布）<br>$$<br>p(\vec{x}) = \frac{1}{(2 \pi)^{D/2} \sqrt{\Sigma}} exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1} (\vec{x}-\vec{\mu})}{2})<br>$$<br>式中，$\vec{\mu}$ 为均值向量，$\Sigma$ 为协方差矩阵（对角元素为每个变量的方差，非对角元素为协方差），$D$ 为维数。</p><p>$\vec{\mu}$ 和 $\Sigma$ 可单独计算：<br>$$<br>\vec{\mu} = \frac{1}{m} \sum_{k=1}^{m} \vec{y_k} \<br>\quad \quad \quad \quad \quad \quad \quad \quad\Sigma = \frac{1}{m-1} \sum_{k=1}^{m}    (\vec{y_k}-\vec{\mu})(\vec{y_k}-\vec{\mu})^T<br>$$<br>式中的 $\vec{y}_{1, \cdots ,m}$ 表示一个网格中所有的点。（也就是说，上式中的 $p(\vec{x})$ 实质是计算每个网格的 PDF ）</p><img src="F:\AFIGHT\笔记\PCL\assets\NDT体素格.png" alt="NDT网格化" style="zoom:50%;" /><p>使用正态分布表示离散点云的优势在于：正态分布是对点云的分段（分块表示，网格）平滑表示，具有连续的导数；每个 PDF 可看作是局部表面的一种近似，描述了该表面的位置、方向、平滑度。在 2D 或 3D 中 ，表面方向和平滑度可用协方差矩阵的特征向量和特征值表示。对于三维的正态分布，随着 $\Sigma$ 的特征值变化，有着不同的形状（图中箭头表示特征向量，长短表示其特征值的大小）</p><p>![3D 正态分布下的不同形状](F:\AFIGHT\笔记\PCL\assets\Differ shape of 3D PDF.png)</p><h4 id="NDT-配准"><a href="#NDT-配准" class="headerlink" title="NDT 配准"></a>NDT 配准</h4><p>NDT 的配准目标是找到一个源点云的姿态，使源点云中的点位于目标点云平面上的可能性最大。（△）</p><p>若源点云为 $\chi = { \vec{x_1}, \cdots , \vec{x_n} }$ ，其姿态变换（R，T）用一个向量 $\vec{p}$ 表示；假设空间变换函数 $T(\vec{p},\vec{x})$ 表示使用姿态变换 $\vec{p}$ 来移动点 $\vec{x}$ ；另外给定源点云的 $PDF \quad p(\vec{x})$ ，则最优位姿 $\vec{p}$ 应是使似然函数最大化：<br>$$<br>\Psi = \prod_{k=1}^{n} p(T(\vec{p}, \vec{x}<em>k))<br>$$<br>其等价于最小化 $\Psi$ 的负对数似然函数（连乘转对数的和）：<br>$$<br>-log\Psi  = - \sum</em>{k=1}^{n} log(p(T(\vec{p},\vec{x}_k)))<br>$$<br>式中的函数 $p$ 即为上述提到的 $PDF \quad  p(\vec{x})$ 。此外，PDF 也不一定是一个正态分布（只要可以局部捕获表面点结构，且对异常值具有鲁棒性即可）（详见P59）。</p><p><em>这也再次说明了我们的第一句话（△）：目的就是找到这个最优的  $\vec{p}$ ，以最大化似然函数（目标函数）</em></p><p>目标很明确，就是优化这个位姿参数，NDT 使用 牛顿迭代法进行优化（见后续）。</p><p>问题是，负对数似然函数在远离均值的点上呈无限增长的趋势（见P59 图6.5b或下图)，故若数据中存在噪声等异常值，会对其结果产生较大的影响，有人提出了<strong>正态分布与均匀分布结合（$\overline p(\vec{x})$）</strong>的方式：<br>$$<br>\overline p(\vec{x}) = c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2p_0<br>$$<br>式中，$p_0$ 为异常值的期望值。利用这个函数，离群值的影响是有限的。常数 $c_1$ 和 $c_2$ 可以通过要求在单元格所跨越的空间内 $\overline p(\vec{x})$ 的概率质量等于1来确定。</p><p>另一个问题是，这种结合的方式没有简单的一阶和二阶导数（其实就是 log 函数求导不方便）；观察负对数似然函数（下图右绿色示），可发现其与高斯函数相像（下图左绿色示），故可用高斯函数来近似上述 $\overline p(\vec{x})$  。</p><img src="F:\AFIGHT\笔记\PCL\assets\likelihood.png" alt="likelihood" style="zoom: 67%;" /><p>$\overline p(\vec{x})$ 对应的 log 形式为（这里 $c_2p_0$ 只剩 $c_2$ ，个人理解为其是一个期望值，是常数，可用一个代替？）：<br>$$<br>-\log (c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2)<br>$$<br>函数形式为<br>$$<br>\overline p(x) = - \log(c_1 exp(\frac{-x^2}{2 \sigma ^2}) + c_2)<br>$$<br>的函数可用形式如下的高斯函数近似：<br>$$<br>\tilde{p}(x) = d_1 exp(\frac{-d_2 x^2}{2 \sigma^2}) + d_3<br>$$<br>当 $x=1，x=\sigma，x = \infty$ 时，$\overline p(x)$ 应与 $\tilde p(x)$ 相等，以此来拟合 $d_i$ ：<br>$$<br>d_3 = - \log(c_2) \<br>d_1 = - \log(c_1 + c_2) -d_3 \<br>d_2 = -2 \log(\frac{-\log(c_1 e^{- \frac{1}{2}} + c_2 -d_3)} {d_1})<br>$$<br>如此，源点云中的一点对 NDT 评分函数的影响可用高斯函数近似为：<br>$$<br>\tilde p(\vec{x}_k) = -d_1 exp(- \frac{d_2}{2} (\vec{x}_k - \vec{\mu}_k)^T \Sigma_k^{-1} (\vec{x}_k - \vec{\mu}_k))<br>$$<br>这里忽略了常数 $d_3$ ，因其只是对评分函数进行了一个偏移，但并不影响其形状或参数。</p><p>到此，目标函数变为：<br>$$<br>s(\vec{p}) = - \sum_{k=1}^{n} \tilde{p}(T(\vec{p},\vec{x}_k))<br>$$<br><em>所以上述过程就是将源点云的 PDF $p(x)$ 用  $\tilde{p}(x)$ 近似的过程，最后得到的近似表示如上</em></p><p>可以看出，似然函数需要求 $\Sigma^{-1}$ ，但若网格内的点是完全共面或共线，则 $\Sigma$ 是奇异的，无法求逆（详见P60）。</p><p>位姿参数 $\vec{p}$ 可用牛顿迭代法求解，其方程为：<br>$$<br>H \Delta \vec{p} = - \vec{g}<br>$$<br>式中，$H$ 为海森矩阵，$\vec{g}$ 为 $s(\vec{p})$ 的梯度向量，$\Delta \vec{p}$ 在每次迭代过程中加到当前的位姿估计中，即 $\vec{p} \leftarrow \vec{p} + \Delta \vec{p}$ 。 （具体求解详见P61)</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在 NDT 配准前需要进行滤波处理，这里使用体素中心网格法</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">filtered_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::ApproximateVoxelGrid&lt;pcl::PointXYZ&gt; approximate_voxel_filter;</span><br><span class="line">approximate_voxel_filter.setLeafSize(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>);</span><br><span class="line">approximate_voxel_filter.setInputCloud(input_cloud);</span><br><span class="line">approximate_voxel_filter.filter(*filtered_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NDT 参数初始化</span></span><br><span class="line">pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;</span><br><span class="line">ndt.setTransformationEpsilon(<span class="number">0.01</span>);<span class="comment">//设置变换的ε：两个连续的变换(迭代)之间允许的最大差值，用于判断优化过程是否达到最终的阈值</span></span><br><span class="line">ndt.setStepSize(<span class="number">0.1</span>);<span class="comment">//牛顿法优化的最大步长（收敛速率系数，理解为什么时候终止？？）</span></span><br><span class="line">ndt.setResolution(<span class="number">1.0</span>);<span class="comment">//分辨率设置，也就是体素化网格的边长</span></span><br><span class="line">ndt.setMaximumIterations(<span class="number">35</span>);<span class="comment">//迭代的次数：达到该次数时停止</span></span><br><span class="line">ndt.setInputSource(filtered_cloud);</span><br><span class="line">ndt.setInputTarget(target_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化变换参数并执行优化</span></span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation</span><span class="params">(<span class="number">0.6931</span>, Eigen::Vector3f::UnitZ())</span></span>;<span class="comment">//初始位姿 R</span></span><br><span class="line"><span class="function">Eigen::Translation3f <span class="title">init_translation</span> <span class="params">(<span class="number">1.79387</span>, <span class="number">0.720047</span>, <span class="number">0</span>)</span></span>; <span class="comment">// T</span></span><br><span class="line">Eigen::Matrix4f init_guess = (init_translation * init_rotation).matrix(); <span class="comment">//初始搜索位置</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">output_cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">ndt.align(*output_cloud, init_guess);<span class="comment">//执行配准</span></span><br></pre></td></tr></table></figure><h2 id="点云分割"><a href="#点云分割" class="headerlink" title="点云分割"></a>点云分割</h2><ul><li>根据空间、几何、纹理等特征对点云进行划分，使得同一划分内的点云具有相似的特征</li></ul><h3 id="聚类分割算法"><a href="#聚类分割算法" class="headerlink" title="聚类分割算法"></a>聚类分割算法</h3><ul><li>详见下一章——论文：聚类与分割</li><li>m 个数据，m 维空间内，定义点与点之间的某种性质的亲属聚类；若 m 个数据点构成 n 类，将具有最小距离的两类合为一类，然乎重新计算两类的之间的距离，如此迭代，直至两类之间的距离大于指定的阈值，或者类的个数少于指定的数目，完成分割。</li></ul><h3 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h3><ul><li>随机采样一致性<ul><li>从样本中随机抽取一个样本子集，使用最小方差估计法对自己进行模型参数的计算，再计算所有样本与该模型的偏差，将该偏差与设置好的阈值进行比较，若其小于设定的阈值，则为内点，否则为外点</li></ul></li><li>根据一组包含噪声、外点等缺陷的样本数据集，估计出数据的数学模型，同时得到有效的样本数据</li><li>参数<ul><li>$\tau$ ：误差容忍度，判断样本是否满足模型 M 的误差容忍度</li><li>$Max$ ：随机抽取样本集的次数（即抽取子集的次数）</li><li>$N$ ：指定的阈值</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">model_p</span><span class="params">(<span class="keyword">new</span> pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;(cloud))</span></span>;<span class="comment">//定义为平面模型（还有其他模型）</span></span><br><span class="line"><span class="function">pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; <span class="title">ransac</span><span class="params">(model_p)</span></span>;</span><br><span class="line">ransac.setDistanceThreshold(<span class="number">.01</span>);<span class="comment">//阈值设置</span></span><br><span class="line">ransac.computeModel();<span class="comment">//计算模型</span></span><br><span class="line">ransac.getInliers(inliers);<span class="comment">//获取内点</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Algorithm : RANSAC</span><br><span class="line">1) Initial: let A be a set of N feature correspondences</span><br><span class="line">2) repeat</span><br><span class="line">2.1) Randomly select a sample of s points from A</span><br><span class="line">2.2) Fit a model to these points</span><br><span class="line">2.3) Compute the distance of all other points to this model</span><br><span class="line">2.4) Construct the inlier set (i.e. count the number of points  whose distance from the model &lt; d)</span><br><span class="line">2.5) Store these inliers</span><br><span class="line">2.6) until maximum number of iterations reached</span><br><span class="line">3) The set with the maximum number of inliers is chosen as</span><br><span class="line">a solution to the problem</span><br><span class="line">4) Estimate the model using all the inliers</span><br></pre></td></tr></table></figure><h3 id="平面点云分割"><a href="#平面点云分割" class="headerlink" title="平面点云分割"></a>平面点云分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//模型系数对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;<span class="comment">//内点对象</span></span><br><span class="line">pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;<span class="comment">// Create the segmentation object，点云分割对象</span></span><br><span class="line">seg.setOptimizeCoefficients(<span class="literal">true</span>);<span class="comment">// Optional，可选项，设置是否优化系数</span></span><br><span class="line">seg.setModelType(pcl::SACMODEL_PLANE);<span class="comment">// Mandatory，必选项，设置分割类型</span></span><br><span class="line">seg.setMethodType(pcl::SAC_RANSAC);<span class="comment">// Mandatory，设置分割方法</span></span><br><span class="line">seg.setDistanceThreshold(<span class="number">0.01</span>);<span class="comment">// Mandatory，设置距离阈值</span></span><br><span class="line">seg.setInputCloud(cloud);</span><br><span class="line">seg.segment(*inliers, *coefficients);<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure><h3 id="圆柱体模型分割"><a href="#圆柱体模型分割" class="headerlink" title="圆柱体模型分割"></a>圆柱体模型分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seg.setOptimizeCoefficients(<span class="literal">true</span>);</span><br><span class="line">seg.setModelType(pcl::SACMODEL_CYLINDER);</span><br><span class="line">seg.setMethodType(pcl::SAC_RANSAC);</span><br><span class="line">seg.setNormalDistanceWeight(<span class="number">0.1</span>);</span><br><span class="line">seg.setMaxIterations(<span class="number">10000</span>);</span><br><span class="line">seg.setDistanceThreshold(<span class="number">0.05</span>);</span><br><span class="line">seg.setRadiusLimits(<span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">seg.setInputCloud(cloud_filtered2);</span><br><span class="line">seg.setInputNormals(cloud_normals2);</span><br><span class="line">seg.segment(*inliers_cylinder, *coefficients_cylinder);</span><br></pre></td></tr></table></figure><h3 id="欧式聚类提取"><a href="#欧式聚类提取" class="headerlink" title="欧式聚类提取"></a>欧式聚类提取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.setClusterTolerance(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.setMinClusterSize(<span class="number">100</span>);</span><br><span class="line">ec.setMaxClusterSize(<span class="number">25000</span>);</span><br><span class="line">ec.setSearchMethod(tree);<span class="comment">//kd-tree</span></span><br><span class="line">ec.setInputCloud(cloud_filtered);</span><br><span class="line">ec.extract(cluster_indices);</span><br></pre></td></tr></table></figure><h3 id="区域生长分割"><a href="#区域生长分割" class="headerlink" title="区域生长分割"></a>区域生长分割</h3><ul><li><p>从曲率最小的点开始生长（初始种子点）</p></li><li><p>输出是一个聚类集合，每个聚类集合属于同一光滑表面的一部分</p></li><li><p>基本思想：</p><p>根据输入点的曲率值对点排序，曲率最小的点为初始种子点，该点所在的区域为最平滑区域，也就是从最平滑区域开始生长，减少分割区域的总数，提高效率。</p></li><li><p>核心：比较近邻点与种子点之间的两个指标</p><ul><li>法线夹角的比较：小于设定的阈值进入区域，即为同一类（满足此条件时进入下一步的判断）</li><li>曲率大小的比较：小于设定的阈值进入序列（这是为何进行排序的原因，形成一个种子序列，每完成一次比较，删除当前的种子点，使用序列中的下一个种子点继续进行比较，如此迭代）</li><li>还需设定一个最小点簇数和最大点簇数</li><li>种子序列为空时意味着算法完成了区域增长，从头开始进行重复上述过程</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::RegionGrowing&lt;pcl::PointXYZ, pcl::Normal&gt; reg;</span><br><span class="line">reg.setMinClusterSize(<span class="number">50</span>);</span><br><span class="line">reg.setMaxClusterSize(<span class="number">1000000</span>);</span><br><span class="line">reg.setSearchMethod(tree);</span><br><span class="line">reg.setNumberOfNeighbours(<span class="number">30</span>);</span><br><span class="line">reg.setInputCloud(cloud);</span><br><span class="line"><span class="comment">//reg.setIndices (indices);</span></span><br><span class="line">reg.setInputNormals(normals);</span><br><span class="line">reg.setSmoothnessThreshold(<span class="number">3.0</span> / <span class="number">180.0</span> * M_PI);<span class="comment">// 平滑阈值</span></span><br><span class="line">reg.setCurvatureThreshold(<span class="number">1.0</span>);<span class="comment">//曲率阈值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;pcl::PointIndices&gt; clusters;</span><br><span class="line">reg.extract(clusters);<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure><h3 id="超体素点云分割（VCCS）"><a href="#超体素点云分割（VCCS）" class="headerlink" title="超体素点云分割（VCCS）"></a>超体素点云分割（VCCS）</h3><ul><li>空间八叉树结构 + k-mean 聚类的区域增长 直接对点云进行超体素分割</li><li>超体素特征：<ul><li>在3D空间中，均匀分布（可通过在点云空间中均匀设定种子达到）</li><li>除非在体素空间上相连，否则超体素不能跨越边界</li></ul></li><li>在空间分辨率为 $R_{seed}$ 的三维空间网格中，对均匀分布在空间中的种子点进行增长形成超体素。这里为提高搜索效率，只考虑以种子为中心的半径为 $R_{seed}$ 区域内的点。</li></ul><p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Cvoxel_segmentation.png" alt="超体素分割"></p><h2 id="论文：聚类与分割"><a href="#论文：聚类与分割" class="headerlink" title="论文：聚类与分割"></a>论文：聚类与分割</h2><ul><li>聚类（clustering）将数据集中的样本划分为不相交的子集，每个子集成为一个“簇（cluster）”    </li><li>聚类过程形成簇结构</li><li>簇标记（cluster label）</li></ul><h3 id="拟合简化的集合模型（平面模型）"><a href="#拟合简化的集合模型（平面模型）" class="headerlink" title="拟合简化的集合模型（平面模型）"></a>拟合简化的集合模型（平面模型）</h3><ul><li>不共线的三点确定一个平面，故先从点云 $\mathcal{P}$ 中随机选取不共线的三点 ${p_i,p_j,p_k}$ </li><li>根据选定的三个点计算平面模型系数（$ax+by+cz+d=0$）（可根据克莱姆法则计算，详见 <a href="https://en.wikipedia.org/wiki/Plane_(geometry)" target="_blank" rel="noopener">Plane (geometry) - Wikipedia</a>）</li><li>计算点云 $\mathcal{P}$ 中所有点 $p$ 到该平面模型的距离（$p_n \quad (a,b,c,d)$）</li><li>保存距离在指定阈值内的点 $p^* \in \mathcal{P}$，并计算其个数 </li></ul><p>上述的最后一步表示对模型的评分；每个点集 $p^<em>$ 都会被保存，且上述步骤会重复（迭代） $k$ 次。算法终止后，点的数量最多的点集（内点），就是对平面模型描述最好的点集（能最好的拟合平面模型）。对所有的点 $p^</em> \in \mathcal{P}$ ，平面模型系数用最小二乘估计。</p><p>上述过程就是找到内点集 $p^*$，拟合出平面或者估计出其2D边界多边形的简化过程，在实际应用中，还需增加额外的约束条件。</p><h3 id="基本聚类技术"><a href="#基本聚类技术" class="headerlink" title="基本聚类技术"></a>基本聚类技术</h3><ul><li><p>依赖于空间分解技术，基于给定的标准，寻找分块及边界，实现分类</p></li><li><p>评判标准：闵氏范数：曼哈顿距离（L1）、欧式距离（L2）</p></li><li><p>欧式聚类数据结构：八叉树（3D网格）</p><ul><li>优点：易于快速构建，适用于不同情况，如需要占用空间的体积表示、用不同结构估计叶节点中的数据等</li><li>缺点：3D网格只适用于空间等分的情况</li></ul></li></ul><p>对于聚类分块大小不一的情况，需要更复杂的算法（下述）。</p><p>实例：</p><ul><li>点聚类 $O_i = {p_i \in \mathcal{P}}$  与点聚类 $O_j = {p_j \in \mathcal{P}}$ 不同的条件是：</li></ul><p>$$<br>min||p_i-p_j||<em>2 \ge d</em>{th}<br>$$</p><p>式中，$d_{th}$ 是指定的阈值。</p><p>即：点集 $p_i \in \mathcal{P}$ 与点集 $p_j \in \mathcal{P}$ 之间的最小距离大于指定的阈值，则前者中的点属于聚类 $O_i$，后者属于聚类 $O_j$ 。</p><p>一个问题是，这个最小距离该如何估计？</p><ul><li><p>最小距离的估计：使用 kd-tree 进行最近邻查询</p></li><li><p>算法伪代码：</p><ul><li>输入点云 $\mathcal{P}$ ，创建 kd-tree 表示</li><li>设置簇 $C$ 的空列表，以及点集序列 $Q$ </li><li>对输入点云的每一个点 $p_i \in \mathcal{P}$ ，执行以下步骤<ul><li>将 $p_i$ 添加到当前序列 $Q$ </li><li>对添加到序列中的每个点 $p_i \in Q$：<ul><li>以3D空间中半径为 $r&lt;d_{th}$ 的球体搜索 $p_i$ 的近邻点（近邻点搜索半径 r），结果形成点集 $P_i^k$  （setRadiusSearch）</li><li>对每个近邻点 $p_i^k \in P_i^k$，若未被分类则将其添加到序列 $Q$ </li></ul></li><li>序列 $Q$ 中的所有点处理完后，将 $Q$ 添加到簇 $C$ 的序列（内点）并重置为空序列</li></ul></li><li>算法终止条件：点云中的所有点均被遍历，且已成为簇 $C$ 的列表的一部分</li></ul></li><li><p>聚类算法(cpp)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被分割出来的点云团（标号队列）</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line"><span class="comment">//欧式分割器</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.setClusterTolerance(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.setMinClusterSize(<span class="number">100</span>);</span><br><span class="line">ec.setMaxClusterSize(<span class="number">25000</span>);</span><br><span class="line"><span class="comment">//搜索策略树</span></span><br><span class="line">ec.setSearchMethod(tree);</span><br><span class="line">ec.setInputCloud(cloud_filtered);</span><br><span class="line">ec.extract(cluster_indices);</span><br></pre></td></tr></table></figure><h3 id="边缘查询"><a href="#边缘查询" class="headerlink" title="边缘查询"></a>边缘查询</h3></li><li><p>表面曲率可用于点云分割：是对点附近采样点的几何近似估计，它们对确定那些具有极高曲率值的点很有用，这些点代表点云数据集 $\mathcal{P}$ 的几何边缘</p></li><li><p>2D 图像中边缘可用梯度定义，3D 中则是场景中几何形状变化剧烈的位置</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCL </tag>
            
            <tag> Point Cloud </tag>
            
            <tag> 点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设：链片条复合模CAD系统使用须知</title>
      <link href="/2020/05/26/Graduate_2/"/>
      <url>/2020/05/26/Graduate_2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="由于该系统只在-win10-系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！"><a href="#由于该系统只在-win10-系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！" class="headerlink" title="由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！"></a>由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！</h5><a id="more"></a><h3 id="已知错误1：数据库引擎"><a href="#已知错误1：数据库引擎" class="headerlink" title="已知错误1：数据库引擎"></a>已知错误1：数据库引擎</h3><p>本系统采用 ACCESS 作为数据库，经测试（虚拟机测试），win7 等系统上会出现 “未在本地计算机上注册‘Microsoft. ACE. OLEDB. 12. 0’提供程序”类似的提示。</p><p><img src="https://i.loli.net/2020/05/26/LJwRFIAp4N3HCyB.png" alt="运行错误.png"></p><center>运行错误提示</center><h3 id="解决1："><a href="#解决1：" class="headerlink" title="解决1："></a>解决1：</h3><p>安装数据库引擎即可，点击下方“下载”，下载完成后安装，提示安装成功后尝试再次运行本系统。</p><div class="btns circle center grid5">            <p class='cell'><a href='https://mqroad.lanzous.com/id006ba' target="_blank" rel="noopener" title='下载'><i class='fas fa-download'></i>下载</a></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设：链片条复合模CAD系统</title>
      <link href="/2020/05/25/Graduate_/"/>
      <url>/2020/05/25/Graduate_/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="毕设题目：采用滚动导向、中间导柱模架的复合模-CAD-系统研制-一-——设计计算及工程图绘制"><a href="#毕设题目：采用滚动导向、中间导柱模架的复合模-CAD-系统研制-一-——设计计算及工程图绘制" class="headerlink" title="毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制"></a>毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制</h5><h5 id="指导老师：谌霖霖"><a href="#指导老师：谌霖霖" class="headerlink" title="指导老师：谌霖霖"></a>指导老师：谌霖霖</h5><a id="more"></a><h2 id="开发平台"><a href="#开发平台" class="headerlink" title="开发平台"></a>开发平台</h2><p>系统环境：Windows 10 2004 专业版<br>开发环境：VB.NET<br>数据库：ACCESSS 365<br>软件平台：VS 2010</p><h2 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h2><p>该复合模 CAD 系统主要包含以下功能：</p><ul><li>用户登录</li><li>参数输入</li><li>设计计算</li><li>主界面<ul><li>设计结果</li><li>标准件库</li><li>建模装配</li><li>关于系统</li></ul></li></ul><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>首先，用户在打开系统后，会出现登录界面，该界面四个按钮的功能如下：<br>1.登录：如若账号密码均正确，通过此按钮即可进入下一界面；<br>2.取消：如用户输入时出错，想直接清空输入框，可使用此按钮；<br>3.注册：新用户可通过注册后再登录；<br>4.退出：退出系统。</p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525214117.png" alt="系统登陆界面" width="400" height="350" align="bottom" /><center>系统登陆界面</center><h3 id="参数输入"><a href="#参数输入" class="headerlink" title="参数输入"></a>参数输入</h3><p>用户登录后将进入该界面，在该界面由用户输入需要的尺寸值，也可使用默认值，点击开始设计，并选择模具的最小闭合高度，在确定之后即可开始设计计算。</p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525220724.png" alt="参数输入界面" width="400" height="350" align="bottom" /><center>参数输入界面</center><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525222908.png" alt="参数输入界面" width="400" height="150" align="bottom" /><center>闭合高度选择</center><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>系统主界面下可进行设计结果的查询、标准件的尺寸查询、三维建模与装配（调用同组同学 GRIP 程序）、查看仿真动画、系统信息及帮助文档</p><p>此外，在查询结果菜单下，用户可通过点击零件图纸查看零件的三维模型。</p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525224828.png" alt="参数输入界面" width="400" height="100" align="bottom" /><center>系统主界面</center><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525230310.png" alt="参数输入界面" width="400" height="100" align="bottom" /><center>系统主界面菜单</center><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525231149.png" alt="参数输入界面" width="400" height="300" align="bottom" /><center>结果查询界面</center><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525233130.png" alt="参数输入界面" width="400" height="300" align="bottom" /><center>零件信息界面</center><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/yanshi.gif" alt="参数输入界面" width="400" height="300" align="bottom" /><center>点击零件图纸查看零件的三维模型</center><p>剩余界面较为简单，这里不再赘述！</p><center>系统演示视频</center><center><iframe height=498 width=650 src='https://player.youku.com/embed/XNDY4NzU3MTk5Mg==' frameborder=0 'allowfullscreen'></iframe></center>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全国性哀悼活动</title>
      <link href="/2020/04/04/ChinaIsTheBest/"/>
      <url>/2020/04/04/ChinaIsTheBest/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200404185413.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Commemorate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Commemorate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开天辟地</title>
      <link href="/2020/04/02/hexo_new/"/>
      <url>/2020/04/02/hexo_new/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
