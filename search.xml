<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器人手眼标定（OpenCV)</title>
      <link href="/hec_opencv/"/>
      <url>/hec_opencv/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="机器人手眼标定"><a href="#机器人手眼标定" class="headerlink" title="机器人手眼标定"></a>机器人手眼标定</h1><p>机器人手眼标定是机器人加工、抓取等的关键，视觉系统的安装方式主要可分为两种：一类是将视觉系统直接安装在机器人末端法兰盘上，构成“眼在手上（eye-in-hand）”的配置方式，该类配置下，视觉系统随着机器人移动，视觉系统与机器人末端工具坐标系之间的位姿固定不变；另一类则与之相反，即视觉系统固定在机器人外部，构成“眼在手外（eye-to-hand）”的配置，此配置下，视觉系统与机器人基坐标系之间的位姿保持不变。</p><p><img src="https://s2.loli.net/2023/04/17/61JeqyzFC5fY9io.png" alt="handeyecalibration"></p><h1 id="手眼标定模型"><a href="#手眼标定模型" class="headerlink" title="手眼标定模型"></a>手眼标定模型</h1><h2 id="AX-XB"><a href="#AX-XB" class="headerlink" title="AX=XB"></a>AX=XB</h2><p>利用机器人的相对位姿求解，如采集 20 个位姿，实际可用于求解有 19 组位姿</p><p><img src="https://s2.loli.net/2023/04/17/b8o16nCE7L5tMAG.png" alt="AXXB"></p><h2 id="AX-ZB"><a href="#AX-ZB" class="headerlink" title="AX=ZB"></a>AX=ZB</h2><p>利用机器人的绝对位姿求解，如采集 20 个位姿，全部参与求解</p><p><img src="https://s2.loli.net/2023/04/17/VUhvm9iSGxZ7o3I.png" alt="AXZB"></p><h1 id="手眼标定算法实现"><a href="#手眼标定算法实现" class="headerlink" title="手眼标定算法实现"></a>手眼标定算法实现</h1><p>OpenCV4 已经实现了部分<a href="https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html#gaebfc1c9f7434196a374c382abf43439b">经典手眼标定算法</a>，但其说明文档实在是一言难尽，经过论文对比和测试，本文对相关参数做一解释!</p><h2 id="AX-XB-1"><a href="#AX-XB-1" class="headerlink" title="AX=XB"></a>AX=XB</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::calibrateHandEye</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays  R_gripper2base,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays t_gripper2base,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays R_target2cam,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays t_target2cam,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray R_cam2gripper,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray t_cam2gripper,</span></span></span><br><span class="line"><span class="params"><span class="function">    HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>参数解释：<br>[输入]    <code>R_gripper2base</code>    <code>vector&lt;Mat&gt;</code> 类型，机器人位姿旋转部分，可传入 3x3 旋转矩阵或 3x1 旋转向量<br>[输入]    <code>t_gripper2base</code>    <code>vector&lt;Mat&gt;</code> 类型，机器人位姿平移部分，3x1 平移向量<br>[输入]    <code>R_target2cam</code>    <code>vector&lt;Mat&gt;</code> 类型，每个位姿相机外参旋转部分，可传入 3x3 旋转矩阵或 3x1 旋转向量<br>[输入]    <code>t_target2cam</code>    <code>vector&lt;Mat&gt;</code> 类型，每个位姿相机外参平移部分，3x1 平移向量<br>[输出]    <code>R_cam2gripper</code>    手眼矩阵旋转部分，3x3 旋转矩阵<br>[输出]    <code>t_cam2gripper</code>    手眼矩阵平移部分，3x1 平移向量<br>[输入]    <code>method</code>    手眼标定算法，详见<a href="https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html#gad10a5ef12ee3499a0774c7904a801b99">cv::HandEyeCalibrationMethod</a></p><p><em>经测试，上述标定算法中，<code>CALIB_HAND_EYE_HORAUD</code>的精度最高</em></p><p><img src="https://docs.opencv.org/4.x/hand-eye_figure.png" alt="Opencv_axxb"></p><p>按照 OpenCV 官方文档解释，机器人末端与基坐标系之间的转换关系为：</p><script type="math/tex; mode=display">\begin{bmatrix} X_b\\ Y_b\\ Z_b\\ 1 \end{bmatrix} = \begin{bmatrix} _{}^{b}\textrm{R}_g & _{}^{b}\textrm{t}_g \\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} X_g\\ Y_g\\ Z_g\\ 1 \end{bmatrix}</script><p>可见该转换矩阵将末端位姿转换到了机器人基坐标系下（等号左边是转换后结果，右边是转换前），所以该部分输入可直接<strong>采用从上位机获取的机器人位姿</strong>。</p><p>机器人上相机与标定板之间的转换关系为：</p><script type="math/tex; mode=display">\begin{bmatrix} X_c\\ Y_c\\ Z_c\\ 1 \end{bmatrix} = \begin{bmatrix} _{}^{c}\textrm{R}_t & _{}^{c}\textrm{t}_t \\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} X_t\\ Y_t\\ Z_t\\ 1 \end{bmatrix}</script><p>该转换矩阵将标定板坐标转换到了相机坐标系下，故该部分可直接传入<strong>每个位姿的相机外参</strong>。</p><p>最终手眼矩阵输出的结果为：</p><script type="math/tex; mode=display">\begin{bmatrix} X_g\\ Y_g\\ Z_g\\ 1 \end{bmatrix} = \begin{bmatrix} _{}^{g}\textrm{R}_c & _{}^{g}\textrm{t}_c \\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} X_c\\ Y_c\\ Z_c\\ 1 \end{bmatrix}</script><p>可见输出的转换矩阵即为机器人末端与相机坐标系之间的位姿关系，无需求逆。</p><p>OpenCV 的示意图误导性严重，没有遵循坐标转换关系的标准写法（具体可参考《机器人学导论》）。</p><h2 id="AX-ZB-1"><a href="#AX-ZB-1" class="headerlink" title="AX=ZB"></a>AX=ZB</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::calibrateRobotWorldHandEye</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays R_world2cam,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays t_world2cam,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays R_base2gripper,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays t_base2gripper,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray R_base2world,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray t_base2world,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray R_gripper2cam,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray t_gripper2cam,</span></span></span><br><span class="line"><span class="params"><span class="function">    RobotWorldHandEyeCalibrationMethod method = CALIB_ROBOT_WORLD_HAND_EYE_SHAH </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p><em>该部分实现了两种算法，分步法和同步法各一种，经测试，两者精度几乎无差别。</em></p><p><img src="https://docs.opencv.org/4.x/robot-world_hand-eye_figure.png" alt="Opencv_e2h"></p><p>参数解释同前，<a href="https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html#ga41b1a8dd70eae371eba707d101729c36">OpenCV官方解释</a>同样具有强烈误导性！！</p><p>首先是传入的机器人位姿，文档给出的转换矩阵为：</p><script type="math/tex; mode=display">\begin{bmatrix} X_g\\ Y_g\\ Z_g\\ 1 \end{bmatrix} = \begin{bmatrix} _{}^{g}\textrm{R}_b & _{}^{g}\textrm{t}_b \\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} X_b\\ Y_b\\ Z_b\\ 1 \end{bmatrix}</script><p>可见其将基坐标系转到了末端法兰盘坐标系，而我们上位机直接获取的位姿是在机器人基坐标系下的，故这部分在传入时需<strong>求逆</strong>矩阵，对转换矩阵而言，其逆矩阵为：</p><script type="math/tex; mode=display">T^{-1}= \begin{bmatrix} R^T & -R^Tt \\ 0^T & 1 \end{bmatrix}</script><p>对每个位姿的相机外参，从其转换矩阵可知无需求逆：</p><script type="math/tex; mode=display">\begin{bmatrix} X_c\\ Y_c\\ Z_c\\ 1 \end{bmatrix} = \begin{bmatrix} _{}^{c}\textrm{R}_w & _{}^{c}\textrm{t}_w \\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ 1 \end{bmatrix}</script><p>最坑的地方来了，从下式可知，最终求解的手眼矩阵是以相机坐标系为参考系的，而基坐标系与世界坐标系之间的关系是以后者为参考系的，<strong>但实际中我们需要的恰好是其逆矩阵</strong>。</p><script type="math/tex; mode=display">\begin{bmatrix} X_w\\ Y_w\\ Z_w\\ 1 \end{bmatrix} = \begin{bmatrix} _{}^{w}\textrm{R}_b & _{}^{w}\textrm{t}_b \\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} X_b\\ Y_b\\ Z_b\\ 1 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} X_c\\ Y_c\\ Z_c\\ 1 \end{bmatrix} = \begin{bmatrix} _{}^{c}\textrm{R}_g & _{}^{c}\textrm{t}_g \\ 0_{1 \times 3} & 1 \end{bmatrix} \begin{bmatrix} X_g\\ Y_g\\ Z_g\\ 1 \end{bmatrix}</script><p><strong>综上，对于部分输入输出参数必须求逆，否则计算结果完全错误，重投影误差显著增大！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Robot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UR5 </tag>
            
            <tag> HEC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 指针</title>
      <link href="/cpp_pointer/"/>
      <url>/cpp_pointer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>重温指针，<a href="https://www.bilibili.com/video/BV1s5411J78m/?spm_id_from=333.788.video.desc.click">参考油管大神</a>，13年的视频，经典经久不衰！</p><!-- don't need more in this theme, just for show cover image--><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><p>内存结构可大致分为四块，各司其职，具体可<a href="https://www.bilibili.com/video/BV1s5411J78m?t=1044.1&amp;p=12">参考</a></p><ul><li><p>Code(Text)区：该区域存储程序代码，相关文本</p></li><li><p>Static/Global区：存储静态变量及全局变量</p></li><li><p>Static区：栈区，存储局部变量，负责程序运行过程中状态存取（函数调用执行信息）</p><ul><li><p>该区域由 main 函数开始存储，遇到函数调用时，会在内部重新开辟一块内存，在新的内存中执行子函数（可认为是入栈），执行完毕后子函数生命周期结束，内存被释放（可认为是出栈），返回主函数继续执行</p></li><li><p>由编译器自动分配，自动清理</p></li></ul></li><li><p>Heap区：堆区，动态内存</p><ul><li><p>该区并不等同于数据结构中的堆，而是一块动态内存，所有动态内存的分配均在此区域进行，如 C 中的 malloc + free，C++ 中的 new + delete</p></li><li><p>由程序员自己负责释放，如不释放，在程序结束后由系统自动回收</p></li></ul></li></ul><p><img src="https://s2.loli.net/2023/03/30/zWjZ3QYSOa1wd6q.png" alt="image.png" style="zoom:50%;" /></p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul><li><p><code>malloc</code>：<code>void* malloc(size_t size)</code></p><ul><li>该函数接受一个参数，该参数告知需要分配内存的具体大小，并返回通用指针类型 void*，因而在实际使用中还需类型转换</li><li>该函数只会分配指定大小的内存，并不会初始化其中的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//sizeof(int) 获取了基本类型 int 的单位大小，如若需要更大的尺寸，可直接用元素数量整数相乘即可，如 20*sizeof(int)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>calloc</code>：<code>void* calloc(size_t num, size_t size)</code></p><ul><li><p>与 malloc 不同的是，该函数接受两个参数，一个元素数量，另一个和 malloc 一致；即将 malloc 中整数相乘的部分作为参数</p></li><li><p><strong>该函数会初始化内存中的值为 0</strong></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><ul><li><p><code>realloc</code>：<code>void* realloc(void* ptr, size_t size)</code></p><ul><li>若已动态分配了内存，需要更改内存的大小（或重新分配），可通过该函数</li><li>第一个参数指向现有内存块的首地址，第二个参数是需新分配的大小</li><li>如果需要扩充现有内存，该函数会将现有内存中的全部内容复制到新的内存中</li><li>在现有内存上扩展的前提是系统能在现有内存后找到可扩展的连续空间，否则会直接分配一块新的内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p_ = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, n*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>free</code>：所有分配的内存必须通过 <code>free</code> 释放，如若不释放，则分配的内存依然被占用，假若每次都不释放，内存终究会被消耗完</p></li></ul><p><strong>即使释放后，内存可是可访问和修改的，但其中的值是随机的，所以使用内存之前一定要申请内存</strong></p><h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><p>new + delete</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>正常情况下，函数的调用均在栈区进行，每调用一次，被调函数生命周期结束返回到主函数时，被调函数的内存被释放，等到下一次调用时重新分配，这个过程由编译器自动进行。</p><p>但若我们从堆区动态申请内存，而不手动释放，且由于编译器并不会自动释放，程序运行一段时间后最终会导致内存耗完，而这些未释放的内存不能被别的程序使用，成为了“垃圾”，这种垃圾的不断增加就是内存泄漏。</p><p>如若申请使用后释放，效果就和栈区一样。</p><p>Java 和 C# 中会自动释放堆区内存，但 C/C++ 不会。</p><h1 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h1><h2 id="指针作为函数返回值"><a href="#指针作为函数返回值" class="headerlink" title="指针作为函数返回值"></a>指针作为函数返回值</h2><p>假设我们需要通过调用函数实现两数之和，最简单的场景是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add</span>(a, b);</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若通过指针作为参数来实现上述过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假若我们将函数的返回值通过指针带回，可以写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> &amp;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="built_in">Add</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum&quot;</span> &lt;&lt; *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该代码完全看运气，或许偶尔能得到正确的值，这是一个典型的逻辑错误，分析如下：</p><ul><li><p>程序从主函数开始，在栈区开辟一段内存，并存储三个局部变量</p><p><img src="https://s2.loli.net/2023/03/30/R16Q937l8LJrHBS.png" alt="image.png" style="zoom: 33%;" /></p></li><li><p>函数执行到12行时，在栈顶开辟一块新内存存储 Add 函数及其局部变量，由于 Add 函数中的 a、b 指针分别指向 main 函数中的 a、b，故其中存储主函数中局部变量的地址，求和后存储在变量 c 中</p><p><img src="https://s2.loli.net/2023/03/30/k6Z8gpdz5AUYlx7.png" alt="image.png" style="zoom:33%;" /></p></li><li><p>Add 函数最终返回了 c 的地址，由主函数中的指针 ptr 接受，Add 函数结束，其内存被自动释放（若有其他函数，则会被其他函数占用），此时在主函数中输出返回值，结果自然是错误的，因为 ptr 指向的内存已被抹去，指针为 NULL了</p><p><img src="https://s2.loli.net/2023/03/30/P2JcMe3KrdwARL5.png" alt="image.png" style="zoom:33%;" /></p></li></ul><p>如何解决呢？</p><p>既然栈区是编译器自动分配与释放，那自然想到堆区（或静态/全局区），由程序员自己申请和释放，只要自己不释放，在程序周期内一直存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* c = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//动态申请，不释放，存在直到程序结束</span></span><br><span class="line">    *c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="built_in">Add</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，在栈区存储的 Add 函数中，向堆区动态申请了一块内存，也就是栈区的 c 指向了堆区，求和的结果存储在堆区，Add 函数返回了堆区的地址，由于堆区需要手动释放，所以主函数可通过返回的地址获取求和的结果。</p><p><img src="https://s2.loli.net/2023/03/30/JqCaSAkg2I6Q5rc.png" alt="image.png"></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="核心含义"><a href="#核心含义" class="headerlink" title="核心含义"></a>核心含义</h3><ul><li><p>顾名思义，指针指向函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);<span class="comment">//声明一个指针，该指针指向一个带有两个 int 型参数的函数</span></span><br><span class="line"><span class="comment">//    p = &amp;Add;//和下述同义</span></span><br><span class="line"><span class="comment">//    int c = (*p)(a, b);</span></span><br><span class="line">    p = Add;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">p</span>(a, b);</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_name</span><span class="params">(<span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*p)();</span><br><span class="line">    p = print;</span><br><span class="line">    <span class="built_in">p</span>();<span class="comment">//函数指针调用其指向的函数（可直接作为函数名进行调用）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*pn)(<span class="type">char</span>*);</span><br><span class="line">    pn = print_name;</span><br><span class="line">    <span class="built_in">pn</span>(<span class="string">&quot;Duke&quot;</span>);<span class="comment">//可接受函数参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>注意和 <code>int* p(int, int)</code> 的区别，这是定义了一个函数 <code>p</code>，其返回值为指向 int  的指针</li></ul><h3 id="函数指针与回调函数"><a href="#函数指针与回调函数" class="headerlink" title="函数指针与回调函数"></a>函数指针与回调函数</h3><p>函数指针是可以作为函数参数的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">void</span> (*p)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">p</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*p)() = print;</span><br><span class="line">    <span class="built_in">print2</span>(p);</span><br><span class="line">    <span class="comment">// 等价于下面的</span></span><br><span class="line">    <span class="built_in">print2</span>(print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中通过函数指针，实现了对另一个函数的回调，但这种显然没有实际意义。</p><p>考虑这样一个场景，我们需要对用户输入的一组数进行排序，但升序和降序由用户决定，简单的做法是写升序和降序两段代码，但显然不利于代码的维护，此时便可通过函数指针作为函数参数，通过由用户定义的回调函数，判断升降排序。以冒泡排序为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，控制比较的机制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//定义规则，此时为升序，改为 -1 即为降序</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> n, <span class="type">int</span> (*compare)(<span class="type">int</span>, <span class="type">int</span>))</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; ++j)&#123;</span><br><span class="line"><span class="comment">//            if(A[j] &gt; A[j + 1])</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(A[j], A[j+<span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;<span class="comment">//若为 true，则交换，否则保持原顺序</span></span><br><span class="line">                tmp = A[j];</span><br><span class="line">                A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">                A[j + <span class="number">1</span>]  = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A[] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//    bubbleSort(A, 6);</span></span><br><span class="line">    <span class="built_in">bubbleSort</span>(A,<span class="number">6</span>,compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : A) cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序定义了回调函数 <code>compare()</code>，其对输入序列中的相邻两个值进行比较，实现升降排序，通过这种方式可完全隐藏函数内部实现，由用户定义自己的排序机制。</p><p>这在 C/C++ 标准库中有诸多体现，如快排 <code>qsort</code>，该函数可以对任意类似的数组进行排序，故其需要定义排序的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">//qsort</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，控制比较的机制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span></span>&#123;</span><br><span class="line"><span class="comment">//    int A = *(int*)a;//强制类型转换</span></span><br><span class="line"><span class="comment">//    int B = *(int*)b;</span></span><br><span class="line"><span class="comment">//    return A - B;</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b);<span class="comment">//也可用 if 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A[] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">qsort</span>(A, <span class="number">6</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : A) cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>qsort</code> 是通用的排序方法，故其回调函数是通用指针 <code>void*</code>，在该函数内部，首先转为所需类型的指针，再解引用参与计算。</p><p>此外，回调函数另一常见的使用场景是 事件处理（MFC、OpenCV 等中的按钮事件）。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 小知识点</title>
      <link href="/cpp_useful_sugar/"/>
      <url>/cpp_useful_sugar/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>旨在记录一些常见、易错点</p><span id="more"></span><h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><ul><li><p>如何比较两个浮点数是否相等</p></li><li><p>FLT_EPSILON 表示计算机能表示的最小的浮点数</p></li><li><p>不能直接使用 <code>a==b</code> 判断浮点数是否相等</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(a - b) &lt; FLT_EPSILON) &#123;</span><br><span class="line">    <span class="comment">// a 和 b 被认为是相等的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// double DBL_EPSILON</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UR5_Vrep 仿真</title>
      <link href="/ur5_vrep_simu/"/>
      <url>/ur5_vrep_simu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>UR5 结合  Coppeliasim（旧Vrep） 的仿真相关操作记录</p><span id="more"></span><h2 id="逆运动学dummy"><a href="#逆运动学dummy" class="headerlink" title="逆运动学dummy"></a>逆运动学dummy</h2><ul><li><p>dummy 解释</p><p><a href="https://zhuanlan.zhihu.com/p/157701389">参考</a></p></li><li><p>dummy  的添加</p><ul><li>添加一个dummy，dummy在V-REP 中是最简单的模型。然后调整其位置到（-3.7658e-1，+0e+0，+1.0013e+0），注意此时我们假设你的UR的坐标是（+0e+0，+0e+0，+1.4650e-2）。如果你调整的UR的位置，那么这个dummy的位置也需要左相应的调整。当然也没有这么死板，只要将其放在你认为的夹持器工作中心即可。然后将其重命名为 UR5_tip。</li><li>所以demo 中的 UR5_Tip 在夹爪中心的原因是其平移过去而非直接与夹爪相连</li></ul></li><li><p>逆运动学计算方法：伪逆（不稳定但快速）、DLS（稳定但慢）</p></li></ul><ul><li>vrep 中编辑 path 时可能出现部分视角看不到完整路径的情况，可新建一场景，编辑后再导入，注意不要更改其位置</li></ul><h2 id="Vrep-仿真小问题"><a href="#Vrep-仿真小问题" class="headerlink" title="Vrep 仿真小问题"></a>Vrep 仿真小问题</h2><ul><li><p>仿真开始时部分位置会显示一个紫色球体，这是由于添加了 <em>Blob to 3D position</em> 相机的原因，紫色球体即为相机在场景中检测到的物体(<a href="https://forum.coppeliarobotics.com/viewtopic.php?t=9039">参考</a>)，可在脚本中将 addDrawingObject 注释</p></li><li><p>编辑路径时，路径上控制点过大，导致编辑看不清，可在属性中设置大小</p></li></ul><p><img src="https://s2.loli.net/2023/03/04/olg48tjWmRypEbC.png" alt="image-20230304151701834"></p><h2 id="Geomagic-提取模型合模线"><a href="#Geomagic-提取模型合模线" class="headerlink" title="Geomagic 提取模型合模线"></a>Geomagic 提取模型合模线</h2><ul><li><p>分别选择两个平面拟合平面特征（也可直接选择探测特征，但效果一般）</p></li><li><p>选择 特征-平面-两平面平均 创建合模线所在平面</p></li><li><p>选择 曲线-从截面创建，创建平面所经过的曲线，即为合模线</p></li><li><p>选择 曲线-创建点，合模线离散为点，后续用于路径规划</p></li></ul><p>2023年2月21日19:08:34</p><ul><li>导入模型后，首先将CAD模型的坐标系移动到合适的位置，这个过程使用 对象移动器，通过主矢可直接对齐坐标系</li><li>在选择选项卡下，更改选择为矩形</li><li>选择两平面拟合</li></ul><h2 id="Geomagic-点云数据导出"><a href="#Geomagic-点云数据导出" class="headerlink" title="Geomagic  点云数据导出"></a>Geomagic  点云数据导出</h2><ul><li><p>不同的格式对应不同的单位</p></li><li><p>pcd 文件对应的单位：m</p></li><li><p>obj  文件对应的单位：mm（导出到该格式的点可能和源文件的有差异，下图左为导出后顺序，右为原点云顺序）</p></li></ul><p><img src="https://s2.loli.net/2022/11/28/PAV3lQRJZkNSyHj.png" alt="image-20221128095828138" style="zoom: 80%;" /></p><ul><li>asc文件格式数据和原点云一致，只需更换点云描述头</li></ul><h2 id="Geomagic-与-Vrep-数据转换"><a href="#Geomagic-与-Vrep-数据转换" class="headerlink" title="Geomagic 与 Vrep 数据转换"></a>Geomagic 与 Vrep 数据转换</h2><ul><li>Vrep 模型导入（<a href="https://www.cnblogs.com/hsw-home/p/16014182.html">图源</a>）</li></ul><p><img src="https://s2.loli.net/2022/11/26/OtpSBv5cqDFo73a.png" alt="img"></p><ul><li><p>由 Vrep 导出后，导入到 Geomagic 中时选择单位必须为 m，否则轨迹不正确</p></li><li><p>关于模型的缩放（当下不需要了，直接在导入时选择单位）</p><ul><li><p>先将扫描得到的 CAD 模型直接导入到 Vrep，可以观察到大小完全不是一个等级，这时候就要缩放，缩放因子设置为 $0.5^n$，这里需要不断调节直到合适的大小</p></li><li><p>缩放的验证：比如设置缩放因子为 $0.5^8$，此即为将原模型缩放了 256 $(1/0.5^8)$倍， 选取轨迹上两点并测量其距离，距离的缩放应满足该倍数关系</p></li></ul></li><li><p>关于最终轨迹的生成</p><ul><li><p>首先将原模型导入，通过设置位置坐标将其移动到机器人基坐标系下（这里可直接输入机器人的基坐标系位置）</p></li><li><p>设置缩放因子缩放到合适的大小，并旋转到合适的位置</p></li><li><p>导出上述缩放后的模型（记住导出的轴哪个向上），并重新导入（注意选择与导出时相同的向上轴），再次导出作为最终的模型，此时的模型重新导入时坐标方向是一致的（原因未知）</p></li><li><p>导入 Geomagic，选择并拟合两个平面，通过拟合的两平面建立中间的平面（即合模线所在平面），通过截面创建曲线，生成点，删除多余的点</p></li></ul></li></ul><p>拟合两个平面：</p><p><img src="https://s2.loli.net/2022/11/25/iJA2wG5mTxcezh4.png" style="zoom: 67%;" /></p><p>取合模线所在平面：</p><p><img src="https://s2.loli.net/2022/11/25/Ee17l36XjGn5Rwb.png" style="zoom: 67%;" /></p><p>截面创建轨迹：</p><p><img src="https://s2.loli.net/2022/11/25/k1QCPw93tcWjrvU.png" style="zoom: 50%;" /></p><p>轨迹线转为点：</p><p><img src="https://s2.loli.net/2022/11/25/qFPz7NXrtipUKxI.png" style="zoom: 50%;" /></p><ul><li>导出的点是无序的，可以将数据在 Origin 中画出来，按顺序排好后再导入到 Vrep，此时的轨迹和前述的模型应当是匹配的，在 Vrep 中可以将其设置为模型的从属</li></ul><p>无序点（显示的标签为行号）：</p><p><img src="https://s2.loli.net/2022/11/25/LXWARHTiYtEmnrq.png" alt="image-20221125194657292" style="zoom: 50%;" /></p><p>排序结果：</p><p><img src="https://s2.loli.net/2022/11/25/jMaw4Z3oyNhscYI.png" alt="image-20221125194657292" style="zoom: 50%;" /></p><h2 id="Geomagic-模型切半"><a href="#Geomagic-模型切半" class="headerlink" title="Geomagic 模型切半"></a>Geomagic 模型切半</h2><ul><li>将点集封装成多边形</li><li>点击裁剪，按平面，选择好平面</li><li>点击下面的平面截面，选择要删除的选区，删除即可</li></ul><p><img src="https://s2.loli.net/2023/02/23/kQTnR7NoBKYzWiq.png" alt="image-20230223104658178" style="zoom:50%;" /></p><h2 id="模型轨迹在实际机器人基坐标系下的位姿"><a href="#模型轨迹在实际机器人基坐标系下的位姿" class="headerlink" title="模型轨迹在实际机器人基坐标系下的位姿"></a>模型轨迹在实际机器人基坐标系下的位姿</h2><ul><li><p>按前述将模型导入 Vrep 后，Vrep 自动生成该模型在基坐标系下的位姿</p></li><li><p>将该模型导出，再导入，再导出作为最终模型使用</p></li><li><p>提取导出模型的合模线，按前述创建轨迹（该轨迹是和模型同处于机器人基坐标系下的） ，导入到 Vrep 指定每个控制点的方向后导出得到最终的轨迹</p><ul><li>注意此时导出的轨迹是 $x,y,z,\alpha,\beta,\gamma$，单位是 $m$ 和 $°$</li></ul></li></ul><p><img src="https://s2.loli.net/2022/11/29/qFLNSlQk89ZnWe6.png" alt="image-20221129101603224"></p><ul><li><p>测量点云与导出模型（作为CAD模型）配准，得到转换矩阵</p></li><li><p>轨迹点位姿与转换矩阵相乘，得到转换到实际机器人基坐标系下的轨迹，该轨迹包含位姿</p><ul><li>在轨迹点与转换矩阵相乘前，需要将其转换为矩阵的形式，转换顺序为：原始轨迹点——单位转换为mm——欧拉角转旋转矩阵——合并为转换矩阵</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Robot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UR5 </tag>
            
            <tag> Coppeliasim/Vrep </tag>
            
            <tag> Simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试问题</title>
      <link href="/interviewing/"/>
      <url>/interviewing/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ea9c56f86e693fc5ca3ece1d16b1c60617d0f32f6b11f90b3ae80ecec1b35313">738c9bd1e95cfc46d04fc0fe0d97f4378cdaa402e7d3c1dc37a22ccbba15c36e7412fbc5113ce4c62a626823664f9d97bf461acdcd260b071fe5b9b4342d73d71a95deec73a2e37507332e0b7e959dec5db8889c70940ba01d3a0527e84d1c8f97204389bc258033b35db08ef068bc029dc180cbb4a330a17db6d17fa3400b2c1b783ce3d306182dccfdfa883c66968da1a2d8d095fee19c0449bc6ed570a0553cdb137765a6762f207c4502522e7a29829dfa146b6f7b41799fda89c072cdcb1abf26d7948c3938aceba5f3f2efda641186d9c0c3f5ec73e9d08c98aa6599574ab3c8a24aea0ef3ffb74d2fe95256a4ea846f1ef9419e2fbe42afd0be10104c2787851b2b735786af917a286cac8f896e94d50cf23c028c8ceeb7a376524eb1533b0b10db54a10d282c61057154e9d22a1e6540c2cfef9f9fb3ad098dd25413323838ff8304f3bca991ab0b3b1c20afbff24e1f8190fa6c9a5ba8d0e11624a0355264deb0f14edc7ae9847af1e9ef6e1a88cd3a9ef1c5c6cc4335889ee0b2de87be1f0b2105d87920e29eb6ce2769d1ca1f4aeb6fd9f89befe799b71c1a4e22485613cc9c2d85307153735ac2a67b4c9806ab8f78709d1e6e7caa88a91af71dc1c476cb31553dc2a0fcaf766439727dde8df1e80b46f9804beb7151ef0b7d69da9cd82268ebf8edb0dc730f35a6a1899e418bdde629ea76e303cfba824a6c9ea41de8cd19b60f1ad3cc372f83399b123005a3b30f0898613e8ee102aa5902d9a2edc672c9ffca6c7d199ed00b195d5a81bb49010479a7839c30e8d218fb05552279e4d3fd55881e9e08af44825d21b93b4378f08bb6680df6b201d2d52768f344525608f29c0a418441569452618e31ca7f513f1ccd495449c2d4ca394c1493d127318a24dc544ef23f14b6b1982fb2f3e66c1a32992e7b4f37bd89f1bb0824efc21cec09ee0f5e174ae886349b7762dd06aef2b2be2397bd83418a0d5a5ae49be44542dff3494082211f9fe6d14d073b0ce573c0fb9a4bed7586ef0179c538ed8d8acc92cd46ccd30e4f1e05af32b91c2b89c170ec1231ff10a1e3767eba281e42542ea8679aba29d187d71132a82565fe0e20d46143f61ec766ba747f1fd51dad80ac0a247e0febb9286efc8ff5ad541d9143288529c990b54d27f058a24457201422215899091ad81a956afdf5f6b6ed5a6801e39379bab57ea805cd7ee796a7619d9a1478e4f56a49350a66f68472777878f8095a508aecb3deb7bcb0f7e2ef315f37fe9aad0787c43f9bec73d698758a42a15b85a67163e43502767f62ae5f38c38db5898a8c1a7fa6cf35e3ecb94ddb46e16b88025feade85b6f9545b4919fe84fb9c0b33d457b97232f5f64c665eeb353fe24a1e103c5bc93e33fab0a270dcc35e83cef12ed2d3cd5689149abe33f76ebd0ca5145f85bb97aeec1540df20cbb9226be80aa9883c4b60d03d40ee554fe5a028a10da6a17472afc308efa8fdd62d8888b7e48067a7e1252d006575e260325b0bd1e60a49f83e6e58531d190c4d293e50161dd4c9dd1db82e4de4f4a131ab812f20c3ef3e380ac00ff6f2624dd2c8a12ef2c1541c63664e312504f650107915665be05e3f26bbd389a44d63207333cbe613095f7f9c7d65e14dcbfeca8dc9bc07b7e78f33e19ecf8e76d70926ea878f3bcd89743fee1a611c9f52deeb338ec43377d326c50d8c3d10fa3928fac2e02fa59cb9184be86ba0f5fa83ee7de7a86fec059be1b989c1c93f118440830d978573d73f7b5ecaec64efce316147fb88e914f49aa91f3c3bbff20a6c35603c11058442c477d3eb50186ec0283fe4ecf381c6456b0d67b63fc58acd7cb7307d87fdc5e5d1037bd7d32782f4357e75b8328e8051edacd477d257948b8cbca9aefcf73c88724839b13d4a5657cf857fe230ec27d9f4f805778dc89d39c680788a824eaa4e238fb3bf05bfa7210c4cda0b0a122a4cacab92388b89848c8ed1450f0b5951a111f5f4d9d23f7d08e273b0c4c3fa38286860711fb873afe25878a19d1b179d1b1937245fe2885f73599de636d1c0cb30d76eab71344bc4edd482aa673c8ec931ebd3a7fbbc52021c7038dc2d754a721c0f23e1bb28bf9ff6ddce4ccdc068630d94eba9ee25b3b9bf5772b896f59a6e0e7001b80d812885f0a27e0a2cbe756af8255a3e8d2e2a8c9a2288a4ba60a90168ac05b2103ea844cf9f0329648f66e9df4fd74f1055d1b1e9e49e6cbf8f7478b070d51b5ac929c70ffbe49cb9e732175462a4bb3976312724db876ff453be169a8e07192795d639c32a0513a3cdfd064f4046b28bb74e9333bfac1c5aad37f8da08f6798ec8210fa8a130f7be2d63800be33c10e93537281b17c72c898f91dc287584f54ae8ba7a0208d5c5c7bb54da5ee6cc84d8c2b6643580f0ad3e7ee328263e080578bb290a9547b26736545e51bfe7f19c266875a60144c24f8698baf4ce3c1b704c8ee16f9749864ee21459408f137faec769531dc28e737be7c803b51f24d53ed4e14f317ad09e1d258acca8edaeaa99eb296791e08165afc9fd4260bc3ba8fdc1288e3d9a3aed16ed139b172118f00ce3587a64dfcd4df4fcb86240dc8821698a3bcb4c5a6181d37d003a5c8754f521a77cc909b77fe8e9154fdd6bd4a2450c6a4c75e4698a3b4e0ac141e9ae49f0f0f3a937e59594818d665b639fff036ee3289f7444a9306ed50ab784eeae4342e10590df4b224d4df07cf698c62822d8bb01ea07237d1c12809ed336965b8adcb1953cb6d17f5ba06c4f01d2a7fc8ed8595eed87ee5f5bc2c751d069f1fead78d3a5e848b61b858e55db1058e14153684d2f526a272fbe427b6b64da53dcaeb1a9e5571a7f535c877665c9fc129527de46c3a5c43ea68495255f75e524ed855e31d84f7cc65d6ff6d2f1f53264b6a54e59e75fe0b656f790b15063d9cc3e1f34e6e68cf5c48a9d19f6a7ee84f55ae6053aa5d250183eb18199f1e349495ea443f0954d2cef0c3fb122b6cdfc09d4515cf87d0d0a05ad1af676e7720ec5b46fb8861ceb1ddb4dea76629db5fe957c72d7444d83440aad5190c9516e6be4682824d86da3711bbfe96724fd84d8f1df59861b740541e6e93c70a4b2b3fa0c2f85d3c90280d78f62d3a9044a82db44e71f1412504cadbe93398bbe6423be53adfe961f188d5c0bb1d5235dac7e5af2061ea55786f673b318320511c7f3e62d72e97bcdc0d5edaecfd29625d7707b5f5b7701f453d0829b8dd89a795ac540ab8dbdf34116892d17c4b0d581644c708d8754761cf9171308361b290711171c911532f7892b0487b09697b9df3aa2aa9eeae4936b353010e00f6a5540688b8757076c0016657a468b3bd53c7a24f2decd02b3bfe81a134b50ea17f788393d5ac32026b6a7c519b3d209a8b775f3cd7dfcf43d9344440b7583fcee4386a8cd3a5eebeac52f27ce133bd9dd0d58b46436c3b717028daca89afc4abe73ec34a30c566fe8aa300c0ac2f0b9fce5d991d0c2f536457bd072682cbcdf3c39d1e1ac9678005aef8ee84203f924a10b95f7fc11b2cab9c59498a4977035cef5b74e24a02af9ef85bf5cee3ae2b0f4f7dd9aa0b2c42b4cbaedac0ace9593c5c7ceb6d8d8d0fb95c0723666cf0248ef309e07881b4dc605dbd7dfd4c466b217da9e0c3e29be56c8719f43950ca10213f56bae8ea3be389ae73d86e8b532402ced75b622d8920f9b1a001096ccd86a735b1ed9874ff8e0edf188f4be0a3ff919878016f90883cb7a2e4503e21634e78c160f611da8edd53a1f9f921f30b6d9e7285260a074f532949fd68577da051418dc6e1b15fae527cac5610102bd6b670b7c786fb16c687dcdb52d5648dfe13b160f2da2eaff0e455accfd70c6b27f1936ac2f151cb87da707de34150ad32f1a8cae09d4bca584e860bf8241e3f45517e05d274d1433b9092bd6e89bdc607f0f93950e160897a9d264611dea8d3080f6d2ec9055493f189e4aaaf59c5cd2618038448a070a147a67b9c2df28c97800ce9a0edffa605078765577dcb0624cbf2fd71463f9a1098fc6369aedaed8a17733bc5d233469598ad5dca88792ef03940e581dc47c9be0ec70a2a5d93b03c5148d8318272cb8194a89fe0616e087861e938ca898c4b43308e79e24ed35cfad0ab714d1a0a73dfadb68b1ad67ad8d7d6af28a8022bc66feb43e0bb4fb89d3ba44ea1459e6ea1cdee048e03772286dec26a00100aef37f4e0a8c01a397afa174d118bec2a58189ee8489f7b02e8814680e05d7590f29554692abc9b938c05c5b9dd37ecce3a71cc8163e6487f5cfc2c0cc6e6973eb42e5bcf32b23c654aad008dff3a56bf26155cd3a51a5592a475924bdd68cef85e9ca97be83f4eb581d736ba00ce46852eb1586db372a0b0e38c48aaff17571689d9076a8382347575a8dc3f007baeabff5064903c3f868e7208bec75b2b89e6e9124b277d476b2bee8707f938348d45bea48972402473821e05176bcbcdfcef92c3d6ee6e428a27308b97ff27630825185b32b70bd94a175ba3ca6804b7382e3d79990eb031cc2350e6535c319f8f2644277ac79023458f8f3fbe66cd7bbab804afec773458ad59a67cbe358ba901f5581ba40765b8eda495bec65bb5244c0f836b25ccd5488d619e7a42a4f56554cbc42ff6662e299e9714607fae668eecd9139ebcb5d90f8faad6b5f1418f65b21e3bd691bd81be12c58fbac3d2c08c66431e2c38ada484f60081a4d248814bc8432bfca66d585495f29b989a4eb2c28e6802d8980a3a9710c74a20cee0ab7d93e4eef3ce70cdda602d00eb4aec34282f4911b313bc044b907833faacd175259168d8b9b4ad35ddf4b7bc99c26971d5e327f938ddc2b9cd49899b7d66a7041e4e3bc6353d50920890d3db936d730f4be662e43e062f9002c12dc90bd65670f4f62a7865871c3be64536cc44e1154a07ea0d40e80e32476df8885ea2f30a49ef793c610100988f4d76e581739be5f5d030d3c253be285694a8f682aace34675f7a6a41c4b4ca57adcedfbce5375257acd6e969666eb8e2b63a0077b91c1beb396fbe8caba971af51258f8cfc55756eb63d1fd08136ca9ee3db10e9186d0531a921b473676467dfd4077fd35a5c9445af55b502f13fc8be7b283f66ee4c6dfbd5b62de639c0cf1e10d9000a1b21b8e6552ab1c7a5442578b9f8452eb8a9a019ae1ed3df45860d1ff3fc7a9d533a8c1dd5c1ef301ffe0157da1ca20d2104482387116a46c9da16196afd82fb6d8d9a2893916a34c43b0a0d215b7add848bf16cbe81de7bd183e0884803564bd2fef2880a1f5e66b9ff4b71f03e1a6c7afb5c5949ba620582f7d9839c54eacd65c0e28fe53d5ad94ad9ea9b65120366adba24117a43339894aa6416a20c2ebe510dde2daf6b15fe0d992adf509882b5fcf0a1450dbccb33c74028092f01e39b03ff450a5ffcd63e18dde552f09d7947722861c35a03a16f64313b2b8fe5b64ac726042f3577c56f51ca9a5e07197a5cd164f8f6d1be9a72bc30e34b3da99000248df1c085ebc63da43c28d77ae5fc05d794aa6b15514314596a6fb52ef4ec40c0dd2bcf2961d0738f0a550e8fa684a3e31f57d863b8037059f02f4cced15f4c21e3a46ea9dea470ab4ad9df3092337de35ef71d010a7962b2391dcb356d7e761557f8ff96f2893724122fb1babd4e0ff3e68139536c2b6052a3b9bfead87e2205f8ba21de6e92936c60d0bcd9ee5e1c5b2af365fce30e1f5149703e4856d089ff398eea9cb8d0a7e61642ee3b82b79700bbe8fc468a93a6becf3b3b73b3adcddbd25da4637bbc3575f049aea19f656fe8210937eaf798a936094554eb474cd60ca1896f158bf557e733b135872953e2da31af895d4a6f24f116e710b60e6b81524d52489ba3f963c61fb29894a6842d6d8a06be006b07a6e90faa98b25ebbb6b396dbf49b9fdcc9e856c07027a74475c056aebd6fdd3301dbce482a8c22978d4e9fb3902057c8dc89276a3a2796e48135da7b5070486e663f6d67fc8428456c479e499b4e3881c96f375e458df02481eb85c430da3a211ab5afb45f8de4298210f58eb1aeb9aad31dcca5b2b8c0464b70df572513cfd26d582e68bb45caf842018bf4ff270134ca5d467fd5afada1e93350d5ac44a903107f2d043d9e4b4ac30a03efaf599bc65523e17b711dbfabc8df669fe255545704de0082945fdeabe5f4332b46d9e39d85bfc53f8c28680ea4065bb3f20e5e260c2eb863fff1c77c92e4f5818039dec3c35b632248d5f4059c4423e53229f6fc3929a217917111d512a49b1f92de0015fee20c7c853774e8143e093425d3b9ac40b01308cd690be6fcecb6396ff48a308abf7d2bdb0a13141719540294ca2180d67e9b30a1de6bd8c6e86db6e14da0401eba8a193073107b4acedfcbad35ecb1b1f9476c733645ea6a9d5ae83b9a8d11e7048b32a4afd1177aaa46ce7423246ebc671e7bfdab30bf45bbc08dddb9c02b12eb754f051fc51c86cf8791c516720fb374e27d6274c952e93e8d0c34c8e1f84261aabe35875fc08a7a3383203303ae56dbabe26a7f892502ebddc47ae1482e6cde4e29110d2808ca7cc32b32146409ef63406ae5b61c736d2eb5f98b20ed9525acba2789119925de316c080c9720d000d77330f4778ec0bc625b660f89d65384aac323b33b6acda6f9250ab3bee19bb1a3e642978e6fcf2c1be0e6d34fd0d3ed18e9b58a378fb0668b94974b02804a662733591c6fac4ffcd976aa75e54488b3cd6cc6572b6399de73ab9c409c5dc093058b3c39c46b6ff067a26c68b725c440122efafef8131b9937f343df96a4b9346666b670c002b67ccaf37e8bafe68c6550cc733cc9f6ff2d2c258e35858372bdaeae378ab1f626d9690a610b1ffc438ab0dcdbf16c27508a4a807d648bf7b967cd90d55d7bad837ad8c1d57842d0181e911662c7db538017d454ed39c2b3fbe9d8ef2285c919006ca792a7c7c8c17beaca0756cb859d3c60a632b12464dcc6d64f892707e2c4b8798e9d2447e302e95592aa33ef5e112013b4a2be37bb3cf69d0ce3c8f26614ff1254d8a5eb9a5e7ed1e6464691ca4d34dcbd4e97eac5b43165f202a050c523f4331a8c8ba83f8555bc5a99c72c79ac7a0d16a279a15836ea1bdfdb0126b9722c09e0f8f32ee3840dc7672403d26a08fa08a8454b0545d417f62d4403aac85703d88f28386630bceec7035f6c713a1c29b22a3a495272d9ea5bd3a3ca91f16d3cf0aceb731a10cccd0adb63685d77497fcb1bf4283162ae17a2f1a5e6b776a81cba37568e65ede66e2c89e89c04e1eaa52392ea019473915240fc9c583c56c274ace07651f46d5b82cbbcca37ae22ed76a94df084704bc68589938cf1c37711860726757631a1a1fed29b987ef668d2bfc0cf380e5e0834511800eddb61b6e5da2dddd982f4c2aca55de3203b2653422a4da1953d73044afd915886bb54d602df27958bd2af28e5f25f6da5fa78339430b42f5eb5555543b8f9a8dc841a28eb9068caff89b23539b7a7e2800c9620f04d27f7d156775fcc1596818f2c2b4f115977786ed2a418521919183681fa627dc649b494635c826a9b31280a7b23b9324059bdd4fdc25b834b4bde3263c0a7c7a89d92c5e9ab13ed1d15276b6a06a25d3f6d30d929d69eceefca75034eb11b90e654855e27f1a75f4b0d6fdb51b197c2b8718268aa8eaba55e4b8a61632af0cb70756f89190c67742c17e8232faafde516e583eb67dd3f054414a855a720801931c465c75967b5f454f30a6ebf8444611b37a5099ec26aec81c69894c934d6809dfe978ae5f7eec6b7a5eb127bf3fe1bfc1acf724d5cc186decca96412bc839168dd5d12651f56f8e4104ec8433d8e3257d59e4eff6cfe329d703e84e718e533bcd824f6b9d257cc157a9848d0381c5b4f7724bc7512d56ffe7457e3034a3e6675f9f29d2446004a364199bf2046a399cd1119986bf293e3a354e2d30e08823107f15ce3125ad246bd2587c1c957db7dcfb74d86a2098670d337bd5fe54d4383ac778c8334e8ddc19f5e9e61e368a7a6010a695202c0013f7f03f0eb90b7e56aa5f5363de053fb64362134ede3d6ee74545564d9a43d4e7ed68a8355b6e71075593b1a1cb0425be89a62f1921193f70bde4aa68a90500ea37ce38b86a9e916ad79a9e0233cbafa64908a8b6919665a46e9c075d234f19b132513202187ea1d21ffc882c6ce07cb707c5428bae8ba6cdeabd5728e12ee34dd729e5616a6c14e764104394a86b0b4e587490f037ee8bea701e9e326420101eb3ee22db9428768e300d31aeb4903ac722a945b54e253293cf25c63720aaed51c56489296821c6fb74cfaefa0a96100827631dc5a57b2008edcd156f9080359f2bd12fe6e6bfaca7044d0f8b749793f22a30e7f83f40bfb31c3d7aefab6d8d0009f02857ecaf1024acedb1a6ecc12e4b3966395cfd8e58e69ef3ba4598724fb561a3c531e2892872c0824587b16fd3e34bd57cabe7118c44aab2a22a4c584d5940518e5c90111438adbb9fefae2f737a5332835724aa8a25fcfbf9772ba2e73ad8e4020377250056181140cc0acaf01e050b1c1bd4a85e46d6eff13e8d003090d8ca66166146a6864793369d5437c0e393ee2cc0ff6342dd53d78a4ae7a70bcde04581abf7b320235633a05ce72f31a078d94e03c2191e01b90571f702561458fc998f697ed237abdc02ae30bf6bfe76b313c401c02e25e886640cc79409ffdb0a5ff4cd9ce219e7db4cbff666e134729aa31d62882eb6a52e263af255b55b927fa2357cd6a8383dacbe66927e9da2972c4d61def63553b1ef99e9e525717aa60fa0e510a8b35337a74d09632122adb53dba64d8e1f638eb17ff18b34db74cdbc69f069b3b34e7925e859a95816e383b8c229848828ae036a229abcd1dd969bc2de3178b78f4e18e8b3c23e64150f3229702d1b79513170b50ab273e5bcbe2386f66c7e70a7837dda2bd7f962754ea02416102ee70d725cd5e8cb2daa26fa29f3f3420d11ebd65edf0be65bd0ba39a31c5128510e5c0facae704657105505cefbc56166a14cfda5fc6eb800e4053e211bb915d94a6cc7c1abf1f58014081cc694ce92ee78099991a826b1a43200fffb4ee4c50b0d7387b3d7d6102ae56c0d53de98b887dc50e4fc188aec48b51e1cb1e08f07c0bd62c53eb17de6c5b53f05c22a7bf3211be572618ecce154dba3bbaeed40418d7ea0bded7cb6ffa64aefb17ba04c45052f19f1d37e9dfaae224e81e4e6cc5f88f4fe86b07c4c9991ad05c1231c72941a35d0c4d6f7ea562fe4c53e61a861c007a7242d81e42ccc45b1fc3fcc3901cdeaae5ba56dc651eae2ad1c69af4897d49c686f710933a88142bab039694d1b913de645b20f4bee44c78d54f523aec7fa43e64f0ccaccd6844201bb4b1e7708ddb0362b55ac1fe119d4701d6ed002b0160274dca7528a88ee8a17fda7350d6dd89b530d21bd38cc79f8abb2c13fe52658ee58b2ce274ea09734df7c073ac17f4ff99f5f65b3dbb9201bba028003318867f973fde5fb3a4dd29975ab108693027e93d8f1bfe7d1dcf97083032d60e541e225baeecdd50bc2b293b7cc794642d5f0a0a1df0fe2a6d61e2e181463d858e1868ac46c72ef8f093311a8be122e9a04d25bff6098973d4e4824cfc1b6fda141a82066c7069d2720e238f6d3127bf73d104fc75b5bcdbc62b14159553386454d509d4876818dd97cf00471b170c6d11c44e07da5c364377e1de1f07b7058019cfbaef6df0b246774d94f77e6d1d8c288b8d5e4f70a48fec083e3e2a36256c4a4b77bc7968dc1b4f569ecbc1d9b6fc91f2f734af5009a0fd1c21f7245023cf95bba23c4321884d7a75b9342bd4f09cb6cda4fc432cbb16710caf3b19728bc480dd8c176d5a468a128a95c4fa371aa6b8fc002b9e3f62cd8ab331d7c869430269ea35dbaee1dfa2bec89dc32f08dca337adfa3469068ff5aba0cd827f126fdc7180db546bd470c4876f3b7d9b5328824eb9c96ae728b21645ee8391839d292b1d5c0736b08136ade4f8797c2254ec1d80937faef05db15a8eee749bf5ff7e968404d5f44834ed067e02c3bb8ca37eddb5eb24fa0ef1dbbcc70ddba90a8d3e948d1912cd3c70f750d1129c546892aa09b222b3fcfcb6606aa82f5f7c758398265bf8c443e80d327a480825e3d8c105d80c69a308cae893096cff931a34ca1bb129c6891bee37d682420ccbcdc0fdbaab4538c09cef651ff96c6b24b6239d84fb72cf8a3aeeb6b6aed2ffbda769ae10b87b2e2fe82f033be2472ef5ec1a4e8c603752168575d4f843d0d3db1d228f98559e994829ba0db8f239b4e1b4348504b6c8d8515f759f4c7ebf6f9a69d542e59b9cfc3a7495bc61e40078f1a1266484fb5f5dd1b645390e58a0ea9624aced3e9bafceeaf55bdf87221c9b0fdd8302e5c74bdf9ec89b23883ccf0f61e363e8923dd79adb227e9dce7209994770091c8d5a327ef3c32994533c655caf651822d4f45ecd91a17951de229e10633c7f863452dd20ad73855ad0b8cf88a521db6a221de496ebebc30738dae67a399d5b428e350ed5302f879aeb243198e1f5932de5bcf3ab8b627494e3865604e0b91de14c934f2956edf77fdb75c94a59eaf7c21b4a54ce5807c158baced9f1088bf523ce6c9fb044a836cafc935d7135c17aae7f74f395b4d0c8346ab3a25ccd945f3412c169fdfd29bab0cbb4d58bbb92325acbf8b2d2d586418f473fa08817996542537676fdbeda064fc07c8f3d26ec0ade34d64e8bd97e59f6ec14f8cdb4a51c969020dc7d38c6097340c4b3dc719fa0b615ce6e22c68ae152aa131630b3d732253eddd9ba9539aa7cc27dddfb35e27d01cd85fcb66858f615ff3d0d7eab6b76c1a6e2f3c8b5e699fb80824ae5ed745e73e4b090ee70cd3c216a19290475c41dd9d9c6d7ec76bab121ca4ca0356e837ca6c7d56a3b4063e40d05575eb2bb318d04d9baec954e0df8d5480716f7a40279d41a6f9b8e85e305ee4ded0f91eb9364528d2b3032cd31f05e9b8947ebfa6463581303eac81bb62a61e27f66684d9db7b076c3baf34e55c40e76fb37f2a00b18d412f5be3421e46839f101e6710f9e8c3aa25f45a43afc26166559b3823c46b123f3b528bb3534753b1dd923d4954af9fe2fbcf12a330ea209fe8a2d1ab1a333264e316fd1a6410f544ac6ffdf7ecd7296bf5a45b5c493bf65726e97c1637aabd5761df9a1d795e0647d10aaa7c96ff706e4f9d395885f9f0b13894c6f4c6380813665756558adade0a0c657625d7170b3f2c73722d690bae08fbac2bd86858e4ceba43c9078ec174fa73dddfaf12b78aa2b728985311825cc25baf66f313abff113235eb67cd1a1a081118186b286bc61c9aa1009d49e3d10549be87a969bad48324e08953d07d25e83ffd68be9e7ca6f919f2bda249289dfc3da40107cfa2e30e82ea2d7d61995938d322aebf24d527003608d8fdef950e03303ecad6a31d735bc20e19876d35a64ccfda8adecce8621fc7c12f02261b6e13cb7e7026625fdc13c2215802eae9ac5b426460bcc12af76070e0c173e2356c781c144204b8aea0b30559c1ca15beff4189f7a02f6d68610925ed48a985b9a55bd7b9723d1617b70bfc164ebd12d6336c6b1bb8f5c4ca7b716f041ce87edb057422ac50176a8775ef01bd4f341187049ca1246f97f4e3e60830f0527f21b5c1ef3e324f83fcd59792f67cd911d5cf98c9af92ec479d432e01b6aca4a8ff18966ec5c7686064c9d4418e7a1535e100a1aea321e31a12ce231bab5b5480c8eb8a2bff00c701e4a7987bf108c073fa57ac3b1b2ec184d5ba1843ddd1cbbbe969a6f7ef720cf5262a79b87dba840680819fa61aa8b9de068803a4e25894b3534f8d535180e6182ca72c4f9f6be6cf80636f49004392675cd6354fb7c1ed1933c610109e0d4d29d35f5fdfe6ba47758585e9e31b530bdf6f73332a9a6f5d8bb387156e9a2d3af3990cc5ab832df0d864f010107631a1e1d7c039a20c4ae5cf03c2e586b843909319e83fdf8b524cb2cfd92911a88bf4506e4e9fe65c9099b6d106a0baecc2e6908b37fc5eee743f911f90bfd3900e34c99b35aead9ce7044e812666855cebf691d1c2d68c72bb01a6b922d358e53df2abbfa34a245cf2893f9ae9e71e0fc71504cdb4b11a95a95506673177776499b7aa576b3fbe55224d7ef1532ede1bf20f79dbeed4c28ca7d5283dc8fe9937b504596d9d129e52f52aad5ee5e4455b2105ae8ebc35851d44ca7168f58174d77d9709924856008c3ea9f5bf8975e9f7db8d9d0b65f7335e863ae11b94073c2cc5656fa35274089f3a475fee8566acab78f43800a5b6f3b2ca7ddeb381450443d7eae3b4c036e2d42daabf9747033c3202207cd37bb9501b40910a18c33d3dca8971507810eea9c410556bcee20cfcf8af0339c06f30dc43608b223c8ef0d7234dd9692e1a37efb562aebbea6134181e8e91af5c5175dbf125f562dcbebb59ebc977bc877fdad481215ee55c7f0b956bfe45650d07f8078e1355f14fd538ed1cebf7c8e28dc5a9748fba41fbe9975c30e1cd71961449239a25483ef32c5cf3510d1a75e161d6dc1af8ac775b00297c8fbbbfd2b5cd307302891ebb89dbcc8c08145d6a93e2f837845bb685b7c689c15f7abcccbb38e3985a285bfabf0178394b281d9d6fc1b22f1a2de03bc8c675cd95400a38ede59a567439eec1973a072191903a6e28e428e97ca95087d19dbbb9319b08f33ea15c73f4070d95e2814a0302fab6bf81f5e76a2fa10e6415cde8f4db02037e29efa1615e5c788162046001fcdacf55d115f89999a559b094e5bd0f690541fa1567abd3498d7465db9196393236388c1c5125475727c950a5959a580de63f90d4a8e2ee3ca0143593d0dfb3137675778fabfd34158ced05be0a9ae00a03a0915b3a8ad86711932b7c6d7f8415f11839a5da0daa3be8714d2155dd7a7315a50e24da1f5f6602bca7e0c70a562fd5f417772e635e2a6778792bdc7de1e525943f13cc6ffbe35a942846d88261fb52d67951fa675e967e4aba1683554b2480809c28b3f2e0d64979e93a20568c822e9ef0da81fe9e9e6740cfab883f60384ecb508b8c827b0f9021f03f8096fed4eaf9f27a25dd769a33c1e3a5e9d927061c9d2f7cc8540929ee821fe305f8dc0d667e9359a55f3281fdc60ba4daf53f5a30ace8340b8c1c41bdccb402dc47295ff5de7ec77ba31b849d1299b9e5153cb90dabc7a505f1bb1dc2c69743a9d6077b5fb0d631df3a5d29ffa83d05e5ba141f9adeb000e522d19ab8d6e481a1970c951f4a2fb5eef7ead1af27186b53779e0a28a277c52fade568fbd069ccbc36242db0bc60fcf585ee20ea12f533298970d69acc1b2bdb72c44529cd2eda575e7cf9784c3726d36d4cc6bfd2a4dc4f61a132f2643ac31586483fb8fc2298d4d4decf5a5d4dcbd8f8742d35b85cf5c9e49f2f5190673240e36143634124be8ec3b9c8083bf4468aebb7eb244be37989da7602443764f4c0d6cf031112225bad13a9cf3906ed8d4031d035a8d1800a8e7f53fad7d684102ba2e1d99914adc219948eefe492874c667eb2653b137a477735e59bf5d8a32f2cfa29dedde631c21029f2d8c84554c7d607d8dc62ea3d6829ac1664b71763c4f05af6fb7cbf6613c53c9e73874e08979c60ed6c33066f575e2957225214a82f45c40c57aa7ce8f55e4b4f6904d09d64075aa00a50f2e9e9b082a8b77835c6efca64b405d9495cc4a99339cb7d1835eec28ab8539103a80a3170ee866840316b363b2342c0fba231126b23ba51d3f81f1c88b55f2d098e9ff79b6607bc9712a678cf9b3741ed0bb7c2ea5206e708f46c3964c10dd235b62aa8845e4aaadfb1ec0584b64fcf87700fff3b6ba3a3a853208cc2d54ff38c686a5a498223879480a95d9a951a6d9227a89533d0386452ab7000060f84b72f896faff9c2dafdfb475ca5d8e956c6c08a116116eb0015c9a73b9eea8dd8299a29eb6b0763754903b7bfa1002301d2e9e1be59f02a24e890ff9ef99d8f5be36c00c750c7a24cfdef1cf519294d039ddf79cd1132680e2e59d18c26cf5eeaebac7f0042b0608b5a7b2fda521490130aedc4af3ac2b63aeeece242d9f9e4e781f80a24c869bc054ea4a5259b5c7c10ffa91c0218e24107b3a737dd3f181d2abee701ae3818236d4cdcbd1a31aab838ed7da890261b7a614a87f36f61407db8738e15343b5014d7125410cdea5e9a07c1a33d708ad5c23fbb38c9f301865d40b8e81045c7e3eb0247ed9e3a8269167ad8612a7225ed6d9a50a4dd9c06e8fa44affe06921b1231e9d4c4219786569bbc108ffbc2e8994d3d91d33d8b35a0568c7809c08725e0f5d381d625be28615a33e1d2c46d1aa476e9ad117c1db50a9f43b91bba36d00d1e456f8dc9fdfdeb8ec7fdc83c2c52e32b917f37efd1c0d05af3099cf8be6c095c6f65d7ddfa923ec8c1cf7e840e1ba45580928adbbcf577aaec6b6518c24eaa793517499f1f2c8cd824667858e995f59b7573c3f2ae969b22a8db40c46e221ccfa670a32c6f01e0c1f5d3cb76f65742ac76283c8eca9ec13fd842614426dbf7b73f896f115923e89def8114a7b55ca345390cdfd8d35f906a9669ab8bc07b8e11bbf10fa152274232561bef3267ed645b746efc39bab873848e9be9b595a62524ceaf54c81e8e3f0e5fb21b3c7ea9dde2af547ed27f168ef891f5ac22d8c3815f02160f434762ec229f525c1878e14f9154c25807e77a91d450bf18df1036006853135aee870cede74282a20fc186ead1afd4ee2072cc4397c55a1ced8bcb2014b1b18c8edbdec991c520e61dab69e77ae66a4d5f7e014c293bce73ad22b5e4b158efc83a4258ee62ee50ffb66f623a6ca832dc484cd39b14d175d8836696580ee951c526cd60bf9cab7ac4e84f78edac3661990386e88178a328360e63dbab9f9bb5c3f0d9b939c7f80b14b612ea338a557a20fc4146348d8e1302667fab1ab484582a5a6d0f769c7ad7f61acd2e94df86745766d487e0b87cdc853afab379cbdfba56e3236a9085e26b90c47e37c51afcb4bcbc1aa9cb6bccd4a8b2bfb0d20b73dff90f831217d999489fa9159ed24b18d855ab0e46da341ac75709c03f59c3c0d2da3dd33d13e0fe2774dc578bacdc341cae40b311e8ee1f1368dca6a76e62b6e3eb5762e1205c22cc376805208425c2c370afd3910438c2db3d4c80189eb73763ec87a52113553909fb586a20c7ff75039b844f797c6dfa64aacc144904a8ade354617815b90a1e8a96f19ff795ded633a915402dd719f99c3ae3572503b444fc1cf9b2d2f473eddf3d094d741183c6c984af3972971921bd781c351ceba75832791369e22c9b079358393dbdca930a0c6617fc980b4637c47b2aa18e24e27643028ecdbc5a5bcc04ac0d5ed9f5964b2582aae5bde6d811e876a40a0a89a1753b508ba599824fc6655ea1c24ac639622d2bb42738e2b0b4213c41e350c102276c7adc2e561e13fc2c1ff7a1e4f405380aaa0e9acd034e66aae2d88a70f9595b898856e49a2ec2858cc1491f754d5f06608dc69d429ba8749a6ee5177e561dc9df364256861c29b73068a41a8196a64ef641faafa90386f667ee9a574404919e0dc4a7a4521bd34c70d6a62241727c85291f4191a33b3bafbd10ba4501a8ce1d11b7f6fe8135500d6070c09fb68919f376266ae22c66c19647b9e45b66c72c1ac2936d2d6d1f7b380e3fe9c4c243de145552bee5268a33bb39967a8b0cededbf5c742be3d67aeb7a02d9f046b484b28e4172f0c1c4e38ab2ec57a4de41ffb1003e21b311c1a4107ad6a80975e11b10b39bc721e033aaa20940f46e6bb8e6eb3d69c2a9d16f8afdb4ffa623e1db7b80b42123f947487d8c97f752f951ef7fc1b7b293840b26da09d8d55e9e40c250ea4d0c8b4f96478e0fc4727cb5ffa2e027d77aceb84794dd3de8877af46fa526f8ccb92b5531ed6ceb9ead9de89a1a98d2e8925698ec3cdf84ace768e04bf5fa0a6acde8ef5e3d83963520951b88acbefd21ea10ee8f2f71a60bfeb3856e73a7d9eb9a3b1322cbbf23e1358a95d027d49d89e4d91c2281626b853a5f5816a2ed07acd2d0980e831e852d41d7d5d37a7ece43f906c02134844656d3fd279abaa87402c3febfc7c99d330cfc2f3efb9ef81f6841c0bb791e880dbc01dd3e05705fba354b739ab7d36a8e7e8d6f7f95b227e920f200a24cd9862aedf437cce785ac9cee503dd92874985481bc20f4890494c0829cde3b1fce8346f06b10e79ce8b3a2bdb4b16908a8a92e7360837aba4e2d8105265ce839545723af8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">已加密，请输入密码查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习笔记</title>
      <link href="/cpp_learning/"/>
      <url>/cpp_learning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++ 学习笔记上传（研）</p><p><a href="https://mqroad.notion.site/C-0fbc6625c13149f482d984f82a02b70e">原链接</a></p><span id="more"></span><h1 id="小概念集锦"><a href="#小概念集锦" class="headerlink" title="小概念集锦"></a>小概念集锦</h1><ul><li>外存储器的容量大， 大部分可移动，便于在不同计算机之间进行信息交流。其只有被读入内存储器后才可被CPU读取，即CPU不能直接访问外存储器</li><li>进程是可以并发执行的程序的执行过程</li><li>循环队列是顺序存储结构</li><li>拷贝构造函数：<ul><li>程序中需要新建立一个对象，并用另一个对象去初始化</li><li>函数的参数为类的对象</li><li>函数的返回值是类的对象</li></ul></li><li>类外同名的变量赋值，不能改变类内的静态变量值</li><li>程序中的 typename 都可以替换为 class</li><li>NULL 与 nullptr<ul><li>NULL 在 C 中表示 void<em>，即指向任意类型的指针，C 中会完成隐式类型转换，但 C++ 中是强制类型转换，导致 void</em> 不能隐式转换为其他类型</li><li>起初 C++ 用 0 代替空指针，但其在函数重载时发生二义性，后续直接用 nullptr，而 NULL 表示 0</li></ul></li></ul><h1 id="CPP小概念"><a href="#CPP小概念" class="headerlink" title="CPP小概念"></a>CPP小概念</h1><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><h3 id="结构化程序设计框架"><a href="#结构化程序设计框架" class="headerlink" title="结构化程序设计框架"></a>结构化程序设计框架</h3><ul><li>函数是程序的基本单元</li></ul><h3 id="面向对象程序设计框架"><a href="#面向对象程序设计框架" class="headerlink" title="面向对象程序设计框架"></a>面向对象程序设计框架</h3><ul><li>类是程序的基本组成单元</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>单精度不能超过 7 位有效数字，双精度不能超过 15 位</li><li>一个字符串常量在存储时在给定的字符序列后再加一个空字符（‘\0’），而字符常量不加</li><li>任一种进制的整数，可添加后缀字母 U 或 L，表示无符号整型（usigned int）和长整型（long int），也可同时添加两者，无排序要求，如：55L，100LU</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>变量的存储类属性<ul><li>auto（自动变量）：默认存储类别，占用空间的分配和释放由系统自动完成</li><li>register（寄存器变量）：寄存器虽然快，但其数量有限，当其不够时，仍然按照 auto 处理</li><li>static（静态变量）：任何静态变量的生存期将延续到整个程序的终止；编译器为其分配的空间在整个程序运行期间不会释放；若未赋初值，系统自动赋值为 0</li><li>extern（外部变量）：声明为外部变量后，该变量可被其他文件引用，可避免为其重复分配内存</li></ul></li><li>typedef 类型<ul><li>给现有的数据类型起一个别名</li></ul></li><li><p>符号常量</p><ul><li>概念：用 const 修饰的标识符</li><li>原则：先声明，后使用</li><li><p>声明：const int i = 1；</p><p>用 const 声明的常量只能被读取，故在声明时需初始化，且其值在程序中无法改变</p></li><li><p>可用预处理命令 #define 定义符号常量：#define PI 3.14</p></li></ul></li></ul><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>单目</li><li>双目</li><li>三目：?:（C++只此一个）</li></ul><h3 id="运算类型"><a href="#运算类型" class="headerlink" title="运算类型"></a>运算类型</h3><ul><li>赋值运算：可一次性给多变量赋值：x=y=z=1; 其从右往左依次赋值，即 z=1，接着将 z=1 赋给 y，得 y=z=1，最后得 x=y=z=1</li><li>自增运算<ul><li>a++：先参与运算，运算后再 +1</li><li>++a：先 +1，再参与到运算中</li></ul></li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>！</li><li>&amp;&amp;</li><li>||</li></ul><p>优先级依次递减</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul><li><p>条件运算符：?:</p><p>  <code>a&gt;b ? 1:0；若a&gt;b，返回1 ，否则0</code></p></li><li><p>逗号运算符：返回最后表达式的值</p><p>  <code>(a = 3 * 5, a * 4), a + 5; // a = 15，表达式结果为 20</code></p></li><li><p>sizeof运算符：取得任何变量和类型在内存中占用的字节数</p><p>  <code>sizeof(int);  //4</code></p></li></ul><p><code>#include &lt;cmath&gt; // C++ 数学函数</code></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针和地址"><a href="#指针和地址" class="headerlink" title="指针和地址"></a>指针和地址</h2><ul><li>指针：变量的地址就是该变量的指针</li><li>指针变量：存放地址的变量</li><li>指针运算<ul><li>指针变量和整型量加减 = 指向下一元素</li><li>相同的指针变量类型之间可以赋值</li><li>两个指向同一类型的指针变量进行逻辑运算，实质是地址的比较</li><li>两指向同一数组成员的指针变量可减运算，结果为两指针之间相差的元素个数</li></ul></li><li><p>指针和数组</p><ul><li>数组名即为该数组首元素的地址，即指针</li><li><p>数组名是常量指针，而指针是指针变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首元素的地址给指针</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line">p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取首元素</span></span><br><span class="line">a[<span class="number">0</span>];</span><br><span class="line">*p;</span><br><span class="line">*a;</span><br></pre></td></tr></table></figure></li><li><p>字符串常量可以赋给指针变量，会将前者第一个字符的指针给后者</p></li></ul></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>引用即为变量起别名</li><li>既然是起别名，在定义时就要初始化，即指定给谁起别名</li><li>既然是别名，那么对引用的操作就是对变量本身的操作</li><li>引用就是两个变量使用的是同一块内存单元</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;j = i; <span class="comment">// 给 i 起别名为 j</span></span><br></pre></td></tr></table></figure><ul><li>&amp;只是标识符，非取地址符</li><li>一旦引用被初始化，不可更改为另一变量的引用</li></ul><h2 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h2><ul><li>静态存储分配是在编译阶段确定变量占据的空间，而部分程序只有在运行时才能确定，即为动态内存分配</li><li>new 申请，delete 释放</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对某种数据类型分配空间，赋初值10</span></span><br><span class="line"><span class="type">int</span> *a;</span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组</span></span><br><span class="line"><span class="type">int</span> *b;</span><br><span class="line">b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">// 元素个数可以是变量，这是与一般的数组声明最大的区别</span></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br></pre></td></tr></table></figure><ul><li>动态内存分配是在堆内存或自由存储区，数量有限，当耗尽时再申请会返回空指针 NULL，故在分配空间后，可做判断如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//正常结束程序</span></span><br></pre></td></tr></table></figure><ul><li>动态分配后的内存需显式的释放，由 new 申请，则必须由 delete 释放</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数及声明"><a href="#函数及声明" class="headerlink" title="函数及声明"></a>函数及声明</h2><ul><li>函数不能嵌套，即函数内部不能定义其他函数</li><li>函数原型声明的两种形式（注意是声明不是定义）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//或省略形参变量名</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> [], <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="参数的传递方式"><a href="#参数的传递方式" class="headerlink" title="参数的传递方式"></a>参数的传递方式</h3><ul><li>值传递<ul><li>实参不变，将实参复制一份给形参</li><li>虽不会改变实参的值，但当传递参数的大型的类对象时，空间和时间开销过大</li></ul></li><li>传地址<ul><li>传地址之后将改变实参的值</li></ul></li><li>引用传递<ul><li>隐式的传地址</li><li>参数声明为引用时，调用时编译器将自动传递实参的地址给被调用函数</li></ul></li></ul><p>一般情况下，当传递大型的数组或类对象时，采取传递指针的方式，因为任意类型的指针大小是一样的（32位下为 4 字节，64 位下为 8 字节），相比复制传递的方式，空间开销小很多。</p><p><em>建议传地址时使用引用代替指针</em></p><ul><li>指针和引用的区别<ul><li>定义和性质的不同<ul><li>指针是地址，引用只是变量的别名，与原变量共用一块地址</li></ul></li><li>函数传参时的区别<ul><li>指针传参可以直接操作实参的地址，对实参进行改变</li><li>引用传参是直接传递实参本身，节约时间空间</li></ul></li></ul></li></ul><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul><li><p>默认参数</p><ul><li><p>缺省的实参只能用于替换函数调用中缺少的尾部实参，即函数调用是按位置依次赋值的，不是按照参数的类型匹配的，即实参的类型要和形参的顺序一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">default_n</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">default_n</span>(, , <span class="string">&#x27;&lt;&lt;&#x27;</span>);  <span class="comment">// 该调用并不等价于 default_n(1, 2, &#x27;&lt;&lt;&#x27;);</span></span><br><span class="line"><span class="built_in">defaulr_n</span>(<span class="string">&#x27;&lt;&lt;&#x27;</span>);      <span class="comment">//同上</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>参数个数/参数类型不同</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li>为取代预处理宏函数</li><li>inline 关键字放在函数定义中的函数类型之前</li><li>内联函数和宏函数<ul><li>宏函数由预处理器进行替换，而内联函数由编译器实现，是真正的函数</li><li>但内联函数调用时像宏一样展开，执行效率更高</li></ul></li><li>内联函数和普通函数<ul><li>普通函数的调用将控制转移给被调用函数，从而调用有一定的时间和空间开销</li><li>内联函数直接将被调用函数复制一份到调用的地方，效率更高</li><li>但该优点也是缺点，即内联函数的函数体不能太大，结构也不能太复杂，否则编译器将放弃内联方式转而采用普通方式调用</li></ul></li></ul><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li>数据成员：属性<ul><li>类中数据成员的类型任意，包括另一个类的对象</li><li>虽自身类的对象不能作为数据成员（因为类还没定义完成，该类型没法分配存储空间），但自身类的指针或引用可以（任意类型的指针大小是确定的）</li><li>类体内不能对数据初始化，初始化由构造函数完成</li></ul></li><li>成员函数：行为<ul><li>在类内定义的成员函数皆为内联函数</li><li>类外也可定义函数，通过<code>类名+作用域运算符::</code>来表明函数属于哪个类</li><li>成员函数可重载，参数可设置默认值</li></ul></li><li>类成员的访问控制<ul><li>私有成员只能被自己所属类中的成员函数及友元函数访问</li></ul></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>对象的定义</p><ul><li><p>可定义一般类对象、对象数组、对象指针、对象引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c2</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">class</span> *c3;</span><br><span class="line"><span class="keyword">class</span> &amp;c4 = c1;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象的成员及其访问</p><ul><li><p><code>.</code> 运算符：访问一般对象的成员（数据成员或成员函数），也可访问对象引用或对象数组的成员，方法一致</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hour;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">settime</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Time T1;</span><br><span class="line">T1.hour;</span><br><span class="line">T1.<span class="built_in">settime</span>();</span><br></pre></td></tr></table></figure></li><li><p><code>-&gt;</code>运算符：访问一个指针变量所指向的对象成员，等价于 <code>(*对象指针名).成员</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time T1;</span><br><span class="line">Time* T2 = T1;</span><br><span class="line"><span class="comment">//对象指针变量 T2 的成员访问</span></span><br><span class="line">T2 -&gt; hour;</span><br><span class="line">T2 -&gt; <span class="built_in">settime</span>();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">(*T2).hour;</span><br><span class="line">(*T2).settime;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><ul><li>构造函数的作用：用于新建对象的初始化工作</li><li>析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等</li></ul><p>每当创建对象，需要对该对象完成初始化时，则需要定义自己的构造函数；而对象撤销，需要自己添加清理工作代码时，则需要定义自己的析构函数</p><ul><li>共同特点：<ul><li>类体中说明的两种成员函数</li><li>没有返回值，void也不行</li><li>构造函数可带参数，可重载；析构函数都不能</li></ul></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>函数名与类名相同</li><li>函数体可在体内/体外</li><li>一般声明为公有函数</li><li>在定义对象时被系统直接调用，用户不能直接调用构造函数</li><li>构造函数初始化对象：<code>类名 对象名 (参数表)</code>，如：class c1 (1,2,3);</li><li>运算符 new + 构造函数： <code>class * c2 = new class ()</code></li><li>定义对象数组时只能调用没有参数或所有参数都有默认值的参数</li><li>定义对象指针时不会调用构造函数，因为指针变量还未实例化</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>~ 类名</li><li>函数体可在体内/外</li><li>在对象生存期即将结束时由系统自动调用，之后对象消失，内存空间被释放</li><li>一个类只能定义一个析构函数</li><li>delete 运算符和析构函数一起使用</li></ul><h3 id="默认构造-析构函数"><a href="#默认构造-析构函数" class="headerlink" title="默认构造/析构函数"></a>默认构造/析构函数</h3><ul><li>不带参数</li><li>函数与类名相同</li><li>参数为空或所有参数带默认值</li><li>用户未定义时系统自动建立</li></ul><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li>只有一个参数，类型是本类对象的引用</li><li>每个类必须要有，若没有则编译系统自动生成一个公有的</li><li>被调用的 3 种情况：<ul><li>用类的已知的对象去初始化另一对象</li><li>对象作为函数的实参传递给函数形参</li><li>对象作为函数的返回值</li></ul></li><li>形式： <code>Copy_ConsFun_Name(const class_name &amp;obj_name)</code></li></ul><h2 id="自由存储对象"><a href="#自由存储对象" class="headerlink" title="自由存储对象"></a>自由存储对象</h2><ul><li>由堆运算符 new 和 delete 建立和删除</li><li>new 创建单个对象：根据参数调用构造函数</li><li>new 创建对象数组：调用默认构造函数</li><li>delete 删除对象：调用析构函数</li><li>new 或 delete 是显式的调用构造函数，调用的顺序取决于 new 和 delete 的顺序，析构的顺序不一定与构造的顺序相反，但对象数组中各个元素的构造和析构仍然是相反的</li><li>delete 删除对象和对象数组时各调用一次析构函数</li></ul><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ul><li>对象创建后，对象的每个成员函数都含有一个系统自动生成的隐含指针，用于保存该对象的地址</li><li>“指向本对象的指针”</li><li>成员函数所属的对象指针，指向类对象的地址</li><li>成员函数可以通过该指针知道自己属于哪个类</li><li><code>this -&gt; 成员变量</code></li><li>可用于区分形参变量和对象成员变量（形参变量和成员变量标识符一致时更加明显）</li><li><p>一般不写，系统默认设置，但要注意：</p><ul><li>只能在类的成员函数中使用，指向该函数被调用的对象，一般用于返回当前对象本身</li><li><p>静态成员函数没有 this 指针</p><p>  编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p></li><li><p>友元函数没有 this 指针 （因为友元函数不属于任何类）</p></li></ul></li></ul><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>类中的非静态成员，每个类对象都有一个拷贝（副本），相互独立；而静态成员便是解决同一类的不同对象之间的数据和函数共享问题的，即不管该类拥有多少对象，其静态成员都只有一个副本，该副本被所有对象共享。</p><ul><li>表示整个类范围的信息，以 <code>static</code>声明</li></ul><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><ul><li>静态数据成员的值对所有对象都是一样的，但每个对象可以更新其值</li><li>必须初始化，格式为：<code>数据类型 类名 :: 静态数据成员名 = 值</code><ul><li>初始化在类体外进行，且前面不加 static，以免与一般静态变量或对象相混淆</li><li>初始化时使用作用域运算符来表明所属的类，因静态数据成员是类的成员</li><li>初始化时不加该成员的访问权限控制符</li></ul></li><li><p>若静态数据成员为 <code>public</code>，可在程序中引用该成员：<code>类名 :: 静态数据成员</code>，此时若未初始化，编译系统会自动赋值 0</p><p>  也即：静态成员变量既可以通过对象名引用（<code>obj.static_memb</code>），也可通过类名引用（<code>class_name::static_memb</code>）</p></li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul><li>用于访问类中保护或私有成员的公有接口</li><li>以 <code>static</code> 声明，属于类，由所有对象共享</li><li>可在类内/外定义，类外定义时不加 static</li><li>对对象的访问：<ul><li>可直接访问类中说明的静态成员，但不能是非静态成员</li><li>非静态成员需通过参数传递的方式得到对象后再通过对象访问</li></ul></li><li>main() 函数中对静态函数的调用：<code>类名 :: 静态成员函数名 (参数可选)</code>或 <code>对象名.静态成员函数名</code></li><li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）</li></ul><h2 id="常成员"><a href="#常成员" class="headerlink" title="常成员"></a>常成员</h2><p>对于既需要共享，又不希望其值被改变的数据，可定义为常成员进行保护，保证其在整个程序运行期间不可改变，用 <code>const</code>修饰符定义</p><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><p>使用 const 关键字修饰的对象</p><ul><li><code>类名 const 对象名</code> 或 <code>const 类名 对象名</code></li><li>常对象必须有初值，且不能被更新</li><li>常对象只能调用类中的常成员函数</li></ul><h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p>使用 const 关键字说明的成员函数</p><ul><li><code>返回类型 成员函数名 (参数) const</code></li><li>函数实现部分也要带有 const 关键字：<code>type class_name :: memb_fun(argu) const</code></li><li>不能更新对象的数据成员，也不能调用类中没有用 const 修饰的函数</li><li>const 关键字可用于对重载函数的区分</li></ul><h3 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h3><p>使用 const 关键字修饰的数据成员</p><ul><li><code>const type name</code></li><li>定义必须出现在类体中</li><li><p>必须通过构造函数的成员初始化列表进行初始化（唯一的方法），且不能被更新，格式：</p><p>  <code>类名 :: 类名(形参) ：常数据成员 (赋值)</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VLA</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m_len;</span><br><span class="line">    <span class="type">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VLA</span>(<span class="type">int</span> len);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须使用初始化列表来初始化 m_len</span></span><br><span class="line">VLA::<span class="built_in">VLA</span>(<span class="type">int</span> len): <span class="built_in">m_len</span>(len)&#123;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul><li>解决类外访问类的私有和保护成员</li><li>友元机制允许一个类授权其他的函数访问其非公有成员，减小开销，提高程序运行效率</li><li>友元声明<ul><li>关键字： <code>friend</code></li><li>只能在类的声明中出现</li></ul></li></ul><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul><li>在类体中以 friend 声明，独立于当前类的外部函数</li><li>可以是不属于任何类的非成员函数，也可以是其他类的成员函数，可访问该类中的私有成员</li><li><code>friend 数据类型 友元函数名 (形参)</code></li><li>在类定义时声明，一般在类外定义友元函数（类中声明，类外定义）</li><li>普通友元函数（即类的非成员函数）引用类的私有成员时，需通过对象，即<code>对象名.</code>的形式，因普通友元函数不是类的成员函数</li><li>一个函数可被多个类声明为友元函数</li></ul><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>类B为A的友元类，则：</p><ul><li>B 中的所有成员函数都是 A 的友元函数，可访问 A 的所有成员</li><li><code>friend 类名</code><ul><li>友元类不具有对称性：B是A的友元类，但A不是B的</li><li>友元类不具有传递性：A是B的友元类，B是C的友元类，不代表A是C的友元类</li></ul></li></ul><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><ul><li>数组元素是对象，且每个元素是同一个类的对象</li><li>定义：<code>类名 数组名 (元素个数可选)</code></li><li>访问：<code>数组名[下标可选].成员名</code></li><li>创建类的对象数组的条件：<ul><li>没有给出构造函数，调用系统默认构造函数</li><li>有一个不带参数的构造函数</li><li>一个构造函数的参数全是默认参数</li></ul></li><li>对象数组的生命周期结束时，默认给每个元素调用一次析构函数，也可通过 delete 强制调用,，构造同理</li><li><p>若定义对象数组时没有使用初始化列表进行初始化，则会为每个对象调用默认构造函数</p><p>  若初始化项少于数组中的对象，则对剩余的对象调用默认构造函数</p></li></ul><h3 id="成员对象"><a href="#成员对象" class="headerlink" title="成员对象"></a>成员对象</h3><ul><li>一个类的成员是另一个类的对象</li><li><code>class c &#123; c1 obj1; c2 obj2; &#125;;</code></li><li><p>类中有成员对象时，该类的构造函数要调用这些成员对象所在类的构造函数，并采用初始化列表进行初始化</p><p>  构造函数的调用顺序取决于类中的说明顺序，析构的调用相反</p></li><li><p>只能调用成员对象的公有函数或变量</p></li></ul><h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>继承：在现有类的基础上创建新类，新类得到已有类已经具备的特性</li><li>派生：从已有类（基类）产生一个子类（派生类）</li><li>单继承、多继承</li><li>基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样</li><li>派生类将基类的所有成员全部接收过来，除了构造和析构函数</li><li>派生类可对基类初始化</li></ul><h2 id="派生类对基类的访问"><a href="#派生类对基类的访问" class="headerlink" title="派生类对基类的访问"></a>派生类对基类的访问</h2><div class="table-container"><table><thead><tr><th>继承方式/基类成员</th><th>public成员</th><th>protected成员</th><th>private成员</th></tr></thead><tbody><tr><td>public继承</td><td>public</td><td>protected</td><td>不可见</td></tr><tr><td>protected继承</td><td>protected</td><td>protected</td><td>不可见</td></tr><tr><td>private继承</td><td>private</td><td>private</td><td>不可见</td></tr></tbody></table></div><ul><li>基类中的私有成员在派生类中不可访问，只能在基类访问</li><li>派生类中可访问基类中的公有和保护成员</li></ul><h2 id="派生类的析构和构造函数"><a href="#派生类的析构和构造函数" class="headerlink" title="派生类的析构和构造函数"></a>派生类的析构和构造函数</h2><p>基类的构造和析构不能被继承，故派生类的构造函数须调用基类的构造函数以初始化，同理，对派生对象的清理也需要新的析构函数</p><h3 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h3><ul><li>问题：<ul><li>考虑新增成员的初始化</li><li>考虑基类成员的初始化</li></ul></li><li>解决：<ul><li>执行派生类的构造函数时，调用基类的构造，注意是调用基类的构造函数，不是声明</li></ul></li><li><p>执行顺序：</p><ul><li><p>调用基类的构造函数：按照定义派生类时基类的声明顺序进行，而与派生类构造函数的成员初始化列表给出的顺序无关</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son_class</span>:<span class="function"><span class="keyword">public</span> <span class="title">dad_class1</span><span class="params">(x)</span>, <span class="title">dad_class2</span><span class="params">(x1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//调用构造函数时先调用基类 dad_class1 的构造，接着调用 dad_class2 的</span></span><br></pre></td></tr></table></figure></li><li><p>调用成员对象的构造函数：派生类中有多个成员对象时，按照派生类中声明成员对象的顺序进行，同样与初始化列表无关</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son_class</span>:<span class="function"><span class="keyword">public</span> <span class="title">dad_class1</span><span class="params">(x)</span>, <span class="title">dad_class2</span><span class="params">(x1)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dad_class2 c2;</span><br><span class="line">dad_class1 c1;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用构造函数时先调用基类 dad_class2 的构造，接着调用 dad_class1 的</span></span><br></pre></td></tr></table></figure></li><li><p>执行派生类构造函数体中的内容，完成对派生类的初始化</p><p>  派生类中既有对基类的声明，又有成员对象时，先调用基类的构造函数，再调用成员对象所属类的构造函数，最后调用派生类自己的构造</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son_class</span>:<span class="function"><span class="keyword">public</span> <span class="title">dad_class1</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dad_class2 c2;</span><br><span class="line"><span class="built_in">son_class</span>(……) &#123;……&#125;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先调用基类 dad_class1 的构造，接着调用 dad_class2 的，最后调用自身的</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h3><p>调用过程与构造相反</p><ul><li>对派生类普通成员清理</li><li>调用成员对象的析构，对派生类新增的成员对象清理</li><li>调用基类析构，对基类清理</li></ul><h2 id="多继承与虚基类"><a href="#多继承与虚基类" class="headerlink" title="多继承与虚基类"></a>多继承与虚基类</h2><h3 id="多继承中的二义性"><a href="#多继承中的二义性" class="headerlink" title="多继承中的二义性"></a>多继承中的二义性</h3><ul><li>一个派生类有两个或多个基类</li><li>在派生类中对基类的访问应该是唯一的</li><li>在多继承情况下，派生类对基类中某个成员的访问出现不唯一的情况，即产生二义性</li><li><p>产生二义性问题的两种情况：</p><ul><li><p>多继承中，有两个或两个以上的基类存在同名成员，采用<code>对象名.函数名</code>直接调用时无法判断属于哪个类</p><p>  解决方法有二：</p><ul><li><p>通过作用域运算符进行限定，指定是哪个基类的函数</p><p>  <code>对象名.基类名 :: 成员函数名()</code></p></li><li><p>在派生类中定义同名成员以屏蔽基类中二义性的成员，但此时仍然可通过 :: 指定访问</p></li></ul></li><li><p>一个派生类从多个基类派生，且这些基类有一个共同的基类时，派生类访问该共同基类的成员时产生二义性</p><p>  解决方法同上，但更优的方法是虚基类</p></li></ul></li></ul><h3 id="虚基类（虚继承）"><a href="#虚基类（虚继承）" class="headerlink" title="虚基类（虚继承）"></a>虚基类（虚继承）</h3><p><a href="http://c.biancheng.net/view/2280.html">http://c.biancheng.net/view/2280.html</a></p><p>解决二义性问题，将共同基类定义为虚基类，方式如下</p><ul><li>定义<ul><li><code>class c_name : virtual 继承方式 基类名</code></li><li><code>class c_name : 继承方式 virtual 基类名</code></li></ul></li><li><p>注意</p><ul><li>虚基类是在声明派生类时，指定继承方式时声明的</li><li><p>虚基类派生的类，只产生一个虚基类子对象</p><p>   （可以理解为在派生类中只保留了一份共同基类的成员，这样就不会产生歧义了）</p></li><li><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p></li></ul></li><li><p>虚基类的构造函数</p><ul><li>虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</li><li>虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。</li><li><p>直接或间接继承虚基类的派生类，其构造函数的成员初始化列表中，都列出了对虚基类构造函数的调用，而在最后的派生类中，除了对直接基类的初始化，还要对虚基类初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚基类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">A</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;    <span class="comment">// B 的直接继承中调用了A 的构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::<span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> c): <span class="built_in">A</span>(a), <span class="built_in">m_c</span>(c)&#123; &#125; <span class="comment">// C 的直接继承中调用了A 的构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_c=&quot;</span>&lt;&lt;m_c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接派生类D</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// D 的间接继承中调用了直接继承 B、C 的构造，以及间接继承 A 的构造</span></span><br><span class="line">D::<span class="built_in">D</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d): <span class="built_in">A</span>(a), <span class="built_in">B</span>(<span class="number">90</span>, b), <span class="built_in">C</span>(<span class="number">100</span>, c), <span class="built_in">m_d</span>(d)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;<span class="string">&quot;, m_c=&quot;</span>&lt;&lt;m_c&lt;&lt;<span class="string">&quot;, m_d=&quot;</span>&lt;&lt;m_d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="子类型关系（向上转型）"><a href="#子类型关系（向上转型）" class="headerlink" title="子类型关系（向上转型）"></a>子类型关系（向上转型）</h2><p>类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。</p><h2 id="虚函数与多态性"><a href="#虚函数与多态性" class="headerlink" title="虚函数与多态性"></a>虚函数与多态性</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>同一接口为不同的对象服务</li><li>分类<ul><li>编译时的多态：通过函数重载和模板实现，在编译阶段确定调用哪个函数，实现机制称为“静态绑定”</li><li>运行时的多态：只有在运行时才知道是哪个函数，“动态绑定”</li></ul></li><li>多态是通过虚函数实现的</li></ul><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li>指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数</li><li>通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数</li><li>而虚函数允许在派生类中定义与基类同名的函数，且可用基类的指针或引用访问基/派生类中的同名函数</li><li>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong></li><li>C++中虚函数的唯一用处就是构成多态，有了多态，只需要一个指针变量就可以调用所有派生类的虚函数</li><li>虚函数可以是另一个类的友元函数，但不能是静态成员函数、内联函数、构造函数</li><li>派生类中可以重新定义从基类继承下来的虚函数，也可以不需要。但在派生类中重新定义虚函数时，函数名、形参表、返回值类型必须保持不变</li><li>换句话说，虚函数使得派生类可以更改（其实是覆盖）基类中的同名函数</li><li>若基类声明了虚函数，则在派生类中凡与该函数同名，同类型，同参数个数的均为虚函数</li></ul><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul><li>一般情况下，清理派生类的对象时先调用派生类的析构，再调用基类的析构</li><li>但若用 new 建立了临时对象，如果基类中有析构，且定义了一个指向基类的指针变量，那么程序在用带指针参数的 delete 撤销对象时，系统只调用基类的析构</li><li>故若要调用派生类的析构函数，就要将其声明为虚函数，即虚析构函数</li></ul><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><ul><li>在基类中给派生类预留一个虚函数的名，但基类不知道拿这个函数干嘛，留给派生类补充函数体</li><li>即基类无法确定一个虚函数的具体操作方式或者内容，只能靠派生类提供该虚函数的具体实现方式，即为纯虚函数</li><li><code>virtual 类型 函数名 (参数表) = 0；</code><ul><li>纯虚函数没有函数体</li><li>“=0” 并不是返回值为 0，只是告诉编译系统这是纯虚函数</li><li>是声明语句，所以句尾要有分号</li><li>将一函数声明为纯虚函数，仍可以有函数体，即纯虚函数的标志是 “=0”，而不是有无函数体</li><li>纯虚函数不得声明为内联函数</li></ul></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>拥有纯虚函数的类称为抽象类（一般为基类）</li><li>抽象类不能用来定义对象</li><li>若抽象类的派生类没有重新定义来自基类的纯虚函数，则该函数在派生类中亦是纯虚函数，派生类也为抽象类，而派生类可将重定义纯虚函数的任务转交给自己的派生类</li><li><p>几点说明：</p><ul><li>只要基类包含一个或多个纯虚函数，就是抽象类，抽象类不能用于定义对象</li><li>在类的层次结构中，顶层或上面几层皆可为抽象基类，抽象基类是各类的共性</li><li>抽象基类是本类族的公共接口</li><li>抽象类可以实现多态，道理同虚函数</li><li><p>只有类中的虚函数才能声明为纯虚函数，普通的函数不能</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶层函数不能被声明为纯虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//compile error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//普通成员函数不能被声明为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//compile error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>运算符重载是多态的体现</li><li>C++ 把重载的运算符看做特殊的函数，称为运算符函数，故运算符重载就是函数重载的一种</li><li>运算符重载是对现有运算符的重载，不能利用重载创造新的运算符</li><li>不能重载的运算符：<code>.</code> 、<code>·*</code> 、<code>-&gt;*</code> 、<code>::</code> 、<code>?:</code></li><li>不得为运算符函数设置默认值，故在调用时不能省略实参</li><li>任何运算符在作为成员函数重载时不得重载为静态成员函数，new 和 delete 除外</li><li>只能作为成员函数重载：<code>=</code>、<code>[]</code>、<code>()</code>、<code>-&gt;</code>以及<code>所有的类型转换运算符</code></li><li><p>关键字：<code>operator</code></p><p>  <code>返回类型 operator 运算符 (参数表) &#123;&#125;</code> </p><p>  返回类型不能是 void</p></li><li><p>运算符重载函数也是函数，满足函数的一切性质</p></li></ul><h2 id="运算符重载的两种形式"><a href="#运算符重载的两种形式" class="headerlink" title="运算符重载的两种形式"></a>运算符重载的两种形式</h2><p>成员函数形式和友元函数形式，都可以访问类的私有成员</p><h3 id="成员函数形式"><a href="#成员函数形式" class="headerlink" title="成员函数形式"></a>成员函数形式</h3><ul><li><p>定义：<code>返回类型 operator 运算符 (参数表)</code></p><p>  可将 <code>operator 运算符</code>部分看做是一个函数名</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    complex <span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A) <span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="type">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(): <span class="built_in">m_real</span>(<span class="number">0.0</span>), <span class="built_in">m_imag</span>(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag): <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现运算符重载</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;A) <span class="type">const</span>&#123;</span><br><span class="line">    complex B;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;m_real&lt;&lt;<span class="string">&quot; + &quot;</span>&lt;&lt;m_imag&lt;&lt;<span class="string">&quot;i&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    complex c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果 6.7 + 9.5i</span></span><br></pre></td></tr></table></figure><p>  执行 <code>c3 = c1 + c2</code>时，编译器检测到 <code>+</code>左边是一个 complex 的对象，故会调用成员函数 <code>operator +()</code>，将该式转换为 <code>c3 = c1.operator(c2)</code>，即对象 c3 调用重载的成员函数，该函数的参数是 c2。</p><p>  所以说，重载为成员函数时，由于具有隐含的 this 指针，一般参数只有一个。对双目运算符如上述的 + 运算符，一般参数是第二个操作数；而对单目运算符，参数表为空。</p></li></ul><h3 id="友元函数形式"><a href="#友元函数形式" class="headerlink" title="友元函数形式"></a>友元函数形式</h3><ul><li>定义：<code>friend 返回类型 operator 运算符 (参数表)</code></li><li><p>注意：</p><p>  友元函数没有 this 指针，故对双目运算符，友元函数有两个参数；对单目运算符有一个参数</p></li></ul><h2 id="典型运算符的重载"><a href="#典型运算符的重载" class="headerlink" title="典型运算符的重载"></a>典型运算符的重载</h2><h3 id="重载负运算符-“-”"><a href="#重载负运算符-“-”" class="headerlink" title="重载负运算符 “-”"></a>重载负运算符 “-”</h3><ul><li>一元运算符，作为成员函数重载时，参数为空，存在默认的 this 指针；以友元函数重载时，参数为1个。</li></ul><h3 id="重载加运算符-“-”"><a href="#重载加运算符-“-”" class="headerlink" title="重载加运算符 “+”"></a>重载加运算符 “+”</h3><ul><li>同前例子</li></ul><h3 id="重载自增-减运算符-“-”"><a href="#重载自增-减运算符-“-”" class="headerlink" title="重载自增/减运算符 “++/- - ”"></a>重载自增/减运算符 “++/- - ”</h3><ul><li>作为类的成员函数重载<ul><li>前缀运算：<code>返回类型 operator ++ ()</code></li><li>后缀运算：<code>返回类型 operator ++ (int)</code></li></ul></li><li>作为类的友元函数重载<ul><li>前缀运算：<code>friend 返回类型 operator ++ (参数 1)</code></li><li>后缀运算：<code>friend 返回类型 operator ++ (参数 1，int)</code></li></ul></li><li>为了与前缀运算符区别，c++ 编译器设定在后缀运算符重载函数中增加一个实际并不使用的整形参数，以示区别</li><li>以自增为例，前缀自增是先增1，用增 1 后的值参与运算，故返回的是增1之后运算的值，内部也增 1；后缀自增是先参与运算，运算完毕之后再增 1，故返回的是对象本身，内部依然增 1</li></ul><h3 id="重载类型转换运算符-“long”"><a href="#重载类型转换运算符-“long”" class="headerlink" title="重载类型转换运算符 “long”"></a>重载类型转换运算符 “long”</h3><ul><li>必须作为成员函数重载</li><li>类型名就是返回值类型，故不需要声明返回值类型</li><li><code>operator long（参数表）</code></li></ul><h3 id="重载赋值运算符-“-”"><a href="#重载赋值运算符-“-”" class="headerlink" title="重载赋值运算符 “=”"></a>重载赋值运算符 “=”</h3><ul><li>必须作为成员函数重载</li><li>类中出现指向动态空间的指针时重载</li><li>注意：<ul><li>返回值应声明为引用，但在函数体中通常使用<code>return * this；</code>语句返回</li><li>若参数被声明为指针或引用，一般应加上 const 修饰</li><li>一般拷贝函数也会同时出现</li></ul></li></ul><h3 id="重载复合赋值运算符-“-”"><a href="#重载复合赋值运算符-“-”" class="headerlink" title="重载复合赋值运算符 “+/-/*=”"></a>重载复合赋值运算符 “+/-/*=”</h3><ul><li>两种重载形式均可</li><li>当重载为友元函数时，需要两个参数，且第一个参数应声明为引用</li></ul><h3 id="重载关系运算符-“-gt-、-lt-、-”"><a href="#重载关系运算符-“-gt-、-lt-、-”" class="headerlink" title="重载关系运算符 “&gt;、&lt;、==”"></a>重载关系运算符 “&gt;、&lt;、==”</h3><ul><li>返回逻辑值，即返回类型为 <code>bool</code></li></ul><h3 id="重载下标访问运算符-“-”"><a href="#重载下标访问运算符-“-”" class="headerlink" title="重载下标访问运算符 “[]”"></a>重载下标访问运算符 “[]”</h3><ul><li>只能重载为成员函数</li><li><code>返回类型 operator [] (下标形参，一般为整型)</code></li></ul><h3 id="重载-C-流运算符-“-gt-gt-lt-lt-”"><a href="#重载-C-流运算符-“-gt-gt-lt-lt-”" class="headerlink" title="重载 C++ 流运算符 “&gt;&gt; / &lt;&lt;”"></a>重载 C++ 流运算符 “&gt;&gt; / &lt;&lt;”</h3><ul><li>只能重载为非成员函数，一般为友元函数</li><li><code>friend istream&amp; operator &gt;&gt; (istream&amp;, 类名&amp;)</code></li><li><code>friend ostream&amp; operator &lt;&lt; (ostream&amp;, 类名&amp;)</code></li><li>之所以返回 i/ostream 类对象的引用，是为了能够连续读取/输出</li></ul><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>一系列相关函数的模型或样板，这些函数的源代码相同，只是针对不同的数据类型</li><li>对函数模板而言，数据类型是其参数，故是一种参数化 类型 的函数</li><li><p>格式：<code>template &lt;模板形参表声明&gt; 函数声明</code></p><ul><li>模板形参表声明可以是多个，中间用逗号隔开</li><li><p>模板形参的形式：</p><ul><li>typename 参数名</li><li>class 参数名</li><li><p>类型修饰 参数名</p><p><em>关键字 typename 与 class 完全等价，两者声明的参数为 虚拟类型参数，即指定这个参数名是一种类型，而这种类型只有实例化时才知道是什么类型，其即可做函数的返回值，也可做形参的类型，还可做函数体内变量的类型；而 类型修饰 声明的参数为常规参数，形式上与普通函数的声明相同。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//此处可换行，但不能有分号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="模板函数的实例化"><a href="#模板函数的实例化" class="headerlink" title="模板函数的实例化"></a>模板函数的实例化</h3><ul><li>函数模板中声明的函数称为 模板函数</li><li>编译系统生成函数模板的某个具体版本的过程称为函数模板的实例化</li></ul><h3 id="模板实参的省略"><a href="#模板实参的省略" class="headerlink" title="模板实参的省略"></a>模板实参的省略</h3><ul><li>模板函数的调用格式：<code>模板函数名 &lt;模板实参表&gt;（函数实参表）</code></li><li><p>调用一个模板函数时，编译系统需要足够的信息判断每个虚拟类型参数对应的实际参数，主要从 模板实参表 和 函数实参表 中获取信息，且后者优先于前者，如从后者获取的信息足够判断虚拟类型的具体参数，而它们恰好是参数表中最后的若干参数，则模板实参中的那几个参数可以省略，若都被省略，则 &lt;&gt; 为空，也可省略</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如上例，调用可分几种：</span></span><br><span class="line"><span class="built_in">Swap</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(&amp;a, &amp;b);</span><br><span class="line">Swap&lt;&gt;(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a, &amp;b);</span><br></pre></td></tr></table></figure></li><li><p>不能省略模板实参的情况：</p><ul><li><p>从模板实参表获得的信息有矛盾</p><p>  若一个函数实参中获得的是 int，另一个则是 float，显然 T 不能同时为 int 和 float，为此，可将其中一个显示的给出 T 的类型</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(&amp;a, &amp;b);   <span class="comment">//将 float 强制转为 int</span></span><br></pre></td></tr></table></figure></li><li><p>需要获得特定的返回值，而不管参数的类型如何</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Swap</span>&lt;<span class="type">double</span>&gt;(&amp;a, &amp;b);   <span class="comment">//将 int，float 强制转为 double</span></span><br></pre></td></tr></table></figure></li><li><p>虚拟参数类型没有出现在模板函数的形参表中</p></li><li>函数模板含有常规实参</li></ul></li></ul><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>类模板就一系列相关类的模板，只是类型不同</li><li>模板类的声明：<code>template &lt;模板参数表声明&gt; 类声明</code></li><li><p>类模板的成员函数可在类体内或类体外定义，在类外定义模板类（需要带上模板头）：</p><p>  <code>template&lt;typename 类型参数1 , typename 类型参数2 , …&gt;</code></p><p>  <code>返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表) &#123;函数体&#125;</code></p></li></ul><h3 id="类模板的实例化"><a href="#类模板的实例化" class="headerlink" title="类模板的实例化"></a>类模板的实例化</h3><ul><li><p>两种方式：</p><p>  <code>类名 &lt;模板实参表&gt; 对象名</code></p><p>  <code>类名 &lt;模板实参名&gt; 对象名(构造函数实参表)</code></p></li><li><p>注意：</p><ul><li><p>使用类模板定义对象时，实参不能省略，即类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Point&lt;<span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">10</span>, <span class="number">15.5</span>)</span></span>;</span><br><span class="line"><span class="function">Point&lt;<span class="type">float</span>, <span class="type">char</span>*&gt; <span class="title">p3</span><span class="params">(<span class="number">12.4</span>, <span class="string">&quot;东经180度&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>除了对象变量，我们也可以使用对象指针的方式来实例化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="type">float</span>, <span class="type">float</span>&gt; *p1 = <span class="keyword">new</span> <span class="built_in">Point</span>&lt;<span class="type">float</span>, <span class="type">float</span>&gt;(<span class="number">10.6</span>, <span class="number">109.3</span>);</span><br><span class="line">Point&lt;<span class="type">char</span>*, <span class="type">char</span>*&gt; *p = <span class="keyword">new</span> <span class="built_in">Point</span>&lt;<span class="type">char</span>*, <span class="type">char</span>*&gt;(<span class="string">&quot;东经180度&quot;</span>, <span class="string">&quot;北纬210度&quot;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值号两边的数据类型不一致</span></span><br><span class="line">Point&lt;<span class="type">float</span>, <span class="type">float</span>&gt; *p = <span class="keyword">new</span> <span class="built_in">Point</span>&lt;<span class="type">float</span>, <span class="type">int</span>&gt;(<span class="number">10.6</span>, <span class="number">109</span>);</span><br><span class="line"><span class="comment">//赋值号右边没有指明数据类型</span></span><br><span class="line">Point&lt;<span class="type">float</span>, <span class="type">float</span>&gt; *p = <span class="keyword">new</span> <span class="built_in">Point</span>(<span class="number">10.6</span>, <span class="number">109</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="C-流"><a href="#C-流" class="headerlink" title="C++流"></a>C++流</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1</span>;  <span class="comment">// 应在声明时初始化，否则变量的值不确定且无法修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * pt;<span class="comment">//指向常量的指针，即指针 *pt 是指向 const int 的，即 *pt 是 const的，不能修改</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣专题刷题</title>
      <link href="/Leetcode_group/"/>
      <url>/Leetcode_group/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>发现菜的不行，按专题来吧，学一点是一点</p><p><a href="https://programmercarl.com/">参考</a></p><p><a href="https://xiaochen1024.com/">参考</a></p><!--more    --><div class="row">    <embed src="https://raw.githubusercontent.com/HBRoad/imgonline/029499dbc6f0fdbefc43c4b449d79ba17e2d3c3c/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%8E%8B%E5%8D%93%E8%80%81%E5%B8%88_%E5%8E%8B%E7%BC%A9.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h4><ul><li><p>思路一：若头结点已经是要删除的值，直接让头结点指向下一个即为删除头结点；若头结点非目标，则定义一个临时指针遍历链表，若该指针的下一节点是目标，则直接让其指向下下个节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionQ</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNodeQ* <span class="title">removeElements</span><span class="params">(ListNodeQ* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == val)    <span class="comment">//头结点即相等的特殊情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNodeQ *tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp; <span class="comment">//C++不会自动释放内存，力扣不会报错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//头结点非相等情况</span></span><br><span class="line">        ListNodeQ *p;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNodeQ *tmp = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>思路二：创建一个节点作为虚拟头结点，让其指向头结点，那包括头结点在内的所有节点的删除方式就都一致了</p><p><img src="https://s2.loli.net/2022/08/20/qYDbV9rIQAFuteX.png" alt="image-20220820224111375.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionQ2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNodeQ* <span class="title">removeElements</span><span class="params">(ListNodeQ* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNodeQ *dummy_head = <span class="keyword">new</span> ListNodeQ;  <span class="comment">//new出来的是虚拟的头节点</span></span><br><span class="line">        dummy_head-&gt;next = head;<span class="comment">//让虚拟头结点指向头结点</span></span><br><span class="line">        ListNodeQ *cur = dummy_head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h4><ul><li><p>包含了链表的增删改查等常见操作，采用虚拟头结点的方式，统一操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkNode *next;</span><br><span class="line">        <span class="built_in">LinkNode</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line">        <span class="built_in">LinkNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">//带单参数的构造函数</span></span><br><span class="line">        <span class="built_in">LinkNode</span>(<span class="type">int</span> x, LinkNode *next): <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;<span class="comment">//双参数构造</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>()  <span class="comment">//链表的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        dummyhead = <span class="keyword">new</span> LinkNode;</span><br><span class="line">        size = <span class="number">0</span>;<span class="comment">//链表的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkNode *cur = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)<span class="comment">//本题头结点是第0个</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index)    <span class="comment">//查找第i个值，也就是让临时指针移动i次，</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkNode *p = <span class="keyword">new</span> LinkNode;</span><br><span class="line">        p-&gt;val = val;   <span class="comment">//赋值</span></span><br><span class="line">        p-&gt;next = dummyhead-&gt;next;<span class="comment">//新节点的后继是旧的头结点</span></span><br><span class="line">        dummyhead-&gt;next = p;    <span class="comment">//新节点的前驱是虚拟节点</span></span><br><span class="line">        size++; <span class="comment">//链表长度+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkNode *p = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        <span class="comment">//需要遍历得到最后一个节点的位置</span></span><br><span class="line">        LinkNode *cur = dummyhead;  <span class="comment">//临时指针用于遍历链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;<span class="comment">//循环结束cur指向最后一个节点</span></span><br><span class="line"></span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line"><span class="comment">//        p-&gt;next = nullptr;    //new节点的时候已经初始化了没必要再写</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任意位置插入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkNode *p = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line"></span><br><span class="line">        LinkNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = cur-&gt;next;    <span class="comment">//该程序也满足头部插入，如 n=0 位置前插入，循环不执行，其他亦满足条件</span></span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkNode *dummyhead;    <span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">//链表长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyLinkedList *obj = <span class="keyword">new</span> MyLinkedList;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">addAtTail</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    obj-&gt;addAtIndex(-1,2);</span></span><br><span class="line">    obj-&gt;<span class="built_in">printLinkedList</span>();</span><br><span class="line">    <span class="type">int</span> param = obj-&gt;<span class="built_in">get</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; param;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><ul><li><p>反转链表并不是说将数据 5 移动到 2 的位置，而是将链表本身反转，可<a href="https://www.bilibili.com/video/BV1Ev411e7w8?t=89.8&amp;p=9">参考</a></p><p><img src="https://s2.loli.net/2023/03/30/a2eAFDVdSRc7wIM.png" alt="image-20230330211103186"></p></li><li><p>思路一：双指针法：利用两个指针交替完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mynode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    mynode *next;</span><br><span class="line">    <span class="built_in">mynode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">mynode* <span class="title">ini</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mynode *node = <span class="keyword">new</span> <span class="built_in">mynode</span>(<span class="number">0</span>);</span><br><span class="line">    mynode *head = node;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> <span class="built_in">mynode</span>(i);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line"><span class="comment">//        newnode = nullptr; //构造函数已赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="function">mynode* <span class="title">reverseLL</span><span class="params">(mynode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mynode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    mynode *cur = head;</span><br><span class="line">    mynode *tmp;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printmynode</span><span class="params">(mynode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mynode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;    <span class="comment">//无虚拟头结点</span></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    mynode *head =  <span class="built_in">ini</span>();</span><br><span class="line">    <span class="built_in">printmynode</span>(head);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    mynode *newhead = <span class="built_in">reverseLL</span>(head);</span><br><span class="line">    <span class="built_in">printmynode</span>(newhead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><ul><li><p>思路：链表题，老老实实画图吧</p><p>为方便操作，仍然定义一个虚拟头结点</p><p>总体流程：为了让 1 2 两节点交换，先让节点 2 成为头结点的后驱，再让节点 1 成为节点 2 的后驱，最后让节点 3 成为节点 1 的后驱，后续节点依次重复，如下图：</p><p><img src="https://s2.loli.net/2022/08/22/DstpAJjHu2ovcgT.png" alt="image.png"></p><p>要注意的是，在完成第一步后，cur 的指向已经变化，所以无法进行第 2-3步，因而需要在操作前保存 cur 原来的指向</p><p>1-2 完成的情况如下图：</p><p><img src="https://s2.loli.net/2022/08/22/D4uNU6HYTdk9Gog.png" alt="image.png"></p><p>即第三步是在前两步基础上的 <code>cur-&gt;next-&gt;next-&gt;next</code> </p><p>最后将 cur 后移两位，进行下一轮的交换</p><p><img src="https://s2.loli.net/2022/08/22/eDEQqH2Bf1K4Nis.png" alt="image.png"> </p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/22.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode204</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode204 *next;</span><br><span class="line">    <span class="built_in">ListNode204</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sol204</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode204* <span class="title">swappairs</span><span class="params">(ListNode204 *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode204 *dummynode = <span class="keyword">new</span> <span class="built_in">ListNode204</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        ListNode204 *cur = dummynode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode204 *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode204 *tmp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp1;<span class="comment">//步骤二</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp2;<span class="comment">//步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;<span class="comment">//指针后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummynode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><ul><li><p>思路：利用快慢指针。首先，要删除一个结点，就需要知道其前一个结点，让前一个结点指向待删除结点的下一个结点即可。如何定位到待删除结点的前一位置呢？</p><p>同样利用虚拟头结点，并定义快慢两个指针，初始时同时指向虚拟头结点，如我们要删除倒数第二个结点：</p><p><img src="https://s2.loli.net/2022/09/01/xFdaq9MptmQAb7n.png" alt=""></p></li></ul><p>快指针用于遍历，慢指针最终指向待删除结点的前一个结点。因此，要删掉第 n 个结点，需快指针移动 n + 1 位</p><p><img src="https://s2.loli.net/2022/09/01/YkULng3yVEJdbwz.png" alt="image-20220901213753617"></p><p>然后两者同时移动直至快指针指向为空:</p><p><img src="https://s2.loli.net/2022/09/01/eHVNxtR9P7So3XK.png" alt="image-20220901214446621"></p><ul><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* dummy_node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy_node-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummy_node;</span><br><span class="line">        ListNode* fast = dummy_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast-&gt;next)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h4><ul><li><p>思路一：字母异位词指的是两个字串中每个字符出现的次数相同，那么两个字串的长度肯定相等，其次，若将字串排序，那么两字串必定相等</p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/09/02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路二：哈希表：维护一个哈希表，先遍历 s 中的字符，将 s 中字符出现的次数纳入其中（因为字符只有26 个字母，故让出现的字母相对于字母 a 的位置作为哈希函数），接着遍历 t，如有相同的字符出现，减去其次数，最后哈希表为空，说明满足；否则不是。</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solutionana</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> hashtable[<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            hashtable[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            hashtable[t[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k : hashtable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><ul><li><p>思路：两个数组中有相同的元素，异或结果为 0，那就依次异或，但相同的元素导致输出重复，再调 STL 去重</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        <span class="comment">// int tmp;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums1[i] ^ nums2[j]) == <span class="number">0</span>)</span><br><span class="line">                    num.<span class="built_in">push_back</span>(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(num.begin(), num.end())</span></span>;</span><br><span class="line">        num.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; num;</span></span><br><span class="line">        <span class="comment">// int tmp;</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums1[i] ^ nums2[j]) == <span class="number">0</span>)</span><br><span class="line">                    num.<span class="built_in">insert</span>(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; <span class="built_in">result</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路：哈希表。同样的逻辑，数据模拟哈希表，让两个输入数组的值作为哈希表的下标，遍历完第一个数组，再去遍历第二个数组，只要查到有数组1中的值，说明是两者公有的。</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">1001</span>] = &#123;&#125;;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[nums1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[nums2[i]] == <span class="number">1</span>)</span><br><span class="line">                num.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h4><ul><li>思路：哈希表，快乐数的计算过程中，各位数的平方和可能一直循环而无法收敛到 1，无序查找的问题，使用无序集合，如果本次求和的结果已经存在了，就无需再计算了，因其已经进入了循环。</li><li><p>代码：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solutionidhappy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//各位数求和</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; setn;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;     </span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(setn.<span class="built_in">find</span>(sum) != setn.<span class="built_in">end</span>())<span class="comment">// find函数找到时返回位置，找不到返回end()</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                setn.<span class="built_in">insert</span>(sum);<span class="comment">//平方和结果保存</span></span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4><ul><li><p>思路：暴力，遍历数组，两两相加，找到与目标值相等的保存其位置，并结束遍历（找到就不要遍历后续了）</p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    a.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    a.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路：既然数组中的两数之和为目标值，则 target - i 的值一定在数组中，找到该值即可，相同的数异或为 0</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solutionsum</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (((target - nums[i]) ^ nums[j]) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    a.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路：哈希表。本题不仅需要知道元素是否存在，还需要知道该元素对应的下标。set 没法存储下标，选择 map 结构，又无需有序，选择效率更高的 unordered_map，具体过程如下（图源见水印）</p><p><img src="https://s2.loli.net/2022/09/04/moQtw96GpL3xhAn.png" alt="过程一" style="zoom: 80%;" /></p><p><img src="https://s2.loli.net/2022/09/04/vYayoR1VJg7bZQf.png" alt="过程二" style="zoom: 80%;" /></p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class Solution</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">auto</span> k = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">               <span class="keyword">if</span>(k != map.<span class="built_in">end</span>())</span><br><span class="line">               <span class="keyword">return</span> &#123;k-&gt;second, i&#125;;</span><br><span class="line">              <span class="comment">// map.insert(pair&lt;int, int&gt;(nums[i], i)); key 存储数组的值，value存储数组的下标</span></span><br><span class="line">               map[nums[i]] = i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">       &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h4><ul><li><p>思路：哈希法。和两数之和类似，首先进行分块，将前两个数组求和并记录和出现的次数。然后另外两个数组求和，由于总和为 0，则 0 - 该和的结果一定在哈希表中，如果查找到了，计数即可。值得注意的是，由于前两个数组求和时已经有相应的计数了，所以后续的计数是直接在前者的基础上进行迭代而非每次加 1。</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/09/05.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4sum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; unmap;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : nums1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b : nums2)</span><br><span class="line">                unmap[a + b]++; <span class="comment">//该操作会查找unmap 中是否存在 (a+b),存在则对应的value++，否则 insert (a+b)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c : nums3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d: nums4)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> k = unmap.<span class="built_in">find</span>(<span class="number">0</span> - (c+d));</span><br><span class="line">                <span class="keyword">if</span> ( k != unmap.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    count += k-&gt;second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution4sum sum4nums;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums1 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums2 = &#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums3 = &#123;<span class="number">-1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums4 = &#123;<span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = sum4nums.<span class="built_in">fourSumCount</span>(nums1, nums2, nums3, nums4);</span><br><span class="line">    cout &lt;&lt; k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h4><ul><li><p>思路：暴力。遍历两个字串，如果 rans 中的字符和 mag 中有相等的，删掉该字符，再判断下一个是否存在。直至 rans 为空</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ransomNote[j] == magazine[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ransomNote.<span class="built_in">erase</span>(ransomNote.<span class="built_in">begin</span>() + j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>思路：哈希法。字母的个数是有限的，用数组模拟哈希比较划算。统计 mag 中各字符出现的次数，再遍历 rans，次数递减，次数 &lt;0 即为失败。此外，当 rans 的长度大于 mag 时，显然是不满足的</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> m : magazine)</span><br><span class="line">            hash[m - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> r : ransomNote)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[r - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (hash[r - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><ul><li><p>思路：双指针原地反转</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionreverseString</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//reverse(s.begin(),s.end());</span></span><br><span class="line">        <span class="built_in">reverse</span>()</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> tmp;</span><br><span class="line">            tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            <span class="comment">//swap(s[left],s[right]);</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><ul><li><p>思路：按题目要求模拟</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span>*k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);<span class="comment">//注意 该函数反转区间是左闭右开，即不包括右边上限</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><ul><li><p>思路：定位空格，替换</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// string str = &quot;%20&quot;;</span></span><br><span class="line">        <span class="comment">// while(1)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     if(s.find(&quot; &quot;) == string::npos)</span></span><br><span class="line">        <span class="comment">//         break;</span></span><br><span class="line">        <span class="comment">//     auto k = s.find(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     s.erase(k,1);</span></span><br><span class="line">        <span class="comment">//     s.insert(k, str);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return s;</span></span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos)</span><br><span class="line">        s.<span class="built_in">replace</span>(s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>), <span class="number">1</span>, <span class="string">&quot;%20&quot;</span>);<span class="comment">//位置，长度，要替换的字串</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路：双指针法，原地替换。两点注意：一是替换为 “%20” 后新的字串长度，二是从后往前遍历，这样就是不用考虑元素平移的问题。（因为从前面遍历替换后，后续位置的元素需全部往后移，效率低）</p></li></ul><p><img src="https://s2.loli.net/2022/09/09/aW3v2uJTgDQsynb.png" alt="Picture6.png" style="zoom: 50%;" /></p><p>​    <a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/">图源及详解</a></p><ul><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solutionreplace</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)  <span class="comment">//确定空格的数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确定新的数组长度</span></span><br><span class="line">        s.<span class="built_in">resize</span>(len + <span class="number">2</span> * count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义双指针，一个指向旧的数组尾部，一个指向新的数组尾部</span></span><br><span class="line">        <span class="type">int</span> i = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i != j; i--, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                s[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><ul><li><p>思路：暴力？先找空格，按空格提取出单词放入容器，再反向遍历</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/09/09.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solutionreverse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; str_vec;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) == string::npos)<span class="comment">//找不到空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)<span class="comment">//特殊情况，最后一个是空格，分割后不能当做单词放入</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    str_vec.<span class="built_in">push_back</span>(s);<span class="comment">//最后一个单词也要保存</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            string tmp = s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="string">&quot;&quot;</span>)<span class="comment">//单个单词</span></span><br><span class="line">                str_vec.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            s = s.<span class="built_in">substr</span>(s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = str_vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                result += str_vec[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result +=  str_vec[i] + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;  hello world  &quot;</span>;</span><br><span class="line">    Solutionreverse obj;</span><br><span class="line">    cout &lt;&lt; obj.<span class="built_in">reverseWords</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路：先去掉空格，再整体反转，反转后单词也被反转，故再反转单词即可</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭又闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格(第一个单词前面无需空格)</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束（这里是分割出单个单词的循环</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/solution/yi-ci-bian-li-shi-xian-fan-zhuan-zi-fu-c-cmos/">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/my_resume/"/>
      <url>/my_resume/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9d991e549da270d039d425d0a2e07a19275120210d87120c77758772b702eea6">7af8d2ce0c30ef843036ed9acb974f943671cd0b821943e130d200d68447f92f2800fb7307a3c3aa022ca267062c8ae5808acd7c6b0a14fa0f2aee468950b31ae722e40a87ee5dfa9105620f8d04ab39e81ccd116d29848ffdb1698e28dcf968226b9337d4b1a356b2642a24e19b6a895861f653367f39729e65d485238ce0b4b43332a8537bbe3ca367ca1ae9bede5f0a263f5d0e19402d6384aa0076e6f0d45e9508adb5c283d10a67cd4ae5a513ead252f5ddfa577df5017700388924bee9e5acdd38925649b90421992b087c50453d6a88197df3f4d69b6ab57ae3a5b32de1b434a3cd4b7a9898e62074d582ca452f95e782cd5b429070923c800cf611c6a4b9ccec3f198cbaea3e10bdda555d0d2e462df1cb2142d1ed5e5eb9f23b5d9cf88472437b8e4bc9c6559f771587cc3233977335df1880cbcda2c195347983c1a07e57df2db7ae37f20fc8cadcb744996329ebdd80c8da0c243d1fc661a45e3c38bce63fd5162a77a309dbfe6298369f12193454d6aee4f298f2d1e7bc3bed1e6233c3af5b547acaa482c6ad67458b528feda5feec968c429af32133e9df066def80ed7a7a5e0335d6e1d12104fc0815c01991b911451609ec82a8a769a8170791a76e0c5abf8148e480c98a08b10fa50bfe836f762258311ae59ec3e98b1a4578252e51f30b068dc42cf4ef879cd9f1db645240d09dfd7028bee2962928d31c1ffa80dc411aed5646e39ac2e5ae8ef3bd2094fab9ab6c29026cf10973cbc39d9fe8e0a8a6e93a13229aae595c4a605a4e49c4154fa72f0fafb11f0b78d46dca5201de883ce8f53e79102f2de2682543d64084441ce85e6c9b93a91e2ce4b580a8fa17553ae39f981135d9adbcb9f373c8adc3f7d59031002b2089ed69842496a829360274a44a3b22c34bd8e9f9379b70514dd41be929dc74a51a9e503b3ce694dfb3d44909f0f288fd52d18381dd1447bcc988c0e8af7f30f9d5868bbb61fd25f439a86d566f3ae7057c8bfc68bbf45b798db42b622a53a89cf03d3813484543a728d2a16fd47287100aa265dc3c441d82afaa7ffc31fc603bc2ae97ffc301210db699f695cebddb9ce60a5f0b34d5187364b8519f3362447a9b96929fecaa8fe3b8d8d4ebbb5113a71e217cd4bafda21c704456a100dd477f4e8516ab2c92</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码已经告诉您了哦，敲完密码回车</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣Top100</title>
      <link href="/leetcode_top_100/"/>
      <url>/leetcode_top_100/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Leetcode Top 100</p><span id="more"></span><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣每日一题</title>
      <link href="/Leetcode_once_day/"/>
      <url>/Leetcode_once_day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>刷的太少，思路只局限在暴力</p><span id="more"></span><h2 id="1422-分割字符串的最大得分"><a href="#1422-分割字符串的最大得分" class="headerlink" title="1422. 分割字符串的最大得分"></a><a href="https://leetcode.cn/problems/maximum-score-after-splitting-a-string/">1422. 分割字符串的最大得分</a></h2><ul><li><p>思路：（暴力）对输入的字串分割成左右两个非空字串，再遍历左字串中字符 0 个数，由字串中字符 1 的个数；依次循环分割输入的字串，将对应的个数存入左右两个容器，遍历完所有的可能后，求和，再求最大值</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string strl, strr;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; l, r;</span><br><span class="line">        <span class="type">int</span> l_tmp = <span class="number">0</span>, r_tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            strl = s.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            strr = s.<span class="built_in">substr</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; strl.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strl[j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    l_tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            l.<span class="built_in">push_back</span>(l_tmp);</span><br><span class="line">            l_tmp = <span class="number">0</span>;<span class="comment">//注意累加器置0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; strr.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strr[k] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                     r_tmp++;</span><br><span class="line">            &#125;</span><br><span class="line">            r.<span class="built_in">push_back</span>(r_tmp);</span><br><span class="line">            r_tmp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; maxsum;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; l.<span class="built_in">size</span>(); n++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> a = l[n] + r[n];</span><br><span class="line">           maxsum.<span class="built_in">push_back</span>(a);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(maxsum.<span class="built_in">begin</span>(), maxsum.<span class="built_in">end</span>());<span class="comment">//取最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    string s = <span class="string">&quot;1111&quot;</span>;</span><br><span class="line">    cout &lt;&lt; sol.<span class="built_in">maxScore</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540. 有序数组中的单一元素"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></h2><ul><li><p>思路，根据异或运算的性质，两个相同的数异或为0，让数组元素依次异或，结果一定是只出现一次的数（代码中是依次一个一个异或，便于理解，推导过程中利用结合律、交换律，相同的数字先异或结果为0）</p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution3 sol3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    cout &lt;&lt; sol3.<span class="built_in">singleNonDuplicate</span>(nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a href="https://leetcode.cn/problems/missing-number/">268. 丢失的数字</a></h2><ul><li><p>思路：给定的范围是[0,n]，可求得该范围内所有数的和，用和减去现有数组中的数，结果即为缺失的数</p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sum = (<span class="number">0</span> + n) * (n + <span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum -= nums[i];<span class="comment">//将现有元素全部减掉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; sol.<span class="built_in">missingNumber</span>(nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://flamsteed.github.io/tags/#HUAWEI">https://flamsteed.github.io/tags/#HUAWEI</a></p><p>第一阶段:</p><p>练习字符串、数组、<a href="https://www.nowcoder.com/jump/super-jump/word?word=链表">链表</a>的基本操作，熟悉语言和编码手感</p><p>参考题目：</p><p>字符串，简单 1154，125，344，20，392，409，859，14，1694，551</p><p>数组，简单 1，169，53，1502，88，594，643，463，</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=链表">链表</a>，简单 234，21，141，83</p><p>第二阶段:</p><p>练习较为复杂的字符串，数组的处理</p><p>字符串，中等 468，692，151，686，1764</p><p>数组，中等56，229，347</p><p>第三阶段:</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=算法">算法</a>练习</p><p>字符串，中等，回溯93</p><p>数组，中等，回溯 39，90，46，78</p><p>数组，中等，深度优先，广度优先，417，994，385</p><p>数组，中等，滑动窗口，713</p><p>字符串，中等，滑动窗口424</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=动态规划">动态规划</a>，简单70</p><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=动态规划">动态规划</a>，中等64</p><p>数组，中等，双指针 16</p><p>字符串，中等，双指针15，</p><p>数组，中等，栈150</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为机试（牛客）</title>
      <link href="/HuaWei_no_way/"/>
      <url>/HuaWei_no_way/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>放弃啦，简历都过不了</p><p><del><a href="https://www.nowcoder.com/exam/oj/ta?page=1&amp;tpId=37&amp;type=37">华为机考</a>刷题记录，初次刷题，想法不成熟，大多直接暴力解决了</del></p><p><del>（知道自己菜，没想到这么菜）</del></p><span id="more"></span><p><a href="https://blog.csdn.net/m0_46663240/article/details/125679183?spm=1001.2014.3001.5502">参考1</a></p><p><a href="https://blog.csdn.net/weixin_38815609/article/details/125658519?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165949738016782390555769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165949738016782390555769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-125658519-null-null.142^v39^pc_rank_34_ecpm25&amp;utm_term=%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83%E9%A2%98&amp;spm=1018.2226.3001.4187">参考2</a></p><p><a href="https://oi-wiki.org/">https://oi-wiki.org/</a></p><h2 id="HJ1"><a href="#HJ1" class="headerlink" title="HJ1"></a>HJ1</h2><ul><li><p>题目：查找输入字符串最后一个单词的长度</p></li><li><p>思路：字符串由空格分隔，找到最后一个空格，用整体的长度减去空格及空格前的长度，剩余的即为所求</p></li><li><p>代码：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line"><span class="comment">// size_t len = str.size();//总长度</span></span><br><span class="line"><span class="comment">// size_t found = str.rfind(&quot; &quot;);//最后空格的位置</span></span><br><span class="line">     <span class="comment">// size_t found = str.find_last_of(&quot; &quot;);</span></span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">size</span>() -  str.<span class="built_in">rfind</span>(<span class="string">&quot; &quot;</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分析：关键有二：</p><ul><li><p>字符串的获取</p><ul><li><p>cin：遇空格或制表符即停，显然无法满足</p></li><li><p>getline：可连续读取输入并存入字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>最后空格的定位</p><ul><li><p>find_last_of()：给定待查找的字符，从后开始查找并返回其位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//可以指定从何处开始查找，即指定第二个参数</span></span><br><span class="line"><span class="comment">//注意字符串从0开始编号</span></span><br></pre></td></tr></table></figure></li><li><p>find 家族辨析：<a href="https://cplusplus.com/reference/string/string/find/">参考</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索指定位置开始的第一个完全匹配的字符（串），即与指定字串完全匹配时才返回，且是第一个</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span>;<span class="comment">//从前往后找</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span></span>;<span class="comment">//从后往前找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索指定位置开始的第一个匹配的字符（串），只需有一个字符满足即可</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span>;<span class="comment">//从前往后找</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span></span>;<span class="comment">//从后往前找</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//查找与指定字串不匹配的字符（串）</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span> <span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span> </span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="HJ2"><a href="#HJ2" class="headerlink" title="HJ2"></a>HJ2</h2><ul><li><p>题目：计算某字符出现的次数</p></li><li><p>思路：读入到两个变量中，遍历字串，是否和目标字符相等，若相等则 count 增1，再判断大小写的问题，大写和小写分别判断</p></li><li><p>代码：（低质量代码）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str,str2;</span><br><span class="line">    <span class="comment">//读入两行内容</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="built_in">getline</span>(cin, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如相等则计数器k自增1</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str2[<span class="number">0</span>])</span><br><span class="line">        &#123;       </span><br><span class="line">            k++;</span><br><span class="line">            <span class="comment">//考虑大小写一致</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;          </span><br><span class="line">                <span class="keyword">if</span>(str2[<span class="number">0</span>] &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; str2[<span class="number">0</span>] &gt;= <span class="string">&#x27;A&#x27;</span>)<span class="comment">//如目标字符是大写，则再判断其对应的小写是否有相等的</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(str[i]+<span class="number">0</span> == str2[<span class="number">0</span>] + <span class="number">32</span>)</span><br><span class="line">                       k++;</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str2[<span class="number">0</span>] &lt;= <span class="string">&#x27;z&#x27;</span> &amp;&amp; str2[<span class="number">0</span>] &gt;= <span class="string">&#x27;a&#x27;</span>)<span class="comment">//如目标字符是小写，则再判断其对应的大写是否有相等的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i]+<span class="number">0</span> == str2[<span class="number">0</span>] - <span class="number">32</span>)</span><br><span class="line">                       k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<ul><li>新手，想法简单粗暴</li></ul></li></ul></li></ul><h2 id="HJ3"><a href="#HJ3" class="headerlink" title="HJ3"></a>HJ3</h2><ul><li><p>题目：输入随机数个数及随机数，去重排序后按行输出</p></li><li><p>思路一：（排名第一的思路，非本人想法）先确定随机数的个数（直接cin），定义一个数组，然后每次将读入的数作为数组的下标，值填充为1，然后输出数组值不为0的下标</p><ul><li>核心：只要有重复值，对应到数组的下标还是同一个，达到既降重又排序的目的；转换思路，输入的值是下标而非数组的值</li><li>缺点：一是必须指定数组的大小是题目给定的范围，而不能动态的设置为输入随机数的个数；二是数组必须初始化，否则其中的垃圾数据会造成输入错误</li></ul></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N, n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; N) &#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">            cin &gt;&gt; n;</span><br><span class="line">            a[n] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i])</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按上述思路重写了一下，比较容易理解和看懂</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N, n;</span><br><span class="line">    cin &gt;&gt; N;<span class="comment">//读入数组的大小</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//指定大小并初始化（不管数组多小，都开辟了这么多空间）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        a[n] = <span class="number">1</span>;<span class="comment">//以读入的数作为下标，有多少重复都无所谓（填充值非零均可）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;<span class="comment">//输出数组值非零的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：调用 STL，去重排序一步到位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span><span class="comment">//包含集合set</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;<span class="comment">//自动实现去重和排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            s.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:s)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析：</p><ul><li>STL 中的 set（集合）自动将插入元素放入合适的位置（排序），同时对重复元素忽略，可以<code>插入删除但不能更改</code></li></ul></li></ul><h2 id="HJ4"><a href="#HJ4" class="headerlink" title="HJ4"></a>HJ4</h2><ul><li><p>题目：字符串的分割，以8为长度分割输入的字符串</p></li><li><p>思路：考虑 ==8 、<8 、>8 三种情况，利用容器，把分割后的字串存入其中，最后遍历容器输出，主要利用 substr 进行字串的分割</p><ul><li>复盘：既然以 8 为单位分割，那只要不为 8 的倍数就要补 0，用余数判断一下需要补 0 的个数，利用 append 插入，再分割输出（<del>另外本题没有给出输出的格式，我以为是空格，结果提交发现是换行</del>）</li></ul></li><li><p>代码：初次写的代码，重复代码太多了，自愧不如，简单问题复杂化了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; str;</span><br><span class="line">    string str_tmp;</span><br><span class="line">    cin &gt;&gt; str_tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = str_tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按8分割</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;  str_tmp.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(str_tmp.<span class="built_in">substr</span>(i, <span class="number">8</span>));</span><br><span class="line">            i += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>-n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            str_tmp.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);<span class="comment">//小于8时判断补 0 的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">          str.<span class="built_in">push_back</span>(str_tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>(n &gt; <span class="number">8</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = n / <span class="number">8</span>;<span class="comment">//有几段以 8 为长度的</span></span><br><span class="line">        <span class="comment">//需要补几个0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span> - n % <span class="number">8</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            str_tmp.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按8分割</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(str_tmp.<span class="built_in">substr</span>(i, <span class="number">8</span>));</span><br><span class="line">            i += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//遍历输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)<span class="comment">//注意这里是补 0 后新的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; str[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复盘后改进的代码：简便多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">8</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str.<span class="built_in">append</span>(<span class="number">8</span> - n % <span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>);    <span class="comment">//不足8位的补0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按8分割</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>();)<span class="comment">//注意这里的 size 是补 0 后新的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;  str.<span class="built_in">substr</span>(i, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">        i += <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分析：</p><ul><li><p>substr 的用法</p><ul><li><p>单参数：从该位置开始取到末尾</p></li><li><p>双参数：从该位置开始取到指定的长度</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s = <span class="string">&quot;time&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单参数：&quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">//返回 me（从位置 2 截取到尾）</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;双参数：&quot;</span> &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;<span class="comment">//返回 ime（从位置1开始，截取长度3）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>append 的用法</p><ul><li>向 string 后面追加字符或字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">append</span>(<span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>); <span class="comment">//在 str 后追加 4 个字符 0</span></span><br><span class="line">str.<span class="built_in">append</span>(c);<span class="comment">//追加 char 类型字串 c</span></span><br><span class="line">str.<span class="built_in">append</span>(str_tmp); <span class="comment">//追加 string 字串</span></span><br><span class="line">str.<span class="built_in">append</span>(str_tmp, <span class="number">5</span>, <span class="number">3</span>);<span class="comment">//追加从位置 5 开始的长度为 3 的字串（包括位置 5）</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="HJ5"><a href="#HJ5" class="headerlink" title="HJ5"></a>HJ5</h2><ul><li><p>题目：输入十六进制字串，将其转为十进制数输出（华为肯定不会考这种题）</p></li><li><p>思路：（笨人笨方法啊）先把输入的前缀0x截掉，剩下的部分依次遍历，如是字符0-9，则转为数字0-9；如是字母A-F，则转为10~15</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="comment">//截掉前缀</span></span><br><span class="line">string str_tmp;</span><br><span class="line">str_tmp = str.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//进制转换</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = (str_tmp.<span class="built_in">size</span>() - <span class="number">1</span>);<span class="comment">//控制幂次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历每一位</span></span><br><span class="line"><span class="keyword">if</span> (str_tmp[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_tmp[i] &lt;= <span class="string">&#x27;9&#x27;</span>)<span class="comment">//判断是否是数字</span></span><br><span class="line">&#123;</span><br><span class="line">n += <span class="built_in">int</span>(str_tmp[i] - <span class="string">&#x27;0&#x27;</span>)*<span class="built_in">pow</span>(<span class="number">16</span>, j);<span class="comment">//转为0~9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str_tmp[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str_tmp[i] &lt;= <span class="string">&#x27;F&#x27;</span>)<span class="comment">//判断是否是字母</span></span><br><span class="line">&#123;</span><br><span class="line">n += (str_tmp[i] - <span class="number">55</span>)*<span class="built_in">pow</span>(<span class="number">16</span>, j);<span class="comment">//A是65，减55是转为10~15</span></span><br><span class="line">&#125;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以直接调库的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">stoi</span>(str,<span class="number">0</span>,<span class="number">16</span>) &lt;&lt; endl;<span class="comment">// 将str从位置 0 开始到末尾的 16 进制转为 十进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ6"><a href="#HJ6" class="headerlink" title="HJ6"></a>HJ6</h2><ul><li><p>题目：质数因子，给定一个整数，输出该数的所有质数因子，包括重复值</p></li><li><p>思路：质数从 2 开始，让给定值从 2 开始遍历，能整除则继续，否则 +1 后再判断是否能整除，这样提交后内存超限</p><ul><li>看了题解，一个数至少有一个质数因子不会超过其平方根，这样就可以从 2 遍历到其平方根，再判断是否是因子。需要注意该值本身就是质数的情况</li></ul></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n) &amp;&amp; i &lt;= n; i++)&#123;  <span class="comment">//从小到大的质因子，质因子不会超过它的平方根</span></span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123; <span class="comment">//所有的质数前面全部除掉，后续就不会有合因子</span></span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            n /= i; <span class="comment">//除掉质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n - <span class="number">1</span>) <span class="comment">//前面已经除掉了所有因子，故在此判断该值是否是 1 ，不是就说明自己本身就是质数</span></span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ7"><a href="#HJ7" class="headerlink" title="HJ7"></a>HJ7</h2><ul><li><p>输入浮点数，四舍五入</p></li><li><p>思路：都说了入门题了</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cmath&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">   <span class="comment">// cout &lt;&lt; round(a);</span></span><br><span class="line">    <span class="keyword">if</span>(a - <span class="built_in">int</span>(a) &gt;= <span class="number">0.5</span>)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">int</span>(a) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ8"><a href="#HJ8" class="headerlink" title="HJ8"></a>HJ8</h2><ul><li><p>题目：合并表记录：给定索引及对应的值，将相同索引的值求和，并按索引升序排序输出</p></li><li><p>思路一：（题目本意是考察哈希表，这里直接暴力解决）首先读入键值对数，再将键值对存入个vector，接着遍历并判断索引号是否相等，如若相等则加到第一个上，同时将另一个清除；新建一个vector，将不为空的复制进去，调用 sort 排序再输出</p></li><li><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v_F;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v_tmp;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line">       </span><br><span class="line">        v_tmp.<span class="built_in">push_back</span>(b);</span><br><span class="line">        v_tmp.<span class="built_in">push_back</span>(c);</span><br><span class="line">        v.<span class="built_in">push_back</span>(v_tmp);</span><br><span class="line">        v_tmp.<span class="built_in">clear</span>();<span class="comment">//注意清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i][<span class="number">0</span>] == v[j][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                v[i][<span class="number">1</span>] += v[j][<span class="number">1</span>]; </span><br><span class="line"><span class="comment">//                 v[j].clear();</span></span><br><span class="line">                v[j].<span class="built_in">erase</span>(v[j].<span class="built_in">begin</span>(), v[j].<span class="built_in">end</span>());<span class="comment">//清除元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(v[i].<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">            v_F.<span class="built_in">push_back</span>(v[i]);<span class="comment">//非空存入新的容器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v_F.<span class="built_in">begin</span>(), v_F.<span class="built_in">end</span>());<span class="comment">//排好序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v_F.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">       cout &lt;&lt; v_F[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v_F[i][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：调用 STL 的 map，其自动建立 key - value 的对应，且其中的数据是有序的，map 是一个模板类，需要 key value 两个参数，关键字 key 只能在 map 中存在一次，其增删改和容器类似，通过 pair 插入，迭代器访问，<code>注意迭代器返回值是变化的</code></p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;    <span class="comment">//输入键值对的个数</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;    <span class="comment">//使用map容器，自带键值对数据结构</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it;    <span class="comment">//map类型的迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;        <span class="comment">//每行输入一个键值对</span></span><br><span class="line">        it = m.<span class="built_in">find</span>(a);    <span class="comment">//查找键 a 是否存在，是返回所在位置，否返回 end 位置，</span></span><br><span class="line">        <span class="keyword">if</span>(it != m.<span class="built_in">end</span>())  <span class="comment">//如果存在，对键相同的单元的值部分求和</span></span><br><span class="line">        &#123;   </span><br><span class="line">            m[a] = it-&gt;second + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若不存在生成新的键值对</span></span><br><span class="line">        &#123;       </span><br><span class="line">            m[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;    <span class="comment">//遍历输出</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ10"><a href="#HJ10" class="headerlink" title="HJ10"></a>HJ10</h2><ul><li><p>题目：字符个数统计，输入一个字符串，输入该字串中不重复的字符个数</p></li><li><p>思路一：利用集合set的自动降重功能，将字符串拆分成字符插入其中，再求集合的 size 即可（需要遍历整个字串，耗时）</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str_tmp;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, str_tmp))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str_tmp.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           str.<span class="built_in">insert</span>(str_tmp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：哈希表，待补充</p></li></ul><h2 id="HJ11"><a href="#HJ11" class="headerlink" title="HJ11"></a>HJ11</h2><ul><li><p>题目：数字颠倒，将输入的整数以字符串的形式逆序输出</p></li><li><p>思路：将整数转为字串类型，再利用函数翻转输出</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    string str;</span><br><span class="line">    str = <span class="built_in">to_string</span>(n);<span class="comment">//int2string转换</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//逆序</span></span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ12"><a href="#HJ12" class="headerlink" title="HJ12"></a>HJ12</h2><ul><li><p>题目：反转字符串</p></li><li><p>思路：同HJ11</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ13"><a href="#HJ13" class="headerlink" title="HJ13"></a>HJ13</h2><ul><li><p>题目：句子逆序，给定一个句子，逆序输出（非逆序字母）</p></li><li><p>思路：遍历字串找到空格，找到一个空格后，空格前的分割出来存下，空格后的分割出来继续找空格，循环直至字串中没有空格</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;string&gt; str_vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos)<span class="comment">//有空格时</span></span><br><span class="line">        &#123;</span><br><span class="line">            str_vec.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>,str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">            str = str.<span class="built_in">substr</span>(str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            n = str.<span class="built_in">size</span>();<span class="comment">//分割后新字串长度</span></span><br><span class="line">            i = <span class="number">0</span>;<span class="comment">//新的字串从头开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str_vec.<span class="built_in">push_back</span>(str);<span class="comment">//最后一个单词也存一下</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = str_vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; str_vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ14"><a href="#HJ14" class="headerlink" title="HJ14"></a>HJ14</h2><ul><li><p>题目：字符串按字典序列排序</p></li><li><p>思路：偷个懒，直接调库函数排序吧</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; str;</span><br><span class="line">    string str_tmp;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str_tmp;</span><br><span class="line">        str.<span class="built_in">push_back</span>(str_tmp);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k: str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// vector&lt;string&gt;::iterator it;</span></span><br><span class="line">   <span class="comment">// for(it = str.begin(); it &lt; str.end(); it++)</span></span><br><span class="line">   <span class="comment">// &#123;</span></span><br><span class="line">   <span class="comment">//   cout &lt;&lt; *it &lt;&lt; endl;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ15"><a href="#HJ15" class="headerlink" title="HJ15"></a>HJ15</h2><ul><li><p>题目：int型整数的二进制中1的个数</p></li><li><p>思路一：笨人笨办法，先转成二进制，二进制顺序无所谓，再数 1 的个数</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; k;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)<span class="comment">//转二进制</span></span><br><span class="line">    &#123;</span><br><span class="line">        k.<span class="built_in">push_back</span>(n%<span class="number">2</span>);</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k[i] == <span class="number">1</span>)</span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路二：用STL，<a href="https://cplusplus.com/reference/bitset/bitset/">bitset</a></p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">bitset&lt;32&gt; <span class="title">set</span><span class="params">(n)</span></span>;<span class="comment">//题目要求大小不超过32</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; set.size(); ++i)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; set[i];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; set.<span class="built_in">count</span>();<span class="comment">//直接返回 1 的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路三：位运算：将整数对应的二进制数的每一位与 1 进行位与运算，为此，每次将该数右移 1 位</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位与运算</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> count= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;<span class="comment">//右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>思路三：（<del>我反正是想不到</del>）位与运算还有一个性质：n&amp;n-1结果会去掉n最末尾的1。比如1110&amp;1101=1100，直接就去掉了111011101110最后的1，我们依照这个性质，不断去掉n末尾的1，直到结果为全0，去掉过程中统计去掉过多少次，即1出现的次数</p><p>  <img src="https://s2.loli.net/2022/08/15/HcQ3pE4LvxeFNJO.gif" alt="alt"></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        count++; <span class="comment">//统计+1</span></span><br><span class="line">        n &amp;= (n - <span class="number">1</span>); <span class="comment">//去掉末尾的1</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ17"><a href="#HJ17" class="headerlink" title="HJ17"></a>HJ17</h2><ul><li><p>题目：坐标移动，ADWS，给定的数字表示移动距离</p></li><li><p>思路一：（纯纯暴力）和HJ13类似，先把给定的字串按 “;” 分割出来，再判断分割后的首位是 ADWS 的哪位，分类讨论，小类中再判断数字是否合理</p></li><li><p>代码：（<del>垃圾代码，真的垃圾</del>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;set&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;S87;S7;W56;S75;A8;S84;W23;W19;W40;D73;S87;A39;W97;W78;A53;D16;D15;A50;W41;S87;D47;W56;D56;A23;A91;S25;D61;D53;D58;W88;W58;S61;D69;W74;D89;A92;D39;D62;S78;W72;W73;W35;S76;W35;S36;W39;A4;&quot;</span>;</span><br><span class="line"><span class="comment">//    getline(cin,str);</span></span><br><span class="line">    vector&lt;string&gt; str_vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>))).<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>) == <span class="string">&quot;A&quot;</span> ||</span><br><span class="line">                (str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>))).<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>) == <span class="string">&quot;D&quot;</span> ||</span><br><span class="line">                (str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>))).<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>) == <span class="string">&quot;W&quot;</span> ||</span><br><span class="line">                (str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>))).<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>) == <span class="string">&quot;S&quot;</span> )<span class="comment">//首位不是ADWS的就不要了</span></span><br><span class="line">        &#123;</span><br><span class="line">            str_vec.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.<span class="built_in">substr</span>(str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str_vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str_vec[i][<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str_vec[i].<span class="built_in">size</span>() == <span class="number">3</span>)<span class="comment">//分割后的是不是有3位，是的话说明数字有两位，两位都要判断是不是数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    x -= <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));<span class="comment">//字串转int</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                x -= <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str_vec[i][<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str_vec[i].<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    x += <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                x += <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str_vec[i][<span class="number">0</span>] == <span class="string">&#x27;W&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str_vec[i].<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    y += <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                y += <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str_vec[i][<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str_vec[i].<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">2</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    y -= <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( str_vec[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str_vec[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                y -= <span class="built_in">stoi</span>(str_vec[i].<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            continue;</span></span><br><span class="line"><span class="comment">//        str_vec[i].size() == 2 &amp;&amp;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>看了排行一的代码，思路和我一样，但是代码简洁多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化坐标</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//存储单步操作</span></span><br><span class="line">        vector&lt;string&gt; steps;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把字符串拆分</span></span><br><span class="line">        <span class="type">int</span> wordlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(str[i] != <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">                wordlen ++, i ++;</span><br><span class="line">            steps.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(i - wordlen, wordlen));</span><br><span class="line">            wordlen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分解成功</span></span><br><span class="line">        <span class="comment">//for(auto x : steps) cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对单个steps执行坐标变换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; steps.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//长度3  A10</span></span><br><span class="line">            <span class="keyword">if</span>(steps[i].<span class="built_in">length</span>() == <span class="number">3</span> &amp;&amp; steps[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; steps[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp;  steps[i][<span class="number">2</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; steps[i][<span class="number">2</span>] &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                num = (steps[i][<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + steps[i][<span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//长度2  A5</span></span><br><span class="line">            <span class="keyword">if</span>(steps[i].<span class="built_in">length</span>() == <span class="number">2</span> &amp;&amp; steps[i][<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; steps[i][<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                num = steps[i][<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span>(steps[i][<span class="number">0</span>])<span class="comment">//ASDW</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: x -= num; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: x += num; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>: y += num; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: y -= num; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ20"><a href="#HJ20" class="headerlink" title="HJ20"></a>HJ20</h2><ul><li><p>题目：密码合格验证：大于8位；大小写、数字、其他符号中的至少三种；不能有三个字符重复</p></li><li><p>思路：分类判断：一是判断是否有三种类型，二是判断是否有重复</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is3kind</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            count[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            count[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count[<span class="number">0</span>] +count[<span class="number">1</span>] + count[<span class="number">2</span>] + count[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isrepet</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i+<span class="number">3</span> &lt; str.<span class="built_in">size</span>(); ++i)<span class="comment">//i+3超过str长度就无需判断了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">find</span>(str.<span class="built_in">substr</span>(i,<span class="number">3</span>), i + <span class="number">3</span>) != string::npos)<span class="comment">//每次将输入字串截取3个，判断3个之后是否有相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">size</span>() &lt;= <span class="number">8</span>||<span class="built_in">is3kind</span>(str)&lt;<span class="number">3</span>|| <span class="built_in">isrepet</span>(str))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NG&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HJ21"><a href="#HJ21" class="headerlink" title="HJ21"></a>HJ21</h2><ul><li><p>题目：密码转换：按手机键盘九键，将小写字母转为对应的数字，大写字母转为对应小写的后一位，Z的直接转为a再转为数字</p></li><li><p>思路：（笨办法，暴力）先将小写字母转为数字，再将大写转为数字</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;d&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;g&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;j&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;m&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;p&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;t&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;w&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        cout &lt;&lt; str[i];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">            str[i] += <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            str[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; str[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优化代码：上述代码遍历了两次，优化如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &lt; <span class="string">&#x27;Z&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = s[i] + <span class="number">33</span>;</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;z&#x27;</span> &amp;&amp; s[i]&gt;= <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;c&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;a&#x27;</span>) cout &lt;&lt; <span class="string">&quot;2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;f&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;d&#x27;</span>) cout &lt;&lt; <span class="string">&quot;3&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;i&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;g&#x27;</span>) cout &lt;&lt; <span class="string">&quot;4&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;l&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;j&#x27;</span>) cout &lt;&lt; <span class="string">&quot;5&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;o&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;m&#x27;</span>) cout &lt;&lt; <span class="string">&quot;6&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;s&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;p&#x27;</span>) cout &lt;&lt; <span class="string">&quot;7&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;v&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;t&#x27;</span>) cout &lt;&lt; <span class="string">&quot;8&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;z&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;w&#x27;</span>) cout &lt;&lt; <span class="string">&quot;9&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="HJ22"><a href="#HJ22" class="headerlink" title="HJ22"></a>HJ22</h2><ul><li>题目：汽水瓶，3个空的换一瓶汽水，可以向老板要一个空瓶，但必须还给老板</li><li><p>思路：（<del>看了题解我TM</del>，这就是个智力题）3个换一个，有2个的话可以找老板要一下空的，换一瓶，喝完了还给老板，所以不管有多少空瓶，就看你有多 2，反正有 2 就可以换一瓶</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MQRoad on 2022/08/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ( cin &gt;&gt; n )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; n/<span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/data_structure/"/>
      <url>/data_structure/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数据结构理论</p><p><a href="https://www.bilibili.com/video/BV1nJ411V7bd?spm_id_from=333.999.0.0">宝藏级+保姆级课程-数据结构与算法基础-青岛大学-王卓老师</a></p><p><a href="https://www.bilibili.com/video/BV1Ev411e7w8/">油管大神</a></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度：各条指令执行的时间之和</p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><ul><li>表示算法执行的渐进上限</li><li>性质：<ul><li>任意常数 $c &gt;0$，$O(f(n))=O(cf(n))$<ul><li>常数乘以某个运算，不改变其时间复杂度（函数正的常系数可忽略等同于1）</li></ul></li><li>任意常数$a&gt;b&gt;0$，$O(n^a+n^b)=O(n^a)$<ul><li>因 $a&gt;b$，故前者的影响大于后者，在整个过程中便可忽略后者的影响（低次项可忽略，保留最高次项）</li></ul></li></ul></li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul><li>不计入输入本身</li><li>其他各方面消耗都计入</li></ul><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>常数时间复杂度 $O(1)$</p></li><li><p>对数时间复杂度 $O(logn)$</p><ul><li>对数多项式复杂度</li></ul></li><li><p>线性 $O(1)$</p></li></ul><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表用于判断一个元素是否出现在集合中，<a href="https://www.nowcoder.com/discuss/1043908">原理及问题</a></p><h1 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>链表结构由指针域+数据域组成</li></ul><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><ul><li>尾部指针域指向头结点</li><li>一般使用带尾指针的循环链表</li></ul><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>单链表为何在插入和删除上优于数组：对插入单个元素而言，两者并无明显优势，但若一次插入多个元素，对单链表而言，只需一次遍历，后续只需进行指针赋值等操作，故为 $O(1)$；而对数组而言，每个元素的插入和删除，伴随着插入位置后所有点的移动，为 $O(n)$。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><p>一种后入先出（LIFO）的结构</p></li><li><p>可通过数组或链表实现</p></li><li><p>主要可用于判断括号的匹配、程序中表达式是否正确</p><ul><li>括号是否匹配：程序中的括号是否是一一对应的，比如 {[()]} 是一一对应且是正确的匹配，为了判断是否匹配，可从左至右遍历字符串，若遇到左括号，压入栈，遇到右括号时查看其与栈中的左括号是否匹配，匹配则将栈中元素弹出，否则说明括号不匹配</li><li>表达式检测：实际计算机检测时并非按我们写的表达式进行检测，其实际将其转换成前缀表示法或后缀表示法，具体<a href="https://www.bilibili.com/video/BV1Ev411e7w8?t=3.7&amp;p=19">参考</a></li></ul></li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><p>一种先入先出（FIFO）的结构</p></li><li><p>可通过数组或链表实现</p></li><li><p>主要应用于服务请求中，如多个人同时请求打印机打印资料，此时打印机可根据请求的顺序排队，依次打印</p></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><a href="https://youtu.be/V5-7GzOfADQ">参考</a></p><ul><li>字符串匹配的快速算法，相交于暴力算法，去除了回溯（主串遇到不匹配字符时不再返回，而是一直前行），减小了时间复杂度，为$O(m+n)$，其中，$m$ 为主串长度，$n$ 为模式串长度</li></ul><h1 id="非线性数据结构"><a href="#非线性数据结构" class="headerlink" title="非线性数据结构"></a>非线性数据结构</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li><p>一种非线性结构</p></li><li><p>典型应用：</p><ul><li>存储分层数据：文件系统（文件和文件夹的层次结构）</li><li>快搜、增、删数据：如二叉数搜索</li><li>拼接检查：一种特殊的树 trie</li><li>网络路由算法</li></ul></li><li><p>最常见的是二叉树</p><ul><li>每个结点最多有两个子结点</li><li>可通过链表实现，每个节点由三部分组成，中间存储数据，左右分别存储左右子节点的地址</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理</title>
      <link href="/digital_image_process/"/>
      <url>/digital_image_process/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数字图像处理基础理论（待补充）</p><p><a href="https://cv-xueba.club/">(通俗易懂的计算机视觉优质课程)北京邮电大学计算机学院-鲁鹏</a></p><p><a href="https://slazebni.cs.illinois.edu/fall22/">参考:CS 543/ECE 549: Computer Vision</a></p><p>（文中所有图片均摘自上述课程）</p><span id="more"></span><h1 id="图像去噪（滤波）"><a href="#图像去噪（滤波）" class="headerlink" title="图像去噪（滤波）"></a>图像去噪（滤波）</h1><h2 id="常见噪声"><a href="#常见噪声" class="headerlink" title="常见噪声"></a>常见噪声</h2><p><img src="https://s2.loli.net/2022/08/24/4JRciqsQVUoTEfL.png" alt="image-20220824111547568" style="zoom:67%;" /></p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><ul><li><p>卷积：把相关运算的<code>核旋转180°</code></p><ul><li>线性：<script type="math/tex">F(f1+f2) = F(f1)+F(f2)</script></li><li>平移不变形：<script type="math/tex">F(S(f)) = S(F(f))</script></li><li>满足线性平移不变性的操作均可定义为卷积</li><li>满足交换律、结合律、分配律</li></ul></li><li><p>卷积时边缘的处理：边界填充</p><ul><li>卷积核的特性导致卷积后的图像和原图不一样大</li><li>零填充（常用）</li><li>复制边缘</li><li>镜像边缘</li></ul></li><li><p>常见核</p><ul><li><p>单位脉冲核</p></li><li><p>平移核</p></li><li><p>平滑核</p></li><li><p>锐化操作</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/24/EbCjmkBXQRn7Z8o.png" alt="图像" style="zoom:67%;" /></p><h2 id="高斯卷积"><a href="#高斯卷积" class="headerlink" title="高斯卷积"></a>高斯卷积</h2><ul><li><p>平均卷积核的问题</p><ul><li><p>中心与邻域的权重一致，导致振铃现象（卷积后图像出现的条状）</p></li><li><p>解决：根据邻域像素与中心的远近程度分配权重，离中心越近，权重越大</p></li></ul></li></ul><h3 id="高斯卷积的生成"><a href="#高斯卷积的生成" class="headerlink" title="高斯卷积的生成"></a>高斯卷积的生成</h3><p><img src="https://s2.loli.net/2022/08/24/9AaKPzItFvZGfxM.png" alt="image-20220824104058744" style="zoom:67%;" /></p><p>​        <code>归一化即为 3 中各个位置权重值/总的权重值</code></p><h3 id="参数的选取"><a href="#参数的选取" class="headerlink" title="参数的选取"></a>参数的选取</h3><ul><li><p>大标准差或者大尺寸卷积核平滑能力强</p></li><li><p>小标准差或者小尺寸卷积核平滑能力弱</p></li></ul><p>解释：</p><p>大标准差，对应的是核中中心元素的权重低于周围元素，即占比低，从而被平滑的越厉害（其实，$\sigma$ 就是模板的模糊半径，该值越大，对应的圆越大，自然模糊的越厉害）</p><p>大尺寸，在标准差不变时，高斯函数值相等，但在归一化后，大尺寸的权重比小尺寸的小，平滑的越厉害</p><ul><li><p>经验法则: <font color = red>将卷积核的半窗宽度设置为 3𝜎，最终卷积模板尺寸为 2 × 3𝜎 + 1</font></p><p>即：<font color = red>只要指定一个参数 $\sigma$ ，就可直接得到窗口大小，从而不用两个参数单独指定</font></p><p>为什么是 $3\sigma$，因为大于该值以后，高斯值为 0，没有意义</p></li></ul><h3 id="高斯核特性说明"><a href="#高斯核特性说明" class="headerlink" title="高斯核特性说明"></a>高斯核特性说明</h3><ul><li><p>高斯核是低通滤波器，滤除图像中的高频成分</p></li><li><p>两个高斯卷积核卷积后得到的还是高斯卷积核</p><ul><li>使用多次小方差卷积核连续卷积，可以得到与大方差卷积核相同的结果</li><li>使用标准差为 $\sigma$ 的高斯核进行两次卷积与使用标准差 $\sqrt 2 \sigma$ 的高斯核进行一次卷积相同</li><li>高斯核 1 为 $f$，高斯核 2 为 $g$，两者卷积：</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$f$</th><th style="text-align:center">$g$</th><th style="text-align:center">$f\star g$</th></tr></thead><tbody><tr><td style="text-align:center">均值</td><td style="text-align:center">$m_f$</td><td style="text-align:center">$m_g$</td><td style="text-align:center">$m_f + m_g$</td></tr><tr><td style="text-align:center">标准差</td><td style="text-align:center">$\sigma_f$</td><td style="text-align:center">$\sigma_g$</td><td style="text-align:center">$\sigma_f + \sigma_g$</td></tr></tbody></table></div><ul><li><p>可分离特性</p><ul><li><p>大卷积核可分为两个一维高斯的乘积</p></li><li><p>降低计算复杂度</p><p>如 $m \times m$ 的核卷积 $n \times n$ 的图像</p><ul><li>无分离时，复杂度为：$O(n^2m^2)$</li><li>分离后，复杂度为：$O(n^2m)$</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/24/S5FT1bBny4zXNPa.png" alt="image-20220824105635805" style="zoom: 50%;" /></p><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><ul><li><p>用于去除椒盐噪声、脉冲噪声</p></li><li><p>使用邻域升序排列的中值作为中心像素的值</p></li><li>中值滤波的灰度值始终是原图像中的灰度值</li></ul><p><img src="https://s2.loli.net/2022/08/24/LZTwWGEa9iYSXb8.png" alt="image-20220824111807801" style="zoom:67%;" /></p><h1 id="卷积与边缘提取"><a href="#卷积与边缘提取" class="headerlink" title="卷积与边缘提取"></a>卷积与边缘提取</h1><h2 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h2><p>图像中亮度明显而急剧变化的点（灰度不连续）</p><h2 id="边缘种类"><a href="#边缘种类" class="headerlink" title="边缘种类"></a>边缘种类</h2><p><img src="https://s2.loli.net/2022/08/24/OgIo69JtzZV1xBs.png" alt="image-20220824112224033"  /></p><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><ul><li>图像中灰度急剧变化的地方，其导数变化明显</li></ul><p><img src="https://s2.loli.net/2022/08/24/behGu1jfyNCqEXa.png" alt="image-20220824112556532" style="zoom: 67%;" /></p><h3 id="图像求导"><a href="#图像求导" class="headerlink" title="图像求导"></a>图像求导</h3><ul><li><p>差分代替一般导数</p><p>一般2D函数的偏导为：</p><script type="math/tex; mode=display">\frac{ \partial f(x,y) }{\partial x} = \lim_{\epsilon \to 0} \frac{f(x+\epsilon) - f(x,y)}{\epsilon}</script></li></ul><p>但在数字图像中，$\epsilon$ 不能为0，其最小单位为一个像素，故有：</p><script type="math/tex; mode=display">\frac{ \partial f(x,y) }{\partial x} \approx  \frac{f(x+1) - f(x,y)}{1}</script><p><img src="https://s2.loli.net/2022/08/24/i3BgH7fVMKzCFvj.png" alt="image-20220824153549791" style="zoom:67%;" /></p><p>X 方向的导数提取了 Y 方向的特征， Y 同理</p><h3 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h3><ul><li>指向灰度变换最快的方向</li></ul><p><img src="https://s2.loli.net/2022/08/24/f7JdjsZrqRTwPuB.png" alt="image-20220824154609791" style="zoom:67%;" /></p><ul><li><p>X 方向的梯度与 Y 方向的边缘垂直，其他同理；即梯度方向与边缘垂直。<a href="http://t.csdn.cn/JaDWT">具体可参考</a></p></li><li><p>可见，梯度向量与边缘垂直，故也称为边缘法线</p></li><li><p>梯度幅值的大小衡量了该点处是否是边的可能性的大小，越小，就说明 x 和 y 方向变换不明显，即接近平坦区域</p></li><li><p>需要对角边缘时，即需要二维核，Robert 算子采用对角性能（详见数字图像处理第四版P516）</p></li></ul><p><img src="https://s2.loli.net/2022/08/24/7wzSxmbYc96Rn4W.png" alt="image-20220824201536126" style="zoom:67%;" /></p><p>上述核的功能在于其考虑了周围更多的邻域，减少了噪声的敏感性，以 Soble 算子为例，其可以分解为两个一维核：</p><script type="math/tex; mode=display">\begin{bmatrix}1 \\2 \\1 \end{bmatrix}* \begin{bmatrix}-1 & 0 & 1\end{bmatrix}</script><p>可见，Sobel 是进行了高斯滤波，再进行边缘提取，故受噪声的影响较低。</p><p>注意：</p><ul><li><p>$3 \times 3$ 的核：最小的中心对称核，考虑了中心对侧数据的性质</p></li><li><p>Soble 算子能够更好的平滑噪声</p></li><li><p>上图中所有的算子，权重和为 0，即在恒定灰度区域的响应为 0 （恒定区域灰度值相等，与核相乘相加为0）</p></li><li><p>梯度幅值的实现</p><p>实际中，使用平方及平方根的开销大，一般使用绝对值近似</p><script type="math/tex; mode=display">M(x,y) \approx |{g_x}| + |g_y|</script></li></ul><p>虽计算简单，但使得滤波器不再具有各向同性（即旋转不变性）</p><h3 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h3><p>但实际中，由于噪声的影响，求导的结果也无法得出边缘的位置</p><p><img src="https://s2.loli.net/2022/08/24/jEVMa2lo1QTYChb.png" alt="image-20220824155924396" style="zoom:67%;" /></p><p>因而在求导前先平滑滤波处理</p><p><img src="https://s2.loli.net/2022/08/24/3owgdve78JiRTkr.png" alt="image-20220824160238988" style="zoom: 80%;" /></p><p>由于微分求导也是卷积，卷积具有结合性，故原图的高斯卷积与可求导结合（高斯一阶偏导核），最后和原图卷积，从而可节省一次卷积操作</p><p><img src="https://s2.loli.net/2022/08/24/xOUgdR14sWHZyKG.png" alt="image-20220824160432968" style="zoom: 80%;" /></p><h3 id="高斯一阶偏导核"><a href="#高斯一阶偏导核" class="headerlink" title="高斯一阶偏导核"></a>高斯一阶偏导核</h3><p><img src="https://s2.loli.net/2022/08/24/u6M2oehGtqyzcU5.png" alt="image-20220824162121661" style="zoom: 80%;" /></p><ul><li><p>高斯与一阶偏导的对比</p><ul><li>高斯核</li></ul><ul><li><p>消除高频成分（低通滤波器）</p></li><li><p>卷积核中的权值不可为负数（倒扣钟型）</p></li><li><p>权值总和为1（恒定区域不受卷积影响）</p></li></ul></li><li><p>高斯一阶偏导核</p><ul><li><p>高斯的导数</p></li><li><p>卷积核中的权值可以为负</p></li><li><p>权值总和是0（恒定区域无响应，急剧变化的地方响应大）</p></li><li><p>高对比度点的响应值大</p></li></ul></li></ul><h3 id="Canny-检测算子"><a href="#Canny-检测算子" class="headerlink" title="Canny 检测算子"></a>Canny 检测算子</h3><p><img src="https://s2.loli.net/2022/08/24/YOA5VQ82f9c74Mr.png" alt="image-20220824210414089" style="zoom:80%;" /></p><p>经过两个方向上高斯一阶导，得到梯度幅值图，可见，边缘较宽，这是因为在灰度斜坡上一阶导不为 0，如何得到更为准确的边缘？</p><ul><li><p>非极大值抑制</p><ul><li>实质：<br>规定梯度方向（边缘法线）的多个离散方向，如定义为水平、垂直、+45°、-45° 四个方向（一条边缘有正负两条边缘法线），即所有可能得边缘量化为这四个方向，但显然，边缘法线方向可能是任意的，故需要定义某个范围，落在该范围内就认为是哪个方向，该定义方式如下图所示（详见数字图像数字图像处理第四版 P526）</li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/24/AzSD6XU5p4Vacyo.png" alt="image-20220824212916034" style="zoom: 80%" /></p><ul><li><p>流程：</p><ul><li><p>对任意一点，求该点的梯度幅值 $K$ 和方向 $\alpha$</p></li><li><p>在四种边缘法线中找到最接近梯度方向 $\alpha$ 的，记为 $d_k$</p></li><li><p>在  $d_k$ 方向上取一个或两个邻点，若 $K$ 小于所取点的梯度幅值，则令 $g_N(x,y) = 0$ （即抑制），否则为 $g_N(x,y) = K$（$g_N(x,y)$ 为非极大值抑制后的图像）</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/24/9b4tNFxhn6AfWTm.png" alt="image-20220824210836545" style="zoom: 67%;" /></p><ul><li><p>双阈值法</p><ul><li>阈值过高导致细节丢失，过低则边缘杂乱</li></ul><p><img src="https://s2.loli.net/2022/08/24/2wQXCbSgkaihLAp.png" alt="image-20220824211107517" style="zoom: 67%;" /></p><ul><li><p>双阈值：先利用高阈值筛选出主要的边缘，再利用低阈值将这些边缘连接起来（低阈值虽然会引入噪声引起的假边，但是这种假边不会和高阈值筛选出的主要边缘有连接）</p><p><img src="https://s2.loli.net/2022/08/24/vPNtdZhnIjlBXi3.png" alt="image-20220824211258649" style="zoom:80%;" /></p></li></ul></li><li><p>Canny 整体流程：</p><ul><li><p>用高斯一阶偏导核卷积图像</p></li><li><p>计算每个点的梯度幅值和方向</p></li><li><p>非极大值抑制：</p><ul><li>将宽的“边缘”细化至单个像素宽度</li></ul></li><li><p>连接与阈值（滞后）：</p><ul><li><p>定义两个阈值：低和高</p></li><li><p>使用高阈值开始边缘曲线，使用低阈值继续边缘曲线</p></li></ul></li></ul></li></ul><h1 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h1><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>在获得边缘后，接下来的问题是，对于图中的特征如何进行描述，即选择参数模型进行拟合，但实际中，面临三个问题：</p><ul><li><p>噪声</p></li><li><p>局外点的影响</p></li><li><p>遮挡导致的数据丢失</p></li></ul><p>为此，针对不同的情况需要不同的方法</p><ul><li><p>如若知道所有点都属于一条直线，该如何找到这条最优直线？</p><ul><li>最小二乘</li></ul></li><li><p>若存在外点呢？</p><ul><li>鲁棒最小二乘、RANSAC</li></ul></li><li><p>若这些点属于多条直线呢？</p><ul><li>投票机制：RANSAC、Hough 变换</li></ul></li><li><p>更一般的情况，不确定其是否是直线？</p><ul><li>模型筛选</li></ul></li></ul><h2 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h2><h3 id="“垂直”最小二乘"><a href="#“垂直”最小二乘" class="headerlink" title="“垂直”最小二乘"></a>“垂直”最小二乘</h3><p>如图，对于 $n$ 个点，若其直线方程为 $y = mx + b$ ，则要使每个点到该直线的垂直距离最小化，方可说明这些点在该直线上</p><p>于是，可建立能量函数（目标函数），并使其最小化：</p><script type="math/tex; mode=display">E=\sum_{i=1}^n (y_i -mx_i -b)^2</script><p>这里之所以取平方，是因为我们只关心点到直线的距离，不关心正负。</p><p>对 $n$ 个点，有</p><script type="math/tex; mode=display">\begin{cases}y_1 = mx_1 + b \\\\y_2 = mx_2 + b \\\\\vdots \\\\y_n = mx_n + b \end{cases}</script><p>写成矩阵形式：</p><script type="math/tex; mode=display">Y = XB</script><script type="math/tex; mode=display">Y=\begin{bmatrix}y_1 \\y_2 \\\vdots \\y_n\end{bmatrix}\qquadX=\begin{bmatrix}x_1 & 1\\x_2 & 1\\\vdots & \vdots \\x_n & 1\end{bmatrix}\qquadB=\begin{bmatrix}m \\b \\\end{bmatrix}</script><p>到此，前述的能量函数变为（平方和即为模）：</p><script type="math/tex; mode=display">E = ||Y-XB||^2</script><p>$B$ 为待求项，$||X||$ 为向量的模，是内部元素的平方和开根号，这也是能量函数取平方的另一个好处。对一个向量 $A = \begin{bmatrix} a_1\\ a_2 \\a_3 \end{bmatrix} $，有：</p><script type="math/tex; mode=display">||A|| ^2 = a_1^2 +a_2^2 + a_3^2 = A^TA</script><p>故能量函数可写为：</p><script type="math/tex; mode=display">\begin{align}E  & = ||Y-XB||^2 =  (Y-XB)^T(Y-XB) \\ & \overset{展开}{=}  (Y^T-B^TX^T)(Y-XB) \\ & = Y^TY - Y^TXB-B^TX^TY + B^TX^TXB  \\ & = Y^TY-2(XB)^TY+(XB)^TXB\end{align}</script><p>为求 $B$，自然想到让 $E$ 对 $B$ 求导：</p><script type="math/tex; mode=display">\frac{dE}{dB} = -2X^TY + 2X^TXB = 0</script><p>从而求得：</p><script type="math/tex; mode=display">B = (X^TX)^{-1}X^TY</script><p><img src="https://s2.loli.net/2022/08/27/D6S5ErMeb4oNcHG.png" alt="image-20220827212852424" style="zoom: 80%;" /></p><p>问题：</p><ul><li>当直线垂直 x 轴时，方法失效</li><li>即不满足旋转不变性，直线转动到垂直时无法求解</li></ul><h3 id="全最小二乘"><a href="#全最小二乘" class="headerlink" title="全最小二乘"></a>全最小二乘</h3><ul><li><p>目的：解决垂直最小二乘的失效情况</p></li><li><p>原理</p></li></ul><p>假设一点$(x_i,y_i)$ 和一直线 $ax+by=d$ （满足 $a^2+b^2=1$)，则该点到该直线的距离为</p><script type="math/tex; mode=display">|ax_i+by_i-d|</script><p>要拟合直线，即找到合适的 $(a,b,d)$ 使得所有的点到该直线的距离最小，即最小化能量函数：</p><script type="math/tex; mode=display">E=\sum^n_{i=1}(ax_i+by_i-d)^2 \tag{*}</script><p>该函数对 $d$ 求导可得：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial d} = \sum^n_{i=1} -2(ax_i+by_i-d) =0</script><p>整理得：</p><script type="math/tex; mode=display">d = \frac{a}{n}\sum^n_{i=1} x_i + \frac{b}{n}\sum^n_{i=1} y_i = a\bar{x} + b\bar{y} \tag{**}</script><p>将其代入 (*) 式可得：</p><script type="math/tex; mode=display">E=\sum^n_{i=1}(a(x_i-\bar{x}) + b(y_i-\bar{y}))^2 = ||\begin{bmatrix} x_1 - \bar{x} & y_1 - \bar{y} \\\vdots & \vdots \\x_n - \bar{x} & y_n - \bar{y}\end{bmatrix}\begin{bmatrix}a \\b\end{bmatrix}||^2= (UN)^T(UN)</script><p>为求得 N，可求导：</p><script type="math/tex; mode=display">\frac{dE}{dN}=2(U^TU)N= (U^TU)N =0</script><p>根据特征值与特征向量的关系，对 $AN=\lambda N$，要使其为 0，只能是 $\lambda = 0$，故该方程的解为<red>最小特征值对应的特征向量</red></p><p><img src="https://s2.loli.net/2022/10/02/67STchKG9yEmrlR.png" alt="image-20221002200507340" style="zoom:50%;" /></p><p>事实上，上述的 $U^TU$ 矩阵为二阶矩矩阵，如下图，由前述(**)式可知点 $(\bar{x},\bar{y})$ 在该直线上，从几何角度来看，使得能量方程最小化的点即为使得任意点与该点的向量在该直线的法线上的分量最小。</p><p><img src="https://s2.loli.net/2022/10/02/myKu2oC3rQwZaf5.png" alt="image-20221002205336633" style="zoom:50%;" /></p><h3 id="鲁棒估计（鲁棒核函数）"><a href="#鲁棒估计（鲁棒核函数）" class="headerlink" title="鲁棒估计（鲁棒核函数）"></a>鲁棒估计（鲁棒核函数）</h3><p>如图是最小二乘拟合的结果，可见，当出现外点（即噪声）的影响时，拟合的准确性很差</p><p><img src="https://s2.loli.net/2022/10/02/syfARnZaT49d1Gp.png" alt="image-20221002211040260" style="zoom:50%;" /></p><p>这是因为最小二乘要确保所有的点都使得能量函数最小化，所以直线朝着外点倾斜，外点距离真实直线的距离很远，拟合时所占的比重很大，为缩小这种外点的比重，引入了鲁棒估计</p><p><img src="https://s2.loli.net/2022/10/02/yJojHPL1dY5aISw.png" alt="image-20221002211109257" style="zoom:50%;" /></p><p>鲁棒估计引入鲁棒核函数 $\rho$ ，该函数有一个缩放因子参数 $\sigma$，通过该值可调整权重，其和距离类似，不同的是，当距离超过一定限度时，该值不再增加。以图中 $\sigma = 0.1$ 为例，当横坐标值大于 4 时，值都为1。换句话说，对一点而言，不论该点距离直线的距离是1k还是1w，对能量函数而言其比重都为 4，这样就在一定程度上避免了外点占比过大，导致拟合精度差的问题。</p><p>缩放因子参数 $\sigma$ 选取不同的拟合结果（一般取平均残差的1.5倍）：</p><center>  <figure>    <img src="https://s2.loli.net/2022/10/02/WpDQRw1NhVK6xdT.png" style="zoom:28%"/>    <img src="https://s2.loli.net/2022/10/02/ZoJ62HKhO8TRGwY.png" style="zoom:27%"/>    <img src="https://s2.loli.net/2022/10/02/p7ZGkib5mg1WABy.png" style="zoom:28%"/>      <!-- <br> -->      合适/          <!-- &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;        &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; -->        过小/          <!-- &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;        &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; -->    过大  </figure></center> <p>需注意的是，鲁棒拟合是一个非线性问题，须通过迭代求解，而迭代需要一个良好的初值，前述的最小二乘便可提供该初值。</p><h2 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h2><p>若无特殊说明，以下均以简单的直线拟合为例。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>RANSAC是一种通用的模型估计思想，主要有四步：</p><ul><li><p>在已有点中随机选择足够拟合某类形状的点（如拟合一条直线需要2点）</p></li><li><p>利用所选的点拟合该形状</p></li><li><p>查找剩余点，保留距离该形状较近的点，剔除外点</p></li><li><p>重复上述过程，直至找到最佳的形状</p></li></ul><h3 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h3><h4 id="所需参数"><a href="#所需参数" class="headerlink" title="所需参数"></a>所需参数</h4><p>可见，我们需要指定一些参数才能使用该方法</p><ul><li><p>初始点数 $s$：拟合形状所需的最小点数</p></li><li><p>距离阈值 $t$：该参数指定范围内的点是内点</p></li><li><p>采样次数 $N$：即迭代的次数</p><p>若外点率为 $e$，拟合的正确率为 $p = 0.99$，则拟合错误的概率为 $(1-p)$，内点率为 $(1-e)$，由于选择 $s$ 个进行拟合，故内点率为 $(1-e)^s$，则采样一次的错误率为 $1-(1-e)^s$，采样 $N$ 次为 $(1-(1-e)^s)^N$，从而</p><script type="math/tex; mode=display">(1-(1-e)^s)^N=1-p</script><p>对左右同时取对数：</p></li></ul><script type="math/tex; mode=display">N = \text{log}(1-p)/\text{log}(1-(1-e)^s)</script><p>  下图表显示了拟合不同的模型，当外点率不同时，要达到 0.99 的正确率所需的迭代次数</p><p><img src="https://s2.loli.net/2022/10/03/J16sXlRSKe9PfOx.png" alt="image-20221003104608787" style="zoom:67%;" /></p><ul><li>一致性点集 $d$：最终模型的内点数，应当和设置的内点率相适应，可通过设置该阈值选择保留哪些拟合结果</li></ul><h4 id="自适应参数选取"><a href="#自适应参数选取" class="headerlink" title="自适应参数选取"></a>自适应参数选取</h4><p>实际使用中，我们可能压根不知道点集中的外点率，这时就需要自适应的参数选择</p><p><img src="https://s2.loli.net/2022/10/03/z2IyQMpLDcxrKFs.png" alt="image-20221003153449842" style="zoom:67%;" /></p><p>起初我们不知道要迭代多少次，就直接假设我们要迭代无穷次，设置一个迭代计数器（sample_count）记录迭代的次数，首次迭代时，可以计算出外点率 $e$，由外点率可计算出迭代的次数 $N$，据此便可迭代。</p><p>但在实际实验中，我们还是会指定迭代的次数，如指定 1k 或 1w，避免耗时过长。</p><h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><ul><li><p>优势</p><ul><li><p>简单，通用</p></li><li><p>通常能得到很好的结果</p></li></ul></li><li><p>缺点</p><ul><li><p>需要指定的参数多</p></li><li><p>内点率较低时，效果不好（迭代过多甚至失败）</p></li><li><p>并不总是能得到很好的初始化</p></li></ul></li></ul><p>实际中，在通过 RANSAC 方法获得内点后，还可继续对这些内点使用最小二乘拟合，以得到更为精确的拟合结果。</p><p>不难看出，RANSAC 实际是一种暴力的方法，通过随机选取点进行拟合，利用剩余的点进行投票，再通过设置一个阈值，只要大于这个阈值，就认为是正确的，这在<font color = red>匹配</font>中应用广泛。</p><h2 id="Hough-变换"><a href="#Hough-变换" class="headerlink" title="Hough 变换"></a>Hough 变换</h2><p>使用条件</p><ul><li>是一种投票机制</li><li>噪声点对任何模型的投票均不具备一致性</li><li>丢失数据不影响，只要剩余的点足够拟合</li></ul><h3 id="整体思想"><a href="#整体思想" class="headerlink" title="整体思想"></a>整体思想</h3><ul><li>将图像空间离散化为霍夫参数空间</li><li>每个特征点都在参数空间中进行投票</li><li>投票最多的点即为所求</li></ul><p><img src="https://s2.loli.net/2022/10/03/BhRVXJMEywZKzWu.png" alt="image-20221003164345726" style="zoom: 50%;" /></p><p>图像空间中的一条直线，对应参数空间中的一点（参数空间的横纵坐标是直线的参数）</p><p><img src="https://s2.loli.net/2022/10/03/phoWfElFcwO9PZs.png" alt="image-20221003164631417" style="zoom: 67%;" /></p><p>图像空间中的一点，对应参数空间中的一条直线（参数空间中自变量和因变量变化了）</p><p><img src="https://s2.loli.net/2022/10/03/RQnKZG89vHdMj2U.png" alt="image-20221003164910566" style="zoom: 67%;" /></p><p>则对于图像空间中的两点（确定一条直线），在霍夫参数空间中对应两条直线，这两条直线的交点，即为投票最多的点 $(m^<em>,b^</em>)$，即为所要拟合直线的参数。换句话说，图像空间中这条直线上的所有点都经过参数空间中的交点。</p><p><img src="https://s2.loli.net/2022/10/03/hB16ocSJYIDdZFK.png" alt="image-20221003165449982" style="zoom:67%;" /></p><p>但当直线是垂直线时，即 $x=a$，该直线上的所有点在参数空间中对应的直线是平行的，即没有交点，方法失效，参数空间无边界</p><h3 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h3><p>通过极坐标表示，解决垂直直线的问题。（详见《数字图像处理》P531）</p><p>直线的极坐标参数化方程为</p><script type="math/tex; mode=display">x\text{cos}\theta+y\text{sin}\theta=\rho</script><p>因而，图像空间中过一点的直线簇对应参数空间中的正弦曲线，交点 $(\rho’,\theta’)$ 即为图像空间中的直线，下图右边是参数空间划分的多个累加单元，初始时将其设为 0，对图像空间中的每个点，利用参数空间中的每个可能的 $\theta$，计算出 $\rho$。实际中，如果选择的 $\theta_q$ 得到解 $\rho_q$，则累加器增1（可以理解为给这个点头了一票），最终输出累加器最大的结果即为所求。</p><p><img src="https://s2.loli.net/2022/10/03/A4UCDy3ScgJGwMV.png" alt="image-20221003195557072" style="zoom:67%;" /></p><p>具体算法流程如下：</p><p><img src="https://s2.loli.net/2022/10/03/DFCbvjPQY6ANfZy.png" alt="image-20221003204134020" style="zoom:67%;" /></p><h3 id="噪声的影响"><a href="#噪声的影响" class="headerlink" title="噪声的影响"></a>噪声的影响</h3><p>当存在噪声时，霍夫空间投票的结果就不再是聚焦于一点，还是一个区域，如下图</p><p><img src="https://s2.loli.net/2022/10/03/S4UjJOpMAtaDiPl.png" alt="image-20221003210310592" style="zoom:67%;" /></p><p> 如何处理噪声?</p><ul><li><p>恰当的离散化网格</p><ul><li><p>既然噪声让聚焦点变成了区域，那么放大划分的网格，就让这块区域落在这一块网格中，即当做同一直线处理</p></li><li><p>但网格划分过大，会导致本来不是直线投票也被包含进来</p></li><li><p>同理，划分过细，导致本来属于一条直线的投票被去除</p></li></ul></li></ul><ul><li><p>增加邻域投票（软投票）</p><ul><li>类似高斯核，根据周围邻域到中心点的距离不同，投不同的票数，离得越近占比越大，中心始终占比最大</li></ul></li><li><p>去除不相关的点</p><ul><li>只使用梯度幅值较大的边缘点，即对每个点，通过计算其梯度方向确定角度，然后只是在该角度范围内投票</li></ul></li></ul><h3 id="Hough-圆"><a href="#Hough-圆" class="headerlink" title="Hough 圆"></a>Hough 圆</h3><p>根据圆的方程</p><script type="math/tex; mode=display">(x-u)^2+(y-v)^2=r^2</script><p>可知，圆有三个参数 $(u,v,r)$，则霍夫空间为三维。</p><p>对于一个点，若已知半径 $r$，且圆过该点，则该圆可能的圆心是在该点梯度方向两侧，对应霍夫参数空间中的两点。</p><p><img src="https://s2.loli.net/2022/10/03/OjrIK1e3zTp5P24.png" alt="image-20221003222148605" style="zoom:67%;" /></p><p>不同的半径对应不同的两点，经过投票，霍夫空间中存在一个立方体小空间，该空间中票数最高，对应的三个参数即为所求。</p><p><img src="https://s2.loli.net/2022/10/03/q3CQ1erh4sN5ZmR.png" alt="image-20221003222604417" style="zoom:67%;" /></p><h3 id="广义-Hough"><a href="#广义-Hough" class="headerlink" title="广义 Hough"></a>广义 Hough</h3><p>Hough 变换可以推广到识别，比如下图的示例中，通过各组件与中心的方向与距离确定一个模板，在一堆混乱的组件中识别其中心，可根据模板中确定的组件方向和距离投票，最终得到票数最多的点即为中心点。实际使用中如由两车轮定位车辆中心。</p><p><img src="https://s2.loli.net/2022/10/04/UH6sBSZPnckeYfI.png" alt="image-20221004202653777" style="zoom: 45%;" /></p><p><img src="https://s2.loli.net/2022/10/04/Wcmy74xDULCsOIq.png" alt="image-20221004202723267" style="zoom: 41%;" /></p><p><img src="https://s2.loli.net/2022/10/04/l4HeacfOPND8gu1.png" alt="image-20221004202755081" style="zoom:41%;" /></p><p><img src="https://s2.loli.net/2022/10/04/9xIPmFQiNeHcWM7.png" alt="image-20221004202826706" style="zoom:41%;" /></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li><p>不受非局部或遮挡影响</p></li><li><p>可检测多个模型</p></li><li><p>一定程度上不受噪声影响：可认为噪声点的投票不具有一致性</p></li></ul></li><li><p>缺点</p><ul><li><p>高维时参数空间复杂，搜索时间指数级增加</p></li><li><p>非目标模型在参数空间也可能产生极值点</p></li><li><p>参数空间的划分较难（较难确定一个比较好的划分方法）</p></li></ul></li></ul><h1 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h1><p>为何提取需要提取特征？多视角拼接</p><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>特征的要求</p><ul><li><p>可重复性：即使有几何变换等的影响，该特征仍能在多视角中找到</p></li><li><p>独特性：每个特征应当是独特的，否则难以匹配</p></li><li><p>高效性：考虑计算的高效性</p></li><li><p>局部性：特征只是局部的</p></li></ul><h2 id="Harris-角点"><a href="#Harris-角点" class="headerlink" title="Harris 角点"></a>Harris 角点</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><em>详述见《数字图像处理》P627</em></p><ul><li>角点：在各个方向移动时窗口内灰度变化大 </li><li>平坦区域：各方向无变化</li><li>边：沿着边缘方向无变化</li></ul><p><img src="https://s2.loli.net/2022/08/25/eiV97TIfXFthGkl.png" alt="image-20220825113340724" style="zoom: 67%;" /></p><p>可见，为了检测角点，只需使用一个窗口进行滑动，判断窗口移动前后窗口区域内的灰度变化，如何从数学角度量化？</p><p>如下图，红色实线框为移动前，绿色虚线框为移动后，$E(u,v)$ 表示移动前后差的平方的加权和，$\text{w(x,y)}$ 为加权函数，主要有两种：盒式滤波器（窗口内为1，外为0）、高斯滤波器（根据距离远近分配权值）</p><!-- <center><figure>    <img src="https://s2.loli.net/2022/10/04/96Pq4MiZjVEwJRI.png" style="zoom:36%"/>    <img src="https://s2.loli.net/2022/10/04/cXPSsfoDCvmNRBT.png" style="zoom:36%"/>    </figure></center>  --><!-- in Butterfly  theme --><center>  <div class="fj-gallery"><p><img src="https://s2.loli.net/2022/10/04/96Pq4MiZjVEwJRI.png" style="zoom:50%"/><br><img src="https://s2.loli.net/2022/10/04/cXPSsfoDCvmNRBT.png" style="zoom:50%"/></p>          </div></center><p>然而，上述公式操作起来比较麻烦（每次移动后都要取像素），我们更希望有一种关系可以直接表达移动 $(u,v)$ 时两者与 $E(u,v)$ 的关系，为此，我们对上式在 $(0,0)$ 点进行泰勒展开（只保留二阶以下的项），每一项求导的结果如下：</p><p><img src="https://s2.loli.net/2022/10/04/b4CNIjp9tQY85U3.png" alt="image-20221004214728246" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2022/10/04/63Prpd24lALc8Ie.png" alt="image-20221004215240090" style="zoom:68%;" /></p><p>上式可以简化为如下的矩阵形式：其中 $M$ 是二阶矩矩阵，可通过图像梯度求得</p><p><img src="https://s2.loli.net/2022/10/04/pFLYvMyx72J94ut.png" alt="image-20221004215759317" style="zoom:67%;" /></p><p>此时 $E(u,v)$ 可由 $M$ 确定，假设 $M = \begin{bmatrix}\lambda_1 &amp; 0 \\ 0 &amp; \lambda_2 \end{bmatrix}$，$E(u,v)=\text{const}$ ，即：</p><script type="math/tex; mode=display">\begin{bmatrix}u & v\end{bmatrix}\begin{bmatrix}\lambda_1 & 0 \\ 0 & \lambda_2 \end{bmatrix}\begin{bmatrix}u \\ v\end{bmatrix}=\text{const}\tag{c1}</script><script type="math/tex; mode=display">\frac{u^2}{(\frac{1}{\lambda_1})^2}+\frac{v^2}{(\frac{1}{\lambda_2})^2} = \text{const} \tag{c2}</script><p>可见结果为椭圆。</p><!-- <center><figure> -->  <div class="fj-gallery"><p><img src="https://s2.loli.net/2022/10/04/14mnucD35lYhPFs.png" style="zoom:49%"/><br><img src="https://s2.loli.net/2022/10/04/MdCnAOrgX4DxImG.png" style="zoom:36%"/></p>          </div><!-- </figure></center>  --><p>现在考虑这样一种情况，梯度方向是水平或者垂直的（即沿 x 或 y 方向的导数为 0，即 $\lambda_1 = 0$ 或 $\lambda_2 = 0$），那么窗口沿着垂直于梯度的方向运动时，另一个方向是不会变化的，也就是边的情况。换句话说，只要 $\lambda_1$ 和 $\lambda_2$ 任意一个接近于 0，那就不是角点；再者说，角点就是两者都比较大的地方。这就对前述的过程进行了量化。</p><p>如果角点是本节第一张图所示的样子，根据上述推导，易知其椭圆是一个正椭圆，但实际中显然不可能都是正椭圆，这时候就需要先对其进行旋转，旋转可由旋转矩阵表示，也就是说，如果有旋转， $M$ 的元素不再是 0，但其是一个实对称矩阵，由线代知识，可将其分解为</p><script type="math/tex; mode=display">M=R^{-1}\begin{bmatrix}\lambda_1 & 0 \\ 0 & \lambda_2 \end{bmatrix}R\tag{c3}</script><p>根据旋转矩阵的性质：$R^{-1}=R^T$，将上式带入 (c1)式可得：</p><script type="math/tex; mode=display">\begin{align}\begin{bmatrix}u & v\end{bmatrix}R^{-1}\begin{bmatrix}\lambda_1 & 0 \\ 0 & \lambda_2 \end{bmatrix}R\begin{bmatrix}u \\ v\end{bmatrix}=\text{const} \\\Rightarrow\begin{bmatrix}u & v\end{bmatrix}R^T\begin{bmatrix}\lambda_1 & 0 \\ 0 & \lambda_2 \end{bmatrix}R\begin{bmatrix}u \\ v\end{bmatrix}=\text{const} \\\Rightarrow(R\begin{bmatrix}u \\ v\end{bmatrix})^T\begin{bmatrix}\lambda_1 & 0 \\ 0 & \lambda_2 \end{bmatrix}R\begin{bmatrix}u \\ v\end{bmatrix}=\text{const} \end{align}\tag{c4}</script><p>$R$ 即为旋转矩阵，可见旋转到正椭圆后，就可只关注  $\lambda$ 了 。</p><p><img src="https://s2.loli.net/2022/10/05/FtESKBvRk3wj4Jf.png" alt="image-20221005214907513" style="zoom:67%;" /></p><p>那么，$\lambda$ 跟椭圆有什么关系呢？根据式(c2)可知，$\lambda$ 越大，对应椭圆的短轴，且在该方向上梯度变化快，反之亦反之。</p><p>也就是说，<font color = red>  $\lambda$ 决定了椭圆的轴长，即决定了梯度变化的快慢，旋转矩阵 $R$ 则决定了其姿态 </font>。</p><p>对 $M$ 进行可视化如下图，结果如上述推导，梯度变化的快慢决定了椭圆的形状。</p><center>    <img src="https://s2.loli.net/2022/10/05/yzv8nVNkjbwhYs1.png" alt="image-20221005222830357" style="zoom:67%;" />    <!-- </br> -->二阶矩矩阵可视化</center><p>也就是说，我们只需要关注 $\lambda$ 的大小就可知是否是角点</p><p><img src="https://s2.loli.net/2022/10/05/DRSIXwgucdFqloY.png" alt="image-20221005223408349" style="zoom:67%;" /></p><p>而在实际中，研究者觉得，要两个 $\lambda$ 比较麻烦，实际过程中使用 $R$，通过该值判断，具体如下：</p><p><img src="https://s2.loli.net/2022/10/05/F4tyUSnB7YvhTCs.png" alt="image-20221005223544418" style="zoom:67%;" /></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>对每个像素计算高斯一阶导</p></li><li><p>在高斯窗口内计算每个像素的二阶矩矩阵 $M$</p></li><li><p>计算角点响应函数 $R$</p></li><li><p>设置 $R$ 的阈值</p></li><li><p>非极大值抑制以找到局部最大值（主要考虑到一块区域内存在多个在阈值范围内的极大值，可通过抑制保留最大的那个）</p></li></ul><p><img src="https://s2.loli.net/2022/08/25/5lLc21vCWtVA8hG.png" alt="image-20220825121708179" style="zoom: 67%;" /></p><h3 id="不变性分析"><a href="#不变性分析" class="headerlink" title="不变性分析"></a>不变性分析</h3><ul><li><p>不变性(Invariance)：图像角度、光照的变化不影响角点的提取，即 $F(T(\text{img}))=F(\text{img})$</p></li><li><p>协变性(covariance)：图像变换后需要经过相应的变换才能匹配，即 $F(T(\text{img}))=T’F(\text{img})$</p></li></ul><p>说白了，不变性就是不论图像怎么变，都能找到角点，而协变性是图像变了之后虽然能找到，但是经过相应的变换之后才能匹配。</p><ul><li><p>灰度仿射变换</p><ul><li><p>仅灰度是具有不变性的，对同一点，增加其灰度和减小其灰度，求导后其趋势不变</p></li><li><p>但灰度缩放导致部分点超过阈值，缩放前后不满足不变性</p></li><li><p>即灰度仿射变换满足部分不变性</p></li></ul></li></ul><p>说明：$I<em>{out} = aI</em>{in}+b$，$a$ 控制图像的对比度（即白的更白，黑的更黑），$b$ 控制其亮度的增减</p><p><img src="https://s2.loli.net/2022/10/06/QuMVbsX6KecqyGE.png" alt="image-20221006195744524" style="zoom:67%;" /></p><ul><li><p>图像平移变换满足协变性</p><p>平移之后角点的位置变化了，需要通过一个变换 $T$ 才能得到平移前的角点</p></li></ul><p><img src="https://s2.loli.net/2022/10/06/rPqXVlvgIORdStU.png" alt="image-20221006200729629" style="zoom:67%;" /></p><ul><li><p>图像旋转变换满足协变性</p><p>如下图，图像旋转之后，二阶矩矩阵对应的椭圆发生了旋转，但椭圆的轴未变，和平移类似，都能找到角点，但要经过旋转变换才能得到原来的点</p></li></ul><p><img src="https://s2.loli.net/2022/10/06/N7KDoOqplYvsAfL.png" alt="image-20221006201053351" style="zoom:67%;" /></p><ul><li><p>不满足尺度不变性</p><p>对缩放这种尺度变换而言，放大后，角点就已经检测不到了，所有的点都会检测为边</p></li></ul><p><img src="https://s2.loli.net/2022/10/06/slON7jmnzBgreyv.png" alt="image-20221006202133664" style="zoom:67%;" /></p><p>Harris角点无法检测尺度变化的角点，那有没有尺度不变的检测算法呢，答案是肯定的！</p><h2 id="斑点（Blob）检测"><a href="#斑点（Blob）检测" class="headerlink" title="斑点（Blob）检测"></a>斑点（Blob）检测</h2><h3 id="拉普拉斯核"><a href="#拉普拉斯核" class="headerlink" title="拉普拉斯核"></a>拉普拉斯核</h3><p>前述提到的 Harris 角点检测算法尺度缩放后无法检测，我们需要一种算法满足尺度协变性，即：不论图像中的特征被放大还是缩小，该算法都可以准确的检测该特征。</p><p>高斯一阶导可用于检测边缘，这里引出高斯二阶导：</p><center><figure>    <img src="https://s2.loli.net/2022/10/06/Wgs9I4uifYk23dR.png" style="zoom:33%"/>    <img src="https://s2.loli.net/2022/10/06/EyxIKoTDHrNbkFv.png" style="zoom:34%"/>    </figure></center> <p>高斯函数的一般形状为：</p><script type="math/tex; mode=display">G(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>对高斯二阶导：</p><script type="math/tex; mode=display">\begin{align}\nabla^2G(x,y) & = \frac{\partial^2G(x,y)}{\partial x^2}+\frac{\partial^2G(x,y)}{\partial y^2} \notag\\& = \frac{\partial}{\partial x}(\frac{-x}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}})+\frac{\partial}{\partial y}(\frac{-y}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}) \notag\\& = (\frac{x^2}{\sigma^4}-\frac{1}{\sigma^2})e^{-\frac{x^2+y^2}{2\sigma^2}}+(\frac{y^2}{\sigma^4}-\frac{1}{\sigma^2})e^{-\frac{x^2+y^2}{2\sigma^2}} \notag \\& = (\frac{x^2+y^2-2\sigma^2}{\sigma^4})e^{-\frac{x^2+y^2}{2\sigma^2}} \notag\end{align}</script><p>此即为 <font color=red>高斯拉普拉斯（LoG）函数</font>，其长相如下：草帽</p><p><img src="https://s2.loli.net/2022/10/06/ipDZhswP3FWzgq2.png" alt="image-20221006214700981" style="zoom:80%;" /></p><p><em>上述推导部分详见《数字图像处理》P521</em></p><h3 id="尺度选择"><a href="#尺度选择" class="headerlink" title="尺度选择"></a>尺度选择</h3><p>拉普拉斯核（差分表示的高斯二阶导）同样可以用于检测边缘（过零点即为边缘的位置），但 LoG 可用于尺度的检测。</p><p>高斯二阶导与信号卷积，如果两者相“匹配”，那么在斑点中心除便会产生极值</p><p><img src="https://s2.loli.net/2022/10/06/3FVjlEB9LWnZdRr.png" alt="image-20221006212419112" style="zoom: 67%;" /></p><p>在实际使用中，我们无法知道信号和什么样的拉普拉斯核匹配，但是我们可以<font color = red>给定一堆核</font>，让信号与其卷积，能得到极值的那个便是所需的核，然而现实往往很骨感：随着 $\sigma$ 的变化，信号被衰减直至消失，这是为啥呢？</p><p><img src="https://s2.loli.net/2022/10/06/nKPMIsWJDa8XTxe.png" alt="image-20221006212742951" style="zoom:67%;" /></p><p>为了搞清这个问题，我们以高斯一阶导为例，如下图，高斯偏导核与信号卷积时，卷积结果为 $\frac{1}{\sigma\sqrt{2\pi}}$，可见，随着 $\sigma$ 的增大，相同的信号，卷积的结果不断减小。如何让卷积结果（尺度）恒定不变呢，当然是把 $\sigma$ 去除，即 $\frac{1}{\sigma\sqrt{2\pi}}*\sigma = \frac{1}{\sqrt{2\pi}} $。那同理，对高斯二阶导而言，就需要乘 $\sigma^2$。这个过程称为尺度归一化。</p><p><img src="https://s2.loli.net/2022/10/06/3T91FEN8KpWtwlj.png" alt="image-20221006213428059" style="zoom:67%;" /></p><p>在尺度归一化后，信号在一堆拉普拉斯核中有一个极大值响应</p><p><img src="https://s2.loli.net/2022/10/06/mZbRXUGoWAap7uC.png" alt="image-20221006214345928" style="zoom:67%;" /></p><p>即实际使用时进行尺度归一化：</p><script type="math/tex; mode=display">\begin{align}\nabla^2_{norm}g & = \sigma^2\nabla^2G(x,y) \notag \\& = (\frac{x^2+y^2-2\sigma^2}{\sigma^2})e^{-\frac{x^2+y^2}{2\sigma^2}} \tag{*}\end{align}</script><p>现在的问题是，拉普拉斯核在什么情况下相应才会最大呢？以二值圆形信号为例说明：</p><p><img src="https://s2.loli.net/2022/10/07/GxQhJinNvosXCpt.png" alt="image-20221007211745319" style="zoom: 50%;" /></p><p>不难看出，只有当拉普拉斯核的零截面与信号对齐时（恰好卡住），响应值最大。</p><p><img src="https://s2.loli.net/2022/10/07/t7oDOCq15wH9uP3.png" alt="image-20221007212010622" style="zoom:67%;" /></p><p>而对齐时，(*)式结果为0，则只能是 $x^2+y^2-2\sigma^2 = r^2-2\sigma^2 = 0$，即 $r=\sqrt{2}\sigma$，也即最大响应出现在 $\sigma = r/\sqrt{2}$ 处。</p><p>直观来看，只有当拉普拉斯核与二值圆形信号的圆一样大时，两者卷积的结果才最大（因为卷积就是信号的圆形区域与模板的圆形区域相差相加），只有两者完全重合时，卷积结果最大。</p><p><img src="https://s2.loli.net/2022/10/07/z5KHwrjAC9shy6P.png" alt="image-20221007212701671" style="zoom:50%;" /></p><h3 id="尺度空间"><a href="#尺度空间" class="headerlink" title="尺度空间"></a>尺度空间</h3><p>前面我们一直在说，通过不同的 $\sigma$ 进行尺度选择，不同的 $\sigma$ 会形成不同的图像，这些不同的图像属于同一个尺度空间，即灰度图像 $f(x,y)$ 的尺度空间 $L(x,y,\sigma)$ 是 $f$ 与一个可变尺度的高斯核 $G(x,y,\sigma)$ 卷积的结果：</p><script type="math/tex; mode=display">L(x,y,\sigma) = G(x,y,\sigma) \star f(x,y)</script><p>其中，$\sigma$ 控制尺度，$f$ 依次与标准差为 $\sigma、k\sigma、k^2\sigma、k^3\sigma、\dots$ 的高斯核卷积，便可生成一堆由常量因子 $k$ 分隔的高斯平滑图像（如下图），即模糊程度不断变化，能模拟人眼由近到远时目标在视网膜上的形成过程。</p><p>$\sigma$ 连续变化时，便可形成该图像的一个尺度空间（Lindeberg等人已证明高斯卷积核是实现尺度变换的唯一变换核，并且是唯一的线性核）</p><p><img src="https://s2.loli.net/2022/10/07/dqk5sGYSbQDLiKw.png" alt="image-20221007220903465" style="zoom:67%;" /></p><p>尺度空间中，只比较上下两个相邻的尺度空间，即比较相邻 27 个点，保留最大的那个（非极大值抑制）</p><p>如前述所述，需要不同的尺度空间，随着 $\sigma$ 的增大，高斯核半径增大，计算量（乘法和加法）增加，显然效率不会很高。</p><h2 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>我们已经知道了拉普拉斯函数，其计算较为复杂，但前辈们发现，该函数可用 <strong>高斯差分(DoG)</strong> 近似：</p><p>LoG：</p><script type="math/tex; mode=display">L=\sigma^2(G_{xx}(x,y,\sigma)+G_{yy}(x,y,\sigma))</script><p>DoG：</p><script type="math/tex; mode=display">DoG=G(x,y,k\sigma)-G(x,y,\sigma)</script><p>实验证明，对 LoG 进行一定的校正就可以通过 DoG 近似，性能基本相同。</p><script type="math/tex; mode=display">DoG=G(x,y,k\sigma)-G(x,y,\sigma) \approx (k-1)\sigma^2 \nabla^2G(x,y)</script><p><img src="https://s2.loli.net/2022/10/10/RY5jihBF19sl2mX.png" alt="image-20221010204720084" style="zoom:50%;" /></p><p>使用高斯差分近似的一大好处是，高斯核是可分离的，大的卷积核卷积的结果可以由两个小的卷积核完成。这样一来，我们不用让不同的核都与原图卷积，而是可以在现有卷积的基础上继续卷积。</p><p>举个例子：</p><p><img src="https://s2.loli.net/2022/10/10/TzlwgD7SEjFsAHy.png" alt="image-20221010221757508"></p><p>这样做的好处显而易见，如果所有尺度都与原图卷积，随着尺度增大，计算量不断增大，如果在已有的结果上卷积，显然模糊半径小，这是 SIFT 特征检测的关键之一，即提速。</p><p>为了构建尺度空间，利用高斯金字塔实现，包括对原图像在多尺度下<strong>高斯卷积</strong>及<strong>降采样</strong>得到。其中，相同的分辨率的图像组成一个尺度空间（作者采用了每个尺度空间 6 张递增的高斯卷积结果图），每个尺度空间称为一个组（Octave），下一组的最底层图像由上一层的倒数第三张图下采样得到（一般是间隔采样，即隔离一个像素取一个，即缩小一半），从而形成了高斯差分金字塔。这是关键之二，这里的核心在于，对原图用 $\sigma$ 卷积，和 将原图缩小一半，再用 $\sigma$ 卷积，结果 *2 一致。</p><p>举个例子，原图中 10 mm 的圆，我用同样大小的 $\sigma$ 卷积；另一种方案是，原图缩小一半，即待检测的圆只有 5mm 了，我仍然用前述的 $\sigma$ 卷积，卷积后的结果是 5mm 的圆，*2 后就是原图中 10mm 的圆。这样做的好处在于，同样的核，但图像缩小了，速度也就上来了。</p><p><img src="https://s2.loli.net/2022/10/10/OUelQiu4ZbRsdY8.png" alt="image-20221010215446390" style="zoom:67%;" /></p><p>如上图所示，第一组有 5 层，可生成 4 层 DoG 尺度空间，这 4 层经过非极大值抑制可得到 2 个尺度，其他组同理。问题是，如何让不同组（Octave）的尺度形成连续的尺度空间？</p><p>经过研究发现，只有当输出的尺度图像数与 k 之间的关系为 $k=s^{\frac{1}{2}}$ 时，方可形成连续尺度空间。</p><p>以上图为例，第一组经过非极大值抑制后得到 $k\sigma$、$k^2\sigma$，同理第二组为  $2k\sigma$、$2k^2\sigma$，输出 2 张尺度图像，即 $k=2^{\frac{1}{2}}$，带入可发现其形成了连续的尺度空间 $\sqrt{2}\sigma、2\sigma、2\sqrt{2}\sigma、4\sigma$。还可发现，要是最终输出 $s$ 张尺度图像，就得有 $s+2$ 张 DoG，$s+3$ 张 LoG。</p><p><em>前述中你可能会问为什么下一组的第一张图示上一组的倒数第三张下采样得到的？看完上面这个例子就显而易见了，我们最终输出 2 张尺度图像，对应的 DOG 有 4 层，4 层中的最底层不能参与特征值的提取，而 DOG 的最底层对应高斯尺度空间的最下面两层，也就是这两层，所以本尺度空间的关键信息点均在倒数第三层</em></p><p>上述即为 SIFT 的所有内容，下面进行总结。</p><h3 id="不变性分析-1"><a href="#不变性分析-1" class="headerlink" title="不变性分析"></a>不变性分析</h3><ul><li><p>拉普拉斯响应满足（旋转、缩放）不变性：即不论特征点有无缩放、旋转，都能检测到</p></li><li><p>特征的定位满足（旋转、缩放）协变性：特征都能检测到，但是匹配需要经过旋转、平移等操作</p></li><li><p>视角变化如何（仿射适应性）</p><p>如图，SIFT 只能输出图中的白色圆特征，但是右图视角变化后，很明显白色圈中的内容发生了变化，这样会导致后续匹配出问题，因而我们希望 SIFT 输出的是黄色圈，这样即使视角变化，其检测的特征还是一致的，匹配更有利。</p></li></ul><p><img src="https://s2.loli.net/2022/10/12/GvY1AMBW4FmnQ9R.png" alt="image-20221012204932015" style="zoom:67%;" /></p><p>如何实现这样的效果呢？</p><p>回顾 Harris 角点检测的部分，其利用了二阶矩矩阵判断梯度变化，二阶矩矩阵的特征值的大小表征了两个方向上梯度变化的快慢。设想这样一种情况，如果左右图像检测到的特征完全一致的话，对应的二阶矩矩阵的椭圆应该是圆形的，因为其在两个方向上的梯度变化是一致的。</p><p>换句话说，以上左图黄色圈为例，其在椭圆长短轴方向的梯度变化基本是一致的了（图中头部），此时对应到二阶矩矩阵的椭圆就是圆了。</p><p>为了达到黄色椭圆的效果（说白了就是抠图扣得准确一点），可以先计算出二阶矩矩阵的特征值，然后将梯度方向变化小的反向向内收缩，直至其变成圆，达到各个方向梯度变化一致，此时 SIFT 输出的就是上图黄色椭圆部分。</p><p><img src="https://s2.loli.net/2022/10/12/o8jWzOYSKtVlfBc.png" alt="image-20221012213518931" style="zoom:50%;" /></p><p><em>注意：这里所说的是二阶矩矩阵的椭圆变成了圆，不是 SIFT 的特征输出了圆</em></p><h3 id="SIFT-特征描述子"><a href="#SIFT-特征描述子" class="headerlink" title="SIFT 特征描述子"></a>SIFT 特征描述子</h3><p>现在我们有了仿射适应性，如何知道输出的特征是否是一致的呢？即如何对两幅图像检测到的特征进行比对？</p><p>在尺度变化后，我们在两幅图像上检测到了大小不同的特征，为方便比较，我们进行归一化操作，即将特征转为大小一致的单位圆</p><p><img src="https://s2.loli.net/2022/10/12/IKn5zUc1XYumyAO.png" alt="image-20221012214718287" style="zoom: 67%;" /></p><p>归一化后，角度还是不一致，为了匹配，必须将其转到一致的方向，即消除旋转。</p><p>为此，提出梯度方向直方图的方法。具体做法是：我们在归一化后的窗口内，计算梯度幅值和方向，将 $0-360°$ 的方向划分为 8 份（下图画错了，只有 7 份），幅值是多少，直方图的值就加多少，给哪个块投票由方向角度决定（例如，某一像素点的梯度方向为17.856 度，那么这个点应该归入10-19 度这一区域），选取直方图中最大的方向作为主方向。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221012214945630.png" alt="image-20221012214945630" style="zoom:67%;" /></p><p>这个主方向与水平方向的夹角就是需要旋转的角度，对两张图都旋转到水平方向，从而消除旋转角度。</p><p><img src="https://s2.loli.net/2022/10/12/TrBnSG5FvZ8pIcP.png" alt="image-20221012221549374" style="zoom:67%;" /></p><p>到此，我们完成尺度、旋转、角度的检测， 还剩下一个光照变化如何应对？SIFT 将经过前述变换的结果综合成为一个特征描述符，形成一个更加鲁棒的特征检测器。具体做法是：将检测特征圆区域划分成 16 个小区域，在每个小区域里面统计前述的梯度方向直方图，量化为 8 份的话，就会有 8 个方向，作为该小区域的描述子，故总共为 $16*8=128$ 维的描述符，两幅图像都如此，在比对时只需计算对应位置的 $L2$ 距离来判断相似性。</p><p>至于为什么划分为 16 块小区域，直方图 8 份，这就是作者实验的结果了，不过我们可以直观的理解，和 Harris 参数空间的划分类似，过大过小都不是好事。</p><ul><li><font color =red>邻域方向性信息联合的思想即增强了SIFT 算法的抗噪声能力，同时又对含有定位误差的特征匹配提供了很好 的容错性</font></li><li><p>实时性不高</p></li><li>有时特征点较少</li><li><p>对边缘光滑的目标无法准确提取特征点</p></li><li><p>对模糊的图像和边缘平滑的图像，检测出的特征点过少，对圆更是无能为力。近来不断有人改进，其中最著名的有SURF和CSIFT。</p></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p>SIFT 的实现包括以下几个步骤</p><ul><li><p>构建高斯多尺度金字塔</p></li><li><p>检测尺度空间的极值点：上下26个点中最大才保留</p></li><li><p>精确定位极值点：局部的极值点不一定是全局的极值，拟合二次函数精确定位</p></li><li><p>选取特征点方向：前述是尺度不变，这里开始旋转不变</p><ul><li><p>首先计算每一个特征点邻域内像素的梯度方向和幅值，然后选择在特征点邻域内最突出的方向赋给这个特征点，以此作为该特征点的主方向</p></li><li><p>统计直方图统计邻域内像素的梯度和方向，直方图中的最大值可认为是关键点的主方向</p></li></ul></li><li><p>生成关键点描述子</p><ul><li><p>金字塔保证特征点的空间不变性， 严格删选保证了特征点的准确性， 方向信息保证了特征点的旋转不变性</p></li><li><p>每一个关键点都拥有三个信息：位置、尺度以及方向</p></li><li><p>接下来需要为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变。描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。</p></li><li><p>将坐标轴旋转为关键点的方向，以确保旋转不变性</p></li><li><p>选取一个大小为16×16的窗口，中心放在关键点上，这个16×16窗口中每一个又被分成4×4的小窗口，在每一个4×4的小窗口中分别计算其梯度幅值和方向</p></li></ul></li></ul><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><h2 id="纹理相关任务"><a href="#纹理相关任务" class="headerlink" title="纹理相关任务"></a>纹理相关任务</h2><ul><li>纹理中估计形状：从图像的纹理估计表面方向或形状</li></ul><p><img src="https://s2.loli.net/2022/10/14/kWVBwyEbrfnMim9.png" alt="image-20221014221553201"></p><ul><li>利用纹理进行分割或分类：分析、表示纹理特征，将具有一致性的纹理分类</li></ul><p><img src="https://s2.loli.net/2022/10/14/lPv8eaL6jZyRiAQ.png" alt="image-20221014222258193" style="zoom: 50%;" /></p><ul><li>合成：生成新的纹理特征</li></ul><p><img src="https://s2.loli.net/2022/10/14/R9bPBOFNzgclQ8W.png" alt="image-20221014222216909" style="zoom:50%;" /></p><h2 id="定义及表示"><a href="#定义及表示" class="headerlink" title="定义及表示"></a>定义及表示</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>纹理即重复出现的局部特征或模式</li><li>通常表示了材料属性</li><li>重要的外观线索，特别是形状相似时</li></ul><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><p>既然纹理具有重复的模式，那么问题是：</p><ul><li><p>如何找到这种模式：</p><ul><li>使用和模式类似的滤波器（点状、条状、块状……）</li><li>考虑滤波器的响应幅值</li></ul></li><li><p>局部窗口中观察其统计特性：</p><ul><li>均值、标准差</li><li>直方图</li></ul></li></ul><p>比如我们使用高斯偏导核对一张图卷积，并统计每个窗口中两个方向上导数的均值。</p><p><img src="https://s2.loli.net/2022/10/14/JiQecFgSuaEOoPD.png" alt="image-20221014223723312" style="zoom:50%;" /></p><p>根据统计的结果绘图如下，由此可进行简单的分类：$x,y$ 方向上都方向变化比较小，说明是平坦区域；$x$ 方向变化大而 $y$ 方向变化小，说明主要是竖直方向的特征（图中竖直的沟渠）；两方向都变化较大，说明是图中的绿草区域。</p><p><img src="https://s2.loli.net/2022/10/14/3GQ9L5RkXDmM1O7.png" alt="image-20221014224103009" style="zoom:60%;" /></p><p>为了表示各类特征之间的相似性，可使用 $L2$ 距离。</p><p><img src="https://s2.loli.net/2022/10/14/LbaIc83qTnGQJp4.png" alt="image-20221014224856141"></p><p>当前我们假设已知了选取窗口的大小，但实际中我们是不知道该取多大的窗口才能分类。为此，我们可以尝试多个窗宽大小，选择区域内特征变化稳定（即不再变化）时对应的窗口大小。</p><p><img src="https://s2.loli.net/2022/10/14/26s5ztBZVgTNOJL.png" alt="image-20221014225345627"></p><h3 id="滤波器组"><a href="#滤波器组" class="headerlink" title="滤波器组"></a>滤波器组</h3><p>前面我们使用 x y 方向的偏导核对图像卷积，得到了局部特征，于是我们就想，如果我们找一堆的滤波器，形成一个滤波器组（Filter Banks)，这个滤波器组尽可能的包含更多的特征，如此一来卷积后得到的特征是否会更多更全呢？</p><p>以下图为例，该滤波器组包含了尺度、方向以及不同类型的模式</p><p><em><a href="http://www.robots.ox.ac.uk/~vgg/research/texclass/filters.html">Matlab code available for these examples</a></em></p><p><img src="https://s2.loli.net/2022/10/15/JXtGgcZEqSfeP67.png" alt="image-20221015211405123" style="zoom:67%;" /></p><p>之前我们使用的高斯核都是一维或二维的，这里介绍一下多维高斯核，其形状如下图所示，$\Sigma$ 是协方差矩阵，不同的 $\Sigma$ 对应不同的高斯核。其中，45° 方向上的值不为 0 时表示 x y 方向上是相关的，即一方增大另一方亦增大。</p><p><img src="https://s2.loli.net/2022/10/15/Aiz8OneMWVvDgaq.png" alt="image-20221015212136540" style="zoom:67%;" /></p><p>据此可以结合多维高斯核，从不同尺度、方向出发，构建滤波器组</p><p><img src="https://s2.loli.net/2022/10/15/H2Dx4mbWNBSKA13.png" alt="image-20221015212547243" style="zoom:67%;" /></p><p>我们利用上述滤波器组对下图卷积：可以发现，随着卷积核的尺度越大，维度越高，所提取的特征也越发抽象。</p><center><figure>    <img src="https://s2.loli.net/2022/10/15/X5Y4rGmVf8aijwx.png" style="zoom:33%"/>    <img src="https://s2.loli.net/2022/10/15/cA4xJUZIKpb6msl.gif" style="zoom:42%"/>    </figure></center> <p>同样，由滤波器组的均值响应向量可以确定纹理（下图的七维响应向量 A B C 是卷积核对图像卷积后再对卷积结果取平均，且越亮表示图像中主要是该类特征）</p><p><img src="https://s2.loli.net/2022/10/15/jIXGtUQHub3DRPf.png" alt="image-20221015215727563" style="zoom:67%;" /></p><p>上述过程采用了均值响应，但也可以采用直接对每个点都使用 7 维的向量。</p><p>举例：假设原图为 $H\times W$，滤器组有 $n$ 维，一种方式是每个点都让滤波器组卷积，即每个点都对应 $n$ 维，则卷积后的响应为 $H\times W \times n$ ；另一种是采用统计结果，如取均值，则每张图像对应一个响应结果。</p><p><strong>上述观点十分重要，因为卷积神经网络的基本思想就是如此，所不同的是，上述的滤波器组是人为设置的，而卷积神经网络的滤波器组则是网络自己学习的，我们可以想象的是，神经网络学习了超强的滤波器组，从而完成相应的任务。</strong></p><p>上述过程可用于分类任务，比如利用滤波器组卷积后得到响应结果，与数据库中的结果进行比对（L2距离)，根据相似性便可完成分类。</p><h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><h2 id="分割的目标"><a href="#分割的目标" class="headerlink" title="分割的目标"></a>分割的目标</h2><ul><li><p>将相似的像素分为一组：是自底向上、无监督的过程，即不知道如何分，只根据像素的相似性分割</p></li><li><p>分割为“物体”，比如人和背景分开</p></li><li><p>诚然，终极目标是不断要分割出单个物体，还要从整体出发，理解某个个体组成的整体的内容。</p></li></ul><p>比如下图，计算机可能只能分割出局部的特征，但对人类而言，还能观察到这些局部特征组成的整体特征。</p><p><img src="https://s2.loli.net/2022/10/16/gUktdrChoLQelMH.png" alt="image-20221016204727007" style="zoom:50%;" /></p><p>更准确的说：</p><ul><li><p>语义分割：只分割出目标</p></li><li><p>实例分割：不仅分割出目标，还需指出一类目标中谁是谁</p></li></ul><h2 id="K-Means-聚类分割"><a href="#K-Means-聚类分割" class="headerlink" title="K-Means 聚类分割"></a>K-Means 聚类分割</h2><ul><li>相似像素聚类：K-Means 聚类，比如基于灰度或者颜色，以彩色分割结果为例，图中相同颜色表示同类，这便是<strong>语义分割</strong>；但这种分割没法知道图中的两个辣椒是不一样的，而要指出这两个辣椒是不同的，就是<strong>实例分割</strong>。</li></ul><p><img src="https://s2.loli.net/2022/10/16/gTDG2kPiwKvoYhf.png" alt="image-20221016210153935"></p><p>为了达到实例分割的目的，还需要额外的约束，观察不难发现，两个辣椒的位置明显不同，于是我们在 RGB 的基础上增加 位置坐标 X Y，便可初步进行分割。但问题是，如下图红圈所示，都是背景，但由于位置不同导致分成了不同的类。</p><p><img src="https://s2.loli.net/2022/10/16/X3tFydZLNKGO86h.png" alt="image-20221016210838314" style="zoom: 67%;" /></p><ul><li><p>K-Means 聚类分割优缺点</p><ul><li><p>简单、局部收敛</p></li><li><p>需要指定参数 K（即分为几类）</p></li><li><p>对初值、外点敏感</p></li><li><p>只适用于“球形”聚类</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/10/16/6JtIyS4cVXgdK9l.png" alt="image-20221016211500089" style="zoom:67%;" /></p><h2 id="Mean-Shift-聚类分割"><a href="#Mean-Shift-聚类分割" class="headerlink" title="Mean Shift 聚类分割"></a>Mean Shift 聚类分割</h2><p>均值漂移算法的思想是在特征空间中寻找密度的局部最大值</p><p>主要过程是：随机选取一个 ROI，计算该 ROI 的重心，然后将该 ROI 向重心偏移，不断重复，最终找到密度的最大值</p><p><img src="https://s2.loli.net/2022/10/16/FriubIXvqnB8gZh.gif" style="zoom: 33%;" /></p><p>不论从哪个方向出发，最终都会导向密度最大的地方</p><p><img src="https://s2.loli.net/2022/10/16/CsBdXpuyhazO8wv.png" alt="image-20221016214908858"></p><p>具体思路如下：</p><ul><li><p>给定特征，如颜色、梯度、纹理等</p></li><li><p>初始化特征点的窗口</p></li><li><p>进行均值漂移直至收敛</p></li><li><p>将具有相同峰值的（密度最大，三维角度看如下图）窗口合并为一类</p></li></ul><p><img src="https://s2.loli.net/2022/10/16/wmh4BMKRyJ9Dtjb.png" alt="image-20221016215635403" style="zoom:50%;" /></p><p>优缺点分析</p><ul><li><p>优点</p><ul><li><p>无需假设是球形聚类（不同于 K-Means)</p></li><li><p>只需指定一个参数：窗宽</p></li><li>可找到不同的多个类别</li><li>对外点鲁棒</li></ul></li><li><p>缺点</p><ul><li>分割结果依赖于窗宽大小（太小容易局部收敛，导致过分割，太大则欠分割）</li><li>计算量大（基本上每个像素都要计算，因为要计算重心）</li><li>高维度下不适用</li></ul></li></ul><h2 id="图割法"><a href="#图割法" class="headerlink" title="图割法"></a>图割法</h2><h3 id="图割思想"><a href="#图割思想" class="headerlink" title="图割思想"></a>图割思想</h3><ul><li>每个像素作为节点</li><li>每对像素之间的连线作为边，边由两个节点的相似度的权值决定（也即边决定两个像素是否相似）</li></ul><p><img src="https://s2.loli.net/2022/10/16/o54ALN7KiJxuIrd.png" alt="image-20221016221846274" style="zoom:67%;" /></p><p>​    而分割的过程就是找到一种切割的方法切开图（断开边），要求断开的边的权重最小（也即最不相似的删掉）</p><p><img src="https://s2.loli.net/2022/10/16/l2JBfH4rsbAYWpQ.png" alt="image-20221016222544876" style="zoom:50%;" /></p><p>既然图割依赖于相似性，那么该如何衡量相似性呢？</p><p>假设每个像素可以用一个特征向量 $x$ 表示（可以是 rgb, x,y），再定义适合的距离函数（如 L2 距离）；然后可借助广义高斯核将两个特征向量之间的距离转为相似性度量：</p><script type="math/tex; mode=display">exp(-\frac{1}{2\sigma^2} \text{dist}(x_i,x_j)^2)</script><p>这样，相似性就由 $\sigma$ 决定，其值越小，表明距离越近的点越相似（即距离我比较小的和我同类）；其值越大，表明即使距离很大，也有可能和我同类。下图中的右下三张图可看作是<strong>邻接矩阵</strong>的示意，邻接矩阵行和列的角点表示对应像素的相似性，不难发现，该矩阵是一个对称矩阵，因为像素 1-2 和像素 2-1 的相似度是一样的。</p><p><img src="https://s2.loli.net/2022/10/16/o8ptPHjVUNka3cI.png" alt="image-20221016223934798" style="zoom:50%;" /></p><p>据此我们可知图割即：</p><ul><li><p>去除一些边，使得图断开连接</p></li><li><p>图割的代价：去除边的权重之和</p></li><li><p>通过图割可以完成分割</p></li></ul><p>如何得到一个“好”的图割结果？</p><h3 id="图割实现"><a href="#图割实现" class="headerlink" title="图割实现"></a>图割实现</h3><p>如之前所说，我们需要找到使得切掉边的所有的权重之和最小的情况，即最小割情形（这里涉及图论知识，菜鸡未深入接触）</p><center><figure>    <img src="https://s2.loli.net/2022/10/18/oKcUf8A1NCPTRea.png" style="zoom:34%"/>    <img src="https://s2.loli.net/2022/10/18/jNHrTzPFkgBiMnl.png" style="zoom:35%"/>    </figure></center> <p>但这种图割的方法存在的问题是：对于一些孤立的元素，容易形成很多独立的小区域，这是因为独立的点与其他的点连接边只有一个，自然权重最小</p><p><img src="https://s2.loli.net/2022/10/18/6kuVM3lGBrxbIw7.png" alt="image-20221018213711452" style="zoom:67%;" /></p><p>为了避免上述情况，也即我们希望 AB 中的元素更多一点，而不仅仅是单个元素，因而在实际中我们使用的是归一化的图割，其代价函数为：</p><script type="math/tex; mode=display">\frac{\text{w}(A,B)}{\text{w}(A,V)} + \frac{\text{w}(A,B)}{\text{w}(B,V)}</script><p>其中，$\text{w}(A,B)$ 是 $A$ 和 $B$ 之间所有边的权重之和，$\text{w}(A,V)$ 同理。</p><p>可以这么理解上述公式：假设 A 只有一个元素，即上图的情况，此时上式中的 $\text{w}(A,V)$ 就会很小（即 A 与其他边连接的很少），故 $\frac{\text{w}(A,B)}{\text{w}(A,V)}$ 就会很大，这样整体的权重就大了，自然不会选择分割，就不会出现上图单元素分割的情况。</p><p>上式经过一系列推导（<em>详见<a href="https://people.eecs.berkeley.edu/~malik/papers/SM-ncut.pdf">J. Shi and J. Malik. Normalized cuts and image segmentation. PAMI 2000</a></em>），最终可得到下式：</p><script type="math/tex; mode=display">\frac{y^T(D-W)y}{y^TDy}</script><p>式中：$W$ 是图的邻接矩阵，$D(i,i)=\Sigma_j(i,j)$，是一个对角矩阵，其元素是同一行元素的和。</p><p>至此，问题转为求解使得上式最小时的 $y$ 向量，该向量是元素不是 0 和 1，元素属于这个类就是 1，否则就是 0,（即归一化的图割只区分为两类）。</p><p>上式的求解采用的是<a href="https://zhuanlan.zhihu.com/p/296445326">拉格朗日法</a>，转换为求解：$ (D − W)y = λDy$，该问题的解 $y$ 是次最小特征值对应的特征向量。</p><p>求解出 $y$ 后，可能会发现该向量并不是 0 或 1，而是带有小数，为此可设置阈值，归一化为 0 和 1（类似二值化）。</p><p>归一化的图割只能分为两类，如何实现多类分割呢？有两种方法：</p><ul><li><p>在现有分割的基础上迭代</p></li><li><p>现有分割的基础上使用 K-Means</p></li></ul><p>值得注意的是，前述中对图像进行描述时使用了 rgb,x,y 的形式，但对于纹理特征难以用其描述时，可采用纹理一节中提到的滤波器组。</p><h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><ul><li><p>适用于众多不同的特征，比如选择不同的描述形式、不同的距离计算方式</p></li><li><p>计算耗时耗内存（所有像素参与）</p></li><li><p>倾向于均分为两类</p></li></ul><h1 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h1><p><img src="https://s2.loli.net/2022/10/09/mjlLvfGA2aXcKTM.png" alt="image-20221009202858533" style="zoom:80%;" /></p><h2 id="低照度图像增强算法-Retinex"><a href="#低照度图像增强算法-Retinex" class="headerlink" title="低照度图像增强算法-Retinex"></a>低照度图像增强算法-Retinex</h2><p>Retinex 理论模型</p><p>该算法的理论基础是光的三色理论和颜色恒常性</p><p>物体的颜色是由物体对长波（红）、中波（绿）、短波（蓝）的反射能力决定的，而不是由反射强度的绝对值决定的。此外，物体的颜色不受光照不均匀性的影响，具有一致性，也就是颜色恒常性。</p><p>不同于传统的线性、非线性图像增强方式只能增强某一类的特征，Retinex 可以在动态范围压缩、边缘增强、颜色恒常三个方面达到平横，可对各种不同类型的图像进行自适应增强。</p><p><img src="https://s2.loli.net/2022/10/09/usZyHrLzKOolSQg.png" alt="clip_image002[4]"></p><p>Retinex 理论的基本假设是：原始图像 $S$ 是由光照图像 (照度图像) $L$、反射图像 $R$ 组成，前者是物体的入射分量的信息，表示为 $L(x,y)$，后者是物体的反射部分，表示为 $R(x,y)$，所以图像 $S$ 可表示为：</p><script type="math/tex; mode=display">S(x,y)=R(x,y)L(x,y)</script><p>Retinex 增强的目的就是从原始图像 $S$ 中估计出 $L$，从而分解出 $R$，消除光照不均的影响，以改善图像的视觉效果。由于人眼感受亮度的过程与对数形式的变换相似，所以将上式转到对数域，这样做的一个好处是将复杂的乘法转为了加法：</p><script type="math/tex; mode=display">\begin{align}logS & = log(RL) \notag \\    & = logR+logL    \notag\end{align}</script><p>可见，如若估计得到 $L$，就可求得 $R$。</p><p>关键是如何得到 $L$ 呢？该值显然不能直接求得，那就只能近似。Retinex 的提出者认为，$L$ 可由<font color = red>原始图像和高斯核卷积</font>得到，即：</p><script type="math/tex; mode=display">logR=logS-logS * G</script><p>$G$ 即为高斯卷积核。</p><p>一般还需对 $R$ 量化映射到 $[0,255]$ 上，这里一般不会直接通过指数映射从 $logR$ 得到 $R$，一般取线性映射，方法是计算 $logR$ 的最大值 $Max$ 和 最小值 $Min$，然后对每一个 $Value$ 进行线性量化：</p><script type="math/tex; mode=display">R(x,y)=\frac{Value-min}{Max-min}*255</script><p>多尺度的原理类似，只是采用不同的尺度（由 $\sigma$ 控制尺度空间），生成不同的高斯核与图像进行卷积，然后对这个尺度按权重计算，为了兼顾长中短三种波（即 RGB），通常取等权重（即 $\omega_1=\omega_2=\omega_3=1/3$），注意权重和为 1。</p><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p>直方图均衡化是图像增强的一种方式，其结果是让过亮或过暗的图像灰度分布更加均匀，其主要是通过累积分布函数进行计算，提高图像的对比度。</p><h1 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h1><h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><p>圆锥模型空间</p><p>H：色相：具体是哪种颜色（角度表示）</p><p>S：饱和度：颜色的深浅（0~1）</p><p>V：亮度：颜色的明暗（0~1）</p><p><img src="https://s2.loli.net/2022/10/09/5psejXIfP1SmgZR.png" alt="img" style="zoom: 33%;" /></p><h2 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h2><p>YUV是通过亮度-色差来描述颜色的颜色空间。</p><p>亮度信号经常被称作Y，色度信号是由两个互相独立的信号组成。视颜色系统和格式不同，两种色度信号经常被称作UV或PbPr或CbCr。这些都是由不同的编码格式所产生的，但是实际上，他们的概念基本相同。在DVD中，色度信号被存储成Cb和Cr（C代表颜色，b代表蓝色，r代表红色）。</p><h1 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h1><h2 id="空间相关与卷积"><a href="#空间相关与卷积" class="headerlink" title="空间相关与卷积"></a>空间相关与卷积</h2><ul><li>相关：图像上移动核的中心，求每个位置的乘积之和<ul><li>只满足分配律</li></ul></li><li><p>卷积：把相关运算的<code>核旋转180°</code></p><ul><li>线性：F(f1+f2) = F(f1)+F(f2)</li><li>平移不变形：F(S(f)) = S(F(f))</li><li>满足线性平移不变性的操作均可定义为卷积</li><li>满足交换律、结合律、分配律</li></ul></li><li><p>卷积时边缘的处理：边界填充</p><ul><li>卷积核的特性导致卷积后的图像和原图不一样大</li><li>零填充</li><li>复制边缘</li><li>镜像边缘</li></ul></li><li><p>可分离核</p><ul><li>可分离核：能够表示为两个向量外积的矩阵</li><li>$m \times n$ 的核 $\text{w}$ 可分离为：$\text{w} = v<em>{m \times 1}w</em>{n \times 1}^T$</li><li>$m \times m$ 的核  $\text{w}$ 可分离为：$\text{w} = v<em>{m \times 1}v</em>{m \times 1}^T$</li><li>优势：减少计算量，大核分离为小核计算</li><li>判断是否可分离：矩阵的秩为 1（矩阵论：一列向量与一行向量的乘积的矩阵，秩为 1）</li></ul></li><li>空间滤波器的构建<ul><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点云+PCL学习笔记</title>
      <link href="/point_cloud_pcl/"/>
      <url>/point_cloud_pcl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客</p><p>（注：部分图片未上传至图床，抽空补充）</p><span id="more"></span><h2 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h2><ul><li><p>分布在 N 维空间中的离散点集</p></li><li><p>是对物体表面信息的离散采样</p></li></ul><h2 id="点云库"><a href="#点云库" class="headerlink" title="点云库"></a>点云库</h2><ul><li>三维处理算法：滤波、特征估计、表面重建等</li></ul><h2 id="PointT-类型"><a href="#PointT-类型" class="headerlink" title="PointT 类型"></a>PointT 类型</h2><h3 id="PointXYZ"><a href="#PointXYZ" class="headerlink" title="PointXYZ"></a>PointXYZ</h3><ul><li><p>包含 x y z 坐标的点数据类型</p></li><li><p>成员变量 float x, y, z</p></li><li><p>points[i].x 访问</p></li><li><p>多余的一个变量用来填充位置以满足存储对齐（?）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">float</span> data[<span class="number">4</span>];</span><br><span class="line">   <span class="keyword">struct</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">float</span> x;</span><br><span class="line">      <span class="type">float</span> y;</span><br><span class="line">      <span class="type">float</span> z;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Point-XYZI"><a href="#Point-XYZI" class="headerlink" title="Point XYZI"></a>Point XYZI</h3><ul><li>包含 x y z 坐标及 intensity</li></ul><h3 id="PointXYZRGBA"><a href="#PointXYZRGBA" class="headerlink" title="PointXYZRGBA"></a>PointXYZRGBA</h3><ul><li>rgba 单独作为一个整型变量（unit32_t）</li></ul><h2 id="PCD-文件"><a href="#PCD-文件" class="headerlink" title="PCD 文件"></a>PCD 文件</h2><ul><li>包含文件头：声明存储点云数据的特性，必须用 ASCII 编码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># .PCD v<span class="number">.7</span> - Point Cloud Data file format</span><br><span class="line">VERSION <span class="number">.7</span>                     # 指定PCD文件版本</span><br><span class="line">FIELDS x y z rgb               # 指定每个点可以有的每一个维度或字段的名字</span><br><span class="line">SIZE <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span>                   # 用字节数指定 FIELDS 中每一个维度的大小</span><br><span class="line">TYPE F F F F                   # 用一个字符指定 FILEDS 中每一个维度的类型</span><br><span class="line">COUNT <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>                  # 指定每一个维度包含的元素数目</span><br><span class="line">WIDTH <span class="number">213</span>                      # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目）  列</span><br><span class="line">HEIGHT <span class="number">1</span>                       # 用点的数量表示点云数据集的高度；同 WIDTH                                      行 </span><br><span class="line">VIEWPOINT <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>        # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）</span><br><span class="line">POINTS <span class="number">213</span>                     # 数据集中点的总数 </span><br><span class="line">DATA ascii                     # 存储点云数据的数据类型：ASCII 或 二进制</span><br><span class="line"><span class="number">0.93773</span> <span class="number">0.33763</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.90805</span> <span class="number">0.35641</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.81915</span> <span class="number">0.32</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.97192</span> <span class="number">0.278</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br></pre></td></tr></table></figure><ul><li>DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开</li><li>DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法</li></ul><h2 id="K-d-tree"><a href="#K-d-tree" class="headerlink" title="K-d tree"></a>K-d tree</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><center class="half">    <img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/KdTree.png" alt="KdTree"  style="zoom:20%;" />    <img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/Kdtree_2d.png" alt="KdTree"  style="zoom:30%;" /></center><p>按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。</p><p>在 k-d tree 中查找距离查询点 $\overline x$ 最近点的，意味着遍历整个树，找到包含 $\overline x$ 的子节点。</p><p>实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。</p><h3 id="两种查询方式"><a href="#两种查询方式" class="headerlink" title="两种查询方式"></a>两种查询方式</h3><p>（详见博士论文 P40）</p><p>PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型：</p><ul><li>==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点）</li><li>==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点</li></ul><p>r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。</p><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144959.jpg" alt="r 搜索实例"></p><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144728.png" alt="K-d tree最近邻搜索"></p><p>上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\vec{q}$ ，但以 $ \vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\vec{q}’$ 。</p><p>另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 <code>正确尺度因子</code> 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。</p><p>如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。</p><center class="half">    <img src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface normals.jpg" alt="估计表面法线"  style="zoom:25%;" />    <img src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface curvatures.jpg" alt="估计表面曲率"  style="zoom:27%;" /></center><p>所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。</p><h2 id="Octree-八叉树"><a href="#Octree-八叉树" class="headerlink" title="Octree(八叉树)"></a>Octree(八叉树)</h2><ul><li>一个根节点包含八个子节点</li><li>若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归</li><li>除近邻搜索外，可用于碰撞检测</li></ul><p><img src="F:\AFIGHT\笔记\PCL\assets\Octree.png" alt="八叉树" style="zoom: 33%;" /></p><h2 id="点云连接"><a href="#点云连接" class="headerlink" title="点云连接"></a>点云连接</h2><h3 id="点连接"><a href="#点连接" class="headerlink" title="点连接"></a>点连接</h3><ul><li>需确保类型和维度相等</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloud_c = cloud_a;</span><br><span class="line">cloud_c += cloud_b;</span><br></pre></td></tr></table></figure><h3 id="字段连接"><a href="#字段连接" class="headerlink" title="字段连接"></a>字段连接</h3><ul><li>需确保数目相等</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="built_in">concatenateFields</span>(cloud_a, n_cloud_b, p_n_cloud_c);</span><br></pre></td></tr></table></figure><h2 id="点云滤波"><a href="#点云滤波" class="headerlink" title="点云滤波"></a>点云滤波</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>噪声点：设备精度、操作者经验、环境因素等</li><li>离群点：外界干扰如障碍物等，产生离主体点云较远的离散点</li></ul><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><ul><li>通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果</li><li>有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征</li></ul><h3 id="直通滤波器"><a href="#直通滤波器" class="headerlink" title="直通滤波器"></a>直通滤波器</h3><ul><li><p>去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt; pass; <span class="comment">// 创建直通滤波器对象</span></span><br><span class="line">pass.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">// 输入</span></span><br><span class="line">pass.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">// 设置滤波字段，此处为 z 轴</span></span><br><span class="line">pass.<span class="built_in">setFilterLimits</span>(<span class="number">0.0</span>, <span class="number">200.0</span>);<span class="comment">// 设置滤波范围，超出则滤除</span></span><br><span class="line">pass.<span class="built_in">setFilterLimitsNegative</span> (<span class="literal">true</span>);<span class="comment">// 默认为 false，设为 ture 则返回被滤除点</span></span><br><span class="line">pass.<span class="built_in">filter</span>(*cloud_filtered);<span class="comment">// 执行滤波，并将滤波结果存储在 cloud_filtered</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="VoxelGrid（体素化网格）滤波器"><a href="#VoxelGrid（体素化网格）滤波器" class="headerlink" title="VoxelGrid（体素化网格）滤波器"></a>VoxelGrid（体素化网格）滤波器</h3><ul><li><p>实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变</p></li><li><p>VoxelGrid</p><ul><li>三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体==</li><li>通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示==</li><li>对所有体素处理后得到过滤后的点云</li><li>缺点：<code>慢</code>，比体素中心逼近法更慢</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;<span class="comment">// 创建体素栅格滤波对象</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);   <span class="comment">// 读入点云设置为输入</span></span><br><span class="line">sor.<span class="built_in">setLeafSize</span>(<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);    <span class="comment">// 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud_filtered);   <span class="comment">// 执行滤波并存储到 cloud_filtered</span></span><br></pre></td></tr></table></figure><ul><li>滤波结果</li></ul><p><center class="half"></p><pre><code>&lt;img src=&quot;F:\AFIGHT\笔记\PCL\assets\滤波前.png&quot; alt=&quot;滤波前&quot;  style=&quot;zoom:50%;&quot; /&gt;&lt;img src=&quot;F:\AFIGHT\笔记\PCL\assets\滤波后.png&quot; alt=&quot;滤波后&quot;  style=&quot;zoom:50%;&quot; /&gt;</code></pre><p>&lt;/center&gt;</p><h3 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h3></li></ul><p>（详见博士论文 P40）</p><ul><li><p>用于去除离群点</p></li><li><p>基于对近邻点集 $P^k$ 的统计分析</p><ul><li>计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\overline d$ </li><li>计算点云 $P$ 在平均距离上的分布，并估计平均值 $\mu_k$ 及标准差 $\sigma_k$ </li></ul></li><li><p>对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离</p></li></ul><p>去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。</p><p><strong>假设第一次扫描 $P<em>i$ 和随后的 $P</em>{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \in P<em>i$，搜索其对应的近邻点 $p \in P</em>{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;<span class="comment">// 创建统计滤波对象</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);  <span class="comment">// 设置输入点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);    <span class="comment">// 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">// 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud_filtered);  <span class="comment">// 执行并存储滤波结果</span></span><br><span class="line"></span><br><span class="line">sor.<span class="built_in">setNegative</span>(<span class="literal">true</span>);  <span class="comment">// 获取离群点（此值默认为 false）</span></span><br></pre></td></tr></table></figure><ul><li>滤波结果</li></ul><center class="half">    <img src="F:\AFIGHT\笔记\PCL\assets\统计滤波结果.png" alt="统计滤波结果"  style="zoom:50%;" />    <img src="F:\AFIGHT\笔记\PCL\assets\统计滤波离群点.png" alt="统计滤波离群点"  style="zoom:50%;" /></center><h3 id="参数化模型投影点云"><a href="#参数化模型投影点云" class="headerlink" title="参数化模型投影点云"></a>参数化模型投影点云</h3><ul><li>点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0</li><li><p>PCL 中有特意存储常见模型系数的数据结构</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a set of planar coefficients with X=Y=0,Z=1  </span></span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients())</span></span>;<span class="comment">// 创建 模型系数 对象</span></span><br><span class="line">coefficients-&gt;values.<span class="built_in">resize</span>(<span class="number">4</span>);<span class="comment">// 参数个数置为 4</span></span><br><span class="line">coefficients-&gt;values[<span class="number">0</span>] = coefficients-&gt;values[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Y</span></span><br><span class="line">coefficients-&gt;values[<span class="number">2</span>] = <span class="number">1.0</span>;</span><br><span class="line">coefficients-&gt;values[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the filtering object</span></span><br><span class="line">pcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj;<span class="comment">// 设置投影滤波对象</span></span><br><span class="line">proj.<span class="built_in">setModelType</span>(pcl::SACMODEL_PLANE);<span class="comment">// 设置对象对应的投影模型类型，此处为平面模型</span></span><br><span class="line">proj.<span class="built_in">setInputCloud</span>(cloud);   <span class="comment">// 设置输入</span></span><br><span class="line">proj.<span class="built_in">setModelCoefficients</span>(coefficients);<span class="comment">// 设置模型系数为前述定义系数</span></span><br><span class="line">proj.<span class="built_in">filter</span>(*cloud_projected);   <span class="comment">// 执行并保存</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="从一个点云中提取一个子集"><a href="#从一个点云中提取一个子集" class="headerlink" title="从一个点云中提取一个子集"></a>从一个点云中提取一个子集</h3><ul><li>基于 ExtractIndices 滤波器（基于分割算法）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; <span class="comment">// 创建分割对象</span></span><br><span class="line">extract.<span class="built_in">setInputCloud</span>(cloud_filtered);     <span class="comment">// 设置输入点云 </span></span><br><span class="line">extract.<span class="built_in">setIndices</span>(inliers);      <span class="comment">// 设置分割后的内点为需要提取的点击（分割部分略）</span></span><br><span class="line">extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);      <span class="comment">// 指定提取内点</span></span><br><span class="line">extract.<span class="built_in">filter</span>(*cloud_p);     <span class="comment">// 执行并存储</span></span><br></pre></td></tr></table></figure><h3 id="RadiusOutlierRemoval-ConditionalRemoval-移除离群点"><a href="#RadiusOutlierRemoval-ConditionalRemoval-移除离群点" class="headerlink" title="RadiusOutlierRemoval / ConditionalRemoval  移除离群点"></a>RadiusOutlierRemoval / ConditionalRemoval  移除离群点</h3><h4 id="RadiusOutlierRemoval"><a href="#RadiusOutlierRemoval" class="headerlink" title="RadiusOutlierRemoval"></a>RadiusOutlierRemoval</h4><ul><li>删除输入点云一定范围内没有达到足够多近邻的所有数据点</li><li>人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。</li></ul><p><img src="F:\AFIGHT\笔记\PCL\assets\radius_outlier.png" alt="RadiusOutlierRemoval "></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem;<span class="comment">// 创建半径滤波对象</span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">outrem.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">// 设置输入点云</span></span><br><span class="line">outrem.<span class="built_in">setRadiusSearch</span>(<span class="number">0.8</span>);<span class="comment">// 设置搜索半径为 0.8</span></span><br><span class="line">outrem.<span class="built_in">setMinNeighborsInRadius</span>(<span class="number">2</span>);<span class="comment">// 设置所需近邻点数为 2</span></span><br><span class="line">outrem.<span class="built_in">setKeepOrganized</span>(<span class="literal">true</span>);   <span class="comment">// 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">outrem.<span class="built_in">filter</span>(*cloud_filtered);<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure><h4 id="ConditionalRemoval"><a href="#ConditionalRemoval" class="headerlink" title="ConditionalRemoval"></a>ConditionalRemoval</h4><ul><li>如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">range_cond</span><span class="params">(<span class="keyword">new</span> pcl::ConditionAnd&lt;pcl::PointXYZ&gt;())</span></span>;<span class="comment">// 创建条件定义对象</span></span><br><span class="line">range_cond-&gt;<span class="built_in">addComparison</span>(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::<span class="built_in">ConstPtr</span>(<span class="keyword">new</span></span><br><span class="line">pcl::<span class="built_in">FieldComparison</span>&lt;pcl::PointXYZ&gt;(<span class="string">&quot;z&quot;</span>, pcl::ComparisonOps::GT, <span class="number">0.0</span>)));  <span class="comment">// 添加比较算子：z 字段上大于 0.0 </span></span><br><span class="line">range_cond-&gt;<span class="built_in">addComparison</span>(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::<span class="built_in">ConstPtr</span>(<span class="keyword">new</span></span><br><span class="line">pcl::<span class="built_in">FieldComparison</span>&lt;pcl::PointXYZ&gt;(<span class="string">&quot;z&quot;</span>, pcl::ComparisonOps::LT, <span class="number">0.8</span>)));  <span class="comment">// 添加比较算子：z 字段上小于 0.8 </span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">pcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem; <span class="comment">// 初始化条件滤波</span></span><br><span class="line">condrem.<span class="built_in">setCondition</span>(range_cond);<span class="comment">// 设置条件为指定的比较算子</span></span><br><span class="line">condrem.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">// 设置输入点云</span></span><br><span class="line">condrem.<span class="built_in">setKeepOrganized</span>(<span class="literal">true</span>);<span class="comment">// 设置将被滤除点保留但置为 NaN</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">condrem.<span class="built_in">filter</span>(*cloud_filtered);<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure><h3 id="CropHull-任意多边形内部点云提取"><a href="#CropHull-任意多边形内部点云提取" class="headerlink" title="CropHull 任意多边形内部点云提取"></a>CropHull 任意多边形内部点云提取</h3><ul><li>CropHull 滤波器得到 2D 封闭多边形内 / 外的点云</li></ul><h2 id="深度图像（Range-Depth-Images）"><a href="#深度图像（Range-Depth-Images）" class="headerlink" title="深度图像（Range/Depth Images）"></a>深度图像（Range/Depth Images）</h2><ul><li>将图像采集器到场景中各点的距离（深度）值作为像素值的图像（<strong>距离是相机到场景点的垂直距离，不是连线距离</strong>）</li><li>直接反映景物可见表面的几何状态</li><li>物体的三维表示形式，可通过<code>立体相机或 TOF 相机</code>获取</li><li>深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据</li><li>英文中常见的等价表述：<code>range image</code>，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles</li></ul><p>注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息</p><h3 id="从点云创建深度图像"><a href="#从点云创建深度图像" class="headerlink" title="从点云创建深度图像"></a>从点云创建深度图像</h3><ul><li><p>主要函数为 createFromPointCloud，声明 9 个参数填充即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> pcl::RangeImage::<span class="built_in">createFromPointCloud</span>(<span class="type">const</span> PointCloudType &amp; point_cloud,</span><br><span class="line"><span class="type">float</span> angular_resolution = pcl::<span class="built_in">deg2rad</span> (<span class="number">0.5f</span>),</span><br><span class="line"><span class="type">float</span> max_angle_width = pcl::<span class="built_in">deg2rad</span> (<span class="number">360.0f</span>),</span><br><span class="line"><span class="type">float</span> max_angle_height = pcl::<span class="built_in">deg2rad</span> (<span class="number">180.0f</span>),</span><br><span class="line"><span class="type">const</span> Eigen::Affine3f &amp; sensor_pose = Eigen::Affine3f::<span class="built_in">Identity</span> (),</span><br><span class="line">RangeImage::CoordinateFrame coordinate_frame = CAMERA_FRAME,</span><br><span class="line"><span class="type">float</span> noise_level = <span class="number">0.0f</span>,</span><br><span class="line"><span class="type">float</span> min_range = <span class="number">0.0f</span>,</span><br><span class="line"><span class="type">int</span> border_size = <span class="number">0</span> </span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Create the depth image from a point cloud.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameter EX:</span></span><br><span class="line"><span class="comment">point_cloudthe input point cloud</span></span><br><span class="line"><span class="comment">angular_resolutionthe angular difference (in radians) between the individual pixels in the image</span></span><br><span class="line"><span class="comment">max_angle_widthan angle (in radians) defining the horizontal bounds of the sensor</span></span><br><span class="line"><span class="comment">max_angle_heightan angle (in radians) defining the vertical bounds of the sensor</span></span><br><span class="line"><span class="comment">sensor_posean affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )</span></span><br><span class="line"><span class="comment">coordinate_framethe coordinate frame (defaults to CAMERA_FRAME)</span></span><br><span class="line"><span class="comment">noise_level- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.</span></span><br><span class="line"><span class="comment">min_rangethe minimum visible range (defaults to 0)</span></span><br><span class="line"><span class="comment">border_sizethe border size (defaults to 0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="从深度图像提取边界"><a href="#从深度图像提取边界" class="headerlink" title="从深度图像提取边界"></a>从深度图像提取边界</h3><ul><li>边界：前景跨越到背景的位置</li><li>物体边界（黑）、阴影边界（绿）、Veil 点集（红）</li></ul><p><img src="F:\AFIGHT\笔记\PCL\assets\range_image_border_points.png" alt="边界点集分类"></p><ul><li>若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li><p>兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集</p></li><li><p>数量比原始点云或图像的数据量小很多</p></li><li><p>组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性</p></li><li><p>利于加快后续的处理速度</p></li></ul><h3 id="关键概念及算法"><a href="#关键概念及算法" class="headerlink" title="关键概念及算法"></a>关键概念及算法</h3><h4 id="NARF-关键点"><a href="#NARF-关键点" class="headerlink" title="NARF 关键点"></a>NARF 关键点</h4><p>*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608.</p><ul><li>从深度图像识别物体</li><li>步骤<ul><li>遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测；</li><li>遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向；</li><li>根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定；</li><li>对兴趣值进行平滑过滤；</li><li>进行无最大值压缩找到最终的关键点，即为 NARF 关键点。</li></ul></li><li>简化步骤*<ul><li>给定深度图像，进行边缘提取</li><li>表面变化基于边界和曲率原则”评分“</li><li>设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多</li></ul></li></ul><h4 id="Harris关键点"><a href="#Harris关键点" class="headerlink" title="Harris关键点"></a>Harris关键点</h4><ul><li>通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点</li><li>若 Harris 矩阵特征的两个特征值都很大，则为关键点</li><li>对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测</li><li>3D Harris 关键点检测使用的是<code>点云表面法向量的信息</code>（2D 使用的是图像梯度）</li></ul><h4 id="PCL-中的-keypoints"><a href="#PCL-中的-keypoints" class="headerlink" title="PCL 中的 keypoints"></a>PCL 中的 keypoints</h4><h5 id="深度图像提取-NARF-关键点"><a href="#深度图像提取-NARF-关键点" class="headerlink" title="深度图像提取 NARF 关键点"></a>深度图像提取 NARF 关键点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RangeImageBorderExtractor range_image_border_extractor;<span class="comment">// 创建对象，用于边缘提取</span></span><br><span class="line"><span class="function">pcl::NarfKeypoint <span class="title">narf_keypoint_detector</span><span class="params">(&amp;range_image_border_extractor)</span></span>; <span class="comment">// 创建对象，传入上述提取出的深度图像边缘</span></span><br><span class="line">narf_keypoint_detector.<span class="built_in">setRangeImage</span>(&amp;range_image);   <span class="comment">// 传入深度图像</span></span><br><span class="line">narf_keypoint_detector.<span class="built_in">getParameters</span>().support_size = support_size;    <span class="comment">// 设置支持范围(搜索空间球体的半径，邻域范围)</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;</span></span><br><span class="line">pcl::PointCloud&lt;<span class="type">int</span>&gt; keypoint_indices;<span class="comment">// 创建点云对象，存储检测到的点云</span></span><br><span class="line">narf_keypoint_detector.<span class="built_in">compute</span>(keypoint_indices);  <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure><h5 id="SIFT-关键点提取"><a href="#SIFT-关键点提取" class="headerlink" title="SIFT 关键点提取"></a>SIFT 关键点提取</h5><p><a href="https://blog.csdn.net/dcrmg/article/details/52561656">参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_43653930/article/details/104651907?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-5&amp;spm=1001.2101.3001.4242">参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40293648/article/details/82836998">参考：SIFT（3）——-尺度空间极值检测_姗姗本人的博客-CSDN博客</a></p><p>注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。</p><p><img src="F:\AFIGHT\笔记\PCL\assets\sift算子-DOG尺度空间.png" alt="DOG尺度空间关键点确定"></p><p>​           ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向</p><p><img src="F:\AFIGHT\笔记\PCL\assets\DOG尺度空间关键点方向确定.png" alt="关键点方向确定"></p><p>​            ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 </p><p><img src="F:\AFIGHT\笔记\PCL\assets\DOG尺度空间关键点描述子.png" alt="关键点描述子" style="zoom:67%;" /></p><ul><li><p>尺度不变性</p></li><li><p>局部特征描述子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift;<span class="comment">// 创建sift关键点检测对象</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointWithScale&gt; result;  <span class="comment">// 存储查询结果</span></span><br><span class="line">sift.<span class="built_in">setInputCloud</span>(cloud_xyz); <span class="comment">// 设置输入点云</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">sift.<span class="built_in">setSearchMethod</span>(tree);<span class="comment">// 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象</span></span><br><span class="line"><span class="comment">// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快</span></span><br><span class="line">sift.<span class="built_in">setScales</span>(min_scale, n_octaves, n_scales_per_octave); <span class="comment">// 设置限制关键点检测的阈值</span></span><br><span class="line">sift.<span class="built_in">compute</span>(result);    <span class="comment">// 执行sift关键点检测，保存结果在result</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setScales 函数原型</span></span><br><span class="line"><span class="type">void</span> pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::<span class="built_in">setScales</span>(<span class="type">float</span> min_scale,</span><br><span class="line"><span class="type">int</span> nr_octaves,</span><br><span class="line"><span class="type">int</span> nr_scales_per_octave </span><br><span class="line">)</span><br><span class="line">   用于指定搜索关键点的尺度范围 </span><br><span class="line"><span class="comment">// Specify the range of scales over which to search for keypoints.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters</span></span><br><span class="line">      设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）</span><br><span class="line"><span class="comment">// min_scalethe standard deviation of the smallest scale in the scale space</span></span><br><span class="line">   高斯金字塔中组（octaves）的数目</span><br><span class="line"><span class="comment">// nr_octavesthe number of otaves (i.e. doublings of scale) to compute</span></span><br><span class="line">       每组计算的尺度数目</span><br><span class="line"><span class="comment">// nr_scales_per_octavethe number of scales to compute within each octave</span></span><br></pre></td></tr></table></figure><p><img src="F:\AFIGHT\笔记\PCL\assets\高斯金字塔sift算子关键点.png" alt="高斯金字塔sift算子关键点" style="zoom: 50%;" /></p></li></ul><h5 id="Harris-关键点提取"><a href="#Harris-关键点提取" class="headerlink" title="Harris 关键点提取"></a>Harris 关键点提取</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//harris_detector-&gt;setNonMaxSupression(true);</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">setRadius</span>(r_normal);<span class="comment">// 设置法向量估计的半径</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">setRadiusSearch</span>(r_keypoint);<span class="comment">// 设置关键点估计的近邻搜索半径</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">setInputCloud</span> (input_cloud);</span><br><span class="line"><span class="comment">//harris_detector-&gt;setNormals(normal_source);</span></span><br><span class="line"><span class="comment">//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">compute</span> (*Harris_keypoints);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Harris_keypoints的大小是&quot;</span>&lt;&lt;Harris_keypoints-&gt;<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">writer.<span class="built_in">write</span>&lt;pcl::PointXYZI&gt; (<span class="string">&quot;Harris_keypoints.pcd&quot;</span>,*Harris_keypoints,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="特征描述与提取"><a href="#特征描述与提取" class="headerlink" title="特征描述与提取"></a>特征描述与提取</h2><h3 id="特征描述"><a href="#特征描述" class="headerlink" title="特征描述"></a>特征描述</h3><ul><li>局部特征描述 + 全局特征描述</li></ul><h3 id="特征描述子"><a href="#特征描述子" class="headerlink" title="特征描述子"></a>特征描述子</h3><p>三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有<strong>形状描述子（shape descriptors）</strong>、<strong>几何特征（gometric features）</strong>、<strong>点特征表示（point feature representations）</strong>等。</p><h4 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文 P23，37）</p><p>给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为：</p><script type="math/tex; mode=display">||p_i^k-p_q||_x \leq d_m \tag{1.1}</script><p>式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见<a href="https://blog.csdn.net/skybirdhua1989/article/details/17584797">范数</a>）。</p><p>此外，$P^k$ 中近邻点的个数可被限制为给定值 k。</p><p>点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围：</p><script type="math/tex; mode=display">F(p_q,P^k)=\{x_1,x_2,···,x_n\}</script><p>式中，$x_i$ , $i \in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。</p><p>比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\Gamma$ 为描述这两点之间差异的<strong>相似性度量</strong>，$d$ 为<strong>距离度量</strong>，则有：</p><script type="math/tex; mode=display">\Gamma = d(F_1,F_2)</script><p>当 $d$ 趋向于某个最小值时，即 $d \to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。</p><p><em>个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。</em></p><p>通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。</p><p>理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣：</p><ul><li>刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有<strong>旋转平移不变性</strong></li><li>不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有<strong>抗密度干扰性</strong></li><li>噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有<strong>鲁棒性</strong></li></ul><p><em>也就是说，一个点特征表示满足上述条件才可以说是好的表示法</em></p><h4 id="邻域的概念"><a href="#邻域的概念" class="headerlink" title="邻域的概念"></a>邻域的概念</h4><p>确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方：</p><script type="math/tex; mode=display">||X||_2 = \sqrt{\sum_{i=1}^n x_i^2}</script><p><em>可用于度量两个向量间的差异</em>，如平方差和：</p><script type="math/tex; mode=display">SSD(x_1,x_2) = \sum_{i=1}^n(x_{1i}-x_{2i})^2</script><p>也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。</p><p>但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。</p><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><h4 id="输入点云的调用"><a href="#输入点云的调用" class="headerlink" title="输入点云的调用"></a>输入点云的调用</h4><ul><li><p>输入点云调用函数主要有：</p><ul><li>setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量</li><li>setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算</li><li><p>setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间</p></li><li><p>后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208）</p></li></ul><p><img src="F:\AFIGHT\笔记\PCL\assets\features_input_explained.png" alt="输入点云调用习惯">                </p><ul><li>经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。</li></ul></li></ul><h4 id="估计点云的表面法线"><a href="#估计点云的表面法线" class="headerlink" title="估计点云的表面法线"></a>估计点云的表面法线</h4><p>（详见博士论文 P45）</p><ul><li><p>描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线</p></li><li><p>一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②<code>直接从点云数据集中近似推断表面法线</code></p></li><li><p>对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中估计一点集对应的协方差矩阵</span></span><br><span class="line">Eigen::Matrix3f covariance_matrix;<span class="comment">// 定义每个表面小块的 3×3 协方差矩阵的存储对象</span></span><br><span class="line">Eigen::Vector4f xyz_controid;<span class="comment">// 定义一个表面小块的质心坐标16字节对其存储对象</span></span><br><span class="line"><span class="built_in">compute3DCentroid</span>(cloud, xyz_controid);<span class="comment">// 估计质心坐标</span></span><br><span class="line"><span class="built_in">computeCovarianceMatrix</span>(cloud, xyz_controid, covariance_matrix);<span class="comment">// 计算 3×3 协方差矩阵</span></span><br></pre></td></tr></table></figure></li></ul><p>一个平面可用一个点 $x$ 和 一个法向量 $\overline n$ 表示，则一个点 $p_i \in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \overline n$ 。 $x$ 和  $\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？）</p><p>设</p><script type="math/tex; mode=display">x = \overline p = \frac{1}{k}· \sum_{i=1}^{k}p_i</script><p>为 $P^k$ 的质心，而 $\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \in R^{3 \times 3}$ 的特征值和特征向量得到，其表达式如下：</p><script type="math/tex; mode=display">C = \frac{1}{k} \sum_{i=1}^{k} \xi_i · (p_i - \overline p)·(p_i - \overline p)^T , \ C· \overline v_i = \lambda_i· \overline v_j ,  \  j \in \{0,1,2\}</script><p>式中，$\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\lambda_j \in R$ ，特征向量 $\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \le \lambda_0 \le \lambda_1 \le \lambda_2$ ，则特征向量 $\overline v_0$ 对应的最小特征值 $\lambda_0$ 就是 $+ \overline n = {n_x,n_y,n_z}$ 或 $ - \overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\overline n$ 可由球坐标中的一对角 $(\phi,\theta)$ 表示如下：</p><script type="math/tex; mode=display">\phi = \arctan \frac{n_z}{n_y}, \ \theta =  \arctan\frac{\sqrt{(n_y^2+n_z^2)}}{n_x}</script><p>问题是，这种主成分分析法（PCA）对方向仍然是模糊的。</p><h4 id="表面曲率"><a href="#表面曲率" class="headerlink" title="表面曲率"></a>表面曲率</h4><p>（详见博士论文P48）</p><p>方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\lambda_0 = min(\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\overline n$ 的变化可使用下式估计：</p><script type="math/tex; mode=display">\sigma_p = \frac{\lambda_0}{\lambda_0+\lambda_1+\lambda_3}</script><p> 该最小特征值与特征值之和的比值 $\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。</p><p>source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998</p><h4 id="法线的定向问题"><a href="#法线的定向问题" class="headerlink" title="法线的定向问题"></a>法线的定向问题</h4><ul><li><p>没有数学方法可以解决法线的正负向问题</p></li><li><p>法线球体描述了点云中所有法线的方向</p></li><li><p>对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）</span></span><br><span class="line"><span class="built_in">flipNormalTowardsViewpoint</span>(<span class="type">const</span> PointCloud &amp; cloud,</span><br><span class="line"><span class="type">float</span> vp_x,</span><br><span class="line"><span class="type">float</span> vp_y,</span><br><span class="line"><span class="type">float</span> vp_z,</span><br><span class="line">Normals &amp; normals </span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><ul><li>但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \cdot n_j = 1$。</li></ul><h3 id="点特征直方图（PFH）"><a href="#点特征直方图（PFH）" class="headerlink" title="点特征直方图（PFH）"></a>点特征直方图（PFH）</h3><p>（详见博士论文P51和PCL书P213）</p><p>bin 可理解为分格的大小，就是直方图每一个柱子的宽度</p><h4 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h4><p>通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。</p><p>一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。</p><p>为形成新的特征空间，引入 <em>双环邻域</em>  的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \in P$ 有双环邻域的条件是：</p><script type="math/tex; mode=display">(\exists)r_1,r_2 \in R, \ r_1 <r_2,  \ \begin{cases} r_1  \Rightarrow P^{k_1} \\ r_2 \Rightarrow P^{k_2}\end{cases}, \ 0<k_1<k_2</script><p>两个半径 $r_1$ 和 $r_2$ 用于确定点 $p_i$ 的两个不同的特征表示层：第一层表示的是查询点处的法线，从邻域集 $p^{k_1}$ 的主成分分析中获得，第二层即为 PFH。</p><p>PFH 是基于 $P_{k_2} $ 中的点及其法线之间的关系的，即通过参数化查询点与邻域点之间的空间差异，形成一个多维直方图对点的 k 邻域几何属性进行描述。直方图所在的高维超空间为特征表示提供了一个可度量的信息空间，对点云对应曲面的 6 维姿态来说它具有不变性，并且在不同的采样密度或邻域的噪音等级下具有鲁棒性。简言之，<strong>它考虑估计法线方向之间所有的相互作用，来尽可能捕获采样表面的变化</strong>。故合成的超空间依赖于每个点表面法线估计的质量。（人话就是：PFH 结果的优劣，取决于法线估计的好坏，这也说明，计算 PFH 的第一步就是表面法线的估计）</p><p>为计算两点 $p<em>i$ 和 $p_j$ 之间的相对差以及它们的法线 $n_i$ 和 $n_j$，在其中一点上定义了一个固定的局部坐标系。为使坐标系被唯一定义，做如下规定： 令 $p</em>{ji} = p<em>j - p_i, \ p</em>{ij} = p_i - p_j$ ，</p><script type="math/tex; mode=display">if \quad \arccos(\overline n_i \cdot \overline p_{ji}) \le \arccos(\overline n_j \cdot \overline p_{ij})\\ then \begin{cases} p_s = p_i,\ n_s =n_i \\ p_t = p_j, \ n_t = n_j  \end{cases}\\ else \begin{cases} p_s = p_j,\ n_s =n_j \\ p_t = p_i, \ n_t = n_i  \end{cases}</script><p>定义 $p_s$ 为源点，$p_t$ 为目标点，源点的选择使其法线与连接两点的直线之间的夹角最小。然后，可以在 $p_s$ 处将局部坐标系的原点定义为：</p><script type="math/tex; mode=display">\begin{cases} u = n_s \\ v= u \times \frac{(p_t - p_s)}{||p_t - p_s||_2} \\ w = u \times v\end{cases}</script><p>在该 uvw 坐标系下，两个法线 $n_s$ 和 $n_t$ 之间的差可以表示为一组角度特征，如下:</p><script type="math/tex; mode=display">\begin{cases} \alpha = v \cdot n_t \\ \phi = u \cdot \frac{(p_t-p_s)}{d} \\ \theta = \arctan(w \cdot n_t,u \cdot n_t)\end{cases}</script><p>式中，d 为欧氏距离，$d= ||p_t-p_s||_2$ 。</p><p>这样，就只需计算近邻点集 $P^{k_2}$ 中每一对点的特征组成的四个参数 $&lt;\alpha,\phi,\theta,d&gt;$ （将其称为四元组），将原来的12（一个点有 $x,y,z,n_x,n_y,n_z$ (坐标及法线)）个参数减少到了4个。(在一般的实际问题中，d 往往不计在内，实验证明，不计在内效果更好)</p><p><img src="F:\AFIGHT\笔记\PCL\assets\PFH局部坐标系.png" alt="PFH坐标系"></p><p>下图是计算查询点 $p_q$ 的 PFH 时的影响区域图，查询半径（图中虚线，2D 中圆，3D中球）为 $r$ ，可见其 k 近邻点用网格完全互连。</p><p><img src="F:\AFIGHT\笔记\PCL\assets\PFH区域影响图.png" alt="PFH影响区域图"></p><p>为创建查询点 $p_i$ 的 PFH 表示，先将所有的四元组放进直方图，这个过程将每个特征的取值范围划分为 b 个子区域，并统计每个子区间中的特征出现次数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每一对点估计 PFH 四元组</span></span><br><span class="line"><span class="built_in">computePairFeatures</span> (<span class="type">const</span> pcl::PointCloud&lt;PointInT&gt; &amp; cloud, <span class="type">const</span> pcl::PointCloud&lt; PointNT &gt; &amp; normals,</span><br><span class="line"><span class="type">int</span> p_idx,</span><br><span class="line"><span class="type">int</span> q_idx,</span><br><span class="line"><span class="type">float</span> &amp; f1,</span><br><span class="line"><span class="type">float</span> &amp; f2,</span><br><span class="line"><span class="type">float</span> &amp; f3,</span><br><span class="line"><span class="type">float</span> &amp; f4 </span><br><span class="line">)</span><br><span class="line">Compute the <span class="number">4</span>-tuple representation containing the three angles <span class="keyword">and</span> one distance between two points represented by Cartesian coordinates <span class="keyword">and</span> normals.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters 参照上图的坐标系理解</span></span><br><span class="line">[in]cloudthe dataset containing the XYZ Cartesian coordinates of the two points <span class="comment">//输入点云</span></span><br><span class="line">[in]<span class="function">normalsthe dataset containing the surface <span class="title">normals</span> <span class="params">(assuming normalized vectors)</span> at each point in cloud <span class="comment">//法线</span></span></span><br><span class="line"><span class="function">[in]p_idxthe index of the first <span class="title">point</span> <span class="params">(source)</span>  <span class="comment">// 源点</span></span></span><br><span class="line"><span class="function">[in]q_idxthe index of the second <span class="title">point</span> <span class="params">(target)</span> <span class="comment">// 目标点</span></span></span><br><span class="line"><span class="function">[out]f1the first angular <span class="title">feature</span> <span class="params">(angle between the projection of nq_idx <span class="keyword">and</span> u)</span> <span class="comment">// θ</span></span></span><br><span class="line"><span class="function">[out]f2the second angular <span class="title">feature</span> <span class="params">(angle between nq_idx <span class="keyword">and</span> v)</span><span class="comment">// α</span></span></span><br><span class="line"><span class="function">[out]f3the third angular <span class="title">feature</span> <span class="params">(angle between np_idx <span class="keyword">and</span> |p_idx - q_idx|)</span> <span class="comment">// Φ</span></span></span><br><span class="line"><span class="function">[out]f4the distance <span class="title">feature</span> <span class="params">(p_idx - q_idx)</span>  <span class="comment">// d 距离</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PFH 特征估计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the PFH estimation class, and pass the input dataset+normals to it</span></span><br><span class="line">pcl::PFHEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PFHSignature125&gt; pfh; <span class="comment">//125是3个角特征量，每个又分为5个区间，故5^3</span></span><br><span class="line"><span class="comment">// 这里的 125 是默认值，也就是直接忽略了 d 的</span></span><br><span class="line">pfh.<span class="built_in">setInputCloud</span> (cloud);</span><br><span class="line">pfh.<span class="built_in">setInputNormals</span> (normals);</span><br><span class="line"><span class="comment">// 若点云类型是 PointNormal, pfh.setInputNormals (cloud);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an empty kdtree representation, and pass it to the PFH estimation object.</span></span><br><span class="line"><span class="comment">// Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">pfh.<span class="built_in">setSearchMethod</span> (tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output datasets</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PFHSignature125&gt;::<span class="function">Ptr <span class="title">pfhs</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PFHSignature125&gt; ())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use all neighbors in a sphere of radius 5cm</span></span><br><span class="line"><span class="comment">// IMPORTANT: the radius used here has to be larger than the radius used to estimate the surface normals!!!</span></span><br><span class="line">pfh.<span class="built_in">setRadiusSearch</span> (<span class="number">0.05</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the features</span></span><br><span class="line">pfh.<span class="built_in">compute</span> (*pfhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pfhs-&gt;size () should have the same size as the input cloud-&gt;size ()*，即每个点对应一个 PFH特征向量</span></span><br><span class="line"><span class="comment">// 实质上，该函数只是执行了以下步骤：</span></span><br><span class="line">对点云 P 中的每个点 p</span><br><span class="line">（<span class="number">1</span>）得到p点的最近邻元素</span><br><span class="line">（<span class="number">2</span>）对于邻域内的每对点，计算其三个角度特征参数值</span><br><span class="line">（<span class="number">3</span>）将所有结果统计到一个输出直方图中</span><br></pre></td></tr></table></figure><h3 id="快速点特征直方图（FPFH）"><a href="#快速点特征直方图（FPFH）" class="headerlink" title="快速点特征直方图（FPFH）"></a>快速点特征直方图（FPFH）</h3><p>PFH 在计算中的复杂度用大O表示法表示的话为 $O(n k^2)$ ，不利于实时应用，需优化，FPFH 将复杂度降低为 $O(nk)$ ，同时保留了前者的识别特性。</p><h4 id="理论-3"><a href="#理论-3" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文P57和PCL书P217）</p><p>首先，对每个查询点 $p_q$ ，计算该点及其近邻点的元组 $&lt;\alpha,\phi,\theta&gt;$ ，这一步称为简化点特征直方图（SPFH），图中红线表示；</p><p>接着，重新确定每个点（这个点已经是 $p_q$ 的近邻点）的 k 近邻点，使用近邻点的 SPFH 值作为权重计算查询点 $p_q$ 的最终直方图，即为 FPFH：</p><script type="math/tex; mode=display">FPFH(p_q) = SPFH(p_q) + \frac{1}{k} \sum_{i=1}^{k} \frac{1}{\omega_k} \cdot SPFH(p_k)</script><p>式中，权重 $\omega_k$ 表示在给定的度量空间中，查询点 $p_q$ 与近邻点 $p_k$ 之间的距离，用于评价点对 $(p_q,p_k)$ ，其影响区域图如下士，每个查询点(红色)只与它的k近邻点(由灰色圈包围)相连。每个直接近邻点又与自己的近邻点相连，所得到的直方图与查询点的直方图进行加权，形成FPFH。用粗线画出的是对 FPFH 计算了两次。</p><p><img src="F:\AFIGHT\笔记\PCL\assets\FPFH区域影响图.png" alt="FPFH区域影响图"></p><p>人话翻译：确定一个查询点，接着找出该查询点的近邻点，计算其参数元组（三个角度参数），（这个过程为 SPFH）然后对找到的所有近邻点，重新作为查询点，找到其近邻点，计算其 SPFH，然后使用上式进行加权，得到 FPFH。</p><p>关于 FPH 和 FPFH 的区别，这里略。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>与 FPH 不同的是，FPFHEstimation 类的默认特征是将四个角特征量每个分为11个区间，分别计算后合并，形成有 33 个元素的特征向量。</p><h2 id="点云配准"><a href="#点云配准" class="headerlink" title="点云配准"></a>点云配准</h2><ul><li>各个视角得到的点集合并到一个统一的坐标系下，形成完整的点云数据的过程 / 操作</li><li>实质：不同坐标系中测到点云之间的<code>坐标变换</code> （寻找 R T 的过程）(==错==)</li><li>实质是：同一坐标系下不同视角的点云之间的配准，即测量设备始终是同一个，得到的点云在同一个坐标下</li></ul><p>点云配准的过程是一个寻找刚性变换矩阵的过程，对于两个点云，一个为源点云 $P_s$ ，另一个为目标点云 $P_t$ ，将源点云通过一定的旋转（R）和平移（t）与目标点云配准（就是让它们完全重合），这个过程可表述为：</p><script type="math/tex; mode=display">P_t = P_s \cdot R + t</script><h3 id="一对点云的配准（两两配准）"><a href="#一对点云的配准（两两配准）" class="headerlink" title="一对点云的配准（两两配准）"></a>一对点云的配准（两两配准）</h3><ul><li>应用一个估计得到一个变换矩阵（R T）使两者完美配准</li><li>步骤：<ul><li><strong>从两个点云提取关键点，注意使用相同的标准</strong></li><li><strong>对所有关键点建立其特征描述子</strong></li><li>估计对应关系，结合特征描述子在两个数据集中的坐标位置等进行</li><li>如含噪声，则去除对配准有影响的对应点</li><li>用剩下的正确点对估计刚体变换，完成配准</li></ul></li></ul><p><img src="F:\AFIGHT\笔记\PCL\assets\block_diagram_single_iteration.jpg" alt="一对点云配对" style="zoom: 67%;" /></p><h3 id="对应估计"><a href="#对应估计" class="headerlink" title="对应估计"></a>对应估计</h3><ul><li>找到相似特征，确定数据重叠部分，进行配准</li><li>使用不同方法来搜索特征之间的对应关系<ul><li>点匹配（即只使用xyz坐标作为特征值）：穷举配准、k-d tree 最近邻查询、有序点云的图像空间查找、无序点云的索引空间查找</li><li>特征匹配（如法向量、形状直方图等）：穷举配准、k-d tree 最近邻查询</li></ul></li><li>分类<ul><li>直接对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点，确认为最终的对应点对（这是默认的估计方式）</li><li>相互对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点；接着对对点云 B 中的每个点，都找到其在点云 A 中的对应点，然后取它们的交集作为最终的对应点对</li></ul></li></ul><h3 id="错误对应关系的去除"><a href="#错误对应关系的去除" class="headerlink" title="错误对应关系的去除"></a>错误对应关系的去除</h3><p>实际中存在着噪声等影响，会导致产生的对应关系不一定是正确的（就是虽然算法找到了对应点对，但其在实际中可能并不是对应的），这些会对最终变换矩阵的估算产生影响，须去除它们，可以提高配准精度和速度。</p><p>去除方法：随机采样一致性（RANSAC）等</p><p>一对多 的情况：只取距离最近的对应点</p><h3 id="ICP算法"><a href="#ICP算法" class="headerlink" title="ICP算法"></a>ICP算法</h3><h4 id="理论-4"><a href="#理论-4" class="headerlink" title="理论"></a>理论</h4><p>无序点云最经典的配准算法——ICP 算法（ Iterative Closest Point ）：通过最小化重叠区域之间的欧氏距离误差度量，来寻找两数据集之间的最优变换。ICP 算法假定两数据集的每个点都有相应的匹配，并使用待匹配与模型之间最近的点做对应。但问题是，两个点云之间不可能是完全的一一对应关系，所以要建立稳定的对应关系显得尤为重要。</p><p>ICP 的核心是不断的去寻找源点云和目标点云中点对的最小距离，并不断缩小这个距离，对变换后的点云继续重复该过程，也就是迭代的过程；该过程用数学表达就是求出 R 和 t ,使误差函数取得最小值：</p><script type="math/tex; mode=display">E(R,t) = \frac{1}{n} \sum_{i=1}^{n} ||P_t^i -(R \cdot P_s^i+t)||^2</script><p>式中，n 是点对的个数，也就是说，这个目标函数是所有点对之间的欧氏距离的平方和。</p><p>==ICP 选择点对原则：对于源点云中的每个点，其对应点是目标点云中的最近邻点（按欧氏距离计算）==</p><p>主要步骤：[1]解则晓, 徐尚. 三维点云数据拼接中ICP及其改进算法综述[J]. 中国海洋大学学报(自然科学版).</p><ul><li>对原始点云数据采样</li><li>确定初始对应点集</li><li>去除错误对应点对</li><li>求解坐标变换</li></ul><p>ICP的主要问题在于搜索近邻点，这个过程耗时严重，为加速该过程，一般将目标点云存储到 k-d tree 结构中。</p><h4 id="简单ICP代码"><a href="#简单ICP代码" class="headerlink" title="简单ICP代码"></a>简单ICP代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp; <span class="comment">// 创建ICP 对象</span></span><br><span class="line">icp.<span class="built_in">setInputSource</span>(cloud_in);<span class="comment">// 设置一个输入点云作为 源点云</span></span><br><span class="line">icp.<span class="built_in">setInputTarget</span>(cloud_out);<span class="comment">// 设置一个输入点云作为 目标点云</span></span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt; Final;<span class="comment">// 存储最终的匹配结果</span></span><br><span class="line">icp.<span class="built_in">align</span>(Final);  <span class="comment">// 执行匹配</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;has converged:&quot;</span> &lt;&lt; icp.<span class="built_in">hasConverged</span>() &lt;&lt; <span class="string">&quot; score: &quot;</span> &lt;&lt; <span class="comment">// 匹配是否正确，返回值为 1 则为正确</span></span><br><span class="line">icp.<span class="built_in">getFitnessScore</span>() &lt;&lt; std::endl;<span class="comment">// 理解为对 配准的评分</span></span><br><span class="line">std::cout &lt;&lt; icp.<span class="built_in">getFinalTransformation</span>() &lt;&lt; std::endl;<span class="comment">// 获取转换矩阵</span></span><br></pre></td></tr></table></figure><h4 id="逐步匹配多幅点云"><a href="#逐步匹配多幅点云" class="headerlink" title="逐步匹配多幅点云"></a>逐步匹配多幅点云</h4><p>按输入的顺序两两匹配，得到最终的效果，结果是最终转换到第一个点云的坐标系下</p><h4 id="交互式ICP"><a href="#交互式ICP" class="headerlink" title="交互式ICP"></a>交互式ICP</h4><p>通过可视化界面实现用户敲空格键时，进行配准，需在内部设置 ICP 迭代次数</p><p><a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/interactive_icp.html#interactive-icp">详见Interactive Iterative Closest Point — Point Cloud Library 0.0 documentation (pcl.readthedocs.io)</a></p><h3 id="正态分布变换配准（NDT）"><a href="#正态分布变换配准（NDT）" class="headerlink" title="正态分布变换配准（NDT）"></a>正态分布变换配准（NDT）</h3><ul><li>适用于大型点云数据集</li><li>配准过程不使用对应点的特征计算及匹配，速度快</li><li>NDT 算法中，在目标点云对应的体素网格数据结构的统计计算中不使用单个点，而是使用包含在每个体素单元格中的点的统计数据</li><li>使用体素化数据结构 + More-Thuente 搜索</li></ul><p>NDT 核心：</p><ul><li><p>将空间划分为网格（2D 中为正方形，3D 中为立方体）</p><p>基于网格内的点分布，计算每个网格的概率密度分布（PDF）。每个网格中的 PDF 可理解为每个网格内曲面上的点 $\overline x$ 的生成过程；也就是说，假设 $\overline x$ 的位置是由 D 维的正态随机过程生成的</p></li></ul><h4 id="理论-5"><a href="#理论-5" class="headerlink" title="理论"></a>理论</h4><p>（详见：Magnusson M. The three-dimensional normal-distributions transform: an efficient representation for registration, surface analysis, and loop detection[D]. Örebro universitet, 2009. 从P55开始</p><p><a href="https://blog.csdn.net/banzhuan133/article/details/103350049?spm=1001.2014.3001.5501">两种常见的点云配准方法ICP&amp;NDT_banzhuan133的博客-CSDN博客_ndt点云配准</a>）</p><p>对于一个随机（多维）变量，若其满足正态分布，则其对应的 PDF 为：（对应于点云：将目标点云网格化，然后计算每个网格内的多维正态分布）</p><script type="math/tex; mode=display">p(\vec{x}) = \frac{1}{(2 \pi)^{D/2} \sqrt{\Sigma}} exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1} (\vec{x}-\vec{\mu})}{2})</script><p>式中，$\vec{\mu}$ 为均值向量，$\Sigma$ 为协方差矩阵（对角元素为每个变量的方差，非对角元素为协方差），$D$ 为维数。</p><p>$\vec{\mu}$ 和 $\Sigma$ 可单独计算：</p><script type="math/tex; mode=display">\vec{\mu} = \frac{1}{m} \sum_{k=1}^{m} \vec{y_k} \\\quad \quad \quad \quad \quad \quad \quad \quad\Sigma = \frac{1}{m-1} \sum_{k=1}^{m}    (\vec{y_k}-\vec{\mu})(\vec{y_k}-\vec{\mu})^T</script><p>式中的 $\vec{y}_{1, \cdots ,m}$ 表示一个网格中所有的点。（也就是说，上式中的 $p(\vec{x})$ 实质是计算每个网格的 PDF ）</p><p><img src="F:\AFIGHT\笔记\PCL\assets\NDT体素格.png" alt="NDT网格化" style="zoom:50%;" /></p><p>使用正态分布表示离散点云的优势在于：正态分布是对点云的分段（分块表示，网格）平滑表示，具有连续的导数；每个 PDF 可看作是局部表面的一种近似，描述了该表面的位置、方向、平滑度。在 2D 或 3D 中 ，表面方向和平滑度可用协方差矩阵的特征向量和特征值表示。对于三维的正态分布，随着 $\Sigma$ 的特征值变化，有着不同的形状（图中箭头表示特征向量，长短表示其特征值的大小）</p><p><img src="F:\AFIGHT\笔记\PCL\assets\Differ shape of 3D PDF.png" alt="3D 正态分布下的不同形状"></p><h4 id="NDT-配准"><a href="#NDT-配准" class="headerlink" title="NDT 配准"></a>NDT 配准</h4><p>NDT 的配准目标是找到一个源点云的姿态，使源点云中的点位于目标点云平面上的可能性最大。（△）</p><p>若源点云为 $\chi = { \vec{x_1}, \cdots , \vec{x_n} }$ ，其姿态变换（R，T）用一个向量 $\vec{p}$ 表示；假设空间变换函数 $T(\vec{p},\vec{x})$ 表示使用姿态变换 $\vec{p}$ 来移动点 $\vec{x}$ ；另外给定源点云的 $PDF \quad p(\vec{x})$ ，则最优位姿 $\vec{p}$ 应是使似然函数最大化：</p><script type="math/tex; mode=display">\Psi = \prod_{k=1}^{n} p(T(\vec{p}, \vec{x}_k))</script><p>其等价于最小化 $\Psi$ 的负对数似然函数（连乘转对数的和）：</p><script type="math/tex; mode=display">-log\Psi  = - \sum_{k=1}^{n} log(p(T(\vec{p},\vec{x}_k)))</script><p>式中的函数 $p$ 即为上述提到的 $PDF \quad  p(\vec{x})$ 。此外，PDF 也不一定是一个正态分布（只要可以局部捕获表面点结构，且对异常值具有鲁棒性即可）（详见P59）。</p><p><em>这也再次说明了我们的第一句话（△）：目的就是找到这个最优的  $\vec{p}$ ，以最大化似然函数（目标函数）</em></p><p>目标很明确，就是优化这个位姿参数，NDT 使用 牛顿迭代法进行优化（见后续）。</p><p>问题是，负对数似然函数在远离均值的点上呈无限增长的趋势（见P59 图6.5b或下图)，故若数据中存在噪声等异常值，会对其结果产生较大的影响，有人提出了<strong>正态分布与均匀分布结合（$\overline p(\vec{x})$）</strong>的方式：</p><script type="math/tex; mode=display">\overline p(\vec{x}) = c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2p_0</script><p>式中，$p_0$ 为异常值的期望值。利用这个函数，离群值的影响是有限的。常数 $c_1$ 和 $c_2$ 可以通过要求在单元格所跨越的空间内 $\overline p(\vec{x})$ 的概率质量等于1来确定。</p><p>另一个问题是，这种结合的方式没有简单的一阶和二阶导数（其实就是 log 函数求导不方便）；观察负对数似然函数（下图右绿色示），可发现其与高斯函数相像（下图左绿色示），故可用高斯函数来近似上述 $\overline p(\vec{x})$  。</p><p><img src="F:\AFIGHT\笔记\PCL\assets\likelihood.png" alt="likelihood" style="zoom: 67%;" /></p><p>$\overline p(\vec{x})$ 对应的 log 形式为（这里 $c_2p_0$ 只剩 $c_2$ ，个人理解为其是一个期望值，是常数，可用一个代替？）：</p><script type="math/tex; mode=display">-\log (c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2)</script><p>函数形式为</p><script type="math/tex; mode=display">\overline p(x) = - \log(c_1 exp(\frac{-x^2}{2 \sigma ^2}) + c_2)</script><p>的函数可用形式如下的高斯函数近似：</p><script type="math/tex; mode=display">\tilde{p}(x) = d_1 exp(\frac{-d_2 x^2}{2 \sigma^2}) + d_3</script><p>当 $x=1，x=\sigma，x = \infty$ 时，$\overline p(x)$ 应与 $\tilde p(x)$ 相等，以此来拟合 $d_i$ ：</p><script type="math/tex; mode=display">d_3 = - \log(c_2) \\d_1 = - \log(c_1 + c_2) -d_3 \\d_2 = -2 \log(\frac{-\log(c_1 e^{- \frac{1}{2}} + c_2 -d_3)} {d_1})</script><p>如此，源点云中的一点对 NDT 评分函数的影响可用高斯函数近似为：</p><script type="math/tex; mode=display">\tilde p(\vec{x}_k) = -d_1 exp(- \frac{d_2}{2} (\vec{x}_k - \vec{\mu}_k)^T \Sigma_k^{-1} (\vec{x}_k - \vec{\mu}_k))</script><p>这里忽略了常数 $d_3$ ，因其只是对评分函数进行了一个偏移，但并不影响其形状或参数。</p><p>到此，目标函数变为：</p><script type="math/tex; mode=display">s(\vec{p}) = - \sum_{k=1}^{n} \tilde{p}(T(\vec{p},\vec{x}_k))</script><p><em>所以上述过程就是将源点云的 PDF $p(x)$ 用  $\tilde{p}(x)$ 近似的过程，最后得到的近似表示如上</em></p><p>可以看出，似然函数需要求 $\Sigma^{-1}$ ，但若网格内的点是完全共面或共线，则 $\Sigma$ 是奇异的，无法求逆（详见P60）。</p><p>位姿参数 $\vec{p}$ 可用牛顿迭代法求解，其方程为：</p><script type="math/tex; mode=display">H \Delta \vec{p} = - \vec{g}</script><p>式中，$H$ 为海森矩阵，$\vec{g}$ 为 $s(\vec{p})$ 的梯度向量，$\Delta \vec{p}$ 在每次迭代过程中加到当前的位姿估计中，即 $\vec{p} \leftarrow \vec{p} + \Delta \vec{p}$ 。 （具体求解详见P61)</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在 NDT 配准前需要进行滤波处理，这里使用体素中心网格法</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">filtered_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::ApproximateVoxelGrid&lt;pcl::PointXYZ&gt; approximate_voxel_filter;</span><br><span class="line">approximate_voxel_filter.<span class="built_in">setLeafSize</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>);</span><br><span class="line">approximate_voxel_filter.<span class="built_in">setInputCloud</span>(input_cloud);</span><br><span class="line">approximate_voxel_filter.<span class="built_in">filter</span>(*filtered_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NDT 参数初始化</span></span><br><span class="line">pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;</span><br><span class="line">ndt.<span class="built_in">setTransformationEpsilon</span>(<span class="number">0.01</span>);<span class="comment">//设置变换的ε：两个连续的变换(迭代)之间允许的最大差值，用于判断优化过程是否达到最终的阈值</span></span><br><span class="line">ndt.<span class="built_in">setStepSize</span>(<span class="number">0.1</span>);<span class="comment">//牛顿法优化的最大步长（收敛速率系数，理解为什么时候终止？？）</span></span><br><span class="line">ndt.<span class="built_in">setResolution</span>(<span class="number">1.0</span>);<span class="comment">//分辨率设置，也就是体素化网格的边长</span></span><br><span class="line">ndt.<span class="built_in">setMaximumIterations</span>(<span class="number">35</span>);<span class="comment">//迭代的次数：达到该次数时停止</span></span><br><span class="line">ndt.<span class="built_in">setInputSource</span>(filtered_cloud);</span><br><span class="line">ndt.<span class="built_in">setInputTarget</span>(target_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化变换参数并执行优化</span></span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation</span><span class="params">(<span class="number">0.6931</span>, Eigen::Vector3f::UnitZ())</span></span>;<span class="comment">//初始位姿 R</span></span><br><span class="line"><span class="function">Eigen::Translation3f <span class="title">init_translation</span> <span class="params">(<span class="number">1.79387</span>, <span class="number">0.720047</span>, <span class="number">0</span>)</span></span>; <span class="comment">// T</span></span><br><span class="line">Eigen::Matrix4f init_guess = (init_translation * init_rotation).<span class="built_in">matrix</span>(); <span class="comment">//初始搜索位置</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">output_cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">ndt.<span class="built_in">align</span>(*output_cloud, init_guess);<span class="comment">//执行配准</span></span><br></pre></td></tr></table></figure><h2 id="点云分割"><a href="#点云分割" class="headerlink" title="点云分割"></a>点云分割</h2><ul><li>根据空间、几何、纹理等特征对点云进行划分，使得同一划分内的点云具有相似的特征</li></ul><h3 id="聚类分割算法"><a href="#聚类分割算法" class="headerlink" title="聚类分割算法"></a>聚类分割算法</h3><ul><li>详见下一章——论文：聚类与分割</li><li>m 个数据，m 维空间内，定义点与点之间的某种性质的亲属聚类；若 m 个数据点构成 n 类，将具有最小距离的两类合为一类，然乎重新计算两类的之间的距离，如此迭代，直至两类之间的距离大于指定的阈值，或者类的个数少于指定的数目，完成分割。</li></ul><h3 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h3><ul><li>随机采样一致性<ul><li>从样本中随机抽取一个样本子集，使用最小方差估计法对自己进行模型参数的计算，再计算所有样本与该模型的偏差，将该偏差与设置好的阈值进行比较，若其小于设定的阈值，则为内点，否则为外点</li></ul></li><li>根据一组包含噪声、外点等缺陷的样本数据集，估计出数据的数学模型，同时得到有效的样本数据</li><li>参数<ul><li>$\tau$ ：误差容忍度，判断样本是否满足模型 M 的误差容忍度</li><li>$Max$ ：随机抽取样本集的次数（即抽取子集的次数）</li><li>$N$ ：指定的阈值</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">model_p</span><span class="params">(<span class="keyword">new</span> pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;(cloud))</span></span>;<span class="comment">//定义为平面模型（还有其他模型）</span></span><br><span class="line"><span class="function">pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; <span class="title">ransac</span><span class="params">(model_p)</span></span>;</span><br><span class="line">ransac.<span class="built_in">setDistanceThreshold</span>(<span class="number">.01</span>);<span class="comment">//阈值设置</span></span><br><span class="line">ransac.<span class="built_in">computeModel</span>();<span class="comment">//计算模型</span></span><br><span class="line">ransac.<span class="built_in">getInliers</span>(inliers);<span class="comment">//获取内点</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Algorithm : RANSAC</span><br><span class="line">1) Initial: let A be a set of N feature correspondences</span><br><span class="line">2) repeat</span><br><span class="line">2.1) Randomly select a sample of s points from A</span><br><span class="line">2.2) Fit a model to these points</span><br><span class="line">2.3) Compute the distance of all other points to this model</span><br><span class="line">2.4) Construct the inlier set (i.e. count the number of points  whose distance from the model &lt; d)</span><br><span class="line">2.5) Store these inliers</span><br><span class="line">2.6) until maximum number of iterations reached</span><br><span class="line">3) The set with the maximum number of inliers is chosen as</span><br><span class="line">a solution to the problem</span><br><span class="line">4) Estimate the model using all the inliers</span><br></pre></td></tr></table></figure><h3 id="平面点云分割"><a href="#平面点云分割" class="headerlink" title="平面点云分割"></a>平面点云分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//模型系数对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;<span class="comment">//内点对象</span></span><br><span class="line">pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;<span class="comment">// Create the segmentation object，点云分割对象</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);<span class="comment">// Optional，可选项，设置是否优化系数</span></span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_PLANE);<span class="comment">// Mandatory，必选项，设置分割类型</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">// Mandatory，设置分割方法</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.01</span>);<span class="comment">// Mandatory，设置距离阈值</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers, *coefficients);<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure><h3 id="圆柱体模型分割"><a href="#圆柱体模型分割" class="headerlink" title="圆柱体模型分割"></a>圆柱体模型分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CYLINDER);</span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);</span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.1</span>);</span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);</span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.05</span>);</span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cloud_filtered2);</span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(cloud_normals2);</span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers_cylinder, *coefficients_cylinder);</span><br></pre></td></tr></table></figure><h3 id="欧式聚类提取"><a href="#欧式聚类提取" class="headerlink" title="欧式聚类提取"></a>欧式聚类提取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">100</span>);</span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(<span class="number">25000</span>);</span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(tree);<span class="comment">//kd-tree</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud_filtered);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure><h3 id="区域生长分割"><a href="#区域生长分割" class="headerlink" title="区域生长分割"></a>区域生长分割</h3><ul><li><p>从曲率最小的点开始生长（初始种子点）</p></li><li><p>输出是一个聚类集合，每个聚类集合属于同一光滑表面的一部分</p></li><li><p>基本思想：</p><p>根据输入点的曲率值对点排序，曲率最小的点为初始种子点，该点所在的区域为最平滑区域，也就是从最平滑区域开始生长，减少分割区域的总数，提高效率。</p></li><li><p>核心：比较近邻点与种子点之间的两个指标</p><ul><li>法线夹角的比较：小于设定的阈值进入区域，即为同一类（满足此条件时进入下一步的判断）</li><li>曲率大小的比较：小于设定的阈值进入序列（这是为何进行排序的原因，形成一个种子序列，每完成一次比较，删除当前的种子点，使用序列中的下一个种子点继续进行比较，如此迭代）</li><li>还需设定一个最小点簇数和最大点簇数</li><li>种子序列为空时意味着算法完成了区域增长，从头开始进行重复上述过程</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::RegionGrowing&lt;pcl::PointXYZ, pcl::Normal&gt; reg;</span><br><span class="line">reg.<span class="built_in">setMinClusterSize</span>(<span class="number">50</span>);</span><br><span class="line">reg.<span class="built_in">setMaxClusterSize</span>(<span class="number">1000000</span>);</span><br><span class="line">reg.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">reg.<span class="built_in">setNumberOfNeighbours</span>(<span class="number">30</span>);</span><br><span class="line">reg.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//reg.setIndices (indices);</span></span><br><span class="line">reg.<span class="built_in">setInputNormals</span>(normals);</span><br><span class="line">reg.<span class="built_in">setSmoothnessThreshold</span>(<span class="number">3.0</span> / <span class="number">180.0</span> * M_PI);<span class="comment">// 平滑阈值</span></span><br><span class="line">reg.<span class="built_in">setCurvatureThreshold</span>(<span class="number">1.0</span>);<span class="comment">//曲率阈值</span></span><br><span class="line">std::vector &lt;pcl::PointIndices&gt; clusters;</span><br><span class="line">reg.<span class="built_in">extract</span>(clusters);<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure><h3 id="超体素点云分割（VCCS）"><a href="#超体素点云分割（VCCS）" class="headerlink" title="超体素点云分割（VCCS）"></a>超体素点云分割（VCCS）</h3><ul><li>空间八叉树结构 + k-mean 聚类的区域增长 直接对点云进行超体素分割</li><li>超体素特征：<ul><li>在3D空间中，均匀分布（可通过在点云空间中均匀设定种子达到）</li><li>除非在体素空间上相连，否则超体素不能跨越边界</li></ul></li><li>在空间分辨率为 $R<em>{seed}$ 的三维空间网格中，对均匀分布在空间中的种子点进行增长形成超体素。这里为提高搜索效率，只考虑以种子为中心的半径为 $R</em>{seed}$ 区域内的点。</li></ul><p><img src="F:\AFIGHT\笔记\PCL\assets\voxel_segmentation.png" alt="超体素分割"></p><h2 id="论文：聚类与分割"><a href="#论文：聚类与分割" class="headerlink" title="论文：聚类与分割"></a>论文：聚类与分割</h2><ul><li>聚类（clustering）将数据集中的样本划分为不相交的子集，每个子集成为一个“簇（cluster）”    </li><li>聚类过程形成簇结构</li><li>簇标记（cluster label）</li></ul><h3 id="拟合简化的集合模型（平面模型）"><a href="#拟合简化的集合模型（平面模型）" class="headerlink" title="拟合简化的集合模型（平面模型）"></a>拟合简化的集合模型（平面模型）</h3><ul><li>不共线的三点确定一个平面，故先从点云 $\mathcal{P}$ 中随机选取不共线的三点 ${p_i,p_j,p_k}$ </li><li>根据选定的三个点计算平面模型系数（$ax+by+cz+d=0$）（可根据克莱姆法则计算，详见 <a href="https://en.wikipedia.org/wiki/Plane_(geometry">Plane (geometry) - Wikipedia</a>)）</li><li>计算点云 $\mathcal{P}$ 中所有点 $p$ 到该平面模型的距离（$p_n \quad (a,b,c,d)$）</li><li>保存距离在指定阈值内的点 $p^* \in \mathcal{P}$，并计算其个数 </li></ul><p>上述的最后一步表示对模型的评分；每个点集 $p^<em>$ 都会被保存，且上述步骤会重复（迭代） $k$ 次。算法终止后，点的数量最多的点集（内点），就是对平面模型描述最好的点集（能最好的拟合平面模型）。对所有的点 $p^</em> \in \mathcal{P}$ ，平面模型系数用最小二乘估计。</p><p>上述过程就是找到内点集 $p^*$，拟合出平面或者估计出其2D边界多边形的简化过程，在实际应用中，还需增加额外的约束条件。</p><h3 id="基本聚类技术"><a href="#基本聚类技术" class="headerlink" title="基本聚类技术"></a>基本聚类技术</h3><ul><li><p>依赖于空间分解技术，基于给定的标准，寻找分块及边界，实现分类</p></li><li><p>评判标准：闵氏范数：曼哈顿距离（L1）、欧式距离（L2）</p></li><li><p>欧式聚类数据结构：八叉树（3D网格）</p><ul><li>优点：易于快速构建，适用于不同情况，如需要占用空间的体积表示、用不同结构估计叶节点中的数据等</li><li>缺点：3D网格只适用于空间等分的情况</li></ul></li></ul><p>对于聚类分块大小不一的情况，需要更复杂的算法（下述）。</p><p>实例：</p><ul><li>点聚类 $O_i = {p_i \in \mathcal{P}}$  与点聚类 $O_j = {p_j \in \mathcal{P}}$ 不同的条件是：</li></ul><script type="math/tex; mode=display">min||p_i-p_j||_2 \ge d_{th}</script><p>式中，$d_{th}$ 是指定的阈值。</p><p>即：点集 $p_i \in \mathcal{P}$ 与点集 $p_j \in \mathcal{P}$ 之间的最小距离大于指定的阈值，则前者中的点属于聚类 $O_i$，后者属于聚类 $O_j$ 。</p><p>一个问题是，这个最小距离该如何估计？</p><ul><li><p>最小距离的估计：使用 kd-tree 进行最近邻查询</p></li><li><p>算法伪代码：</p><ul><li>输入点云 $\mathcal{P}$ ，创建 kd-tree 表示</li><li>设置簇 $C$ 的空列表，以及点集序列 $Q$ </li><li>对输入点云的每一个点 $p_i \in \mathcal{P}$ ，执行以下步骤<ul><li>将 $p_i$ 添加到当前序列 $Q$ </li><li>对添加到序列中的每个点 $p_i \in Q$：<ul><li>以3D空间中半径为 $r&lt;d_{th}$ 的球体搜索 $p_i$ 的近邻点（近邻点搜索半径 r），结果形成点集 $P_i^k$  （setRadiusSearch）</li><li>对每个近邻点 $p_i^k \in P_i^k$，若未被分类则将其添加到序列 $Q$ </li></ul></li><li>序列 $Q$ 中的所有点处理完后，将 $Q$ 添加到簇 $C$ 的序列（内点）并重置为空序列</li></ul></li><li>算法终止条件：点云中的所有点均被遍历，且已成为簇 $C$ 的列表的一部分</li></ul></li><li><p>聚类算法(cpp)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被分割出来的点云团（标号队列）</span></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line"><span class="comment">//欧式分割器</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">100</span>);</span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(<span class="number">25000</span>);</span><br><span class="line"><span class="comment">//搜索策略树</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud_filtered);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure><h3 id="边缘查询"><a href="#边缘查询" class="headerlink" title="边缘查询"></a>边缘查询</h3></li><li><p>表面曲率可用于点云分割：是对点附近采样点的几何近似估计，它们对确定那些具有极高曲率值的点很有用，这些点代表点云数据集 $\mathcal{P}$ 的几何边缘</p></li><li>2D 图像中边缘可用梯度定义，3D 中则是场景中几何形状变化剧烈的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCL </tag>
            
            <tag> Point Cloud </tag>
            
            <tag> 点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设：链片条复合模CAD系统使用须知</title>
      <link href="/Graduate_2/"/>
      <url>/Graduate_2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="由于该系统只在-win10-系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！"><a href="#由于该系统只在-win10-系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！" class="headerlink" title="由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！"></a>由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！</h5><span id="more"></span><h3 id="已知错误1：数据库引擎"><a href="#已知错误1：数据库引擎" class="headerlink" title="已知错误1：数据库引擎"></a>已知错误1：数据库引擎</h3><p>本系统采用 ACCESS 作为数据库，经测试（虚拟机测试），win7 等系统上会出现 “未在本地计算机上注册‘Microsoft. ACE. OLEDB. 12. 0’提供程序”类似的提示。</p><p><img src="https://i.loli.net/2020/05/26/LJwRFIAp4N3HCyB.png" alt="运行错误.png"></p><center>运行错误提示</center><h3 id="解决1："><a href="#解决1：" class="headerlink" title="解决1："></a>解决1：</h3><p>安装数据库引擎即可，点击下方“下载”，下载完成后安装，提示安装成功后尝试再次运行本系统。</p><div class="btns circle center grid5">            <a class="button" href='https://mqroad.lanzous.com/id006ba' title='下载'><i class='fas fa-download'></i>下载</a>          </div>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设：链片条复合模CAD系统</title>
      <link href="/Graduate_/"/>
      <url>/Graduate_/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="毕设题目：采用滚动导向、中间导柱模架的复合模-CAD-系统研制-一-——设计计算及工程图绘制"><a href="#毕设题目：采用滚动导向、中间导柱模架的复合模-CAD-系统研制-一-——设计计算及工程图绘制" class="headerlink" title="毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制"></a>毕设题目：采用滚动导向、中间导柱模架的复合模 CAD 系统研制(一) ——设计计算及工程图绘制</h5><h5 id="指导老师：谌霖霖"><a href="#指导老师：谌霖霖" class="headerlink" title="指导老师：谌霖霖"></a>指导老师：谌霖霖</h5><span id="more"></span><h2 id="开发平台"><a href="#开发平台" class="headerlink" title="开发平台"></a>开发平台</h2><p>系统环境：Windows 10 2004 专业版<br>开发环境：VB.NET<br>数据库：ACCESSS 365<br>软件平台：VS 2010</p><h2 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h2><p>该复合模 CAD 系统主要包含以下功能：</p><ul><li>用户登录</li><li>参数输入</li><li>设计计算</li><li>主界面<ul><li>设计结果</li><li>标准件库</li><li>建模装配</li><li>关于系统</li></ul></li></ul><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>首先，用户在打开系统后，会出现登录界面，该界面四个按钮的功能如下：<br>1.登录：如若账号密码均正确，通过此按钮即可进入下一界面；<br>2.取消：如用户输入时出错，想直接清空输入框，可使用此按钮；<br>3.注册：新用户可通过注册后再登录；<br>4.退出：退出系统。</p><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525214117.png" alt="系统登陆界面" width="400" height="350" align="bottom" /></p><center>系统登陆界面</center><h3 id="参数输入"><a href="#参数输入" class="headerlink" title="参数输入"></a>参数输入</h3><p>用户登录后将进入该界面，在该界面由用户输入需要的尺寸值，也可使用默认值，点击开始设计，并选择模具的最小闭合高度，在确定之后即可开始设计计算。</p><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525220724.png" alt="参数输入界面" width="400" height="350" align="bottom" /></p><center>参数输入界面</center><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525222908.png" alt="参数输入界面" width="400" height="150" align="bottom" /></p><center>闭合高度选择</center><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>系统主界面下可进行设计结果的查询、标准件的尺寸查询、三维建模与装配（调用同组同学 GRIP 程序）、查看仿真动画、系统信息及帮助文档</p><p>此外，在查询结果菜单下，用户可通过点击零件图纸查看零件的三维模型。</p><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525224828.png" alt="参数输入界面" width="400" height="100" align="bottom" /></p><center>系统主界面</center><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525230310.png" alt="参数输入界面" width="400" height="100" align="bottom" /></p><center>系统主界面菜单</center><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525231149.png" alt="参数输入界面" width="400" height="300" align="bottom" /></p><center>结果查询界面</center><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/20200525233130.png" alt="参数输入界面" width="400" height="300" align="bottom" /></p><center>零件信息界面</center><p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/yanshi.gif" alt="参数输入界面" width="400" height="300" align="bottom" /></p><center>点击零件图纸查看零件的三维模型</center><p>剩余界面较为简单，这里不再赘述！</p><p>（密码：姓名拼音的首字母大写）</p><center>系统演示视频</center><center><iframe height=498 width=650 src='https://player.youku.com/embed/XNDY4NzU3MTk5Mg==' frameborder=0 'allowfullscreen'></iframe></center>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全国性哀悼活动</title>
      <link href="/ChinaIsTheBest/"/>
      <url>/ChinaIsTheBest/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>据国家卫健委消息，截至4月3日，我国因感染新冠肺炎的逝者已有3326名。他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。</p><p><img src="https://s2.loli.net/2023/04/17/1HNytJQGg8BKTMd.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Commemorate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开天辟地</title>
      <link href="/hexo_new/"/>
      <url>/hexo_new/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是 Hexo 的介绍文档，这里面有它的官网以及官方文档，最重要的是记录下 hexo 的常用命令！</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
