<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>点云+PCL学习笔记 | 南阳向北</title><meta name="keywords" content="PCL,Point Cloud,点云"><meta name="author" content="MQRoad"><meta name="copyright" content="MQRoad"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="点云+PCL学习笔记"><meta name="application-name" content="点云+PCL学习笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="bookmark" href="/img/siteicon/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="apple-touch-icon" sizes="192x192" href="/img/siteicon/apple-touch-icon.png"><link rel="apple-touch-icon" sizes="512x512" href="/img/siteicon/apple-touch-icon.png"><link rel="apple-touch-startup-image" media="screen and (device-width:320px) and (device-height:568px) and (-webkit-device-pixel-ratio:2) and (orientation:landscape)" href="/img/siteicon/splashIcons/icon_1136x640.png"><link rel="apple-touch-startup-image" media="screen and (device-width:320px) and (device-height:568px) and (-webkit-device-pixel-ratio:2) and (orientation:portrait)" href="/img/siteicon/splashIcons/icon_640x1136.png"><link rel="apple-touch-startup-image" media="screen and (device-width:414px) and (device-height:896px) and (-webkit-device-pixel-ratio:3) and (orientation:landscape)" href="/img/siteicon/splashIcons/icon_2688x1242.png"><link rel="apple-touch-startup-image" media="screen and (device-width:414px) and (device-height:896px) and (-webkit-device-pixel-ratio:2) and (orientation:landscape)" href="/img/siteicon/splashIcons/icon_1792x828.png"><link rel="apple-touch-startup-image" media="screen and (device-width:375px) and (device-height:812px) and (-webkit-device-pixel-ratio:3) and (orientation:portrait)" href="/img/siteicon/splashIcons/icon_1125x2436.png"><link rel="apple-touch-startup-image" media="screen and (device-width:414px) and (device-height:896px) and (-webkit-device-pixel-ratio:2) and (orientation:portrait)" href="/img/siteicon/splashIcons/icon_828x1792.png"><link rel="apple-touch-startup-image" media="screen and (device-width:375px) and (device-height:812px) and (-webkit-device-pixel-ratio:3) and (orientation:landscape)" href="/img/siteicon/splashIcons/icon_2436x1125.png"><link rel="apple-touch-startup-image" media="screen and (device-width:414px) and (device-height:736px) and (-webkit-device-pixel-ratio:3) and (orientation:portrait)" href="/img/siteicon/splashIcons/icon_1242x2208.png"><link rel="apple-touch-startup-image" media="screen and (device-width:414px) and (device-height:736px) and (-webkit-device-pixel-ratio:3) and (orientation:landscape)" href="/img/siteicon/splashIcons/icon_2208x1242.png"><link rel="apple-touch-startup-image" media="screen and (device-width:375px) and (device-height:667px) and (-webkit-device-pixel-ratio:2) and (orientation:landscape)" href="/img/siteicon/splashIcons/icon_1334x750.png"><link rel="apple-touch-startup-image" media="screen and (device-width:375px) and (device-height:667px) and (-webkit-device-pixel-ratio:2) and (orientation:portrait)" href="/img/siteicon/splashIcons/icon_750x1334.png"><link rel="apple-touch-startup-image" media="screen and (device-width:1024px) and (device-height:1366px) and (-webkit-device-pixel-ratio:2) and (orientation:landscape)" href="/img/siteicon/splashIcons/icon_2732x2048.png"><meta name="description" content="研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充）">
<meta property="og:type" content="article">
<meta property="og:title" content="点云+PCL学习笔记">
<meta property="og:url" content="https://hbroad.github.io/point_cloud_pcl/index.html">
<meta property="og:site_name" content="南阳向北">
<meta property="og:description" content="研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客 （注：部分图片未上传至图床，抽空补充）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/04/28/yGbIuVMHqwkANfh.png">
<meta property="article:published_time" content="2022-07-16T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-28T08:02:40.014Z">
<meta property="article:author" content="MQRoad">
<meta property="article:tag" content="PCL">
<meta property="article:tag" content="Point Cloud">
<meta property="article:tag" content="点云">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/04/28/yGbIuVMHqwkANfh.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hbroad.github.io/point_cloud_pcl/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.3.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '点云+PCL学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-28 16:02:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              // const now = new Date()
              // const hour = now.getHours()
              // const isNight = hour <= 6 || hour >= 18
              // isNight ? activateDarkMode() : activateLightMode()
              activateDarkMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<style>#recent-posts{margin-top:-1rem;align-content:flex-start;display:flex;flex-wrap:wrap;justify-content:space-between}#recent-posts>.recent-post-item{margin-top:1rem;display:inline-block;height:auto;width:49%}#recent-posts>.recent-post-item .post_cover{width:100%;height:200px}#recent-posts>.recent-post-item .post_cover img.post_bg{width:100%;height:100%}#recent-posts>.recent-post-item>.recent-post-info>.content{display:none}#recent-posts>.recent-post-item{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}#recent-posts>.recent-post-item .left_radius{border-radius:8px 8px 0 0}#recent-posts>.recent-post-item .right_radius{border-radius:8px 8px 0 0}.recent-post-item{height:auto!important}.recent-post-info{padding:0 40px;margin-top:1em;width:100%!important}#recent-posts>.recent-post-item>.recent-post-info>.article-title{-webkit-line-clamp:1;margin-top:.3rem;margin-bottom:.3rem;color:var(--text-highlight-color);font-size:1.2em;line-height:1.4}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap{margin-bottom:1rem}@media screen and (max-width:768px){#recent-posts>.recent-post-item{width:100%}}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"><div class="title">南阳向北</div><i class="fa-solid fa-house"></i></a></span><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 全部</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-shapes faa-tada"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD"><span> AI资讯</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="fa-fw fas fas fa-lightbulb faa-tada"></i><span> 发个说说</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/timeline/"><i class="fa-fw fa-fw fas fa-shoe-prints faa-tada faa-tada"></i><span> 建站小记</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="fas fa-dice" style="font-size:1.2rem"></i></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" href="javascript:void(0);" title="浅色和深色模式转换" onclick="rm.switchDarkMode()"><i class="fas fa-adjust"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="fas fa-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">点云+PCL学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-16T16:00:00.000Z" title="发表于 2022-07-17 00:00:00">2022-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-28T08:02:40.014Z" title="更新于 2023-04-28 16:02:40">2023-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2023/04/28/yGbIuVMHqwkANfh.png"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客</p>
<p>（注：部分图片未上传至图床，抽空补充）</p>
<span id="more"></span>
<h2 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h2><ul>
<li><p>分布在 N 维空间中的离散点集</p>
</li>
<li><p>是对物体表面信息的离散采样</p>
</li>
</ul>
<h2 id="点云库"><a href="#点云库" class="headerlink" title="点云库"></a>点云库</h2><ul>
<li>三维处理算法：滤波、特征估计、表面重建等</li>
</ul>
<h2 id="PointT-类型"><a href="#PointT-类型" class="headerlink" title="PointT 类型"></a>PointT 类型</h2><h3 id="PointXYZ"><a href="#PointXYZ" class="headerlink" title="PointXYZ"></a>PointXYZ</h3><ul>
<li><p>包含 x y z 坐标的点数据类型</p>
</li>
<li><p>成员变量 float x, y, z</p>
</li>
<li><p>points[i].x 访问</p>
</li>
<li><p>多余的一个变量用来填充位置以满足存储对齐（?）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">float</span> data[<span class="number">4</span>];</span><br><span class="line">   <span class="keyword">struct</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">float</span> x;</span><br><span class="line">      <span class="type">float</span> y;</span><br><span class="line">      <span class="type">float</span> z;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Point-XYZI"><a href="#Point-XYZI" class="headerlink" title="Point XYZI"></a>Point XYZI</h3><ul>
<li>包含 x y z 坐标及 intensity</li>
</ul>
<h3 id="PointXYZRGBA"><a href="#PointXYZRGBA" class="headerlink" title="PointXYZRGBA"></a>PointXYZRGBA</h3><ul>
<li>rgba 单独作为一个整型变量（unit32_t）</li>
</ul>
<h2 id="PCD-文件"><a href="#PCD-文件" class="headerlink" title="PCD 文件"></a>PCD 文件</h2><ul>
<li>包含文件头：声明存储点云数据的特性，必须用 ASCII 编码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># .PCD v<span class="number">.7</span> - Point Cloud Data file format</span><br><span class="line">VERSION <span class="number">.7</span>                     # 指定PCD文件版本</span><br><span class="line">FIELDS x y z rgb               # 指定每个点可以有的每一个维度或字段的名字</span><br><span class="line">SIZE <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span>                   # 用字节数指定 FIELDS 中每一个维度的大小</span><br><span class="line">TYPE F F F F                   # 用一个字符指定 FILEDS 中每一个维度的类型</span><br><span class="line">COUNT <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>                  # 指定每一个维度包含的元素数目</span><br><span class="line">WIDTH <span class="number">213</span>                      # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目）  列</span><br><span class="line">HEIGHT <span class="number">1</span>                       # 用点的数量表示点云数据集的高度；同 WIDTH                                      行 </span><br><span class="line">VIEWPOINT <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>        # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）</span><br><span class="line">POINTS <span class="number">213</span>                     # 数据集中点的总数 </span><br><span class="line">DATA ascii                     # 存储点云数据的数据类型：ASCII 或 二进制</span><br><span class="line"><span class="number">0.93773</span> <span class="number">0.33763</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.90805</span> <span class="number">0.35641</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.81915</span> <span class="number">0.32</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.97192</span> <span class="number">0.278</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br></pre></td></tr></table></figure>
<ul>
<li>DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开</li>
<li>DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法</li>
</ul>
<h2 id="K-d-tree"><a href="#K-d-tree" class="headerlink" title="K-d tree"></a>K-d tree</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><center class="half">
    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/KdTree.png" alt="KdTree"  style="zoom:20%;" />
    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/Kdtree_2d.png" alt="KdTree"  style="zoom:30%;" />
</center>

<p>按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。</p>
<p>在 k-d tree 中查找距离查询点 $\overline x$ 最近点的，意味着遍历整个树，找到包含 $\overline x$ 的子节点。</p>
<p>实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。</p>
<h3 id="两种查询方式"><a href="#两种查询方式" class="headerlink" title="两种查询方式"></a>两种查询方式</h3><p>（详见博士论文 P40）</p>
<p>PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型：</p>
<ul>
<li>==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点）</li>
<li>==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点</li>
</ul>
<p>r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144959.jpg" alt="r 搜索实例"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144728.png" alt="K-d tree最近邻搜索"></p>
<p>上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\vec{q}$ ，但以 $ \vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\vec{q}’$ 。</p>
<p>另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 <code>正确尺度因子</code> 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。</p>
<p>如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。</p>
<center class="half">
    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface normals.jpg" alt="估计表面法线"  style="zoom:25%;" />
    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface curvatures.jpg" alt="估计表面曲率"  style="zoom:27%;" />
</center>

<p>所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。</p>
<h2 id="Octree-八叉树"><a href="#Octree-八叉树" class="headerlink" title="Octree(八叉树)"></a>Octree(八叉树)</h2><ul>
<li>一个根节点包含八个子节点</li>
<li>若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归</li>
<li>除近邻搜索外，可用于碰撞检测</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\Octree.png" alt="八叉树" style="zoom: 33%;" /></p>
<h2 id="点云连接"><a href="#点云连接" class="headerlink" title="点云连接"></a>点云连接</h2><h3 id="点连接"><a href="#点连接" class="headerlink" title="点连接"></a>点连接</h3><ul>
<li>需确保类型和维度相等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloud_c = cloud_a;</span><br><span class="line">cloud_c += cloud_b;</span><br></pre></td></tr></table></figure>
<h3 id="字段连接"><a href="#字段连接" class="headerlink" title="字段连接"></a>字段连接</h3><ul>
<li>需确保数目相等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="built_in">concatenateFields</span>(cloud_a, n_cloud_b, p_n_cloud_c);</span><br></pre></td></tr></table></figure>
<h2 id="点云滤波"><a href="#点云滤波" class="headerlink" title="点云滤波"></a>点云滤波</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>噪声点：设备精度、操作者经验、环境因素等</li>
<li>离群点：外界干扰如障碍物等，产生离主体点云较远的离散点</li>
</ul>
<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><ul>
<li>通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果</li>
<li>有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征</li>
</ul>
<h3 id="直通滤波器"><a href="#直通滤波器" class="headerlink" title="直通滤波器"></a>直通滤波器</h3><ul>
<li><p>去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt; pass;	 <span class="comment">// 创建直通滤波器对象</span></span><br><span class="line">pass.<span class="built_in">setInputCloud</span>(cloud);				<span class="comment">// 输入</span></span><br><span class="line">pass.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);			<span class="comment">// 设置滤波字段，此处为 z 轴</span></span><br><span class="line">pass.<span class="built_in">setFilterLimits</span>(<span class="number">0.0</span>, <span class="number">200.0</span>);		<span class="comment">// 设置滤波范围，超出则滤除</span></span><br><span class="line">pass.<span class="built_in">setFilterLimitsNegative</span> (<span class="literal">true</span>);	<span class="comment">// 默认为 false，设为 ture 则返回被滤除点</span></span><br><span class="line">pass.<span class="built_in">filter</span>(*cloud_filtered);			<span class="comment">// 执行滤波，并将滤波结果存储在 cloud_filtered</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="VoxelGrid（体素化网格）滤波器"><a href="#VoxelGrid（体素化网格）滤波器" class="headerlink" title="VoxelGrid（体素化网格）滤波器"></a>VoxelGrid（体素化网格）滤波器</h3><ul>
<li><p>实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变</p>
</li>
<li><p>VoxelGrid</p>
<ul>
<li>三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体==</li>
<li>通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示==</li>
<li>对所有体素处理后得到过滤后的点云</li>
<li>缺点：<code>慢</code>，比体素中心逼近法更慢</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;	<span class="comment">// 创建体素栅格滤波对象</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);				   <span class="comment">// 读入点云设置为输入</span></span><br><span class="line">sor.<span class="built_in">setLeafSize</span>(<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);	    <span class="comment">// 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud_filtered);			   <span class="comment">// 执行滤波并存储到 cloud_filtered</span></span><br></pre></td></tr></table></figure>
<ul>
<li>滤波结果</li>
</ul>
<p><center class="half"></p>
<pre><code>&lt;img src=&quot;F:\AFIGHT\笔记\PCL\assets\滤波前.png&quot; alt=&quot;滤波前&quot;  style=&quot;zoom:50%;&quot; /&gt;
&lt;img src=&quot;F:\AFIGHT\笔记\PCL\assets\滤波后.png&quot; alt=&quot;滤波后&quot;  style=&quot;zoom:50%;&quot; /&gt;
</code></pre><p>&lt;/center&gt;</p>
<h3 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h3></li>
</ul>
<p>（详见博士论文 P40）</p>
<ul>
<li><p>用于去除离群点</p>
</li>
<li><p>基于对近邻点集 $P^k$ 的统计分析</p>
<ul>
<li>计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\overline d$ </li>
<li>计算点云 $P$ 在平均距离上的分布，并估计平均值 $\mu_k$ 及标准差 $\sigma_k$ </li>
</ul>
</li>
<li><p>对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离</p>
</li>
</ul>
<p>去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。</p>
<p><strong>假设第一次扫描 $P<em>i$ 和随后的 $P</em>{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \in P<em>i$，搜索其对应的近邻点 $p \in P</em>{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;	<span class="comment">// 创建统计滤波对象</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);						  <span class="comment">// 设置输入点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);				    <span class="comment">// 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);		<span class="comment">// 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud_filtered);					  <span class="comment">// 执行并存储滤波结果</span></span><br><span class="line"></span><br><span class="line">sor.<span class="built_in">setNegative</span>(<span class="literal">true</span>);							  <span class="comment">// 获取离群点（此值默认为 false）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>滤波结果</li>
</ul>
<center class="half">
    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\统计滤波结果.png" alt="统计滤波结果"  style="zoom:50%;" />
    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\统计滤波离群点.png" alt="统计滤波离群点"  style="zoom:50%;" />
</center>

<h3 id="参数化模型投影点云"><a href="#参数化模型投影点云" class="headerlink" title="参数化模型投影点云"></a>参数化模型投影点云</h3><ul>
<li>点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0</li>
<li><p>PCL 中有特意存储常见模型系数的数据结构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a set of planar coefficients with X=Y=0,Z=1  </span></span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients())</span></span>;	<span class="comment">// 创建 模型系数 对象</span></span><br><span class="line">coefficients-&gt;values.<span class="built_in">resize</span>(<span class="number">4</span>);										<span class="comment">// 参数个数置为 4</span></span><br><span class="line">coefficients-&gt;values[<span class="number">0</span>] = coefficients-&gt;values[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Y</span></span><br><span class="line">coefficients-&gt;values[<span class="number">2</span>] = <span class="number">1.0</span>;</span><br><span class="line">coefficients-&gt;values[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the filtering object</span></span><br><span class="line">pcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj;	<span class="comment">// 设置投影滤波对象			</span></span><br><span class="line">proj.<span class="built_in">setModelType</span>(pcl::SACMODEL_PLANE);		<span class="comment">// 设置对象对应的投影模型类型，此处为平面模型</span></span><br><span class="line">proj.<span class="built_in">setInputCloud</span>(cloud);				   <span class="comment">// 设置输入</span></span><br><span class="line">proj.<span class="built_in">setModelCoefficients</span>(coefficients);	<span class="comment">// 设置模型系数为前述定义系数</span></span><br><span class="line">proj.<span class="built_in">filter</span>(*cloud_projected);			   <span class="comment">// 执行并保存</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="从一个点云中提取一个子集"><a href="#从一个点云中提取一个子集" class="headerlink" title="从一个点云中提取一个子集"></a>从一个点云中提取一个子集</h3><ul>
<li>基于 ExtractIndices 滤波器（基于分割算法）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; <span class="comment">// 创建分割对象</span></span><br><span class="line">extract.<span class="built_in">setInputCloud</span>(cloud_filtered); 	    <span class="comment">// 设置输入点云 </span></span><br><span class="line">extract.<span class="built_in">setIndices</span>(inliers);		   	   <span class="comment">// 设置分割后的内点为需要提取的点击（分割部分略）</span></span><br><span class="line">extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);			   	   <span class="comment">// 指定提取内点</span></span><br><span class="line">extract.<span class="built_in">filter</span>(*cloud_p);			  	   <span class="comment">// 执行并存储</span></span><br></pre></td></tr></table></figure>
<h3 id="RadiusOutlierRemoval-ConditionalRemoval-移除离群点"><a href="#RadiusOutlierRemoval-ConditionalRemoval-移除离群点" class="headerlink" title="RadiusOutlierRemoval / ConditionalRemoval  移除离群点"></a>RadiusOutlierRemoval / ConditionalRemoval  移除离群点</h3><h4 id="RadiusOutlierRemoval"><a href="#RadiusOutlierRemoval" class="headerlink" title="RadiusOutlierRemoval"></a>RadiusOutlierRemoval</h4><ul>
<li>删除输入点云一定范围内没有达到足够多近邻的所有数据点</li>
<li>人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\radius_outlier.png" alt="RadiusOutlierRemoval "></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem;	<span class="comment">// 创建半径滤波对象</span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">outrem.<span class="built_in">setInputCloud</span>(cloud);						<span class="comment">// 设置输入点云</span></span><br><span class="line">outrem.<span class="built_in">setRadiusSearch</span>(<span class="number">0.8</span>);						<span class="comment">// 设置搜索半径为 0.8</span></span><br><span class="line">outrem.<span class="built_in">setMinNeighborsInRadius</span>(<span class="number">2</span>);					<span class="comment">// 设置所需近邻点数为 2</span></span><br><span class="line">outrem.<span class="built_in">setKeepOrganized</span>(<span class="literal">true</span>);	   <span class="comment">// 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">outrem.<span class="built_in">filter</span>(*cloud_filtered);						<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure>
<h4 id="ConditionalRemoval"><a href="#ConditionalRemoval" class="headerlink" title="ConditionalRemoval"></a>ConditionalRemoval</h4><ul>
<li>如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">range_cond</span><span class="params">(<span class="keyword">new</span> pcl::ConditionAnd&lt;pcl::PointXYZ&gt;())</span></span>;	<span class="comment">// 创建条件定义对象</span></span><br><span class="line">range_cond-&gt;<span class="built_in">addComparison</span>(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::<span class="built_in">ConstPtr</span>(<span class="keyword">new</span></span><br><span class="line">		pcl::<span class="built_in">FieldComparison</span>&lt;pcl::PointXYZ&gt;(<span class="string">&quot;z&quot;</span>, pcl::ComparisonOps::GT, <span class="number">0.0</span>)));  <span class="comment">// 添加比较算子：z 字段上大于 0.0 </span></span><br><span class="line">range_cond-&gt;<span class="built_in">addComparison</span>(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::<span class="built_in">ConstPtr</span>(<span class="keyword">new</span></span><br><span class="line">		pcl::<span class="built_in">FieldComparison</span>&lt;pcl::PointXYZ&gt;(<span class="string">&quot;z&quot;</span>, pcl::ComparisonOps::LT, <span class="number">0.8</span>)));  <span class="comment">// 添加比较算子：z 字段上小于 0.8 </span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">pcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem;	 <span class="comment">// 初始化条件滤波</span></span><br><span class="line">condrem.<span class="built_in">setCondition</span>(range_cond);				<span class="comment">// 设置条件为指定的比较算子</span></span><br><span class="line">condrem.<span class="built_in">setInputCloud</span>(cloud);					<span class="comment">// 设置输入点云</span></span><br><span class="line">condrem.<span class="built_in">setKeepOrganized</span>(<span class="literal">true</span>);					<span class="comment">// 设置将被滤除点保留但置为 NaN</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">condrem.<span class="built_in">filter</span>(*cloud_filtered);				<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure>
<h3 id="CropHull-任意多边形内部点云提取"><a href="#CropHull-任意多边形内部点云提取" class="headerlink" title="CropHull 任意多边形内部点云提取"></a>CropHull 任意多边形内部点云提取</h3><ul>
<li>CropHull 滤波器得到 2D 封闭多边形内 / 外的点云</li>
</ul>
<h2 id="深度图像（Range-Depth-Images）"><a href="#深度图像（Range-Depth-Images）" class="headerlink" title="深度图像（Range/Depth Images）"></a>深度图像（Range/Depth Images）</h2><ul>
<li>将图像采集器到场景中各点的距离（深度）值作为像素值的图像（<strong>距离是相机到场景点的垂直距离，不是连线距离</strong>）</li>
<li>直接反映景物可见表面的几何状态</li>
<li>物体的三维表示形式，可通过<code>立体相机或 TOF 相机</code>获取</li>
<li>深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据</li>
<li>英文中常见的等价表述：<code>range image</code>，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles</li>
</ul>
<p>注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息</p>
<h3 id="从点云创建深度图像"><a href="#从点云创建深度图像" class="headerlink" title="从点云创建深度图像"></a>从点云创建深度图像</h3><ul>
<li><p>主要函数为 createFromPointCloud，声明 9 个参数填充即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> pcl::RangeImage::<span class="built_in">createFromPointCloud</span>	(	<span class="type">const</span> PointCloudType &amp; 	point_cloud,</span><br><span class="line"><span class="type">float</span> 	angular_resolution = pcl::<span class="built_in">deg2rad</span> (<span class="number">0.5f</span>),</span><br><span class="line"><span class="type">float</span> 	max_angle_width = pcl::<span class="built_in">deg2rad</span> (<span class="number">360.0f</span>),</span><br><span class="line"><span class="type">float</span> 	max_angle_height = pcl::<span class="built_in">deg2rad</span> (<span class="number">180.0f</span>),</span><br><span class="line"><span class="type">const</span> Eigen::Affine3f &amp; 	sensor_pose = Eigen::Affine3f::<span class="built_in">Identity</span> (),</span><br><span class="line">RangeImage::CoordinateFrame 	coordinate_frame = CAMERA_FRAME,</span><br><span class="line"><span class="type">float</span> 	noise_level = <span class="number">0.0f</span>,</span><br><span class="line"><span class="type">float</span> 	min_range = <span class="number">0.0f</span>,</span><br><span class="line"><span class="type">int</span> 	border_size = <span class="number">0</span> </span><br><span class="line">)		</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Create the depth image from a point cloud.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameter EX:</span></span><br><span class="line"><span class="comment">point_cloud	the input point cloud</span></span><br><span class="line"><span class="comment">angular_resolution	the angular difference (in radians) between the individual pixels in the image</span></span><br><span class="line"><span class="comment">max_angle_width	an angle (in radians) defining the horizontal bounds of the sensor</span></span><br><span class="line"><span class="comment">max_angle_height	an angle (in radians) defining the vertical bounds of the sensor</span></span><br><span class="line"><span class="comment">sensor_pose	an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )</span></span><br><span class="line"><span class="comment">coordinate_frame	the coordinate frame (defaults to CAMERA_FRAME)</span></span><br><span class="line"><span class="comment">noise_level	- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.</span></span><br><span class="line"><span class="comment">min_range	the minimum visible range (defaults to 0)</span></span><br><span class="line"><span class="comment">border_size	the border size (defaults to 0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="从深度图像提取边界"><a href="#从深度图像提取边界" class="headerlink" title="从深度图像提取边界"></a>从深度图像提取边界</h3><ul>
<li>边界：前景跨越到背景的位置</li>
<li>物体边界（黑）、阴影边界（绿）、Veil 点集（红）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\range_image_border_points.png" alt="边界点集分类"></p>
<ul>
<li>若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘</li>
</ul>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li><p>兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集</p>
</li>
<li><p>数量比原始点云或图像的数据量小很多</p>
</li>
<li><p>组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性</p>
</li>
<li><p>利于加快后续的处理速度</p>
</li>
</ul>
<h3 id="关键概念及算法"><a href="#关键概念及算法" class="headerlink" title="关键概念及算法"></a>关键概念及算法</h3><h4 id="NARF-关键点"><a href="#NARF-关键点" class="headerlink" title="NARF 关键点"></a>NARF 关键点</h4><p>*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608.</p>
<ul>
<li>从深度图像识别物体</li>
<li>步骤<ul>
<li>遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测；</li>
<li>遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向；</li>
<li>根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定；</li>
<li>对兴趣值进行平滑过滤；</li>
<li>进行无最大值压缩找到最终的关键点，即为 NARF 关键点。</li>
</ul>
</li>
<li>简化步骤*<ul>
<li>给定深度图像，进行边缘提取</li>
<li>表面变化基于边界和曲率原则”评分“</li>
<li>设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多</li>
</ul>
</li>
</ul>
<h4 id="Harris关键点"><a href="#Harris关键点" class="headerlink" title="Harris关键点"></a>Harris关键点</h4><ul>
<li>通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点</li>
<li>若 Harris 矩阵特征的两个特征值都很大，则为关键点</li>
<li>对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测</li>
<li>3D Harris 关键点检测使用的是<code>点云表面法向量的信息</code>（2D 使用的是图像梯度）</li>
</ul>
<h4 id="PCL-中的-keypoints"><a href="#PCL-中的-keypoints" class="headerlink" title="PCL 中的 keypoints"></a>PCL 中的 keypoints</h4><h5 id="深度图像提取-NARF-关键点"><a href="#深度图像提取-NARF-关键点" class="headerlink" title="深度图像提取 NARF 关键点"></a>深度图像提取 NARF 关键点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RangeImageBorderExtractor range_image_border_extractor;			<span class="comment">// 创建对象，用于边缘提取</span></span><br><span class="line"><span class="function">pcl::NarfKeypoint <span class="title">narf_keypoint_detector</span><span class="params">(&amp;range_image_border_extractor)</span></span>; <span class="comment">// 创建对象，传入上述提取出的深度图像边缘</span></span><br><span class="line">narf_keypoint_detector.<span class="built_in">setRangeImage</span>(&amp;range_image);					   <span class="comment">// 传入深度图像</span></span><br><span class="line">narf_keypoint_detector.<span class="built_in">getParameters</span>().support_size = support_size;	    <span class="comment">// 设置支持范围(搜索空间球体的半径，邻域范围)</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;</span></span><br><span class="line">pcl::PointCloud&lt;<span class="type">int</span>&gt; keypoint_indices;								<span class="comment">// 创建点云对象，存储检测到的点云</span></span><br><span class="line">narf_keypoint_detector.<span class="built_in">compute</span>(keypoint_indices);	 				 <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure>
<h5 id="SIFT-关键点提取"><a href="#SIFT-关键点提取" class="headerlink" title="SIFT 关键点提取"></a>SIFT 关键点提取</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dcrmg/article/details/52561656">参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43653930/article/details/104651907?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-5&amp;spm=1001.2101.3001.4242">参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40293648/article/details/82836998">参考：SIFT（3）——-尺度空间极值检测_姗姗本人的博客-CSDN博客</a></p>
<p>注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\sift算子-DOG尺度空间.png" alt="DOG尺度空间关键点确定"></p>
<p>​           ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\DOG尺度空间关键点方向确定.png" alt="关键点方向确定"></p>
<p>​            ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\DOG尺度空间关键点描述子.png" alt="关键点描述子" style="zoom:67%;" /></p>
<ul>
<li><p>尺度不变性</p>
</li>
<li><p>局部特征描述子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift;	<span class="comment">// 创建sift关键点检测对象</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointWithScale&gt; result;			  <span class="comment">// 存储查询结果</span></span><br><span class="line">sift.<span class="built_in">setInputCloud</span>(cloud_xyz);							 <span class="comment">// 设置输入点云</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">sift.<span class="built_in">setSearchMethod</span>(tree);							<span class="comment">// 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象</span></span><br><span class="line"><span class="comment">// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快</span></span><br><span class="line">sift.<span class="built_in">setScales</span>(min_scale, n_octaves, n_scales_per_octave); <span class="comment">// 设置限制关键点检测的阈值</span></span><br><span class="line">sift.<span class="built_in">compute</span>(result);								    <span class="comment">// 执行sift关键点检测，保存结果在result</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setScales 函数原型</span></span><br><span class="line"><span class="type">void</span> pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::<span class="built_in">setScales</span>	(	<span class="type">float</span> 	min_scale,</span><br><span class="line"><span class="type">int</span> 	nr_octaves,</span><br><span class="line"><span class="type">int</span> 	nr_scales_per_octave </span><br><span class="line">)	</span><br><span class="line">   用于指定搜索关键点的尺度范围 </span><br><span class="line"><span class="comment">// Specify the range of scales over which to search for keypoints.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters</span></span><br><span class="line">   			   设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）</span><br><span class="line"><span class="comment">// min_scale	the standard deviation of the smallest scale in the scale space</span></span><br><span class="line">			   高斯金字塔中组（octaves）的数目</span><br><span class="line"><span class="comment">// nr_octaves	the number of otaves (i.e. doublings of scale) to compute</span></span><br><span class="line">    				   每组计算的尺度数目</span><br><span class="line"><span class="comment">// nr_scales_per_octave	the number of scales to compute within each octave</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\高斯金字塔sift算子关键点.png" alt="高斯金字塔sift算子关键点" style="zoom: 50%;" /></p>
</li>
</ul>
<h5 id="Harris-关键点提取"><a href="#Harris-关键点提取" class="headerlink" title="Harris 关键点提取"></a>Harris 关键点提取</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//harris_detector-&gt;setNonMaxSupression(true);</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">setRadius</span>(r_normal);			<span class="comment">// 设置法向量估计的半径</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">setRadiusSearch</span>(r_keypoint);	<span class="comment">// 设置关键点估计的近邻搜索半径</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">setInputCloud</span> (input_cloud);</span><br><span class="line"><span class="comment">//harris_detector-&gt;setNormals(normal_source);</span></span><br><span class="line"><span class="comment">//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);</span></span><br><span class="line">harris_detector-&gt;<span class="built_in">compute</span> (*Harris_keypoints);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Harris_keypoints的大小是&quot;</span>&lt;&lt;Harris_keypoints-&gt;<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">writer.<span class="built_in">write</span>&lt;pcl::PointXYZI&gt; (<span class="string">&quot;Harris_keypoints.pcd&quot;</span>,*Harris_keypoints,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="特征描述与提取"><a href="#特征描述与提取" class="headerlink" title="特征描述与提取"></a>特征描述与提取</h2><h3 id="特征描述"><a href="#特征描述" class="headerlink" title="特征描述"></a>特征描述</h3><ul>
<li>局部特征描述 + 全局特征描述</li>
</ul>
<h3 id="特征描述子"><a href="#特征描述子" class="headerlink" title="特征描述子"></a>特征描述子</h3><p>三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有<strong>形状描述子（shape descriptors）</strong>、<strong>几何特征（gometric features）</strong>、<strong>点特征表示（point feature representations）</strong>等。</p>
<h4 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文 P23，37）</p>
<p>给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为：</p>
<script type="math/tex; mode=display">
||p_i^k-p_q||_x \leq d_m \tag{1.1}</script><p>式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/skybirdhua1989/article/details/17584797">范数</a>）。</p>
<p>此外，$P^k$ 中近邻点的个数可被限制为给定值 k。</p>
<p>点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围：</p>
<script type="math/tex; mode=display">
F(p_q,P^k)=\{x_1,x_2,···,x_n\}</script><p>式中，$x_i$ , $i \in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。</p>
<p>比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\Gamma$ 为描述这两点之间差异的<strong>相似性度量</strong>，$d$ 为<strong>距离度量</strong>，则有：</p>
<script type="math/tex; mode=display">
\Gamma = d(F_1,F_2)</script><p>当 $d$ 趋向于某个最小值时，即 $d \to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。</p>
<p><em>个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。</em></p>
<p>通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。</p>
<p>理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣：</p>
<ul>
<li>刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有<strong>旋转平移不变性</strong></li>
<li>不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有<strong>抗密度干扰性</strong></li>
<li>噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有<strong>鲁棒性</strong></li>
</ul>
<p><em>也就是说，一个点特征表示满足上述条件才可以说是好的表示法</em></p>
<h4 id="邻域的概念"><a href="#邻域的概念" class="headerlink" title="邻域的概念"></a>邻域的概念</h4><p>确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方：</p>
<script type="math/tex; mode=display">
||X||_2 = \sqrt{\sum_{i=1}^n x_i^2}</script><p><em>可用于度量两个向量间的差异</em>，如平方差和：</p>
<script type="math/tex; mode=display">
SSD(x_1,x_2) = \sum_{i=1}^n(x_{1i}-x_{2i})^2</script><p>也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。</p>
<p>但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。</p>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><h4 id="输入点云的调用"><a href="#输入点云的调用" class="headerlink" title="输入点云的调用"></a>输入点云的调用</h4><ul>
<li><p>输入点云调用函数主要有：</p>
<ul>
<li>setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量</li>
<li>setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算</li>
<li><p>setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间</p>
</li>
<li><p>后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208）</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\features_input_explained.png" alt="输入点云调用习惯">                </p>
<ul>
<li>经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。</li>
</ul>
</li>
</ul>
<h4 id="估计点云的表面法线"><a href="#估计点云的表面法线" class="headerlink" title="估计点云的表面法线"></a>估计点云的表面法线</h4><p>（详见博士论文 P45）</p>
<ul>
<li><p>描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线</p>
</li>
<li><p>一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②<code>直接从点云数据集中近似推断表面法线</code></p>
</li>
<li><p>对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中估计一点集对应的协方差矩阵</span></span><br><span class="line">Eigen::Matrix3f covariance_matrix;	<span class="comment">// 定义每个表面小块的 3×3 协方差矩阵的存储对象</span></span><br><span class="line">Eigen::Vector4f xyz_controid;		<span class="comment">// 定义一个表面小块的质心坐标16字节对其存储对象</span></span><br><span class="line"><span class="built_in">compute3DCentroid</span>(cloud, xyz_controid);	<span class="comment">// 估计质心坐标</span></span><br><span class="line"><span class="built_in">computeCovarianceMatrix</span>(cloud, xyz_controid, covariance_matrix);	<span class="comment">// 计算 3×3 协方差矩阵</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一个平面可用一个点 $x$ 和 一个法向量 $\overline n$ 表示，则一个点 $p_i \in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \overline n$ 。 $x$ 和  $\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？）</p>
<p>设</p>
<script type="math/tex; mode=display">
x = \overline p = \frac{1}{k}· \sum_{i=1}^{k}p_i</script><p>为 $P^k$ 的质心，而 $\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \in R^{3 \times 3}$ 的特征值和特征向量得到，其表达式如下：</p>
<script type="math/tex; mode=display">
C = \frac{1}{k} \sum_{i=1}^{k} \xi_i · (p_i - \overline p)·(p_i - \overline p)^T , \ C· \overline v_i = \lambda_i· \overline v_j ,  \  j \in \{0,1,2\}</script><p>式中，$\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\lambda_j \in R$ ，特征向量 $\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \le \lambda_0 \le \lambda_1 \le \lambda_2$ ，则特征向量 $\overline v_0$ 对应的最小特征值 $\lambda_0$ 就是 $+ \overline n = {n_x,n_y,n_z}$ 或 $ - \overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\overline n$ 可由球坐标中的一对角 $(\phi,\theta)$ 表示如下：</p>
<script type="math/tex; mode=display">
\phi = \arctan \frac{n_z}{n_y}, \ \theta =  \arctan\frac{\sqrt{(n_y^2+n_z^2)}}{n_x}</script><p>问题是，这种主成分分析法（PCA）对方向仍然是模糊的。</p>
<h4 id="表面曲率"><a href="#表面曲率" class="headerlink" title="表面曲率"></a>表面曲率</h4><p>（详见博士论文P48）</p>
<p>方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\lambda_0 = min(\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\overline n$ 的变化可使用下式估计：</p>
<script type="math/tex; mode=display">
\sigma_p = \frac{\lambda_0}{\lambda_0+\lambda_1+\lambda_3}</script><p> 该最小特征值与特征值之和的比值 $\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。</p>
<p>source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998</p>
<h4 id="法线的定向问题"><a href="#法线的定向问题" class="headerlink" title="法线的定向问题"></a>法线的定向问题</h4><ul>
<li><p>没有数学方法可以解决法线的正负向问题</p>
</li>
<li><p>法线球体描述了点云中所有法线的方向</p>
</li>
<li><p>对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）</span></span><br><span class="line"><span class="built_in">flipNormalTowardsViewpoint</span>	(	<span class="type">const</span> PointCloud &amp; 	cloud,</span><br><span class="line"><span class="type">float</span> 	vp_x,</span><br><span class="line"><span class="type">float</span> 	vp_y,</span><br><span class="line"><span class="type">float</span> 	vp_z,</span><br><span class="line">Normals &amp; 	normals </span><br><span class="line">)	</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \cdot n_j = 1$。</li>
</ul>
<h3 id="点特征直方图（PFH）"><a href="#点特征直方图（PFH）" class="headerlink" title="点特征直方图（PFH）"></a>点特征直方图（PFH）</h3><p>（详见博士论文P51和PCL书P213）</p>
<p>bin 可理解为分格的大小，就是直方图每一个柱子的宽度</p>
<h4 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h4><p>通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。</p>
<p>一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。</p>
<p>为形成新的特征空间，引入 <em>双环邻域</em>  的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \in P$ 有双环邻域的条件是：</p>
<script type="math/tex; mode=display">
(\exists)r_1,r_2 \in R, \ r_1 <r_2,  \ \begin{cases} r_1  \Rightarrow P^{k_1} \\ r_2 \Rightarrow P^{k_2}\end{cases}, \ 0<k_1<k_2</script><p>两个半径 $r_1$ 和 $r_2$ 用于确定点 $p_i$ 的两个不同的特征表示层：第一层表示的是查询点处的法线，从邻域集 $p^{k_1}$ 的主成分分析中获得，第二层即为 PFH。</p>
<p>PFH 是基于 $P_{k_2} $ 中的点及其法线之间的关系的，即通过参数化查询点与邻域点之间的空间差异，形成一个多维直方图对点的 k 邻域几何属性进行描述。直方图所在的高维超空间为特征表示提供了一个可度量的信息空间，对点云对应曲面的 6 维姿态来说它具有不变性，并且在不同的采样密度或邻域的噪音等级下具有鲁棒性。简言之，<strong>它考虑估计法线方向之间所有的相互作用，来尽可能捕获采样表面的变化</strong>。故合成的超空间依赖于每个点表面法线估计的质量。（人话就是：PFH 结果的优劣，取决于法线估计的好坏，这也说明，计算 PFH 的第一步就是表面法线的估计）</p>
<p>为计算两点 $p<em>i$ 和 $p_j$ 之间的相对差以及它们的法线 $n_i$ 和 $n_j$，在其中一点上定义了一个固定的局部坐标系。为使坐标系被唯一定义，做如下规定： 令 $p</em>{ji} = p<em>j - p_i, \ p</em>{ij} = p_i - p_j$ ，</p>
<script type="math/tex; mode=display">
if \quad \arccos(\overline n_i \cdot \overline p_{ji}) \le \arccos(\overline n_j \cdot \overline p_{ij})
\\ then \begin{cases} p_s = p_i,\ n_s =n_i \\ p_t = p_j, \ n_t = n_j  \end{cases}
\\ else \begin{cases} p_s = p_j,\ n_s =n_j \\ p_t = p_i, \ n_t = n_i  \end{cases}</script><p>定义 $p_s$ 为源点，$p_t$ 为目标点，源点的选择使其法线与连接两点的直线之间的夹角最小。然后，可以在 $p_s$ 处将局部坐标系的原点定义为：</p>
<script type="math/tex; mode=display">
\begin{cases} u = n_s \\ v= u \times \frac{(p_t - p_s)}{||p_t - p_s||_2} \\ w = u \times v\end{cases}</script><p>在该 uvw 坐标系下，两个法线 $n_s$ 和 $n_t$ 之间的差可以表示为一组角度特征，如下:</p>
<script type="math/tex; mode=display">
\begin{cases} \alpha = v \cdot n_t \\ \phi = u \cdot \frac{(p_t-p_s)}{d} \\ \theta = \arctan(w \cdot n_t,u \cdot n_t)\end{cases}</script><p>式中，d 为欧氏距离，$d= ||p_t-p_s||_2$ 。</p>
<p>这样，就只需计算近邻点集 $P^{k_2}$ 中每一对点的特征组成的四个参数 $&lt;\alpha,\phi,\theta,d&gt;$ （将其称为四元组），将原来的12（一个点有 $x,y,z,n_x,n_y,n_z$ (坐标及法线)）个参数减少到了4个。(在一般的实际问题中，d 往往不计在内，实验证明，不计在内效果更好)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\PFH局部坐标系.png" alt="PFH坐标系"></p>
<p>下图是计算查询点 $p_q$ 的 PFH 时的影响区域图，查询半径（图中虚线，2D 中圆，3D中球）为 $r$ ，可见其 k 近邻点用网格完全互连。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\PFH区域影响图.png" alt="PFH影响区域图"></p>
<p>为创建查询点 $p_i$ 的 PFH 表示，先将所有的四元组放进直方图，这个过程将每个特征的取值范围划分为 b 个子区域，并统计每个子区间中的特征出现次数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每一对点估计 PFH 四元组</span></span><br><span class="line"><span class="built_in">computePairFeatures</span> (<span class="type">const</span> pcl::PointCloud&lt;PointInT&gt; &amp; cloud, <span class="type">const</span> pcl::PointCloud&lt; PointNT &gt; &amp; normals,</span><br><span class="line"><span class="type">int</span> 	p_idx,</span><br><span class="line"><span class="type">int</span> 	q_idx,</span><br><span class="line"><span class="type">float</span> &amp; 	f1,</span><br><span class="line"><span class="type">float</span> &amp; 	f2,</span><br><span class="line"><span class="type">float</span> &amp; 	f3,</span><br><span class="line"><span class="type">float</span> &amp; 	f4 </span><br><span class="line">)		</span><br><span class="line">Compute the <span class="number">4</span>-tuple representation containing the three angles <span class="keyword">and</span> one distance between two points represented by Cartesian coordinates <span class="keyword">and</span> normals.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters 参照上图的坐标系理解</span></span><br><span class="line">[in]	cloud	the dataset containing the XYZ Cartesian coordinates of the two points <span class="comment">//输入点云</span></span><br><span class="line">[in]	<span class="function">normals	the dataset containing the surface <span class="title">normals</span> <span class="params">(assuming normalized vectors)</span> at each point in cloud <span class="comment">//法线</span></span></span><br><span class="line"><span class="function">[in]	p_idx	the index of the first <span class="title">point</span> <span class="params">(source)</span>  <span class="comment">// 源点</span></span></span><br><span class="line"><span class="function">[in]	q_idx	the index of the second <span class="title">point</span> <span class="params">(target)</span> <span class="comment">// 目标点</span></span></span><br><span class="line"><span class="function">[out]	f1	the first angular <span class="title">feature</span> <span class="params">(angle between the projection of nq_idx <span class="keyword">and</span> u)</span> <span class="comment">// θ</span></span></span><br><span class="line"><span class="function">[out]	f2	the second angular <span class="title">feature</span> <span class="params">(angle between nq_idx <span class="keyword">and</span> v)</span>					<span class="comment">// α</span></span></span><br><span class="line"><span class="function">[out]	f3	the third angular <span class="title">feature</span> <span class="params">(angle between np_idx <span class="keyword">and</span> |p_idx - q_idx|)</span>	 <span class="comment">// Φ</span></span></span><br><span class="line"><span class="function">[out]	f4	the distance <span class="title">feature</span> <span class="params">(p_idx - q_idx)</span>								  <span class="comment">// d 距离</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PFH 特征估计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the PFH estimation class, and pass the input dataset+normals to it</span></span><br><span class="line">pcl::PFHEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PFHSignature125&gt; pfh; <span class="comment">//125是3个角特征量，每个又分为5个区间，故5^3</span></span><br><span class="line"><span class="comment">// 这里的 125 是默认值，也就是直接忽略了 d 的</span></span><br><span class="line">pfh.<span class="built_in">setInputCloud</span> (cloud);</span><br><span class="line">pfh.<span class="built_in">setInputNormals</span> (normals);</span><br><span class="line"><span class="comment">// 若点云类型是 PointNormal, pfh.setInputNormals (cloud);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an empty kdtree representation, and pass it to the PFH estimation object.</span></span><br><span class="line"><span class="comment">// Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">pfh.<span class="built_in">setSearchMethod</span> (tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output datasets</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PFHSignature125&gt;::<span class="function">Ptr <span class="title">pfhs</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PFHSignature125&gt; ())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use all neighbors in a sphere of radius 5cm</span></span><br><span class="line"><span class="comment">// IMPORTANT: the radius used here has to be larger than the radius used to estimate the surface normals!!!</span></span><br><span class="line">pfh.<span class="built_in">setRadiusSearch</span> (<span class="number">0.05</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the features</span></span><br><span class="line">pfh.<span class="built_in">compute</span> (*pfhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pfhs-&gt;size () should have the same size as the input cloud-&gt;size ()*，即每个点对应一个 PFH特征向量</span></span><br><span class="line"><span class="comment">// 实质上，该函数只是执行了以下步骤：</span></span><br><span class="line">对点云 P 中的每个点 p</span><br><span class="line">（<span class="number">1</span>）得到p点的最近邻元素</span><br><span class="line">（<span class="number">2</span>）对于邻域内的每对点，计算其三个角度特征参数值</span><br><span class="line">（<span class="number">3</span>）将所有结果统计到一个输出直方图中</span><br></pre></td></tr></table></figure>
<h3 id="快速点特征直方图（FPFH）"><a href="#快速点特征直方图（FPFH）" class="headerlink" title="快速点特征直方图（FPFH）"></a>快速点特征直方图（FPFH）</h3><p>PFH 在计算中的复杂度用大O表示法表示的话为 $O(n k^2)$ ，不利于实时应用，需优化，FPFH 将复杂度降低为 $O(nk)$ ，同时保留了前者的识别特性。</p>
<h4 id="理论-3"><a href="#理论-3" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文P57和PCL书P217）</p>
<p>首先，对每个查询点 $p_q$ ，计算该点及其近邻点的元组 $&lt;\alpha,\phi,\theta&gt;$ ，这一步称为简化点特征直方图（SPFH），图中红线表示；</p>
<p>接着，重新确定每个点（这个点已经是 $p_q$ 的近邻点）的 k 近邻点，使用近邻点的 SPFH 值作为权重计算查询点 $p_q$ 的最终直方图，即为 FPFH：</p>
<script type="math/tex; mode=display">
FPFH(p_q) = SPFH(p_q) + \frac{1}{k} \sum_{i=1}^{k} \frac{1}{\omega_k} \cdot SPFH(p_k)</script><p>式中，权重 $\omega_k$ 表示在给定的度量空间中，查询点 $p_q$ 与近邻点 $p_k$ 之间的距离，用于评价点对 $(p_q,p_k)$ ，其影响区域图如下士，每个查询点(红色)只与它的k近邻点(由灰色圈包围)相连。每个直接近邻点又与自己的近邻点相连，所得到的直方图与查询点的直方图进行加权，形成FPFH。用粗线画出的是对 FPFH 计算了两次。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\FPFH区域影响图.png" alt="FPFH区域影响图"></p>
<p>人话翻译：确定一个查询点，接着找出该查询点的近邻点，计算其参数元组（三个角度参数），（这个过程为 SPFH）然后对找到的所有近邻点，重新作为查询点，找到其近邻点，计算其 SPFH，然后使用上式进行加权，得到 FPFH。</p>
<p>关于 FPH 和 FPFH 的区别，这里略。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>与 FPH 不同的是，FPFHEstimation 类的默认特征是将四个角特征量每个分为11个区间，分别计算后合并，形成有 33 个元素的特征向量。</p>
<h2 id="点云配准"><a href="#点云配准" class="headerlink" title="点云配准"></a>点云配准</h2><ul>
<li>各个视角得到的点集合并到一个统一的坐标系下，形成完整的点云数据的过程 / 操作</li>
<li>实质：不同坐标系中测到点云之间的<code>坐标变换</code> （寻找 R T 的过程）(==错==)</li>
<li>实质是：同一坐标系下不同视角的点云之间的配准，即测量设备始终是同一个，得到的点云在同一个坐标下</li>
</ul>
<p>点云配准的过程是一个寻找刚性变换矩阵的过程，对于两个点云，一个为源点云 $P_s$ ，另一个为目标点云 $P_t$ ，将源点云通过一定的旋转（R）和平移（t）与目标点云配准（就是让它们完全重合），这个过程可表述为：</p>
<script type="math/tex; mode=display">
P_t = P_s \cdot R + t</script><h3 id="一对点云的配准（两两配准）"><a href="#一对点云的配准（两两配准）" class="headerlink" title="一对点云的配准（两两配准）"></a>一对点云的配准（两两配准）</h3><ul>
<li>应用一个估计得到一个变换矩阵（R T）使两者完美配准</li>
<li>步骤：<ul>
<li><strong>从两个点云提取关键点，注意使用相同的标准</strong></li>
<li><strong>对所有关键点建立其特征描述子</strong></li>
<li>估计对应关系，结合特征描述子在两个数据集中的坐标位置等进行</li>
<li>如含噪声，则去除对配准有影响的对应点</li>
<li>用剩下的正确点对估计刚体变换，完成配准</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\block_diagram_single_iteration.jpg" alt="一对点云配对" style="zoom: 67%;" /></p>
<h3 id="对应估计"><a href="#对应估计" class="headerlink" title="对应估计"></a>对应估计</h3><ul>
<li>找到相似特征，确定数据重叠部分，进行配准</li>
<li>使用不同方法来搜索特征之间的对应关系<ul>
<li>点匹配（即只使用xyz坐标作为特征值）：穷举配准、k-d tree 最近邻查询、有序点云的图像空间查找、无序点云的索引空间查找</li>
<li>特征匹配（如法向量、形状直方图等）：穷举配准、k-d tree 最近邻查询</li>
</ul>
</li>
<li>分类<ul>
<li>直接对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点，确认为最终的对应点对（这是默认的估计方式）</li>
<li>相互对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点；接着对对点云 B 中的每个点，都找到其在点云 A 中的对应点，然后取它们的交集作为最终的对应点对</li>
</ul>
</li>
</ul>
<h3 id="错误对应关系的去除"><a href="#错误对应关系的去除" class="headerlink" title="错误对应关系的去除"></a>错误对应关系的去除</h3><p>实际中存在着噪声等影响，会导致产生的对应关系不一定是正确的（就是虽然算法找到了对应点对，但其在实际中可能并不是对应的），这些会对最终变换矩阵的估算产生影响，须去除它们，可以提高配准精度和速度。</p>
<p>去除方法：随机采样一致性（RANSAC）等</p>
<p>一对多 的情况：只取距离最近的对应点</p>
<h3 id="ICP算法"><a href="#ICP算法" class="headerlink" title="ICP算法"></a>ICP算法</h3><h4 id="理论-4"><a href="#理论-4" class="headerlink" title="理论"></a>理论</h4><p>无序点云最经典的配准算法——ICP 算法（ Iterative Closest Point ）：通过最小化重叠区域之间的欧氏距离误差度量，来寻找两数据集之间的最优变换。ICP 算法假定两数据集的每个点都有相应的匹配，并使用待匹配与模型之间最近的点做对应。但问题是，两个点云之间不可能是完全的一一对应关系，所以要建立稳定的对应关系显得尤为重要。</p>
<p>ICP 的核心是不断的去寻找源点云和目标点云中点对的最小距离，并不断缩小这个距离，对变换后的点云继续重复该过程，也就是迭代的过程；该过程用数学表达就是求出 R 和 t ,使误差函数取得最小值：</p>
<script type="math/tex; mode=display">
E(R,t) = \frac{1}{n} \sum_{i=1}^{n} ||P_t^i -(R \cdot P_s^i+t)||^2</script><p>式中，n 是点对的个数，也就是说，这个目标函数是所有点对之间的欧氏距离的平方和。</p>
<p>==ICP 选择点对原则：对于源点云中的每个点，其对应点是目标点云中的最近邻点（按欧氏距离计算）==</p>
<p>主要步骤：[1]解则晓, 徐尚. 三维点云数据拼接中ICP及其改进算法综述[J]. 中国海洋大学学报(自然科学版).</p>
<ul>
<li>对原始点云数据采样</li>
<li>确定初始对应点集</li>
<li>去除错误对应点对</li>
<li>求解坐标变换</li>
</ul>
<p>ICP的主要问题在于搜索近邻点，这个过程耗时严重，为加速该过程，一般将目标点云存储到 k-d tree 结构中。</p>
<h4 id="简单ICP代码"><a href="#简单ICP代码" class="headerlink" title="简单ICP代码"></a>简单ICP代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp; <span class="comment">// 创建	ICP 对象</span></span><br><span class="line">icp.<span class="built_in">setInputSource</span>(cloud_in);	<span class="comment">// 设置一个输入点云作为 源点云</span></span><br><span class="line">icp.<span class="built_in">setInputTarget</span>(cloud_out);	<span class="comment">// 设置一个输入点云作为 目标点云</span></span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt; Final;	<span class="comment">// 存储最终的匹配结果</span></span><br><span class="line">icp.<span class="built_in">align</span>(Final);					  <span class="comment">// 执行匹配</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;has converged:&quot;</span> &lt;&lt; icp.<span class="built_in">hasConverged</span>() &lt;&lt; <span class="string">&quot; score: &quot;</span> &lt;&lt; <span class="comment">// 匹配是否正确，返回值为 1 则为正确</span></span><br><span class="line">	icp.<span class="built_in">getFitnessScore</span>() &lt;&lt; std::endl;							<span class="comment">// 理解为对 配准的评分		</span></span><br><span class="line">std::cout &lt;&lt; icp.<span class="built_in">getFinalTransformation</span>() &lt;&lt; std::endl;			<span class="comment">// 获取转换矩阵</span></span><br></pre></td></tr></table></figure>
<h4 id="逐步匹配多幅点云"><a href="#逐步匹配多幅点云" class="headerlink" title="逐步匹配多幅点云"></a>逐步匹配多幅点云</h4><p>按输入的顺序两两匹配，得到最终的效果，结果是最终转换到第一个点云的坐标系下</p>
<h4 id="交互式ICP"><a href="#交互式ICP" class="headerlink" title="交互式ICP"></a>交互式ICP</h4><p>通过可视化界面实现用户敲空格键时，进行配准，需在内部设置 ICP 迭代次数</p>
<p><a target="_blank" rel="noopener" href="https://pcl.readthedocs.io/projects/tutorials/en/latest/interactive_icp.html#interactive-icp">详见Interactive Iterative Closest Point — Point Cloud Library 0.0 documentation (pcl.readthedocs.io)</a></p>
<h3 id="正态分布变换配准（NDT）"><a href="#正态分布变换配准（NDT）" class="headerlink" title="正态分布变换配准（NDT）"></a>正态分布变换配准（NDT）</h3><ul>
<li>适用于大型点云数据集</li>
<li>配准过程不使用对应点的特征计算及匹配，速度快</li>
<li>NDT 算法中，在目标点云对应的体素网格数据结构的统计计算中不使用单个点，而是使用包含在每个体素单元格中的点的统计数据</li>
<li>使用体素化数据结构 + More-Thuente 搜索</li>
</ul>
<p>NDT 核心：</p>
<ul>
<li><p>将空间划分为网格（2D 中为正方形，3D 中为立方体）</p>
<p>基于网格内的点分布，计算每个网格的概率密度分布（PDF）。每个网格中的 PDF 可理解为每个网格内曲面上的点 $\overline x$ 的生成过程；也就是说，假设 $\overline x$ 的位置是由 D 维的正态随机过程生成的</p>
</li>
</ul>
<h4 id="理论-5"><a href="#理论-5" class="headerlink" title="理论"></a>理论</h4><p>（详见：Magnusson M. The three-dimensional normal-distributions transform: an efficient representation for registration, surface analysis, and loop detection[D]. Örebro universitet, 2009. 从P55开始</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/banzhuan133/article/details/103350049?spm=1001.2014.3001.5501">两种常见的点云配准方法ICP&amp;NDT_banzhuan133的博客-CSDN博客_ndt点云配准</a>）</p>
<p>对于一个随机（多维）变量，若其满足正态分布，则其对应的 PDF 为：（对应于点云：将目标点云网格化，然后计算每个网格内的多维正态分布）</p>
<script type="math/tex; mode=display">
p(\vec{x}) = \frac{1}{(2 \pi)^{D/2} \sqrt{\Sigma}} exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1} (\vec{x}-\vec{\mu})}{2})</script><p>式中，$\vec{\mu}$ 为均值向量，$\Sigma$ 为协方差矩阵（对角元素为每个变量的方差，非对角元素为协方差），$D$ 为维数。</p>
<p>$\vec{\mu}$ 和 $\Sigma$ 可单独计算：</p>
<script type="math/tex; mode=display">
\vec{\mu} = \frac{1}{m} \sum_{k=1}^{m} \vec{y_k} \\
\quad \quad \quad \quad \quad \quad \quad \quad\Sigma = \frac{1}{m-1} \sum_{k=1}^{m}    (\vec{y_k}-\vec{\mu})(\vec{y_k}-\vec{\mu})^T</script><p>式中的 $\vec{y}_{1, \cdots ,m}$ 表示一个网格中所有的点。（也就是说，上式中的 $p(\vec{x})$ 实质是计算每个网格的 PDF ）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\NDT体素格.png" alt="NDT网格化" style="zoom:50%;" /></p>
<p>使用正态分布表示离散点云的优势在于：正态分布是对点云的分段（分块表示，网格）平滑表示，具有连续的导数；每个 PDF 可看作是局部表面的一种近似，描述了该表面的位置、方向、平滑度。在 2D 或 3D 中 ，表面方向和平滑度可用协方差矩阵的特征向量和特征值表示。对于三维的正态分布，随着 $\Sigma$ 的特征值变化，有着不同的形状（图中箭头表示特征向量，长短表示其特征值的大小）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\Differ shape of 3D PDF.png" alt="3D 正态分布下的不同形状"></p>
<h4 id="NDT-配准"><a href="#NDT-配准" class="headerlink" title="NDT 配准"></a>NDT 配准</h4><p>NDT 的配准目标是找到一个源点云的姿态，使源点云中的点位于目标点云平面上的可能性最大。（△）</p>
<p>若源点云为 $\chi = { \vec{x_1}, \cdots , \vec{x_n} }$ ，其姿态变换（R，T）用一个向量 $\vec{p}$ 表示；假设空间变换函数 $T(\vec{p},\vec{x})$ 表示使用姿态变换 $\vec{p}$ 来移动点 $\vec{x}$ ；另外给定源点云的 $PDF \quad p(\vec{x})$ ，则最优位姿 $\vec{p}$ 应是使似然函数最大化：</p>
<script type="math/tex; mode=display">
\Psi = \prod_{k=1}^{n} p(T(\vec{p}, \vec{x}_k))</script><p>其等价于最小化 $\Psi$ 的负对数似然函数（连乘转对数的和）：</p>
<script type="math/tex; mode=display">
-log\Psi  = - \sum_{k=1}^{n} log(p(T(\vec{p},\vec{x}_k)))</script><p>式中的函数 $p$ 即为上述提到的 $PDF \quad  p(\vec{x})$ 。此外，PDF 也不一定是一个正态分布（只要可以局部捕获表面点结构，且对异常值具有鲁棒性即可）（详见P59）。</p>
<p><em>这也再次说明了我们的第一句话（△）：目的就是找到这个最优的  $\vec{p}$ ，以最大化似然函数（目标函数）</em></p>
<p>目标很明确，就是优化这个位姿参数，NDT 使用 牛顿迭代法进行优化（见后续）。</p>
<p>问题是，负对数似然函数在远离均值的点上呈无限增长的趋势（见P59 图6.5b或下图)，故若数据中存在噪声等异常值，会对其结果产生较大的影响，有人提出了<strong>正态分布与均匀分布结合（$\overline p(\vec{x})$）</strong>的方式：</p>
<script type="math/tex; mode=display">
\overline p(\vec{x}) = c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2p_0</script><p>式中，$p_0$ 为异常值的期望值。利用这个函数，离群值的影响是有限的。常数 $c_1$ 和 $c_2$ 可以通过要求在单元格所跨越的空间内 $\overline p(\vec{x})$ 的概率质量等于1来确定。</p>
<p>另一个问题是，这种结合的方式没有简单的一阶和二阶导数（其实就是 log 函数求导不方便）；观察负对数似然函数（下图右绿色示），可发现其与高斯函数相像（下图左绿色示），故可用高斯函数来近似上述 $\overline p(\vec{x})$  。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\likelihood.png" alt="likelihood" style="zoom: 67%;" /></p>
<p>$\overline p(\vec{x})$ 对应的 log 形式为（这里 $c_2p_0$ 只剩 $c_2$ ，个人理解为其是一个期望值，是常数，可用一个代替？）：</p>
<script type="math/tex; mode=display">
-\log (c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2)</script><p>函数形式为</p>
<script type="math/tex; mode=display">
\overline p(x) = - \log(c_1 exp(\frac{-x^2}{2 \sigma ^2}) + c_2)</script><p>的函数可用形式如下的高斯函数近似：</p>
<script type="math/tex; mode=display">
\tilde{p}(x) = d_1 exp(\frac{-d_2 x^2}{2 \sigma^2}) + d_3</script><p>当 $x=1，x=\sigma，x = \infty$ 时，$\overline p(x)$ 应与 $\tilde p(x)$ 相等，以此来拟合 $d_i$ ：</p>
<script type="math/tex; mode=display">
d_3 = - \log(c_2) \\
d_1 = - \log(c_1 + c_2) -d_3 \\
d_2 = -2 \log(\frac{-\log(c_1 e^{- \frac{1}{2}} + c_2 -d_3)} {d_1})</script><p>如此，源点云中的一点对 NDT 评分函数的影响可用高斯函数近似为：</p>
<script type="math/tex; mode=display">
\tilde p(\vec{x}_k) = -d_1 exp(- \frac{d_2}{2} (\vec{x}_k - \vec{\mu}_k)^T \Sigma_k^{-1} (\vec{x}_k - \vec{\mu}_k))</script><p>这里忽略了常数 $d_3$ ，因其只是对评分函数进行了一个偏移，但并不影响其形状或参数。</p>
<p>到此，目标函数变为：</p>
<script type="math/tex; mode=display">
s(\vec{p}) = - \sum_{k=1}^{n} \tilde{p}(T(\vec{p},\vec{x}_k))</script><p><em>所以上述过程就是将源点云的 PDF $p(x)$ 用  $\tilde{p}(x)$ 近似的过程，最后得到的近似表示如上</em></p>
<p>可以看出，似然函数需要求 $\Sigma^{-1}$ ，但若网格内的点是完全共面或共线，则 $\Sigma$ 是奇异的，无法求逆（详见P60）。</p>
<p>位姿参数 $\vec{p}$ 可用牛顿迭代法求解，其方程为：</p>
<script type="math/tex; mode=display">
H \Delta \vec{p} = - \vec{g}</script><p>式中，$H$ 为海森矩阵，$\vec{g}$ 为 $s(\vec{p})$ 的梯度向量，$\Delta \vec{p}$ 在每次迭代过程中加到当前的位姿估计中，即 $\vec{p} \leftarrow \vec{p} + \Delta \vec{p}$ 。 （具体求解详见P61)</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在 NDT 配准前需要进行滤波处理，这里使用体素中心网格法</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">filtered_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::ApproximateVoxelGrid&lt;pcl::PointXYZ&gt; approximate_voxel_filter;</span><br><span class="line">approximate_voxel_filter.<span class="built_in">setLeafSize</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>);</span><br><span class="line">approximate_voxel_filter.<span class="built_in">setInputCloud</span>(input_cloud);</span><br><span class="line">approximate_voxel_filter.<span class="built_in">filter</span>(*filtered_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NDT 参数初始化</span></span><br><span class="line">pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;	</span><br><span class="line">ndt.<span class="built_in">setTransformationEpsilon</span>(<span class="number">0.01</span>);<span class="comment">//设置变换的ε：两个连续的变换(迭代)之间允许的最大差值，用于判断优化过程是否达到最终的阈值</span></span><br><span class="line">ndt.<span class="built_in">setStepSize</span>(<span class="number">0.1</span>);	<span class="comment">//牛顿法优化的最大步长（收敛速率系数，理解为什么时候终止？？）</span></span><br><span class="line">ndt.<span class="built_in">setResolution</span>(<span class="number">1.0</span>);	<span class="comment">//分辨率设置，也就是体素化网格的边长</span></span><br><span class="line">ndt.<span class="built_in">setMaximumIterations</span>(<span class="number">35</span>);	<span class="comment">//迭代的次数：达到该次数时停止</span></span><br><span class="line">ndt.<span class="built_in">setInputSource</span>(filtered_cloud);</span><br><span class="line">ndt.<span class="built_in">setInputTarget</span>(target_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化变换参数并执行优化</span></span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation</span><span class="params">(<span class="number">0.6931</span>, Eigen::Vector3f::UnitZ())</span></span>;	<span class="comment">//初始位姿 R</span></span><br><span class="line"><span class="function">Eigen::Translation3f <span class="title">init_translation</span> <span class="params">(<span class="number">1.79387</span>, <span class="number">0.720047</span>, <span class="number">0</span>)</span></span>; <span class="comment">// T</span></span><br><span class="line">Eigen::Matrix4f init_guess = (init_translation * init_rotation).<span class="built_in">matrix</span>(); <span class="comment">//初始搜索位置</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">output_cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">ndt.<span class="built_in">align</span>(*output_cloud, init_guess);	<span class="comment">//执行配准</span></span><br></pre></td></tr></table></figure>
<h2 id="点云分割"><a href="#点云分割" class="headerlink" title="点云分割"></a>点云分割</h2><ul>
<li>根据空间、几何、纹理等特征对点云进行划分，使得同一划分内的点云具有相似的特征</li>
</ul>
<h3 id="聚类分割算法"><a href="#聚类分割算法" class="headerlink" title="聚类分割算法"></a>聚类分割算法</h3><ul>
<li>详见下一章——论文：聚类与分割</li>
<li>m 个数据，m 维空间内，定义点与点之间的某种性质的亲属聚类；若 m 个数据点构成 n 类，将具有最小距离的两类合为一类，然乎重新计算两类的之间的距离，如此迭代，直至两类之间的距离大于指定的阈值，或者类的个数少于指定的数目，完成分割。</li>
</ul>
<h3 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h3><ul>
<li>随机采样一致性<ul>
<li>从样本中随机抽取一个样本子集，使用最小方差估计法对自己进行模型参数的计算，再计算所有样本与该模型的偏差，将该偏差与设置好的阈值进行比较，若其小于设定的阈值，则为内点，否则为外点</li>
</ul>
</li>
<li>根据一组包含噪声、外点等缺陷的样本数据集，估计出数据的数学模型，同时得到有效的样本数据</li>
<li>参数<ul>
<li>$\tau$ ：误差容忍度，判断样本是否满足模型 M 的误差容忍度</li>
<li>$Max$ ：随机抽取样本集的次数（即抽取子集的次数）</li>
<li>$N$ ：指定的阈值</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">model_p</span><span class="params">(<span class="keyword">new</span> pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;(cloud))</span></span>;	<span class="comment">//定义为平面模型（还有其他模型）</span></span><br><span class="line"><span class="function">pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; <span class="title">ransac</span><span class="params">(model_p)</span></span>;	</span><br><span class="line">ransac.<span class="built_in">setDistanceThreshold</span>(<span class="number">.01</span>);	<span class="comment">//阈值设置</span></span><br><span class="line">ransac.<span class="built_in">computeModel</span>();	<span class="comment">//计算模型</span></span><br><span class="line">ransac.<span class="built_in">getInliers</span>(inliers);	<span class="comment">//获取内点</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Algorithm : RANSAC</span><br><span class="line">1) Initial: let A be a set of N feature correspondences</span><br><span class="line">2) repeat</span><br><span class="line">2.1) Randomly select a sample of s points from A</span><br><span class="line">2.2) Fit a model to these points</span><br><span class="line">2.3) Compute the distance of all other points to this model</span><br><span class="line">2.4) Construct the inlier set (i.e. count the number of points  whose distance from the model &lt; d)</span><br><span class="line">2.5) Store these inliers</span><br><span class="line">2.6) until maximum number of iterations reached</span><br><span class="line">3) The set with the maximum number of inliers is chosen as</span><br><span class="line">a solution to the problem</span><br><span class="line">4) Estimate the model using all the inliers</span><br></pre></td></tr></table></figure>
<h3 id="平面点云分割"><a href="#平面点云分割" class="headerlink" title="平面点云分割"></a>平面点云分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;	<span class="comment">//模型系数对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;	<span class="comment">//内点对象</span></span><br><span class="line">pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;	<span class="comment">// Create the segmentation object，点云分割对象</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);	<span class="comment">// Optional，可选项，设置是否优化系数</span></span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_PLANE);	<span class="comment">// Mandatory，必选项，设置分割类型</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);	<span class="comment">// Mandatory，设置分割方法</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.01</span>);	<span class="comment">// Mandatory，设置距离阈值</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers, *coefficients);	<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure>
<h3 id="圆柱体模型分割"><a href="#圆柱体模型分割" class="headerlink" title="圆柱体模型分割"></a>圆柱体模型分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CYLINDER);</span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);</span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.1</span>);</span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);</span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.05</span>);</span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cloud_filtered2);</span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(cloud_normals2);</span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers_cylinder, *coefficients_cylinder);</span><br></pre></td></tr></table></figure>
<h3 id="欧式聚类提取"><a href="#欧式聚类提取" class="headerlink" title="欧式聚类提取"></a>欧式聚类提取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">100</span>);</span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(<span class="number">25000</span>);</span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(tree);	<span class="comment">//kd-tree</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud_filtered);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>
<h3 id="区域生长分割"><a href="#区域生长分割" class="headerlink" title="区域生长分割"></a>区域生长分割</h3><ul>
<li><p>从曲率最小的点开始生长（初始种子点）</p>
</li>
<li><p>输出是一个聚类集合，每个聚类集合属于同一光滑表面的一部分</p>
</li>
<li><p>基本思想：</p>
<p>根据输入点的曲率值对点排序，曲率最小的点为初始种子点，该点所在的区域为最平滑区域，也就是从最平滑区域开始生长，减少分割区域的总数，提高效率。</p>
</li>
<li><p>核心：比较近邻点与种子点之间的两个指标</p>
<ul>
<li>法线夹角的比较：小于设定的阈值进入区域，即为同一类（满足此条件时进入下一步的判断）</li>
<li>曲率大小的比较：小于设定的阈值进入序列（这是为何进行排序的原因，形成一个种子序列，每完成一次比较，删除当前的种子点，使用序列中的下一个种子点继续进行比较，如此迭代）</li>
<li>还需设定一个最小点簇数和最大点簇数</li>
<li>种子序列为空时意味着算法完成了区域增长，从头开始进行重复上述过程</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::RegionGrowing&lt;pcl::PointXYZ, pcl::Normal&gt; reg;</span><br><span class="line">reg.<span class="built_in">setMinClusterSize</span>(<span class="number">50</span>);</span><br><span class="line">reg.<span class="built_in">setMaxClusterSize</span>(<span class="number">1000000</span>);</span><br><span class="line">reg.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">reg.<span class="built_in">setNumberOfNeighbours</span>(<span class="number">30</span>);</span><br><span class="line">reg.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//reg.setIndices (indices);</span></span><br><span class="line">reg.<span class="built_in">setInputNormals</span>(normals);</span><br><span class="line">reg.<span class="built_in">setSmoothnessThreshold</span>(<span class="number">3.0</span> / <span class="number">180.0</span> * M_PI);	<span class="comment">// 平滑阈值</span></span><br><span class="line">reg.<span class="built_in">setCurvatureThreshold</span>(<span class="number">1.0</span>);	<span class="comment">//曲率阈值</span></span><br><span class="line">std::vector &lt;pcl::PointIndices&gt; clusters;</span><br><span class="line">reg.<span class="built_in">extract</span>(clusters);	<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure>
<h3 id="超体素点云分割（VCCS）"><a href="#超体素点云分割（VCCS）" class="headerlink" title="超体素点云分割（VCCS）"></a>超体素点云分割（VCCS）</h3><ul>
<li>空间八叉树结构 + k-mean 聚类的区域增长 直接对点云进行超体素分割</li>
<li>超体素特征：<ul>
<li>在3D空间中，均匀分布（可通过在点云空间中均匀设定种子达到）</li>
<li>除非在体素空间上相连，否则超体素不能跨越边界</li>
</ul>
</li>
<li>在空间分辨率为 $R<em>{seed}$ 的三维空间网格中，对均匀分布在空间中的种子点进行增长形成超体素。这里为提高搜索效率，只考虑以种子为中心的半径为 $R</em>{seed}$ 区域内的点。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:\AFIGHT\笔记\PCL\assets\voxel_segmentation.png" alt="超体素分割"></p>
<h2 id="论文：聚类与分割"><a href="#论文：聚类与分割" class="headerlink" title="论文：聚类与分割"></a>论文：聚类与分割</h2><ul>
<li>聚类（clustering）将数据集中的样本划分为不相交的子集，每个子集成为一个“簇（cluster）”    </li>
<li>聚类过程形成簇结构</li>
<li>簇标记（cluster label）</li>
</ul>
<h3 id="拟合简化的集合模型（平面模型）"><a href="#拟合简化的集合模型（平面模型）" class="headerlink" title="拟合简化的集合模型（平面模型）"></a>拟合简化的集合模型（平面模型）</h3><ul>
<li>不共线的三点确定一个平面，故先从点云 $\mathcal{P}$ 中随机选取不共线的三点 ${p_i,p_j,p_k}$ </li>
<li>根据选定的三个点计算平面模型系数（$ax+by+cz+d=0$）（可根据克莱姆法则计算，详见 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Plane_(geometry">Plane (geometry) - Wikipedia</a>)）</li>
<li>计算点云 $\mathcal{P}$ 中所有点 $p$ 到该平面模型的距离（$p_n \quad (a,b,c,d)$）</li>
<li>保存距离在指定阈值内的点 $p^* \in \mathcal{P}$，并计算其个数 </li>
</ul>
<p>上述的最后一步表示对模型的评分；每个点集 $p^<em>$ 都会被保存，且上述步骤会重复（迭代） $k$ 次。算法终止后，点的数量最多的点集（内点），就是对平面模型描述最好的点集（能最好的拟合平面模型）。对所有的点 $p^</em> \in \mathcal{P}$ ，平面模型系数用最小二乘估计。</p>
<p>上述过程就是找到内点集 $p^*$，拟合出平面或者估计出其2D边界多边形的简化过程，在实际应用中，还需增加额外的约束条件。</p>
<h3 id="基本聚类技术"><a href="#基本聚类技术" class="headerlink" title="基本聚类技术"></a>基本聚类技术</h3><ul>
<li><p>依赖于空间分解技术，基于给定的标准，寻找分块及边界，实现分类</p>
</li>
<li><p>评判标准：闵氏范数：曼哈顿距离（L1）、欧式距离（L2）</p>
</li>
<li><p>欧式聚类数据结构：八叉树（3D网格）</p>
<ul>
<li>优点：易于快速构建，适用于不同情况，如需要占用空间的体积表示、用不同结构估计叶节点中的数据等</li>
<li>缺点：3D网格只适用于空间等分的情况</li>
</ul>
</li>
</ul>
<p>对于聚类分块大小不一的情况，需要更复杂的算法（下述）。</p>
<p>实例：</p>
<ul>
<li>点聚类 $O_i = {p_i \in \mathcal{P}}$  与点聚类 $O_j = {p_j \in \mathcal{P}}$ 不同的条件是：</li>
</ul>
<script type="math/tex; mode=display">
min||p_i-p_j||_2 \ge d_{th}</script><p>式中，$d_{th}$ 是指定的阈值。</p>
<p>即：点集 $p_i \in \mathcal{P}$ 与点集 $p_j \in \mathcal{P}$ 之间的最小距离大于指定的阈值，则前者中的点属于聚类 $O_i$，后者属于聚类 $O_j$ 。</p>
<p>一个问题是，这个最小距离该如何估计？</p>
<ul>
<li><p>最小距离的估计：使用 kd-tree 进行最近邻查询</p>
</li>
<li><p>算法伪代码：</p>
<ul>
<li>输入点云 $\mathcal{P}$ ，创建 kd-tree 表示</li>
<li>设置簇 $C$ 的空列表，以及点集序列 $Q$ </li>
<li>对输入点云的每一个点 $p_i \in \mathcal{P}$ ，执行以下步骤<ul>
<li>将 $p_i$ 添加到当前序列 $Q$ </li>
<li>对添加到序列中的每个点 $p_i \in Q$：<ul>
<li>以3D空间中半径为 $r&lt;d_{th}$ 的球体搜索 $p_i$ 的近邻点（近邻点搜索半径 r），结果形成点集 $P_i^k$  （setRadiusSearch）</li>
<li>对每个近邻点 $p_i^k \in P_i^k$，若未被分类则将其添加到序列 $Q$ </li>
</ul>
</li>
<li>序列 $Q$ 中的所有点处理完后，将 $Q$ 添加到簇 $C$ 的序列（内点）并重置为空序列</li>
</ul>
</li>
<li>算法终止条件：点云中的所有点均被遍历，且已成为簇 $C$ 的列表的一部分</li>
</ul>
</li>
<li><p>聚类算法(cpp)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被分割出来的点云团（标号队列）</span></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line"><span class="comment">//欧式分割器</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">100</span>);</span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(<span class="number">25000</span>);</span><br><span class="line"><span class="comment">//搜索策略树</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud_filtered);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>
<h3 id="边缘查询"><a href="#边缘查询" class="headerlink" title="边缘查询"></a>边缘查询</h3></li>
<li><p>表面曲率可用于点云分割：是对点附近采样点的几何近似估计，它们对确定那些具有极高曲率值的点很有用，这些点代表点云数据集 $\mathcal{P}$ 的几何边缘</p>
</li>
<li>2D 图像中边缘可用梯度定义，3D 中则是场景中几何形状变化剧烈的位置</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hbroad.github.io">MQRoad</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hbroad.github.io/point_cloud_pcl/">https://hbroad.github.io/point_cloud_pcl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hbroad.github.io" target="_blank">南阳向北</a>！</span></div></div><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E7%AC%94%E8%AE%B0/"><span class="categoryes-punctuation"> <svg class="icon iconfont icon-biaoqian" title="笔记" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg></span>笔记<span class="categoryesPageCount">3</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/PCL/"><span class="tags-punctuation"> <svg class="icon iconfont icon-biaoqian" title="PCL" aria-hidden="true"><use xlink:href="#icon-biaoqian1"></use></svg></span>PCL<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/Point-Cloud/"><span class="tags-punctuation"> <svg class="icon iconfont icon-biaoqian" title="Point Cloud" aria-hidden="true"><use xlink:href="#icon-biaoqian1"></use></svg></span>Point Cloud<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E7%82%B9%E4%BA%91/"><span class="tags-punctuation"> <svg class="icon iconfont icon-biaoqian" title="点云" aria-hidden="true"><use xlink:href="#icon-biaoqian1"></use></svg></span>点云<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/04/28/yGbIuVMHqwkANfh.png" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Graduate_2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/28/npEewZRC9hHocgU.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">毕设：链片条复合模CAD系统使用须知</div></div></a></div><div class="next-post pull-right"><a href="/digital_image_process/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/17/UEvPTVuJ7eH2KfA.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数字图像处理</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a></div><div class="comment-tips" id="comment-tips"><span>你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div><div class="comment-barrage"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><a class="avatar-img" href="/about"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/17/YGpk958xbD3jyol.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></a><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="writing_hand" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png">✍️</g-emoji><span>on Studying</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">MQRoad</h1><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">即将踏入社会成为打工人，在此记录过去、现在和未来！</div></div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)"><span class="banner-button-text">了解更多</span><i class="fas fa-circle-right"></i></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hbroad" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1746469211@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/188520608" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=1746469211&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://img02.anzhiy.cn/adminuploads/1/2022/09/11/631ddb7c9b250.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2022/08/23/LaJqogHM3WOiAD6.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%91"><span class="toc-number">1.</span> <span class="toc-text">点云</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%91%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">点云库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PointT-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">PointT 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PointXYZ"><span class="toc-number">3.1.</span> <span class="toc-text">PointXYZ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-XYZI"><span class="toc-number">3.2.</span> <span class="toc-text">Point XYZI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PointXYZRGBA"><span class="toc-number">3.3.</span> <span class="toc-text">PointXYZRGBA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCD-%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">PCD 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K-d-tree"><span class="toc-number">5.</span> <span class="toc-text">K-d tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">5.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">两种查询方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Octree-%E5%85%AB%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">Octree(八叉树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%91%E8%BF%9E%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">点云连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E8%BF%9E%E6%8E%A5"><span class="toc-number">7.1.</span> <span class="toc-text">点连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%BF%9E%E6%8E%A5"><span class="toc-number">7.2.</span> <span class="toc-text">字段连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%91%E6%BB%A4%E6%B3%A2"><span class="toc-number">8.</span> <span class="toc-text">点云滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2"><span class="toc-number">8.2.</span> <span class="toc-text">双边滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">直通滤波器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VoxelGrid%EF%BC%88%E4%BD%93%E7%B4%A0%E5%8C%96%E7%BD%91%E6%A0%BC%EF%BC%89%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">8.4.</span> <span class="toc-text">VoxelGrid（体素化网格）滤波器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%BB%A4%E6%B3%A2"><span class="toc-number">8.5.</span> <span class="toc-text">统计滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E6%A8%A1%E5%9E%8B%E6%8A%95%E5%BD%B1%E7%82%B9%E4%BA%91"><span class="toc-number">8.6.</span> <span class="toc-text">参数化模型投影点云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%82%B9%E4%BA%91%E4%B8%AD%E6%8F%90%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%90%E9%9B%86"><span class="toc-number">8.7.</span> <span class="toc-text">从一个点云中提取一个子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RadiusOutlierRemoval-ConditionalRemoval-%E7%A7%BB%E9%99%A4%E7%A6%BB%E7%BE%A4%E7%82%B9"><span class="toc-number">8.8.</span> <span class="toc-text">RadiusOutlierRemoval &#x2F; ConditionalRemoval  移除离群点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RadiusOutlierRemoval"><span class="toc-number">8.8.1.</span> <span class="toc-text">RadiusOutlierRemoval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConditionalRemoval"><span class="toc-number">8.8.2.</span> <span class="toc-text">ConditionalRemoval</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CropHull-%E4%BB%BB%E6%84%8F%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8%E7%82%B9%E4%BA%91%E6%8F%90%E5%8F%96"><span class="toc-number">8.9.</span> <span class="toc-text">CropHull 任意多边形内部点云提取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%83%8F%EF%BC%88Range-Depth-Images%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">深度图像（Range&#x2F;Depth Images）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%82%B9%E4%BA%91%E5%88%9B%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%83%8F"><span class="toc-number">9.1.</span> <span class="toc-text">从点云创建深度图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%83%8F%E6%8F%90%E5%8F%96%E8%BE%B9%E7%95%8C"><span class="toc-number">9.2.</span> <span class="toc-text">从深度图像提取边界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">关键点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%97%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">关键概念及算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NARF-%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">10.1.1.</span> <span class="toc-text">NARF 关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Harris%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">10.1.2.</span> <span class="toc-text">Harris关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCL-%E4%B8%AD%E7%9A%84-keypoints"><span class="toc-number">10.1.3.</span> <span class="toc-text">PCL 中的 keypoints</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%83%8F%E6%8F%90%E5%8F%96-NARF-%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">深度图像提取 NARF 关键点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SIFT-%E5%85%B3%E9%94%AE%E7%82%B9%E6%8F%90%E5%8F%96"><span class="toc-number">10.1.3.2.</span> <span class="toc-text">SIFT 关键点提取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Harris-%E5%85%B3%E9%94%AE%E7%82%B9%E6%8F%90%E5%8F%96"><span class="toc-number">10.1.3.3.</span> <span class="toc-text">Harris 关键点提取</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8F%90%E5%8F%96"><span class="toc-number">11.</span> <span class="toc-text">特征描述与提取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text">特征描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E5%AD%90"><span class="toc-number">11.2.</span> <span class="toc-text">特征描述子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA-1"><span class="toc-number">11.2.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E5%9F%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">11.2.2.</span> <span class="toc-text">邻域的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96"><span class="toc-number">11.3.</span> <span class="toc-text">特征提取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%82%B9%E4%BA%91%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">11.3.1.</span> <span class="toc-text">输入点云的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%B0%E8%AE%A1%E7%82%B9%E4%BA%91%E7%9A%84%E8%A1%A8%E9%9D%A2%E6%B3%95%E7%BA%BF"><span class="toc-number">11.3.2.</span> <span class="toc-text">估计点云的表面法线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%9D%A2%E6%9B%B2%E7%8E%87"><span class="toc-number">11.3.3.</span> <span class="toc-text">表面曲率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E7%9A%84%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.4.</span> <span class="toc-text">法线的定向问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E7%89%B9%E5%BE%81%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%88PFH%EF%BC%89"><span class="toc-number">11.4.</span> <span class="toc-text">点特征直方图（PFH）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA-2"><span class="toc-number">11.4.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">11.4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E7%82%B9%E7%89%B9%E5%BE%81%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%88FPFH%EF%BC%89"><span class="toc-number">11.5.</span> <span class="toc-text">快速点特征直方图（FPFH）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA-3"><span class="toc-number">11.5.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">11.5.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%91%E9%85%8D%E5%87%86"><span class="toc-number">12.</span> <span class="toc-text">点云配准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E7%82%B9%E4%BA%91%E7%9A%84%E9%85%8D%E5%87%86%EF%BC%88%E4%B8%A4%E4%B8%A4%E9%85%8D%E5%87%86%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">一对点云的配准（两两配准）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E4%BC%B0%E8%AE%A1"><span class="toc-number">12.2.</span> <span class="toc-text">对应估计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E7%9A%84%E5%8E%BB%E9%99%A4"><span class="toc-number">12.3.</span> <span class="toc-text">错误对应关系的去除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICP%E7%AE%97%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">ICP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA-4"><span class="toc-number">12.4.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95ICP%E4%BB%A3%E7%A0%81"><span class="toc-number">12.4.2.</span> <span class="toc-text">简单ICP代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%90%E6%AD%A5%E5%8C%B9%E9%85%8D%E5%A4%9A%E5%B9%85%E7%82%B9%E4%BA%91"><span class="toc-number">12.4.3.</span> <span class="toc-text">逐步匹配多幅点云</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8FICP"><span class="toc-number">12.4.4.</span> <span class="toc-text">交互式ICP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%8F%98%E6%8D%A2%E9%85%8D%E5%87%86%EF%BC%88NDT%EF%BC%89"><span class="toc-number">12.5.</span> <span class="toc-text">正态分布变换配准（NDT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA-5"><span class="toc-number">12.5.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NDT-%E9%85%8D%E5%87%86"><span class="toc-number">12.5.2.</span> <span class="toc-text">NDT 配准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">12.5.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%91%E5%88%86%E5%89%B2"><span class="toc-number">13.</span> <span class="toc-text">点云分割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B1%BB%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">聚类分割算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RANSAC"><span class="toc-number">13.2.</span> <span class="toc-text">RANSAC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E7%82%B9%E4%BA%91%E5%88%86%E5%89%B2"><span class="toc-number">13.3.</span> <span class="toc-text">平面点云分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%86%E6%9F%B1%E4%BD%93%E6%A8%A1%E5%9E%8B%E5%88%86%E5%89%B2"><span class="toc-number">13.4.</span> <span class="toc-text">圆柱体模型分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E5%BC%8F%E8%81%9A%E7%B1%BB%E6%8F%90%E5%8F%96"><span class="toc-number">13.5.</span> <span class="toc-text">欧式聚类提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF%E5%88%86%E5%89%B2"><span class="toc-number">13.6.</span> <span class="toc-text">区域生长分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E4%BD%93%E7%B4%A0%E7%82%B9%E4%BA%91%E5%88%86%E5%89%B2%EF%BC%88VCCS%EF%BC%89"><span class="toc-number">13.7.</span> <span class="toc-text">超体素点云分割（VCCS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%EF%BC%9A%E8%81%9A%E7%B1%BB%E4%B8%8E%E5%88%86%E5%89%B2"><span class="toc-number">14.</span> <span class="toc-text">论文：聚类与分割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9F%E5%90%88%E7%AE%80%E5%8C%96%E7%9A%84%E9%9B%86%E5%90%88%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%B9%B3%E9%9D%A2%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">14.1.</span> <span class="toc-text">拟合简化的集合模型（平面模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%81%9A%E7%B1%BB%E6%8A%80%E6%9C%AF"><span class="toc-number">14.2.</span> <span class="toc-text">基本聚类技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E6%9F%A5%E8%AF%A2"><span class="toc-number">14.3.</span> <span class="toc-text">边缘查询</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/chatgptlike/" title="ChatGPT 类产品"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/28/kopIxRQtBaFM1Oe.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ChatGPT 类产品"/></a><div class="content"><a class="title" href="/chatgptlike/" title="ChatGPT 类产品">ChatGPT 类产品</a><time datetime="2023-04-28T01:53:21.000Z" title="发表于 2023-04-28 09:53:21">2023-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Python_start2end/" title="Python 从入门到放弃"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/28/X9hLcsObyviEjfw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 从入门到放弃"/></a><div class="content"><a class="title" href="/Python_start2end/" title="Python 从入门到放弃">Python 从入门到放弃</a><time datetime="2023-04-19T13:07:56.000Z" title="发表于 2023-04-19 21:07:56">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hec_opencv/" title="机器人手眼标定（OpenCV)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/17/61JeqyzFC5fY9io.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器人手眼标定（OpenCV)"/></a><div class="content"><a class="title" href="/hec_opencv/" title="机器人手眼标定（OpenCV)">机器人手眼标定（OpenCV)</a><time datetime="2023-04-17T09:12:29.000Z" title="发表于 2023-04-17 17:12:29">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cpp_pointer/" title="C++ 指针"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/17/TlC3fSRJz1Q69pj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 指针"/></a><div class="content"><a class="title" href="/cpp_pointer/" title="C++ 指针">C++ 指针</a><time datetime="2023-03-29T16:00:00.000Z" title="发表于 2023-03-30 00:00:00">2023-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cpp_useful_sugar/" title="C++ 小知识点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/17/TlC3fSRJz1Q69pj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 小知识点"/></a><div class="content"><a class="title" href="/cpp_useful_sugar/" title="C++ 小知识点">C++ 小知识点</a><time datetime="2023-03-12T16:00:00.000Z" title="发表于 2023-03-13 00:00:00">2023-03-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 MQRoad</div><div id="workboard"><div id="runtimeTextTip"></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/04/17/YGpk958xbD3jyol.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 全部</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-shapes faa-tada"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD"><span> AI资讯</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="fa-fw fas fas fa-lightbulb faa-tada"></i><span> 发个说说</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/timeline/"><i class="fa-fw fa-fw fas fa-shoe-prints faa-tada faa-tada"></i><span> 建站小记</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><a id="switch_commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><svg class="icon" aria-hidden="true"><use href="#icon-danmu"></use></svg></a><button id="center-console" type="button" title="中控台"><i class="fas fa-fish-fins"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="console"><div class="close-btn" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"><i class="fas fa-circle-xmark"></i></div><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://s2.loli.net/2022/08/02/NU5AfdCaoirtyK1.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/02/NU5AfdCaoirtyK1.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://img01.anzhiy.cn/useruploads/0/2023/04/06/642ec98c8227c.png" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/04/06/642ec98c8227c.png"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.35em; color: rgb(164, 117, 141)">C++<sup>3</sup></a><a href="/tags/Commemorate/" style="font-size: 1.15em; color: rgb(142, 65, 76)">Commemorate<sup>1</sup></a><a href="/tags/Coppeliasim-Vrep/" style="font-size: 1.15em; color: rgb(79, 86, 107)">Coppeliasim/Vrep<sup>1</sup></a><a href="/tags/DIP/" style="font-size: 1.15em; color: rgb(121, 30, 99)">DIP<sup>1</sup></a><a href="/tags/HEC/" style="font-size: 1.15em; color: rgb(108, 140, 14)">HEC<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.15em; color: rgb(34, 93, 141)">Hexo<sup>1</sup></a><a href="/tags/Interview/" style="font-size: 1.45em; color: rgb(146, 9, 156)">Interview<sup>8</sup></a><a href="/tags/Leetcode/" style="font-size: 1.35em; color: rgb(198, 102, 80)">Leetcode<sup>3</sup></a><a href="/tags/PCL/" style="font-size: 1.15em; color: rgb(174, 185, 112)">PCL<sup>1</sup></a><a href="/tags/Point-Cloud/" style="font-size: 1.15em; color: rgb(148, 32, 71)">Point Cloud<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.15em; color: rgb(36, 191, 21)">Python<sup>1</sup></a><a href="/tags/Simulation/" style="font-size: 1.15em; color: rgb(147, 129, 176)">Simulation<sup>1</sup></a><a href="/tags/UR5/" style="font-size: 1.25em; color: rgb(16, 185, 75)">UR5<sup>2</sup></a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.15em; color: rgb(53, 13, 95)">人工智能<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.15em; color: rgb(18, 179, 17)">数据结构<sup>1</sup></a><a href="/tags/%E6%AF%95%E8%AE%BE/" style="font-size: 1.25em; color: rgb(174, 64, 81)">毕设<sup>2</sup></a><a href="/tags/%E7%82%B9%E4%BA%91/" style="font-size: 1.15em; color: rgb(122, 112, 99)">点云<sup>1</sup></a><a href="/tags/%E8%B5%84%E8%AE%AF/" style="font-size: 1.15em; color: rgb(23, 88, 186)">资讯<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="fas fa-archive"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/11/"><span class="card-archive-list-date">十一月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/09/"><span class="card-archive-list-date">九月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">八月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">七月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/05/"><span class="card-archive-list-date">五月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/04/"><span class="card-archive-list-date">四月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="rm.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="fas fa-moon" style="font-size: 1rem;"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="fas fa-arrows-alt-h"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="fa-solid fa-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="fas fa-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-top"><i class="fa-solid fa-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="fas fa-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="fas fa-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="fas fa-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="fas fa-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="fas fa-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="fas fa-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="fas fa-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="fas fa-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="fa-solid fa-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="fa-solid fa-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="fa-solid fa-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="fas fa-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="fas fa-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="fas fa-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="fas fa-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="fas fa-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fas fa-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fas fa-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="fas fa-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="fa-solid fa-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="fa-solid fa-moon"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="fas fa-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.0.8/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.0.8/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.0.8/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  console.log(1)
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2020 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    //- `
        
    //-    █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
    //-   ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
    //-   ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
    //-   ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
    //-   ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
    //-   ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
    //-     `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 MQRoad 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2020 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    let currentTimeHtml = "";
    if (hnum < 18 && hnum >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='fas fa-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "";
      img.title = "";
      img.alt = "";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='fas fa-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.0
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://npm.elemecdn.com/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://mqroad.zeabur.app',
      region: '',
      onCommentLoaded: function () {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://mqroad.zeabur.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://npm.elemecdn.com/twikoo@1.6.11/dist/twikoo.all.min.js').then(runFn)
  }
  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://mqroad.zeabur.app',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://npm.elemecdn.com/twikoo@1.6.11/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick}</span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";</script><script data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/catalog-bar/catalog-bar.js"></script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/categoryBar/categoryBar.js"></script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script async="async">// 初始化函数
let rm = {};

//禁止图片拖拽
let imgElements = document.getElementsByTagName("img");
for (let i = 0; i < imgElements.length; i++) {
  imgElements[i].addEventListener("dragstart", function (event) {
    event.preventDefault();
  });
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = $("#rightMenu").width();
let rmHeight = $("#rightMenu").height();

// 重新定义尺寸
rm.reloadrmSize = function () {
  rmWidth = $("#rightMenu").width();
  rmHeight = $("#rightMenu").height();
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

// 监听右键初始化
window.oncontextmenu = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    let $rightMenuOther = $(".rightMenuOther");
    let $rightMenuPlugin = $(".rightMenuPlugin");
    let $rightMenuCopyText = $("#menu-copytext");
    let $rightMenuPasteText = $("#menu-pastetext");
    let $rightMenuCommentText = $("#menu-commenttext");
    let $rightMenuNewWindow = $("#menu-newwindow");
    let $rightMenuNewWindowImg = $("#menu-newwindowimg");
    let $rightMenuCopyLink = $("#menu-copylink");
    let $rightMenuCopyImg = $("#menu-copyimg");
    let $rightMenuDownloadImg = $("#menu-downloadimg");
    let $rightMenuSearch = $("#menu-search");
    let $rightMenuSearchBaidu = $("#menu-searchBaidu");
    let $rightMenuMusicToggle = $("#menu-music-toggle");
    let $rightMenuMusicBack = $("#menu-music-back");
    let $rightMenuMusicForward = $("#menu-music-forward");
    let $rightMenuMusicPlaylist = $("#menu-music-playlist");
    let $rightMenuMusicCopyMusicName = $("#menu-music-copyMusicName");
    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.show();
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.show();
      $rightMenuCommentText.show();
      $rightMenuSearch.show();
      $rightMenuSearchBaidu.show();
    } else {
      $rightMenuCopyText.hide();
      $rightMenuCommentText.hide();
      $rightMenuSearchBaidu.hide();
      $rightMenuSearch.hide();
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.show();
      $rightMenuCopyLink.show();
      domhref = href;
    } else {
      $rightMenuNewWindow.hide();
      $rightMenuCopyLink.hide();
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.show();
      $rightMenuDownloadImg.show();
      $rightMenuNewWindowImg.show();
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.hide();
      $rightMenuDownloadImg.hide();
      $rightMenuNewWindowImg.hide();
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      console.log("这是一个输入框");
      pluginMode = true;
      $rightMenuPasteText.show();
    } else {
      $rightMenuPasteText.hide();
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.show();
      $rightMenuMusicBack.show();
      $rightMenuMusicForward.show();
      $rightMenuMusicPlaylist.show();
      $rightMenuMusicCopyMusicName.show();
    } else {
      $rightMenuMusicToggle.hide();
      $rightMenuMusicBack.hide();
      $rightMenuMusicForward.hide();
      $rightMenuMusicPlaylist.hide();
      $rightMenuMusicCopyMusicName.hide();
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.hide();
      $rightMenuPlugin.show();
    } else {
      $rightMenuPlugin.hide();
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或考下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    $("#rightmenu-mask").attr("style", "display: flex");
    return false;
  }
};

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.switchDarkMode = function () {
  // Switch Between Light And Dark Mode
  const nowMode = document.documentElement.getAttribute("data-theme") === "dark" ? "dark" : "light";
  if (nowMode === "light") {
    activateDarkMode();
    saveToLocal.set("theme", "dark", 2);
    GLOBAL_CONFIG.Snackbar !== undefined && anzhiyu.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night);
  } else {
    activateLightMode();
    saveToLocal.set("theme", "light", 2);
    GLOBAL_CONFIG.Snackbar !== undefined && anzhiyu.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day);
  }
  // handle some cases
  typeof runMermaid === "function" && window.runMermaid();
  rm.hideRightMenu();
  anzhiyu.darkModeStatus();
};

rm.copyUrl = function (id) {
  $("body").after("<input id='copyVal'></input>");
  var text = id;
  var input = document.getElementById("copyVal");
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  $("#copyVal").remove();
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      false
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      false
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function () {
  var url = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.querySelector("#post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  $("#menu-backward").on("click", function () {
    window.history.back();
    rm.hideRightMenu();
  });
  $("#menu-forward").on("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });
  $("#menu-refresh").on("click", function () {
    window.location.reload();
  });
  $("#menu-top").on("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });
  $(".menu-link").on("click", rm.hideRightMenu);
  $("#menu-darkmode").on("click", rm.switchDarkMode);
  $("#menu-home").on("click", function () {
    window.location.href = window.location.origin;
  });
  $("#menu-randomPost").on("click", function () {
    toRandomPost();
  });
  $("#menu-commentBarrage").on("click", anzhiyu.switchCommentBarrage);
  $("#rightmenu-mask").on("click", rm.hideRightMenu);
  $("#rightmenu-mask").contextmenu(function () {
    rm.hideRightMenu();
    return false;
  });
  $("#menu-copy").on("click", rm.copyPageUrl);
  $("#menu-pastetext").on("click", rm.pasteText);
  $("#menu-copytext").on("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });
  $("#menu-commenttext").on("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });
  $("#menu-newwindow").on("click", function () {
    window.open(domhref);
    rm.hideRightMenu();
  });
  $("#menu-copylink").on("click", rm.copyLink);
  $("#menu-downloadimg").on("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });
  $("#menu-newwindowimg").on("click", function () {
    window.open(domImgSrc);
    rm.hideRightMenu();
  });
  $("#menu-copyimg").on("click", function () {
    rm.writeClipImg(domImgSrc);
  });
  $("#menu-searchBaidu").on("click", rm.searchBaidu);
  //音乐
  $("#menu-music-toggle").on("click", anzhiyu.musicToggle);
  $("#menu-music-back").on("click", anzhiyu.musicSkipBack);
  $("#menu-music-forward").on("click", anzhiyu.musicSkipForward);
  $("#menu-music-copyMusicName").on("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });
}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | 安知鱼")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();

anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);</script><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/ali_font.js"></script><script id="click-heart" src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)
  window.anzhiyuScrollFnToDo && window.removeEventListener('scroll', anzhiyuScrollFnToDo)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>