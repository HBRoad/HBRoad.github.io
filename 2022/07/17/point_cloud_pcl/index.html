<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>点云+PCL学习笔记 - 南阳向北</title>
  
    <meta name="keywords" content="PCL,Point Cloud,点云">
  
  
    <meta name="description" content="研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客
（注：部分图片未上传至图床，抽空补充）">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css">
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            南阳向北 <b><sup style='color:#3AA757'></sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  
                    <i class='fa fa-home fa-fw'></i>
                  
                  首页
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  
                    <i class='fas fa-folder-open fa-fw'></i>
                  
                  分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  
                    <i class='fas fa-tags fa-fw'></i>
                  
                  标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  
                    <i class='fas fa-archive fa-fw'></i>
                  
                  归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  
                    <i class='fas fa-link fa-fw'></i>
                  
                  友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  
                    <i class='fas fa-info-circle fa-fw'></i>
                  
                  关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="搜索" />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  
                    <i class='fa fa-home fa-fw'></i>
                  
                  首页
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  
                    <i class='fas fa-folder-open fa-fw'></i>
                  
                  分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  
                    <i class='fas fa-tags fa-fw'></i>
                  
                  标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  
                    <i class='fas fa-archive fa-fw'></i>
                  
                  归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  
                    <i class='fas fa-link fa-fw'></i>
                  
                  友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  
                    <i class='fas fa-info-circle fa-fw'></i>
                  
                  关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>




  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box blur article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2022/07/17/point_cloud_pcl/">
        点云+PCL学习笔记
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
<div class='new-meta-item author'>
  <a href="https://hbroad.github.io/" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/blogbackground4b763.jpg">
    <p>南阳向北</p>
  </a>
</div>

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2022年7月17日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/%E7%AC%94%E8%AE%B0/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
          
            
  
    <div class="new-meta-item browse valine">
      <a class='notlink'>
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id="/2022/07/17/point_cloud_pcl/" class="leancloud_visitors" data-flag-title="点云+PCL学习笔记">
        <p>
          <span class="leancloud-visitors-count">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
        </span>
      </a>
    </div>
  


          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <p>研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客</p>
<p>（注：部分图片未上传至图床，抽空补充）</p>
<a id="more"></a>

<h2 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h2><ul>
<li><p>分布在 N 维空间中的离散点集</p>
</li>
<li><p>是对物体表面信息的离散采样</p>
</li>
</ul>
<h2 id="点云库"><a href="#点云库" class="headerlink" title="点云库"></a>点云库</h2><ul>
<li>三维处理算法：滤波、特征估计、表面重建等</li>
</ul>
<h2 id="PointT-类型"><a href="#PointT-类型" class="headerlink" title="PointT 类型"></a>PointT 类型</h2><h3 id="PointXYZ"><a href="#PointXYZ" class="headerlink" title="PointXYZ"></a>PointXYZ</h3><ul>
<li><p>包含 x y z 坐标的点数据类型</p>
</li>
<li><p>成员变量 float x, y, z</p>
</li>
<li><p>points[i].x 访问</p>
</li>
<li><p>多余的一个变量用来填充位置以满足存储对齐（?）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">float</span> data[<span class="number">4</span>];</span><br><span class="line">   <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">      <span class="keyword">float</span> x;</span><br><span class="line">      <span class="keyword">float</span> y;</span><br><span class="line">      <span class="keyword">float</span> z;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Point-XYZI"><a href="#Point-XYZI" class="headerlink" title="Point XYZI"></a>Point XYZI</h3><ul>
<li>包含 x y z 坐标及 intensity</li>
</ul>
<h3 id="PointXYZRGBA"><a href="#PointXYZRGBA" class="headerlink" title="PointXYZRGBA"></a>PointXYZRGBA</h3><ul>
<li>rgba 单独作为一个整型变量（unit32_t）</li>
</ul>
<h2 id="PCD-文件"><a href="#PCD-文件" class="headerlink" title="PCD 文件"></a>PCD 文件</h2><ul>
<li>包含文件头：声明存储点云数据的特性，必须用 ASCII 编码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># .PCD v<span class="number">.7</span> - Point Cloud Data file format</span><br><span class="line">VERSION <span class="number">.7</span>                     # 指定PCD文件版本</span><br><span class="line">FIELDS x y z rgb               # 指定每个点可以有的每一个维度或字段的名字</span><br><span class="line">SIZE <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span>                   # 用字节数指定 FIELDS 中每一个维度的大小</span><br><span class="line">TYPE F F F F                   # 用一个字符指定 FILEDS 中每一个维度的类型</span><br><span class="line">COUNT <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>                  # 指定每一个维度包含的元素数目</span><br><span class="line">WIDTH <span class="number">213</span>                      # 用点的数量表示点云数据集的宽度: 无序点云的个数；有序点云的宽度（指一行中的数目）  列</span><br><span class="line">HEIGHT <span class="number">1</span>                       # 用点的数量表示点云数据集的高度；同 WIDTH                                      行 </span><br><span class="line">VIEWPOINT <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>        # 数据集中点云的获取视角，形式为：平移（tx ty tz）+ 四元数（qw qx qy qz）</span><br><span class="line">POINTS <span class="number">213</span>                     # 数据集中点的总数 </span><br><span class="line">DATA ascii                     # 存储点云数据的数据类型：ASCII 或 二进制</span><br><span class="line"><span class="number">0.93773</span> <span class="number">0.33763</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.90805</span> <span class="number">0.35641</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.81915</span> <span class="number">0.32</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br><span class="line"><span class="number">0.97192</span> <span class="number">0.278</span> <span class="number">0</span> <span class="number">4.2108e+06</span></span><br></pre></td></tr></table></figure>

<ul>
<li>DATA 之后即为点云数据，PCD 的头文件必须按照该顺序指定，必须之间换行隔开</li>
<li>DATA = ASCII，则每点占一行，“nan”表该点值不存在或非法</li>
</ul>
<h2 id="K-d-tree"><a href="#K-d-tree" class="headerlink" title="K-d tree"></a>K-d tree</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><center class="half">
    <img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/KdTree.png" alt="KdTree"  style="zoom:20%;" />
    <img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/Kdtree_2d.png" alt="KdTree"  style="zoom:30%;" />
</center>

<p>按 X Y X 的顺序进行，如上图，（7，2）为根节点，做关于 X 的垂线，划分成左右两板，找到该处的近邻点，大于根节点的在右，小于根节点的在左，找到的两点做关于 Y 轴的垂线，重复操作即可。</p>
<p>在 k-d tree 中查找距离查询点 $\overline x$ 最近点的，意味着遍历整个树，找到包含 $\overline x$ 的子节点。</p>
<p>实际中，可考虑使用近似的近邻点，而不是实际的最近邻点，以提高运行速率。</p>
<h3 id="两种查询方式"><a href="#两种查询方式" class="headerlink" title="两种查询方式"></a>两种查询方式</h3><p>（详见博士论文 P40）</p>
<p>PCL 中 ，通常使用快速 K-d tree 查询，并使用近似然法来计算查询点的最近邻元素，有两种查询类型：</p>
<ul>
<li>==k - 搜索==：确定一个查询点的 k 近邻搜索，该方式需用户指定一个 k 值（也就是搜索 查询点 附近多少个点）</li>
<li>==r - 搜索==：确定一个半径 r，在以查询点为圆心，半径为 r 查询近邻点</li>
</ul>
<p>r - 搜索 主要用于三维特征估计，它试图捕获同一表面小块上的数据，与采样点的数量、距离，或相对于传感器的角度独立。如下图士，对于一个给定的查询点（红色点），查询半径 r 内的近邻点，这些点构成的集合 $P^k$ ，用于估计查询点处（或周围）的法线（蓝色）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144959.jpg" alt="r 搜索实例"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HBRoad/imgonline/paperimg/202207171144728.png" alt="K-d tree最近邻搜索"></p>
<p>上图为 k-d tree 的最近邻搜索，一个分格（bin）中有 3 个点；左边为树结构，右边为空间划分。查询点为 $ \vec{x}$ ，从右图可以看出其在 aba 的叶节点中，其最近邻点是 $\vec{q}$ ，但以 $ \vec{x}$ 为中心的最小球（圆）与节点的边界重合，所以搜索算法需要回溯并遍历节点 aab 和 abb，最后得到其真正的近邻点是在节点 aab 中的 $\vec{q}’$ 。</p>
<p>另一个问题是，k 和 r 到底如何取值，才能确定近邻点集 $P^k$ ，即确定 <code>正确尺度因子</code> 的问题（尺度，也就是 k 和 r 取多大多小）。这个问题之所以很重要，是因为在自动估计点特征表示（即用户没指定 k 和 r）时，可以作为一个限制因素。</p>
<p>如下左图为估计表面法线的实例，左边是尺度因子较小（好），右边是较大（差），可以看出，左边的法线与表面垂直，估计的效果较好，而右边则出现偏离。同理，右图是估计表面曲率的实例，左边的桌子的边缘清晰，右边的尺度过大，边缘模糊，丢失了部分细节。</p>
<center class="half">
    <img src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface normals.jpg" alt="估计表面法线"  style="zoom:25%;" />
    <img src="F:\AFIGHT\笔记\PCL\assets\Example of estimated surface curvatures.jpg" alt="估计表面曲率"  style="zoom:27%;" />
</center>

<p>所以，关于 k 和 r 取值的尺度问题，当需获得某部分的细节信息时，可选择小的尺度，反之可选大尺度（简单地说，如果杯子把手和圆柱形部分之间的边缘曲率很重要，那么尺度因子就需要足够小来捕捉这些细节，否则就需要很大）。</p>
<h2 id="Octree-八叉树"><a href="#Octree-八叉树" class="headerlink" title="Octree(八叉树)"></a>Octree(八叉树)</h2><ul>
<li>一个根节点包含八个子节点</li>
<li>若被划分的体元具有相同的属性，则为叶节点（子节点），否则继续划分为 8 个子节点，依次递归</li>
<li>除近邻搜索外，可用于碰撞检测</li>
</ul>
<img src="F:\AFIGHT\笔记\PCL\assets\Octree.png" alt="八叉树" style="zoom: 33%;" />

<h2 id="点云连接"><a href="#点云连接" class="headerlink" title="点云连接"></a>点云连接</h2><h3 id="点连接"><a href="#点连接" class="headerlink" title="点连接"></a>点连接</h3><ul>
<li>需确保类型和维度相等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloud_c = cloud_a;</span><br><span class="line">cloud_c += cloud_b;</span><br></pre></td></tr></table></figure>

<h3 id="字段连接"><a href="#字段连接" class="headerlink" title="字段连接"></a>字段连接</h3><ul>
<li>需确保数目相等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c);</span><br></pre></td></tr></table></figure>

<h2 id="点云滤波"><a href="#点云滤波" class="headerlink" title="点云滤波"></a>点云滤波</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>噪声点：设备精度、操作者经验、环境因素等</li>
<li>离群点：外界干扰如障碍物等，产生离主体点云较远的离散点</li>
</ul>
<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><ul>
<li>通过取邻近采样点的加权平均来修正当前采样点的位置，达到滤波效果</li>
<li>有选择地剔除与当前采样点差异较大的相邻采样点，以保持原特征</li>
</ul>
<h3 id="直通滤波器"><a href="#直通滤波器" class="headerlink" title="直通滤波器"></a>直通滤波器</h3><ul>
<li><p>去掉指定范围内/外的点（外点即要滤除的点，内点即要保留的点）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt; pass;	 <span class="comment">// 创建直通滤波器对象</span></span><br><span class="line">pass.setInputCloud(cloud);				<span class="comment">// 输入</span></span><br><span class="line">pass.setFilterFieldName(<span class="string">"z"</span>);			<span class="comment">// 设置滤波字段，此处为 z 轴</span></span><br><span class="line">pass.setFilterLimits(<span class="number">0.0</span>, <span class="number">200.0</span>);		<span class="comment">// 设置滤波范围，超出则滤除</span></span><br><span class="line">pass.setFilterLimitsNegative (<span class="literal">true</span>);	<span class="comment">// 默认为 false，设为 ture 则返回被滤除点</span></span><br><span class="line">pass.filter(*cloud_filtered);			<span class="comment">// 执行滤波，并将滤波结果存储在 cloud_filtered</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="VoxelGrid（体素化网格）滤波器"><a href="#VoxelGrid（体素化网格）滤波器" class="headerlink" title="VoxelGrid（体素化网格）滤波器"></a>VoxelGrid（体素化网格）滤波器</h3><ul>
<li><p>实现下采样：减少点的数量及点云数据，同时保持点云形状特征不变</p>
</li>
<li><p>VoxelGrid</p>
<ul>
<li>三维体素栅格：微小三维立方体的集合，==一个体素 = 一个三维立方体==</li>
<li>通过输入点云创建一个三维体素栅格，用体素中所有点的重心近似显示体素中其他点，故==一个体素内所有点就用一个重心点表示==</li>
<li>对所有体素处理后得到过滤后的点云</li>
<li>缺点：<code>慢</code>，比体素中心逼近法更慢</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;	<span class="comment">// 创建体素栅格滤波对象</span></span><br><span class="line">sor.setInputCloud(cloud);				   <span class="comment">// 读入点云设置为输入</span></span><br><span class="line">sor.setLeafSize(<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);	    <span class="comment">// 滤波时创建的体素大小为 1cm 立方体（长宽高），猜测这里单位为 米</span></span><br><span class="line">sor.filter(*cloud_filtered);			   <span class="comment">// 执行滤波并存储到 cloud_filtered</span></span><br></pre></td></tr></table></figure>

<ul>
<li>滤波结果</li>
</ul>
<center class="half">
    <img src="F:\AFIGHT\笔记\PCL\assets\滤波前.png" alt="滤波前"  style="zoom:50%;" />
    <img src="F:\AFIGHT\笔记\PCL\assets\滤波后.png" alt="滤波后"  style="zoom:50%;" />
</center>
### 统计滤波

</li>
</ul>
<p>（详见博士论文 P40）</p>
<ul>
<li><p>用于去除离群点</p>
</li>
<li><p>基于对近邻点集 $P^k$ 的统计分析</p>
<ul>
<li>计算查询点 $p_q$ 到 k 个近邻点的平均距离 $\overline d$ </li>
<li>计算点云 $P$ 在平均距离上的分布，并估计平均值 $\mu_k$ 及标准差 $\sigma_k$ </li>
</ul>
</li>
<li><p>对每个邻域统计分析，去除不符合标准的点，基于输入数据中点到邻近点距离分布的计算，计算每个点到其所有邻近点的平均距离</p>
</li>
</ul>
<p>去除错误点的另一种方法是，考虑从相同或非常接近的位置进行额外的扫描，然后融合扫描结果来推断错误。</p>
<p><strong>假设第一次扫描 $P_i$ 和随后的 $P_{i+1}$ 之间的环境没有变化，并且它们的获取观点相同，可以采用以下最简单的过滤离群值形式：对于每个点$p \in P_i$，搜索其对应的近邻点 $p \in P_{i+1}$。如果 $p$ 和 $q$ 之间的距离大于用户指定的阈值，那么 $p$ 是一个离群点，可以安全地从 $P_i$ 中移除。此外，所有剩余的点可以在两次扫描之间取平均值。</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;	<span class="comment">// 创建统计滤波对象</span></span><br><span class="line">sor.setInputCloud(cloud);						  <span class="comment">// 设置输入点云</span></span><br><span class="line">sor.setMeanK(<span class="number">50</span>);				    <span class="comment">// 设置统计分析时查询点的邻近点数，即计算查询点附近多少个点的平均距离（最近邻点）</span></span><br><span class="line">sor.setStddevMulThresh(<span class="number">1.0</span>);		<span class="comment">// 判断是否是离群点的阈值，若计算出的距离超过平均距离 1 个标准差以上即判断为离群点</span></span><br><span class="line">sor.filter(*cloud_filtered);					  <span class="comment">// 执行并存储滤波结果</span></span><br><span class="line"></span><br><span class="line">sor.setNegative(<span class="literal">true</span>);							  <span class="comment">// 获取离群点（此值默认为 false）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>滤波结果</li>
</ul>
<center class="half">
    <img src="F:\AFIGHT\笔记\PCL\assets\统计滤波结果.png" alt="统计滤波结果"  style="zoom:50%;" />
    <img src="F:\AFIGHT\笔记\PCL\assets\统计滤波离群点.png" alt="统计滤波离群点"  style="zoom:50%;" />
</center>

<h3 id="参数化模型投影点云"><a href="#参数化模型投影点云" class="headerlink" title="参数化模型投影点云"></a>参数化模型投影点云</h3><ul>
<li><p>点投影到参数化模型，该模型由一组参数设定，如标准平面方程：ax + by + cz + d = 0</p>
</li>
<li><p>PCL 中有特意存储常见模型系数的数据结构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a set of planar coefficients with X=Y=0,Z=1  </span></span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients())</span></span>;	<span class="comment">// 创建 模型系数 对象</span></span><br><span class="line">coefficients-&gt;values.resize(<span class="number">4</span>);										<span class="comment">// 参数个数置为 4</span></span><br><span class="line">coefficients-&gt;values[<span class="number">0</span>] = coefficients-&gt;values[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 设置 x y d 的系数为 0 ，z 为 1，即平面为 Z=0，也就是 X-Y</span></span><br><span class="line">coefficients-&gt;values[<span class="number">2</span>] = <span class="number">1.0</span>;</span><br><span class="line">coefficients-&gt;values[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the filtering object</span></span><br><span class="line">pcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj;	<span class="comment">// 设置投影滤波对象			</span></span><br><span class="line">proj.setModelType(pcl::SACMODEL_PLANE);		<span class="comment">// 设置对象对应的投影模型类型，此处为平面模型</span></span><br><span class="line">proj.setInputCloud(cloud);				   <span class="comment">// 设置输入</span></span><br><span class="line">proj.setModelCoefficients(coefficients);	<span class="comment">// 设置模型系数为前述定义系数</span></span><br><span class="line">proj.filter(*cloud_projected);			   <span class="comment">// 执行并保存</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="从一个点云中提取一个子集"><a href="#从一个点云中提取一个子集" class="headerlink" title="从一个点云中提取一个子集"></a>从一个点云中提取一个子集</h3><ul>
<li>基于 ExtractIndices 滤波器（基于分割算法）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; <span class="comment">// 创建分割对象</span></span><br><span class="line">extract.setInputCloud(cloud_filtered); 	    <span class="comment">// 设置输入点云 </span></span><br><span class="line">extract.setIndices(inliers);		   	   <span class="comment">// 设置分割后的内点为需要提取的点击（分割部分略）</span></span><br><span class="line">extract.setNegative(<span class="literal">false</span>);			   	   <span class="comment">// 指定提取内点</span></span><br><span class="line">extract.filter(*cloud_p);			  	   <span class="comment">// 执行并存储</span></span><br></pre></td></tr></table></figure>

<h3 id="RadiusOutlierRemoval-ConditionalRemoval-移除离群点"><a href="#RadiusOutlierRemoval-ConditionalRemoval-移除离群点" class="headerlink" title="RadiusOutlierRemoval / ConditionalRemoval  移除离群点"></a>RadiusOutlierRemoval / ConditionalRemoval  移除离群点</h3><h4 id="RadiusOutlierRemoval"><a href="#RadiusOutlierRemoval" class="headerlink" title="RadiusOutlierRemoval"></a>RadiusOutlierRemoval</h4><ul>
<li>删除输入点云一定范围内没有达到足够多近邻的所有数据点</li>
<li>人话：如图，若设置搜索的半径为 d，即在半径为 d 的范围内查找近邻点，如若用户指定在此半径内至少需要 1 个近邻点，对图中的黄色点而言，其在此范围内没有近邻点，故会被删除；若指定至少需要 2 个近邻点，则黄色和绿色均会被删除（显然它们在圈内呆不住），黑色点则保留。</li>
</ul>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Cradius_outlier.png" alt="RadiusOutlierRemoval "></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem;	<span class="comment">// 创建半径滤波对象</span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">outrem.setInputCloud(cloud);						<span class="comment">// 设置输入点云</span></span><br><span class="line">outrem.setRadiusSearch(<span class="number">0.8</span>);						<span class="comment">// 设置搜索半径为 0.8</span></span><br><span class="line">outrem.setMinNeighborsInRadius(<span class="number">2</span>);					<span class="comment">// 设置所需近邻点数为 2</span></span><br><span class="line">outrem.setKeepOrganized(<span class="literal">true</span>);	   <span class="comment">// 设置将被滤除点保留但置为 NaN(true,保持数据结构不变，若为 false，则移除点，此为默认值)</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">outrem.filter(*cloud_filtered);						<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure>

<h4 id="ConditionalRemoval"><a href="#ConditionalRemoval" class="headerlink" title="ConditionalRemoval"></a>ConditionalRemoval</h4><ul>
<li>如其名，可删除点云中不符合用户指定条件的数据点，条件可为一个或多个</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">range_cond</span><span class="params">(<span class="keyword">new</span> pcl::ConditionAnd&lt;pcl::PointXYZ&gt;())</span></span>;	<span class="comment">// 创建条件定义对象</span></span><br><span class="line">range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(<span class="keyword">new</span></span><br><span class="line">		pcl::FieldComparison&lt;pcl::PointXYZ&gt;(<span class="string">"z"</span>, pcl::ComparisonOps::GT, <span class="number">0.0</span>)));  <span class="comment">// 添加比较算子：z 字段上大于 0.0 </span></span><br><span class="line">range_cond-&gt;addComparison(pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr(<span class="keyword">new</span></span><br><span class="line">		pcl::FieldComparison&lt;pcl::PointXYZ&gt;(<span class="string">"z"</span>, pcl::ComparisonOps::LT, <span class="number">0.8</span>)));  <span class="comment">// 添加比较算子：z 字段上小于 0.8 </span></span><br><span class="line"><span class="comment">// build the filter</span></span><br><span class="line">pcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem;	 <span class="comment">// 初始化条件滤波</span></span><br><span class="line">condrem.setCondition(range_cond);				<span class="comment">// 设置条件为指定的比较算子</span></span><br><span class="line">condrem.setInputCloud(cloud);					<span class="comment">// 设置输入点云</span></span><br><span class="line">condrem.setKeepOrganized(<span class="literal">true</span>);					<span class="comment">// 设置将被滤除点保留但置为 NaN</span></span><br><span class="line"><span class="comment">// apply filter</span></span><br><span class="line">condrem.filter(*cloud_filtered);				<span class="comment">// 执行滤波并保存</span></span><br></pre></td></tr></table></figure>

<h3 id="CropHull-任意多边形内部点云提取"><a href="#CropHull-任意多边形内部点云提取" class="headerlink" title="CropHull 任意多边形内部点云提取"></a>CropHull 任意多边形内部点云提取</h3><ul>
<li>CropHull 滤波器得到 2D 封闭多边形内 / 外的点云</li>
</ul>
<h2 id="深度图像（Range-Depth-Images）"><a href="#深度图像（Range-Depth-Images）" class="headerlink" title="深度图像（Range/Depth Images）"></a>深度图像（Range/Depth Images）</h2><ul>
<li>将图像采集器到场景中各点的距离（深度）值作为像素值的图像（<strong>距离是相机到场景点的垂直距离，不是连线距离</strong>）</li>
<li>直接反映景物可见表面的几何状态</li>
<li>物体的三维表示形式，可通过<code>立体相机或 TOF 相机</code>获取</li>
<li>深度图像和点云的相互转换：深度图像——&gt;坐标转换（相机内参已知）——&gt;点云数据；点云数据（有规则及必要信息）——&gt;反算——&gt;深度图像数据</li>
<li>英文中常见的等价表述：<code>range image</code>，depth map、dense-depth map、range picture、3D image、surface height map、dense-range image、2.5D image、3D data、xyz maps、surface profiles</li>
</ul>
<p>注：Z 代表的是相机的光轴在相机的 Z 轴方向，也就是深度信息</p>
<h3 id="从点云创建深度图像"><a href="#从点云创建深度图像" class="headerlink" title="从点云创建深度图像"></a>从点云创建深度图像</h3><ul>
<li><p>主要函数为 createFromPointCloud，声明 9 个参数填充即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pcl::RangeImage::createFromPointCloud	(	<span class="keyword">const</span> PointCloudType &amp; 	point_cloud,</span><br><span class="line"><span class="keyword">float</span> 	angular_resolution = pcl::deg2rad (<span class="number">0.5f</span>),</span><br><span class="line"><span class="keyword">float</span> 	max_angle_width = pcl::deg2rad (<span class="number">360.0f</span>),</span><br><span class="line"><span class="keyword">float</span> 	max_angle_height = pcl::deg2rad (<span class="number">180.0f</span>),</span><br><span class="line"><span class="keyword">const</span> Eigen::Affine3f &amp; 	sensor_pose = Eigen::Affine3f::Identity (),</span><br><span class="line">RangeImage::CoordinateFrame 	coordinate_frame = CAMERA_FRAME,</span><br><span class="line"><span class="keyword">float</span> 	noise_level = <span class="number">0.0f</span>,</span><br><span class="line"><span class="keyword">float</span> 	min_range = <span class="number">0.0f</span>,</span><br><span class="line"><span class="keyword">int</span> 	border_size = <span class="number">0</span> </span><br><span class="line">)		</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Create the depth image from a point cloud.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parameter EX:</span></span><br><span class="line"><span class="comment">point_cloud	the input point cloud</span></span><br><span class="line"><span class="comment">angular_resolution	the angular difference (in radians) between the individual pixels in the image</span></span><br><span class="line"><span class="comment">max_angle_width	an angle (in radians) defining the horizontal bounds of the sensor</span></span><br><span class="line"><span class="comment">max_angle_height	an angle (in radians) defining the vertical bounds of the sensor</span></span><br><span class="line"><span class="comment">sensor_pose	an affine matrix defining the pose of the sensor (defaults to Eigen::Affine3f::Identity () )</span></span><br><span class="line"><span class="comment">coordinate_frame	the coordinate frame (defaults to CAMERA_FRAME)</span></span><br><span class="line"><span class="comment">noise_level	- The distance in meters inside of which the z-buffer will not use the minimum, but the mean of the points. If 0.0 it is equivalent to a normal z-buffer and will always take the minimum per cell.</span></span><br><span class="line"><span class="comment">min_range	the minimum visible range (defaults to 0)</span></span><br><span class="line"><span class="comment">border_size	the border size (defaults to 0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="从深度图像提取边界"><a href="#从深度图像提取边界" class="headerlink" title="从深度图像提取边界"></a>从深度图像提取边界</h3><ul>
<li>边界：前景跨越到背景的位置</li>
<li>物体边界（黑）、阴影边界（绿）、Veil 点集（红）</li>
</ul>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Crange_image_border_points.png" alt="边界点集分类"></p>
<ul>
<li>若两点在深度图像上相邻，但在三维距离上很远，则可判断该处有边缘</li>
</ul>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li><p>兴趣点，是 2D 图像、3D 点云或曲面模型上可通过定义检测标准来获取的具有稳定性、区别性的点集</p>
</li>
<li><p>数量比原始点云或图像的数据量小很多</p>
</li>
<li><p>组成关键点描述子（关键点 + 局部特征描述子），形成原始数据的紧凑表示，且不失代表性与描述性</p>
</li>
<li><p>利于加快后续的处理速度</p>
</li>
</ul>
<h3 id="关键概念及算法"><a href="#关键概念及算法" class="headerlink" title="关键概念及算法"></a>关键概念及算法</h3><h4 id="NARF-关键点"><a href="#NARF-关键点" class="headerlink" title="NARF 关键点"></a>NARF 关键点</h4><p>*Steder B, Rusu R B, Konolige K, et al. Point feature extraction on 3D range scans taking into account object boundaries[C]//2011 IEEE International Conference on Robotics and Automation. IEEE, 2011: 2601-2608.</p>
<ul>
<li>从深度图像识别物体</li>
<li>步骤<ul>
<li>遍历每个深度图像点，通过寻找在近邻区域有深度突变的位置进行边缘检测；</li>
<li>遍历每个深度图像点，根据近邻区域的表面变化决定一种测度表面变化的系数，以及变化的主方向；</li>
<li>根据第二步找到的主方向计算兴趣值，表征该方向与其他方向的不同，以及该处表面的变化情况，即该点有多稳定；</li>
<li>对兴趣值进行平滑过滤；</li>
<li>进行无最大值压缩找到最终的关键点，即为 NARF 关键点。</li>
</ul>
</li>
<li>简化步骤*<ul>
<li>给定深度图像，进行边缘提取</li>
<li>表面变化基于边界和曲率原则”评分“</li>
<li>设置支持范围（搜索邻域的球体半径）：范围越大，可识别的到的关键点越多</li>
</ul>
</li>
</ul>
<h4 id="Harris关键点"><a href="#Harris关键点" class="headerlink" title="Harris关键点"></a>Harris关键点</h4><ul>
<li>通过计算图像点的 Harris 矩阵和矩阵对应的特征值来判断是否是关键点</li>
<li>若 Harris 矩阵特征的两个特征值都很大，则为关键点</li>
<li>对图像旋转变换保持较好的检测重复率，但不适合尺度变化的关键点检测</li>
<li>3D Harris 关键点检测使用的是<code>点云表面法向量的信息</code>（2D 使用的是图像梯度）</li>
</ul>
<h4 id="PCL-中的-keypoints"><a href="#PCL-中的-keypoints" class="headerlink" title="PCL 中的 keypoints"></a>PCL 中的 keypoints</h4><h5 id="深度图像提取-NARF-关键点"><a href="#深度图像提取-NARF-关键点" class="headerlink" title="深度图像提取 NARF 关键点"></a>深度图像提取 NARF 关键点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::RangeImageBorderExtractor range_image_border_extractor;			<span class="comment">// 创建对象，用于边缘提取</span></span><br><span class="line"><span class="function">pcl::NarfKeypoint <span class="title">narf_keypoint_detector</span><span class="params">(&amp;range_image_border_extractor)</span></span>; <span class="comment">// 创建对象，传入上述提取出的深度图像边缘</span></span><br><span class="line">narf_keypoint_detector.setRangeImage(&amp;range_image);					   <span class="comment">// 传入深度图像</span></span><br><span class="line">narf_keypoint_detector.getParameters().support_size = support_size;	    <span class="comment">// 设置支持范围(搜索空间球体的半径，邻域范围)</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().add_points_on_straight_edges = true;</span></span><br><span class="line"><span class="comment">//narf_keypoint_detector.getParameters ().distance_for_additional_points = 0.5;</span></span><br><span class="line">pcl::PointCloud&lt;<span class="keyword">int</span>&gt; keypoint_indices;								<span class="comment">// 创建点云对象，存储检测到的点云</span></span><br><span class="line">narf_keypoint_detector.compute(keypoint_indices);	 				 <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure>

<h5 id="SIFT-关键点提取"><a href="#SIFT-关键点提取" class="headerlink" title="SIFT 关键点提取"></a>SIFT 关键点提取</h5><p><a href="https://blog.csdn.net/dcrmg/article/details/52561656" target="_blank" rel="noopener">参考：Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔_牧野的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_43653930/article/details/104651907?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-5&spm=1001.2101.3001.4242" target="_blank" rel="noopener">参考：计算机视觉3—SIFT理解与应用_wwy的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_40293648/article/details/82836998" target="_blank" rel="noopener">参考：SIFT（3）—–尺度空间极值检测_姗姗本人的博客-CSDN博客</a></p>
<p>注意：① 关键点确定：是通过 DOG（高斯差分）尺度空间求极值确定的，只要一个点在 DOG 尺度空间本层以及上下两层的26个邻域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点。</p>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Csift%E7%AE%97%E5%AD%90-DOG%E5%B0%BA%E5%BA%A6%E7%A9%BA%E9%97%B4.png" alt="DOG尺度空间关键点确定"></p>
<p>​           ② 方向的确定：通过求每个极值点的梯度来为极值点赋予方向，完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。确定关键点的方向采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点对关键点方向生成所作的贡献。如图，以邻域中确定的方向占比最高的一个确定为该关键点的方向</p>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CDOG%E5%B0%BA%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%85%B3%E9%94%AE%E7%82%B9%E6%96%B9%E5%90%91%E7%A1%AE%E5%AE%9A.png" alt="关键点方向确定"></p>
<p>​            ③ 特征描述子：每个关键点包含 位置、尺度、方向。建立一个描述子，用一个向量将关键点表示出来。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。 </p>
<img src="F:\AFIGHT\笔记\PCL\assets\DOG尺度空间关键点描述子.png" alt="关键点描述子" style="zoom:67%;" />

<ul>
<li><p>尺度不变性</p>
</li>
<li><p>局部特征描述子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::SIFTKeypoint&lt;pcl::PointXYZ, pcl::PointWithScale&gt; sift;	<span class="comment">// 创建sift关键点检测对象</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointWithScale&gt; result;			  <span class="comment">// 存储查询结果</span></span><br><span class="line">sift.setInputCloud(cloud_xyz);							 <span class="comment">// 设置输入点云</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">sift.setSearchMethod(tree);							<span class="comment">// 创建一个空的 kd 树对象 tree，并把它传递给 sift 检测对象</span></span><br><span class="line"><span class="comment">// 建立 k-d 树的原因：群举法耗时，k-d 作为平衡二叉树，搜索较快</span></span><br><span class="line">sift.setScales(min_scale, n_octaves, n_scales_per_octave); <span class="comment">// 设置限制关键点检测的阈值</span></span><br><span class="line">sift.compute(result);								    <span class="comment">// 执行sift关键点检测，保存结果在result</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setScales 函数原型</span></span><br><span class="line"><span class="keyword">void</span> pcl::SIFTKeypoint&lt; PointInT, PointOutT &gt;::setScales	(	<span class="keyword">float</span> 	min_scale,</span><br><span class="line"><span class="keyword">int</span> 	nr_octaves,</span><br><span class="line"><span class="keyword">int</span> 	nr_scales_per_octave </span><br><span class="line">)	</span><br><span class="line">   用于指定搜索关键点的尺度范围 </span><br><span class="line"><span class="comment">// Specify the range of scales over which to search for keypoints.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters</span></span><br><span class="line">   			   设置尺度空间中最小尺度的标准偏差（尺度高斯函数中的 σ）</span><br><span class="line"><span class="comment">// min_scale	the standard deviation of the smallest scale in the scale space</span></span><br><span class="line">			   高斯金字塔中组（octaves）的数目</span><br><span class="line"><span class="comment">// nr_octaves	the number of otaves (i.e. doublings of scale) to compute</span></span><br><span class="line">    				   每组计算的尺度数目</span><br><span class="line"><span class="comment">// nr_scales_per_octave	the number of scales to compute within each octave</span></span><br></pre></td></tr></table></figure>

<img src="F:\AFIGHT\笔记\PCL\assets\高斯金字塔sift算子关键点.png" alt="高斯金字塔sift算子关键点" style="zoom: 50%;" />

</li>
</ul>
<h5 id="Harris-关键点提取"><a href="#Harris-关键点提取" class="headerlink" title="Harris 关键点提取"></a>Harris 关键点提取</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//harris_detector-&gt;setNonMaxSupression(true);</span></span><br><span class="line">harris_detector-&gt;setRadius(r_normal);			<span class="comment">// 设置法向量估计的半径</span></span><br><span class="line">harris_detector-&gt;setRadiusSearch(r_keypoint);	<span class="comment">// 设置关键点估计的近邻搜索半径</span></span><br><span class="line">harris_detector-&gt;setInputCloud (input_cloud);</span><br><span class="line"><span class="comment">//harris_detector-&gt;setNormals(normal_source);</span></span><br><span class="line"><span class="comment">//harris_detector-&gt;setMethod(pcl::HarrisKeypoint3D&lt;pcl::PointXYZRGB,pcl::PointXYZI&gt;::LOWE);</span></span><br><span class="line">harris_detector-&gt;compute (*Harris_keypoints);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Harris_keypoints的大小是"</span>&lt;&lt;Harris_keypoints-&gt;size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">writer.write&lt;pcl::PointXYZI&gt; (<span class="string">"Harris_keypoints.pcd"</span>,*Harris_keypoints,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="特征描述与提取"><a href="#特征描述与提取" class="headerlink" title="特征描述与提取"></a>特征描述与提取</h2><h3 id="特征描述"><a href="#特征描述" class="headerlink" title="特征描述"></a>特征描述</h3><ul>
<li>局部特征描述 + 全局特征描述</li>
</ul>
<h3 id="特征描述子"><a href="#特征描述子" class="headerlink" title="特征描述子"></a>特征描述子</h3><p>三维坐标系中，一个点自然用 xyz 坐标即可表示；但在坐标原点不随时间变化时，在不同时间获取的两个点，其位置可能可能是相同的（这是一种不适定问题（ill-posed problem）），但它们可能是在不同的表面产生的，即包含的信息是完全不同的。此时，用简单的三维坐标是没法表达这种信息的，故引入==描述子==的概念，其他的别称有<strong>形状描述子（shape descriptors）</strong>、<strong>几何特征（gometric features）</strong>、<strong>点特征表示（point feature representations）</strong>等。</p>
<h4 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文 P23，37）</p>
<p>给定一个点 $ p_q $ 作为查询点，设 $P^k = {p_1^k···p_2^k}$ 是 $ p_q $ 近邻点的点集（即这个集合中的每个点都是 $p_q$ 的近邻点），则近邻点的概念为：<br>$$<br>||p_i^k-p_q||_x \leq d_m \tag{1.1}<br>$$<br>式中，$d_m$ 是近邻点到指定点之间允许的最大距离，$||·||_x$ 是闵式范数 $L_x$ （范数可以理解为两个 n 维空间点之间的距离，详见<a href="https://blog.csdn.net/skybirdhua1989/article/details/17584797" target="_blank" rel="noopener">范数</a>）。</p>
<p>此外，$P^k$ 中近邻点的个数可被限制为给定值 k。</p>
<p>点的特征表示可描述为向量函数 $F$, 该函数描述了由点集 $P^k$ 捕获的局部几何信息，在 $ p_q $ 周围：<br>$$<br>F(p_q,P^k)={x_1,x_2,···,x_n}<br>$$<br>式中，$x_i$ , $i \in { 1···n}$ 表示的是特征向量 $F$ 的维数 $i$。</p>
<p>比较两个不同的点 $p_1$ 和 $p_2$，并比较这两点对应的特征向量 $F_1$ 、$F_2$ 在空间上的差异。设 $\Gamma$ 为描述这两点之间差异的<strong>相似性度量</strong>，$d$ 为<strong>距离度量</strong>，则有：<br>$$<br>\Gamma = d(F_1,F_2)<br>$$<br>当 $d$ 趋向于某个最小值时，即 $d \to 0$ 时，这两点(在特征表示上)即可被认为是相似的；若 $d$ 很大，则为不相似，即它们表示不同表面的几何信息。</p>
<p><em>个人理解：两点之间的相似程度可以用两点对应的特征向量之间的距离表示，距离越小越相似。</em></p>
<p>通过包含周围的邻域，可以解决前述中的模糊比较问题（不适定问题）。</p>
<p>理想情况下，相同或相似表面上的点的特征值是相似的，在下面的条件中，通过比较是否有相同的局部表面特征，判断点特征表示的优劣：</p>
<ul>
<li>刚体变换：3D旋转和平移不影响特征向量 F 的估计，即 特征向量具有<strong>旋转平移不变性</strong></li>
<li>不同的采样密度：原则上，一个局部表面小块的采样密度无论大还是小，应具有相同的特征向量值，即特征向量具有<strong>抗密度干扰性</strong></li>
<li>噪声：在数据中存在轻微噪声的情况下，点特征表示在其特征向量中须保持相同或非常相似的值，即特征向量对点云噪声具有<strong>鲁棒性</strong></li>
</ul>
<p><em>也就是说，一个点特征表示满足上述条件才可以说是好的表示法</em></p>
<h4 id="邻域的概念"><a href="#邻域的概念" class="headerlink" title="邻域的概念"></a>邻域的概念</h4><p>确定点的近邻点集 $P^k$ 的问题，与所使用的特定的度量空间是相关的。式 1.1 给出的定义是成立的，更常见的范数是欧几里得 $L_2$ 范数，其定义如下，表示向量元素（或者是点的坐标）的平方和再开方：<br>$$<br>||X||<em>2 = \sqrt{\sum</em>{i=1}^n x_i^2}<br>$$<br><em>可用于度量两个向量间的差异</em>，如平方差和：<br>$$<br>SSD(x_1,x_2) = \sum_{i=1}^n(x_{1i}-x_{2i})^2<br>$$<br>也就是说，为确定查询点 $p_q$ 的 k 近邻点，就需要对查询点到点云中所有点的距离进行估计和排序，这个排序中最小的 k 个值就对应最近邻点集 $P^k$ 。</p>
<p>但事实上，这种蛮力的处理代价过高，所以前述中提高的 k-d tree 等数据结构就派上用场了（详见 k-d tree 部分的两种查询方式）。</p>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><h4 id="输入点云的调用"><a href="#输入点云的调用" class="headerlink" title="输入点云的调用"></a>输入点云的调用</h4><ul>
<li><p>输入点云调用函数主要有：</p>
<ul>
<li><p>setInputCloud，必选项，设置输入点云，并为输入点云中的每个点估计一个特征向量</p>
</li>
<li><p>setIndices，可选项，使用此项设置索引，此时只对输入点云中给定索引的点估计特征向量；若不设置此项，则输入点云中所有点均参与计算</p>
</li>
<li><p>setSearchSurface，可选项，设置搜索时使用的点的集合；若不设置该项，默认将输入点云作为搜索空间</p>
</li>
<li><p>后两个可选项必须结合 setInputCloud 使用，两种可能的组合有四种，如下图示（不懂可看 PCL书 P208）</p>
</li>
</ul>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Cfeatures_input_explained.png" alt="输入点云调用习惯">                </p>
<ul>
<li>经典案例：对一个密集的输入点云，诚然不想对其所有点都进行特征估计，只希望在关键点出进行，此时只需把找出的关键点设置为输入点云，而使用 setSearchSurface 将原始的数据设置为搜索空间，从而提高搜索的效率。</li>
</ul>
</li>
</ul>
<h4 id="估计点云的表面法线"><a href="#估计点云的表面法线" class="headerlink" title="估计点云的表面法线"></a>估计点云的表面法线</h4><p>（详见博士论文 P45）</p>
<ul>
<li><p>描述曲面几何的首要问题是推断其在坐标系中的方向，即估计其法线</p>
</li>
<li><p>一般有两种方法：①使用曲面重建技术，点云数据——&gt;采样点对应的曲面——&gt;从曲面模型计算表面法线；②<code>直接从点云数据集中近似推断表面法线</code></p>
</li>
<li><p>对后一种，==一点的法线问题可等效为该点的一个相切面的法线的问题==，也就是最小二乘的平面拟合估计问题（*），转换为为分析一个协方差矩阵的特征向量和特征值的问题，而估计点集的协方差矩阵在 PCL 中有对应的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中估计一点集对应的协方差矩阵</span></span><br><span class="line">Eigen::Matrix3f covariance_matrix;	<span class="comment">// 定义每个表面小块的 3×3 协方差矩阵的存储对象</span></span><br><span class="line">Eigen::Vector4f xyz_controid;		<span class="comment">// 定义一个表面小块的质心坐标16字节对其存储对象</span></span><br><span class="line">compute3DCentroid(cloud, xyz_controid);	<span class="comment">// 估计质心坐标</span></span><br><span class="line">computeCovarianceMatrix(cloud, xyz_controid, covariance_matrix);	<span class="comment">// 计算 3×3 协方差矩阵</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一个平面可用一个点 $x$ 和 一个法向量 $\overline n$ 表示，则一个点 $p_i \in P^k$ 到平面的距离定义为 $d_i = (p_i -x)· \overline n$ 。 $x$ 和  $\overline n$ 的值用最小二乘法计算，即 $d_i = 0$。（个人理解：一点的法线等效于该点切面的法线，而切面可用一点和一法向量表示，故只要 $p_i \in P^k$ 到切面的距离为0，它们就是同一个点，那么法向量就是法线？）</p>
<p>设<br>$$<br>x = \overline p = \frac{1}{k}· \sum_{i=1}^{k}p_i<br>$$<br>为 $P^k$ 的质心，而 $\overline n$ 的解可通过分析 $P^k$ 的协方差矩阵 $C \in R^{3 \times 3}$ 的特征值和特征向量得到，其表达式如下：<br>$$<br>C = \frac{1}{k} \sum_{i=1}^{k} \xi_i · (p_i - \overline p)·(p_i - \overline p)^T , \ C· \overline v_i = \lambda_i· \overline v_j ,  \  j \in {0,1,2}<br>$$<br>式中，$\xi_i$ 为 $p_i$ 可能的权值，通常为 1；$C$ 为对称半正定矩阵，其特征值是实数 $\lambda_j \in R$ ，特征向量 $\overline v_j$ 形成一个正交坐标系，对应 $P^k$ 的主成分。若 $0 \le \lambda_0 \le \lambda_1 \le \lambda_2$ ，则特征向量 $\overline v_0$ 对应的最小特征值 $\lambda_0$ 就是 $+ \overline n = {n_x,n_y,n_z}$ 或 $ - \overline n$ 的近似（也就是把法向量用特征值近似）。此外，$\overline n$ 可由球坐标中的一对角 $(\phi,\theta)$ 表示如下：<br>$$<br>\phi = \arctan \frac{n_z}{n_y}, \ \theta =  \arctan\frac{\sqrt{(n_y^2+n_z^2)}}{n_x}<br>$$<br>问题是，这种主成分分析法（PCA）对方向仍然是模糊的。</p>
<h4 id="表面曲率"><a href="#表面曲率" class="headerlink" title="表面曲率"></a>表面曲率</h4><p>（详见博士论文P48）</p>
<p>方法多但都无法很好的解决，对噪声敏感问题，一种解决方式是：用协方差矩阵 $C$ 的特征值 $\lambda_j$ 点 $p$ 周围表面变化的近似。若 $\lambda_0 = min(\lambda_j)$ ，则点 $p$ 沿着表面法线的 $\overline n$ 的变化可使用下式估计：<br>$$<br>\sigma_p = \frac{\lambda_0}{\lambda_0+\lambda_1+\lambda_3}<br>$$<br> 该最小特征值与特征值之和的比值 $\sigma_p$ 近似于以 $p$ 为圆心的邻域 $P^k$ 的曲率变化，且具有缩放不变性；该值越小，意味着 $P^k$ 中的所有点都在与该曲面相切的平面上。</p>
<p>source：* Craig Shakarji. Least-Squares Fitting Algorithms of the NIST Algorithm Testing System. Journal of Research of the National Institute of Standards and Technology, 103(6):633–641, November-December 1998</p>
<h4 id="法线的定向问题"><a href="#法线的定向问题" class="headerlink" title="法线的定向问题"></a>法线的定向问题</h4><ul>
<li><p>没有数学方法可以解决法线的正负向问题</p>
</li>
<li><p>法线球体描述了点云中所有法线的方向</p>
</li>
<li><p>对于已知视点，且是单个视点获得的点云的法线定向，可以将所有方向定向到视点方向</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCL 中对已知点的法线手动重定向（只适用于单视点获取的数据集）</span></span><br><span class="line">flipNormalTowardsViewpoint	(	<span class="keyword">const</span> PointCloud &amp; 	cloud,</span><br><span class="line"><span class="keyword">float</span> 	vp_x,</span><br><span class="line"><span class="keyword">float</span> 	vp_y,</span><br><span class="line"><span class="keyword">float</span> 	vp_z,</span><br><span class="line">Normals &amp; 	normals </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>但若视点未知，则可考虑将两点 $p_i$ 、$p_j$ 认为是在一光滑的曲面上或是在几何上十分接近，需它们的法线方向一致，即 $n_i \cdot n_j = 1$。</li>
</ul>
<h3 id="点特征直方图（PFH）"><a href="#点特征直方图（PFH）" class="headerlink" title="点特征直方图（PFH）"></a>点特征直方图（PFH）</h3><p>（详见博士论文P51和PCL书P213）</p>
<p>bin 可理解为分格的大小，就是直方图每一个柱子的宽度</p>
<h4 id="理论-2"><a href="#理论-2" class="headerlink" title="理论"></a>理论</h4><p>通过使用近邻点的方式确定表面法线和曲率是最基本的方式，但其使用的近邻点毕竟是少数，所以会丢失信息；且当场景中的特征值相似时，将大大减少获取的信息。</p>
<p>一种方法是，给不同的点添加累标签，如 边缘上的点，平面上的点等，这样数据点在不同的表面就会被分配到不同的类别。</p>
<p>为形成新的特征空间，引入 <em>双环邻域</em>  的概念：设 $P$ 是一组几何坐标为 ${x_i,y_i,z_i}$ 的 3D 点集，点 $p_i \in P$ 有双环邻域的条件是：<br>$$<br>(\exists)r_1,r_2 \in R, \ r_1 &lt;r_2,  \ \begin{cases} r_1  \Rightarrow P^{k_1} \ r_2 \Rightarrow P^{k_2}\end{cases}, \ 0&lt;k_1&lt;k_2<br>$$<br>两个半径 $r_1$ 和 $r_2$ 用于确定点 $p_i$ 的两个不同的特征表示层：第一层表示的是查询点处的法线，从邻域集 $p^{k_1}$ 的主成分分析中获得，第二层即为 PFH。</p>
<p>PFH 是基于 $P_{k_2} $ 中的点及其法线之间的关系的，即通过参数化查询点与邻域点之间的空间差异，形成一个多维直方图对点的 k 邻域几何属性进行描述。直方图所在的高维超空间为特征表示提供了一个可度量的信息空间，对点云对应曲面的 6 维姿态来说它具有不变性，并且在不同的采样密度或邻域的噪音等级下具有鲁棒性。简言之，<strong>它考虑估计法线方向之间所有的相互作用，来尽可能捕获采样表面的变化</strong>。故合成的超空间依赖于每个点表面法线估计的质量。（人话就是：PFH 结果的优劣，取决于法线估计的好坏，这也说明，计算 PFH 的第一步就是表面法线的估计）</p>
<p>为计算两点 $p_i$ 和 $p_j$ 之间的相对差以及它们的法线 $n_i$ 和 $n_j$，在其中一点上定义了一个固定的局部坐标系。为使坐标系被唯一定义，做如下规定： 令 $p_{ji} = p_j - p_i, \ p_{ij} = p_i - p_j$ ，<br>$$<br>if \quad \arccos(\overline n_i \cdot \overline p_{ji}) \le \arccos(\overline n_j \cdot \overline p_{ij})<br>\ then \begin{cases} p_s = p_i,\ n_s =n_i \ p_t = p_j, \ n_t = n_j  \end{cases}<br>\ else \begin{cases} p_s = p_j,\ n_s =n_j \ p_t = p_i, \ n_t = n_i  \end{cases}<br>$$<br>定义 $p_s$ 为源点，$p_t$ 为目标点，源点的选择使其法线与连接两点的直线之间的夹角最小。然后，可以在 $p_s$ 处将局部坐标系的原点定义为：<br>$$<br>\begin{cases} u = n_s \ v= u \times \frac{(p_t - p_s)}{||p_t - p_s||_2} \ w = u \times v\end{cases}<br>$$<br>在该 uvw 坐标系下，两个法线 $n_s$ 和 $n_t$ 之间的差可以表示为一组角度特征，如下:<br>$$<br>\begin{cases} \alpha = v \cdot n_t \ \phi = u \cdot \frac{(p_t-p_s)}{d} \ \theta = \arctan(w \cdot n_t,u \cdot n_t)\end{cases}<br>$$<br>式中，d 为欧氏距离，$d= ||p_t-p_s||_2$ 。</p>
<p>这样，就只需计算近邻点集 $P^{k_2}$ 中每一对点的特征组成的四个参数 $&lt;\alpha,\phi,\theta,d&gt;$ （将其称为四元组），将原来的12（一个点有 $x,y,z,n_x,n_y,n_z$ (坐标及法线)）个参数减少到了4个。(在一般的实际问题中，d 往往不计在内，实验证明，不计在内效果更好)</p>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CPFH%E5%B1%80%E9%83%A8%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="PFH坐标系"></p>
<p>下图是计算查询点 $p_q$ 的 PFH 时的影响区域图，查询半径（图中虚线，2D 中圆，3D中球）为 $r$ ，可见其 k 近邻点用网格完全互连。</p>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CPFH%E5%8C%BA%E5%9F%9F%E5%BD%B1%E5%93%8D%E5%9B%BE.png" alt="PFH影响区域图"></p>
<p>为创建查询点 $p_i$ 的 PFH 表示，先将所有的四元组放进直方图，这个过程将每个特征的取值范围划分为 b 个子区域，并统计每个子区间中的特征出现次数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每一对点估计 PFH 四元组</span></span><br><span class="line">computePairFeatures (<span class="keyword">const</span> pcl::PointCloud&lt;PointInT&gt; &amp; cloud, <span class="keyword">const</span> pcl::PointCloud&lt; PointNT &gt; &amp; normals,</span><br><span class="line"><span class="keyword">int</span> 	p_idx,</span><br><span class="line"><span class="keyword">int</span> 	q_idx,</span><br><span class="line"><span class="keyword">float</span> &amp; 	f1,</span><br><span class="line"><span class="keyword">float</span> &amp; 	f2,</span><br><span class="line"><span class="keyword">float</span> &amp; 	f3,</span><br><span class="line"><span class="keyword">float</span> &amp; 	f4 </span><br><span class="line">)		</span><br><span class="line">Compute the <span class="number">4</span>-tuple representation containing the three angles <span class="keyword">and</span> one distance between two points represented by Cartesian coordinates <span class="keyword">and</span> normals.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters 参照上图的坐标系理解</span></span><br><span class="line">[in]	cloud	the dataset containing the XYZ Cartesian coordinates of the two points <span class="comment">//输入点云</span></span><br><span class="line">[in]	<span class="function">normals	the dataset containing the surface <span class="title">normals</span> <span class="params">(assuming normalized vectors)</span> at each point in cloud <span class="comment">//法线</span></span></span><br><span class="line">[in]	p_idx	the index of the first point (source)  // 源点</span><br><span class="line">[in]	<span class="function">q_idx	the index of the second <span class="title">point</span> <span class="params">(target)</span> <span class="comment">// 目标点</span></span></span><br><span class="line">[out]	f1	the first angular feature (angle between the projection of nq_idx and u) // θ</span><br><span class="line">[out]	<span class="function">f2	the second angular <span class="title">feature</span> <span class="params">(angle between nq_idx <span class="keyword">and</span> v)</span>					<span class="comment">// α</span></span></span><br><span class="line">[out]	f3	the third angular feature (angle between np_idx and |p_idx - q_idx|)	 // Φ</span><br><span class="line">[out]	<span class="function">f4	the distance <span class="title">feature</span> <span class="params">(p_idx - q_idx)</span>								  <span class="comment">// d 距离</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PFH 特征估计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the PFH estimation class, and pass the input dataset+normals to it</span></span><br><span class="line">pcl::PFHEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PFHSignature125&gt; pfh; <span class="comment">//125是3个角特征量，每个又分为5个区间，故5^3</span></span><br><span class="line"><span class="comment">// 这里的 125 是默认值，也就是直接忽略了 d 的</span></span><br><span class="line">pfh.setInputCloud (cloud);</span><br><span class="line">pfh.setInputNormals (normals);</span><br><span class="line"><span class="comment">// 若点云类型是 PointNormal, pfh.setInputNormals (cloud);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an empty kdtree representation, and pass it to the PFH estimation object.</span></span><br><span class="line"><span class="comment">// Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">pfh.setSearchMethod (tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output datasets</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PFHSignature125&gt;::<span class="function">Ptr <span class="title">pfhs</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PFHSignature125&gt; ())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use all neighbors in a sphere of radius 5cm</span></span><br><span class="line"><span class="comment">// IMPORTANT: the radius used here has to be larger than the radius used to estimate the surface normals!!!</span></span><br><span class="line">pfh.setRadiusSearch (<span class="number">0.05</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the features</span></span><br><span class="line">pfh.compute (*pfhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pfhs-&gt;size () should have the same size as the input cloud-&gt;size ()*，即每个点对应一个 PFH特征向量</span></span><br><span class="line"><span class="comment">// 实质上，该函数只是执行了以下步骤：</span></span><br><span class="line">对点云 P 中的每个点 p</span><br><span class="line">（<span class="number">1</span>）得到p点的最近邻元素</span><br><span class="line">（<span class="number">2</span>）对于邻域内的每对点，计算其三个角度特征参数值</span><br><span class="line">（<span class="number">3</span>）将所有结果统计到一个输出直方图中</span><br></pre></td></tr></table></figure>

<h3 id="快速点特征直方图（FPFH）"><a href="#快速点特征直方图（FPFH）" class="headerlink" title="快速点特征直方图（FPFH）"></a>快速点特征直方图（FPFH）</h3><p>PFH 在计算中的复杂度用大O表示法表示的话为 $O(n k^2)$ ，不利于实时应用，需优化，FPFH 将复杂度降低为 $O(nk)$ ，同时保留了前者的识别特性。</p>
<h4 id="理论-3"><a href="#理论-3" class="headerlink" title="理论"></a>理论</h4><p>（详见博士论文P57和PCL书P217）</p>
<p>首先，对每个查询点 $p_q$ ，计算该点及其近邻点的元组 $&lt;\alpha,\phi,\theta&gt;$ ，这一步称为简化点特征直方图（SPFH），图中红线表示；</p>
<p>接着，重新确定每个点（这个点已经是 $p_q$ 的近邻点）的 k 近邻点，使用近邻点的 SPFH 值作为权重计算查询点 $p_q$ 的最终直方图，即为 FPFH：<br>$$<br>FPFH(p_q) = SPFH(p_q) + \frac{1}{k} \sum_{i=1}^{k} \frac{1}{\omega_k} \cdot SPFH(p_k)<br>$$<br>式中，权重 $\omega_k$ 表示在给定的度量空间中，查询点 $p_q$ 与近邻点 $p_k$ 之间的距离，用于评价点对 $(p_q,p_k)$ ，其影响区域图如下士，每个查询点(红色)只与它的k近邻点(由灰色圈包围)相连。每个直接近邻点又与自己的近邻点相连，所得到的直方图与查询点的直方图进行加权，形成FPFH。用粗线画出的是对 FPFH 计算了两次。</p>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5CFPFH%E5%8C%BA%E5%9F%9F%E5%BD%B1%E5%93%8D%E5%9B%BE.png" alt="FPFH区域影响图"></p>
<p>人话翻译：确定一个查询点，接着找出该查询点的近邻点，计算其参数元组（三个角度参数），（这个过程为 SPFH）然后对找到的所有近邻点，重新作为查询点，找到其近邻点，计算其 SPFH，然后使用上式进行加权，得到 FPFH。</p>
<p>关于 FPH 和 FPFH 的区别，这里略。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>与 FPH 不同的是，FPFHEstimation 类的默认特征是将四个角特征量每个分为11个区间，分别计算后合并，形成有 33 个元素的特征向量。</p>
<h2 id="点云配准"><a href="#点云配准" class="headerlink" title="点云配准"></a>点云配准</h2><ul>
<li>各个视角得到的点集合并到一个统一的坐标系下，形成完整的点云数据的过程 / 操作</li>
<li>实质：不同坐标系中测到点云之间的<code>坐标变换</code> （寻找 R T 的过程）(==错==)</li>
<li>实质是：同一坐标系下不同视角的点云之间的配准，即测量设备始终是同一个，得到的点云在同一个坐标下</li>
</ul>
<p>点云配准的过程是一个寻找刚性变换矩阵的过程，对于两个点云，一个为源点云 $P_s$ ，另一个为目标点云 $P_t$ ，将源点云通过一定的旋转（R）和平移（t）与目标点云配准（就是让它们完全重合），这个过程可表述为：<br>$$<br>P_t = P_s \cdot R + t<br>$$</p>
<h3 id="一对点云的配准（两两配准）"><a href="#一对点云的配准（两两配准）" class="headerlink" title="一对点云的配准（两两配准）"></a>一对点云的配准（两两配准）</h3><ul>
<li>应用一个估计得到一个变换矩阵（R T）使两者完美配准</li>
<li>步骤：<ul>
<li><strong>从两个点云提取关键点，注意使用相同的标准</strong></li>
<li><strong>对所有关键点建立其特征描述子</strong></li>
<li>估计对应关系，结合特征描述子在两个数据集中的坐标位置等进行</li>
<li>如含噪声，则去除对配准有影响的对应点</li>
<li>用剩下的正确点对估计刚体变换，完成配准</li>
</ul>
</li>
</ul>
<img src="F:\AFIGHT\笔记\PCL\assets\block_diagram_single_iteration.jpg" alt="一对点云配对" style="zoom: 67%;" />

<h3 id="对应估计"><a href="#对应估计" class="headerlink" title="对应估计"></a>对应估计</h3><ul>
<li>找到相似特征，确定数据重叠部分，进行配准</li>
<li>使用不同方法来搜索特征之间的对应关系<ul>
<li>点匹配（即只使用xyz坐标作为特征值）：穷举配准、k-d tree 最近邻查询、有序点云的图像空间查找、无序点云的索引空间查找</li>
<li>特征匹配（如法向量、形状直方图等）：穷举配准、k-d tree 最近邻查询</li>
</ul>
</li>
<li>分类<ul>
<li>直接对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点，确认为最终的对应点对（这是默认的估计方式）</li>
<li>相互对应估计：对点云 A 中的每个点，都找到其在点云 B 中的对应点；接着对对点云 B 中的每个点，都找到其在点云 A 中的对应点，然后取它们的交集作为最终的对应点对</li>
</ul>
</li>
</ul>
<h3 id="错误对应关系的去除"><a href="#错误对应关系的去除" class="headerlink" title="错误对应关系的去除"></a>错误对应关系的去除</h3><p>实际中存在着噪声等影响，会导致产生的对应关系不一定是正确的（就是虽然算法找到了对应点对，但其在实际中可能并不是对应的），这些会对最终变换矩阵的估算产生影响，须去除它们，可以提高配准精度和速度。</p>
<p>去除方法：随机采样一致性（RANSAC）等</p>
<p>一对多 的情况：只取距离最近的对应点</p>
<h3 id="ICP算法"><a href="#ICP算法" class="headerlink" title="ICP算法"></a>ICP算法</h3><h4 id="理论-4"><a href="#理论-4" class="headerlink" title="理论"></a>理论</h4><p>无序点云最经典的配准算法——ICP 算法（ Iterative Closest Point ）：通过最小化重叠区域之间的欧氏距离误差度量，来寻找两数据集之间的最优变换。ICP 算法假定两数据集的每个点都有相应的匹配，并使用待匹配与模型之间最近的点做对应。但问题是，两个点云之间不可能是完全的一一对应关系，所以要建立稳定的对应关系显得尤为重要。</p>
<p>ICP 的核心是不断的去寻找源点云和目标点云中点对的最小距离，并不断缩小这个距离，对变换后的点云继续重复该过程，也就是迭代的过程；该过程用数学表达就是求出 R 和 t ,使误差函数取得最小值：<br>$$<br>E(R,t) = \frac{1}{n} \sum_{i=1}^{n} ||P_t^i -(R \cdot P_s^i+t)||^2<br>$$<br>式中，n 是点对的个数，也就是说，这个目标函数是所有点对之间的欧氏距离的平方和。</p>
<p>==ICP 选择点对原则：对于源点云中的每个点，其对应点是目标点云中的最近邻点（按欧氏距离计算）==</p>
<p>主要步骤：[1]解则晓, 徐尚. 三维点云数据拼接中ICP及其改进算法综述[J]. 中国海洋大学学报(自然科学版).</p>
<ul>
<li>对原始点云数据采样</li>
<li>确定初始对应点集</li>
<li>去除错误对应点对</li>
<li>求解坐标变换</li>
</ul>
<p>ICP的主要问题在于搜索近邻点，这个过程耗时严重，为加速该过程，一般将目标点云存储到 k-d tree 结构中。</p>
<h4 id="简单ICP代码"><a href="#简单ICP代码" class="headerlink" title="简单ICP代码"></a>简单ICP代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp; <span class="comment">// 创建	ICP 对象</span></span><br><span class="line">icp.setInputSource(cloud_in);	<span class="comment">// 设置一个输入点云作为 源点云</span></span><br><span class="line">icp.setInputTarget(cloud_out);	<span class="comment">// 设置一个输入点云作为 目标点云</span></span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt; Final;	<span class="comment">// 存储最终的匹配结果</span></span><br><span class="line">icp.align(Final);					  <span class="comment">// 执行匹配</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"has converged:"</span> &lt;&lt; icp.hasConverged() &lt;&lt; <span class="string">" score: "</span> &lt;&lt; <span class="comment">// 匹配是否正确，返回值为 1 则为正确</span></span><br><span class="line">	icp.getFitnessScore() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;							<span class="comment">// 理解为对 配准的评分		</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; icp.getFinalTransformation() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="comment">// 获取转换矩阵</span></span><br></pre></td></tr></table></figure>

<h4 id="逐步匹配多幅点云"><a href="#逐步匹配多幅点云" class="headerlink" title="逐步匹配多幅点云"></a>逐步匹配多幅点云</h4><p>按输入的顺序两两匹配，得到最终的效果，结果是最终转换到第一个点云的坐标系下</p>
<h4 id="交互式ICP"><a href="#交互式ICP" class="headerlink" title="交互式ICP"></a>交互式ICP</h4><p>通过可视化界面实现用户敲空格键时，进行配准，需在内部设置 ICP 迭代次数</p>
<p><a href="https://pcl.readthedocs.io/projects/tutorials/en/latest/interactive_icp.html#interactive-icp" target="_blank" rel="noopener">详见Interactive Iterative Closest Point — Point Cloud Library 0.0 documentation (pcl.readthedocs.io)</a></p>
<h3 id="正态分布变换配准（NDT）"><a href="#正态分布变换配准（NDT）" class="headerlink" title="正态分布变换配准（NDT）"></a>正态分布变换配准（NDT）</h3><ul>
<li>适用于大型点云数据集</li>
<li>配准过程不使用对应点的特征计算及匹配，速度快</li>
<li>NDT 算法中，在目标点云对应的体素网格数据结构的统计计算中不使用单个点，而是使用包含在每个体素单元格中的点的统计数据</li>
<li>使用体素化数据结构 + More-Thuente 搜索</li>
</ul>
<p>NDT 核心：</p>
<ul>
<li><p>将空间划分为网格（2D 中为正方形，3D 中为立方体）</p>
<p>基于网格内的点分布，计算每个网格的概率密度分布（PDF）。每个网格中的 PDF 可理解为每个网格内曲面上的点 $\overline x$ 的生成过程；也就是说，假设 $\overline x$ 的位置是由 D 维的正态随机过程生成的</p>
</li>
</ul>
<h4 id="理论-5"><a href="#理论-5" class="headerlink" title="理论"></a>理论</h4><p>（详见：Magnusson M. The three-dimensional normal-distributions transform: an efficient representation for registration, surface analysis, and loop detection[D]. Örebro universitet, 2009. 从P55开始</p>
<p><a href="https://blog.csdn.net/banzhuan133/article/details/103350049?spm=1001.2014.3001.5501" target="_blank" rel="noopener">两种常见的点云配准方法ICP&amp;NDT_banzhuan133的博客-CSDN博客_ndt点云配准</a>）</p>
<p>对于一个随机（多维）变量，若其满足正态分布，则其对应的 PDF 为：（对应于点云：将目标点云网格化，然后计算每个网格内的多维正态分布）<br>$$<br>p(\vec{x}) = \frac{1}{(2 \pi)^{D/2} \sqrt{\Sigma}} exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1} (\vec{x}-\vec{\mu})}{2})<br>$$<br>式中，$\vec{\mu}$ 为均值向量，$\Sigma$ 为协方差矩阵（对角元素为每个变量的方差，非对角元素为协方差），$D$ 为维数。</p>
<p>$\vec{\mu}$ 和 $\Sigma$ 可单独计算：<br>$$<br>\vec{\mu} = \frac{1}{m} \sum_{k=1}^{m} \vec{y_k} \<br>\quad \quad \quad \quad \quad \quad \quad \quad\Sigma = \frac{1}{m-1} \sum_{k=1}^{m}    (\vec{y_k}-\vec{\mu})(\vec{y_k}-\vec{\mu})^T<br>$$<br>式中的 $\vec{y}_{1, \cdots ,m}$ 表示一个网格中所有的点。（也就是说，上式中的 $p(\vec{x})$ 实质是计算每个网格的 PDF ）</p>
<img src="F:\AFIGHT\笔记\PCL\assets\NDT体素格.png" alt="NDT网格化" style="zoom:50%;" />

<p>使用正态分布表示离散点云的优势在于：正态分布是对点云的分段（分块表示，网格）平滑表示，具有连续的导数；每个 PDF 可看作是局部表面的一种近似，描述了该表面的位置、方向、平滑度。在 2D 或 3D 中 ，表面方向和平滑度可用协方差矩阵的特征向量和特征值表示。对于三维的正态分布，随着 $\Sigma$ 的特征值变化，有着不同的形状（图中箭头表示特征向量，长短表示其特征值的大小）</p>
<p>![3D 正态分布下的不同形状](F:\AFIGHT\笔记\PCL\assets\Differ shape of 3D PDF.png)</p>
<h4 id="NDT-配准"><a href="#NDT-配准" class="headerlink" title="NDT 配准"></a>NDT 配准</h4><p>NDT 的配准目标是找到一个源点云的姿态，使源点云中的点位于目标点云平面上的可能性最大。（△）</p>
<p>若源点云为 $\chi = { \vec{x_1}, \cdots , \vec{x_n} }$ ，其姿态变换（R，T）用一个向量 $\vec{p}$ 表示；假设空间变换函数 $T(\vec{p},\vec{x})$ 表示使用姿态变换 $\vec{p}$ 来移动点 $\vec{x}$ ；另外给定源点云的 $PDF \quad p(\vec{x})$ ，则最优位姿 $\vec{p}$ 应是使似然函数最大化：<br>$$<br>\Psi = \prod_{k=1}^{n} p(T(\vec{p}, \vec{x}<em>k))<br>$$<br>其等价于最小化 $\Psi$ 的负对数似然函数（连乘转对数的和）：<br>$$<br>-log\Psi  = - \sum</em>{k=1}^{n} log(p(T(\vec{p},\vec{x}_k)))<br>$$<br>式中的函数 $p$ 即为上述提到的 $PDF \quad  p(\vec{x})$ 。此外，PDF 也不一定是一个正态分布（只要可以局部捕获表面点结构，且对异常值具有鲁棒性即可）（详见P59）。</p>
<p><em>这也再次说明了我们的第一句话（△）：目的就是找到这个最优的  $\vec{p}$ ，以最大化似然函数（目标函数）</em></p>
<p>目标很明确，就是优化这个位姿参数，NDT 使用 牛顿迭代法进行优化（见后续）。</p>
<p>问题是，负对数似然函数在远离均值的点上呈无限增长的趋势（见P59 图6.5b或下图)，故若数据中存在噪声等异常值，会对其结果产生较大的影响，有人提出了<strong>正态分布与均匀分布结合（$\overline p(\vec{x})$）</strong>的方式：<br>$$<br>\overline p(\vec{x}) = c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2p_0<br>$$<br>式中，$p_0$ 为异常值的期望值。利用这个函数，离群值的影响是有限的。常数 $c_1$ 和 $c_2$ 可以通过要求在单元格所跨越的空间内 $\overline p(\vec{x})$ 的概率质量等于1来确定。</p>
<p>另一个问题是，这种结合的方式没有简单的一阶和二阶导数（其实就是 log 函数求导不方便）；观察负对数似然函数（下图右绿色示），可发现其与高斯函数相像（下图左绿色示），故可用高斯函数来近似上述 $\overline p(\vec{x})$  。</p>
<img src="F:\AFIGHT\笔记\PCL\assets\likelihood.png" alt="likelihood" style="zoom: 67%;" />

<p>$\overline p(\vec{x})$ 对应的 log 形式为（这里 $c_2p_0$ 只剩 $c_2$ ，个人理解为其是一个期望值，是常数，可用一个代替？）：<br>$$<br>-\log (c_1 exp(- \frac{(\vec{x} - \vec{\mu})^T \Sigma^{-1}(\vec{x} - \vec{\mu})}{2}) + c_2)<br>$$<br>函数形式为<br>$$<br>\overline p(x) = - \log(c_1 exp(\frac{-x^2}{2 \sigma ^2}) + c_2)<br>$$<br>的函数可用形式如下的高斯函数近似：<br>$$<br>\tilde{p}(x) = d_1 exp(\frac{-d_2 x^2}{2 \sigma^2}) + d_3<br>$$<br>当 $x=1，x=\sigma，x = \infty$ 时，$\overline p(x)$ 应与 $\tilde p(x)$ 相等，以此来拟合 $d_i$ ：<br>$$<br>d_3 = - \log(c_2) \<br>d_1 = - \log(c_1 + c_2) -d_3 \<br>d_2 = -2 \log(\frac{-\log(c_1 e^{- \frac{1}{2}} + c_2 -d_3)} {d_1})<br>$$<br>如此，源点云中的一点对 NDT 评分函数的影响可用高斯函数近似为：<br>$$<br>\tilde p(\vec{x}_k) = -d_1 exp(- \frac{d_2}{2} (\vec{x}_k - \vec{\mu}_k)^T \Sigma_k^{-1} (\vec{x}_k - \vec{\mu}_k))<br>$$<br>这里忽略了常数 $d_3$ ，因其只是对评分函数进行了一个偏移，但并不影响其形状或参数。</p>
<p>到此，目标函数变为：<br>$$<br>s(\vec{p}) = - \sum_{k=1}^{n} \tilde{p}(T(\vec{p},\vec{x}_k))<br>$$<br><em>所以上述过程就是将源点云的 PDF $p(x)$ 用  $\tilde{p}(x)$ 近似的过程，最后得到的近似表示如上</em></p>
<p>可以看出，似然函数需要求 $\Sigma^{-1}$ ，但若网格内的点是完全共面或共线，则 $\Sigma$ 是奇异的，无法求逆（详见P60）。</p>
<p>位姿参数 $\vec{p}$ 可用牛顿迭代法求解，其方程为：<br>$$<br>H \Delta \vec{p} = - \vec{g}<br>$$<br>式中，$H$ 为海森矩阵，$\vec{g}$ 为 $s(\vec{p})$ 的梯度向量，$\Delta \vec{p}$ 在每次迭代过程中加到当前的位姿估计中，即 $\vec{p} \leftarrow \vec{p} + \Delta \vec{p}$ 。 （具体求解详见P61)</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般在 NDT 配准前需要进行滤波处理，这里使用体素中心网格法</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">filtered_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::ApproximateVoxelGrid&lt;pcl::PointXYZ&gt; approximate_voxel_filter;</span><br><span class="line">approximate_voxel_filter.setLeafSize(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>);</span><br><span class="line">approximate_voxel_filter.setInputCloud(input_cloud);</span><br><span class="line">approximate_voxel_filter.filter(*filtered_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NDT 参数初始化</span></span><br><span class="line">pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;	</span><br><span class="line">ndt.setTransformationEpsilon(<span class="number">0.01</span>);<span class="comment">//设置变换的ε：两个连续的变换(迭代)之间允许的最大差值，用于判断优化过程是否达到最终的阈值</span></span><br><span class="line">ndt.setStepSize(<span class="number">0.1</span>);	<span class="comment">//牛顿法优化的最大步长（收敛速率系数，理解为什么时候终止？？）</span></span><br><span class="line">ndt.setResolution(<span class="number">1.0</span>);	<span class="comment">//分辨率设置，也就是体素化网格的边长</span></span><br><span class="line">ndt.setMaximumIterations(<span class="number">35</span>);	<span class="comment">//迭代的次数：达到该次数时停止</span></span><br><span class="line">ndt.setInputSource(filtered_cloud);</span><br><span class="line">ndt.setInputTarget(target_cloud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化变换参数并执行优化</span></span><br><span class="line"><span class="function">Eigen::AngleAxisf <span class="title">init_rotation</span><span class="params">(<span class="number">0.6931</span>, Eigen::Vector3f::UnitZ())</span></span>;	<span class="comment">//初始位姿 R</span></span><br><span class="line"><span class="function">Eigen::Translation3f <span class="title">init_translation</span> <span class="params">(<span class="number">1.79387</span>, <span class="number">0.720047</span>, <span class="number">0</span>)</span></span>; <span class="comment">// T</span></span><br><span class="line">Eigen::Matrix4f init_guess = (init_translation * init_rotation).matrix(); <span class="comment">//初始搜索位置</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">output_cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">ndt.align(*output_cloud, init_guess);	<span class="comment">//执行配准</span></span><br></pre></td></tr></table></figure>



<h2 id="点云分割"><a href="#点云分割" class="headerlink" title="点云分割"></a>点云分割</h2><ul>
<li>根据空间、几何、纹理等特征对点云进行划分，使得同一划分内的点云具有相似的特征</li>
</ul>
<h3 id="聚类分割算法"><a href="#聚类分割算法" class="headerlink" title="聚类分割算法"></a>聚类分割算法</h3><ul>
<li>详见下一章——论文：聚类与分割</li>
<li>m 个数据，m 维空间内，定义点与点之间的某种性质的亲属聚类；若 m 个数据点构成 n 类，将具有最小距离的两类合为一类，然乎重新计算两类的之间的距离，如此迭代，直至两类之间的距离大于指定的阈值，或者类的个数少于指定的数目，完成分割。</li>
</ul>
<h3 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h3><ul>
<li>随机采样一致性<ul>
<li>从样本中随机抽取一个样本子集，使用最小方差估计法对自己进行模型参数的计算，再计算所有样本与该模型的偏差，将该偏差与设置好的阈值进行比较，若其小于设定的阈值，则为内点，否则为外点</li>
</ul>
</li>
<li>根据一组包含噪声、外点等缺陷的样本数据集，估计出数据的数学模型，同时得到有效的样本数据</li>
<li>参数<ul>
<li>$\tau$ ：误差容忍度，判断样本是否满足模型 M 的误差容忍度</li>
<li>$Max$ ：随机抽取样本集的次数（即抽取子集的次数）</li>
<li>$N$ ：指定的阈值</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">model_p</span><span class="params">(<span class="keyword">new</span> pcl::SampleConsensusModelPlane&lt;pcl::PointXYZ&gt;(cloud))</span></span>;	<span class="comment">//定义为平面模型（还有其他模型）</span></span><br><span class="line"><span class="function">pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; <span class="title">ransac</span><span class="params">(model_p)</span></span>;	</span><br><span class="line">ransac.setDistanceThreshold(<span class="number">.01</span>);	<span class="comment">//阈值设置</span></span><br><span class="line">ransac.computeModel();	<span class="comment">//计算模型</span></span><br><span class="line">ransac.getInliers(inliers);	<span class="comment">//获取内点</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Algorithm : RANSAC</span><br><span class="line">1) Initial: let A be a set of N feature correspondences</span><br><span class="line">2) repeat</span><br><span class="line">2.1) Randomly select a sample of s points from A</span><br><span class="line">2.2) Fit a model to these points</span><br><span class="line">2.3) Compute the distance of all other points to this model</span><br><span class="line">2.4) Construct the inlier set (i.e. count the number of points  whose distance from the model &lt; d)</span><br><span class="line">2.5) Store these inliers</span><br><span class="line">2.6) until maximum number of iterations reached</span><br><span class="line">3) The set with the maximum number of inliers is chosen as</span><br><span class="line">a solution to the problem</span><br><span class="line">4) Estimate the model using all the inliers</span><br></pre></td></tr></table></figure>

<h3 id="平面点云分割"><a href="#平面点云分割" class="headerlink" title="平面点云分割"></a>平面点云分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;	<span class="comment">//模型系数对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;	<span class="comment">//内点对象</span></span><br><span class="line">pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;	<span class="comment">// Create the segmentation object，点云分割对象</span></span><br><span class="line">seg.setOptimizeCoefficients(<span class="literal">true</span>);	<span class="comment">// Optional，可选项，设置是否优化系数</span></span><br><span class="line">seg.setModelType(pcl::SACMODEL_PLANE);	<span class="comment">// Mandatory，必选项，设置分割类型</span></span><br><span class="line">seg.setMethodType(pcl::SAC_RANSAC);	<span class="comment">// Mandatory，设置分割方法</span></span><br><span class="line">seg.setDistanceThreshold(<span class="number">0.01</span>);	<span class="comment">// Mandatory，设置距离阈值</span></span><br><span class="line">seg.setInputCloud(cloud);</span><br><span class="line">seg.segment(*inliers, *coefficients);	<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure>

<h3 id="圆柱体模型分割"><a href="#圆柱体模型分割" class="headerlink" title="圆柱体模型分割"></a>圆柱体模型分割</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seg.setOptimizeCoefficients(<span class="literal">true</span>);</span><br><span class="line">seg.setModelType(pcl::SACMODEL_CYLINDER);</span><br><span class="line">seg.setMethodType(pcl::SAC_RANSAC);</span><br><span class="line">seg.setNormalDistanceWeight(<span class="number">0.1</span>);</span><br><span class="line">seg.setMaxIterations(<span class="number">10000</span>);</span><br><span class="line">seg.setDistanceThreshold(<span class="number">0.05</span>);</span><br><span class="line">seg.setRadiusLimits(<span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">seg.setInputCloud(cloud_filtered2);</span><br><span class="line">seg.setInputNormals(cloud_normals2);</span><br><span class="line">seg.segment(*inliers_cylinder, *coefficients_cylinder);</span><br></pre></td></tr></table></figure>

<h3 id="欧式聚类提取"><a href="#欧式聚类提取" class="headerlink" title="欧式聚类提取"></a>欧式聚类提取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.setClusterTolerance(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.setMinClusterSize(<span class="number">100</span>);</span><br><span class="line">ec.setMaxClusterSize(<span class="number">25000</span>);</span><br><span class="line">ec.setSearchMethod(tree);	<span class="comment">//kd-tree</span></span><br><span class="line">ec.setInputCloud(cloud_filtered);</span><br><span class="line">ec.extract(cluster_indices);</span><br></pre></td></tr></table></figure>

<h3 id="区域生长分割"><a href="#区域生长分割" class="headerlink" title="区域生长分割"></a>区域生长分割</h3><ul>
<li><p>从曲率最小的点开始生长（初始种子点）</p>
</li>
<li><p>输出是一个聚类集合，每个聚类集合属于同一光滑表面的一部分</p>
</li>
<li><p>基本思想：</p>
<p>根据输入点的曲率值对点排序，曲率最小的点为初始种子点，该点所在的区域为最平滑区域，也就是从最平滑区域开始生长，减少分割区域的总数，提高效率。</p>
</li>
<li><p>核心：比较近邻点与种子点之间的两个指标</p>
<ul>
<li>法线夹角的比较：小于设定的阈值进入区域，即为同一类（满足此条件时进入下一步的判断）</li>
<li>曲率大小的比较：小于设定的阈值进入序列（这是为何进行排序的原因，形成一个种子序列，每完成一次比较，删除当前的种子点，使用序列中的下一个种子点继续进行比较，如此迭代）</li>
<li>还需设定一个最小点簇数和最大点簇数</li>
<li>种子序列为空时意味着算法完成了区域增长，从头开始进行重复上述过程</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::RegionGrowing&lt;pcl::PointXYZ, pcl::Normal&gt; reg;</span><br><span class="line">reg.setMinClusterSize(<span class="number">50</span>);</span><br><span class="line">reg.setMaxClusterSize(<span class="number">1000000</span>);</span><br><span class="line">reg.setSearchMethod(tree);</span><br><span class="line">reg.setNumberOfNeighbours(<span class="number">30</span>);</span><br><span class="line">reg.setInputCloud(cloud);</span><br><span class="line"><span class="comment">//reg.setIndices (indices);</span></span><br><span class="line">reg.setInputNormals(normals);</span><br><span class="line">reg.setSmoothnessThreshold(<span class="number">3.0</span> / <span class="number">180.0</span> * M_PI);	<span class="comment">// 平滑阈值</span></span><br><span class="line">reg.setCurvatureThreshold(<span class="number">1.0</span>);	<span class="comment">//曲率阈值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;pcl::PointIndices&gt; clusters;</span><br><span class="line">reg.extract(clusters);	<span class="comment">//执行分割</span></span><br></pre></td></tr></table></figure>

<h3 id="超体素点云分割（VCCS）"><a href="#超体素点云分割（VCCS）" class="headerlink" title="超体素点云分割（VCCS）"></a>超体素点云分割（VCCS）</h3><ul>
<li>空间八叉树结构 + k-mean 聚类的区域增长 直接对点云进行超体素分割</li>
<li>超体素特征：<ul>
<li>在3D空间中，均匀分布（可通过在点云空间中均匀设定种子达到）</li>
<li>除非在体素空间上相连，否则超体素不能跨越边界</li>
</ul>
</li>
<li>在空间分辨率为 $R_{seed}$ 的三维空间网格中，对均匀分布在空间中的种子点进行增长形成超体素。这里为提高搜索效率，只考虑以种子为中心的半径为 $R_{seed}$ 区域内的点。</li>
</ul>
<p><img src="F:%5CAFIGHT%5C%E7%AC%94%E8%AE%B0%5CPCL%5Cassets%5Cvoxel_segmentation.png" alt="超体素分割"></p>
<h2 id="论文：聚类与分割"><a href="#论文：聚类与分割" class="headerlink" title="论文：聚类与分割"></a>论文：聚类与分割</h2><ul>
<li>聚类（clustering）将数据集中的样本划分为不相交的子集，每个子集成为一个“簇（cluster）”    </li>
<li>聚类过程形成簇结构</li>
<li>簇标记（cluster label）</li>
</ul>
<h3 id="拟合简化的集合模型（平面模型）"><a href="#拟合简化的集合模型（平面模型）" class="headerlink" title="拟合简化的集合模型（平面模型）"></a>拟合简化的集合模型（平面模型）</h3><ul>
<li>不共线的三点确定一个平面，故先从点云 $\mathcal{P}$ 中随机选取不共线的三点 ${p_i,p_j,p_k}$ </li>
<li>根据选定的三个点计算平面模型系数（$ax+by+cz+d=0$）（可根据克莱姆法则计算，详见 <a href="https://en.wikipedia.org/wiki/Plane_(geometry)" target="_blank" rel="noopener">Plane (geometry) - Wikipedia</a>）</li>
<li>计算点云 $\mathcal{P}$ 中所有点 $p$ 到该平面模型的距离（$p_n \quad (a,b,c,d)$）</li>
<li>保存距离在指定阈值内的点 $p^* \in \mathcal{P}$，并计算其个数 </li>
</ul>
<p>上述的最后一步表示对模型的评分；每个点集 $p^<em>$ 都会被保存，且上述步骤会重复（迭代） $k$ 次。算法终止后，点的数量最多的点集（内点），就是对平面模型描述最好的点集（能最好的拟合平面模型）。对所有的点 $p^</em> \in \mathcal{P}$ ，平面模型系数用最小二乘估计。</p>
<p>上述过程就是找到内点集 $p^*$，拟合出平面或者估计出其2D边界多边形的简化过程，在实际应用中，还需增加额外的约束条件。</p>
<h3 id="基本聚类技术"><a href="#基本聚类技术" class="headerlink" title="基本聚类技术"></a>基本聚类技术</h3><ul>
<li><p>依赖于空间分解技术，基于给定的标准，寻找分块及边界，实现分类</p>
</li>
<li><p>评判标准：闵氏范数：曼哈顿距离（L1）、欧式距离（L2）</p>
</li>
<li><p>欧式聚类数据结构：八叉树（3D网格）</p>
<ul>
<li>优点：易于快速构建，适用于不同情况，如需要占用空间的体积表示、用不同结构估计叶节点中的数据等</li>
<li>缺点：3D网格只适用于空间等分的情况</li>
</ul>
</li>
</ul>
<p>对于聚类分块大小不一的情况，需要更复杂的算法（下述）。</p>
<p>实例：</p>
<ul>
<li>点聚类 $O_i = {p_i \in \mathcal{P}}$  与点聚类 $O_j = {p_j \in \mathcal{P}}$ 不同的条件是：</li>
</ul>
<p>$$<br>min||p_i-p_j||<em>2 \ge d</em>{th}<br>$$</p>
<p>式中，$d_{th}$ 是指定的阈值。</p>
<p>即：点集 $p_i \in \mathcal{P}$ 与点集 $p_j \in \mathcal{P}$ 之间的最小距离大于指定的阈值，则前者中的点属于聚类 $O_i$，后者属于聚类 $O_j$ 。</p>
<p>一个问题是，这个最小距离该如何估计？</p>
<ul>
<li><p>最小距离的估计：使用 kd-tree 进行最近邻查询</p>
</li>
<li><p>算法伪代码：</p>
<ul>
<li>输入点云 $\mathcal{P}$ ，创建 kd-tree 表示</li>
<li>设置簇 $C$ 的空列表，以及点集序列 $Q$ </li>
<li>对输入点云的每一个点 $p_i \in \mathcal{P}$ ，执行以下步骤<ul>
<li>将 $p_i$ 添加到当前序列 $Q$ </li>
<li>对添加到序列中的每个点 $p_i \in Q$：<ul>
<li>以3D空间中半径为 $r&lt;d_{th}$ 的球体搜索 $p_i$ 的近邻点（近邻点搜索半径 r），结果形成点集 $P_i^k$  （setRadiusSearch）</li>
<li>对每个近邻点 $p_i^k \in P_i^k$，若未被分类则将其添加到序列 $Q$ </li>
</ul>
</li>
<li>序列 $Q$ 中的所有点处理完后，将 $Q$ 添加到簇 $C$ 的序列（内点）并重置为空序列</li>
</ul>
</li>
<li>算法终止条件：点云中的所有点均被遍历，且已成为簇 $C$ 的列表的一部分</li>
</ul>
</li>
<li><p>聚类算法(cpp)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被分割出来的点云团（标号队列）</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line"><span class="comment">//欧式分割器</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">ec.setClusterTolerance(<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">ec.setMinClusterSize(<span class="number">100</span>);</span><br><span class="line">ec.setMaxClusterSize(<span class="number">25000</span>);</span><br><span class="line"><span class="comment">//搜索策略树</span></span><br><span class="line">ec.setSearchMethod(tree);</span><br><span class="line">ec.setInputCloud(cloud_filtered);</span><br><span class="line">ec.extract(cluster_indices);</span><br></pre></td></tr></table></figure>
<h3 id="边缘查询"><a href="#边缘查询" class="headerlink" title="边缘查询"></a>边缘查询</h3></li>
<li><p>表面曲率可用于点云分割：是对点附近采样点的几何近似估计，它们对确定那些具有极高曲率值的点很有用，这些点代表点云数据集 $\mathcal{P}$ 的几何边缘</p>
</li>
<li><p>2D 图像中边缘可用梯度定义，3D 中则是场景中几何形状变化剧烈的位置</p>
</li>
</ul>

          
            <br>
            
  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://hbroad.github.io/2022/07/17/point_cloud_pcl/>https://hbroad.github.io/2022/07/17/point_cloud_pcl/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  


          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2022-07-29T20:30:06+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2022年7月29日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/PCL/" rel="nofollow"><i class="fas fa-hashtag fas fa-tags" aria-hidden="true"></i><p>PCL</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Point-Cloud/" rel="nofollow"><i class="fas fa-hashtag fas fa-tags" aria-hidden="true"></i><p>Point Cloud</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E7%82%B9%E4%BA%91/" rel="nofollow"><i class="fas fa-hashtag fas fa-tags" aria-hidden="true"></i><p>点云</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://hbroad.github.io/2022/07/17/point_cloud_pcl/&title=点云+PCL学习笔记 - 南阳向北&summary=研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客
（注：部分图片未上传至图床，抽空补充）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://hbroad.github.io/2022/07/17/point_cloud_pcl/&title=点云+PCL学习笔记 - 南阳向北&summary=研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客
（注：部分图片未上传至图床，抽空补充）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://hbroad.github.io/2022/07/17/point_cloud_pcl/&title=点云+PCL学习笔记 - 南阳向北&summary=研究生阶段开始学习的一些笔记，存储在本地，为方便查看，现搬至博客
（注：部分图片未上传至图床，抽空补充）"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2022/07/17/digital_image_process/'>
              <h6><i class="fas fa-chevron-left" aria-hidden="true"></i> 上一页</h6>
                <p class='title'>数字图像处理</p>
                <!--
                <p class='content'>数字图像处理基础理论（待补充）


空间滤波空间相关与卷积
相关：图像上移动核的中心，求每个位置的乘积之和

只满足分配律


卷积：把相关运算的核旋转180°

满足交换律、结合律、分配律

...</p>
                -->
              </a>
            
            
              <a class='next' href='/2020/05/26/Graduate_2/'>
               <h6>下一页 <i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                <p class='title'>毕设：链片条复合模CAD系统使用须知</p>
                <!--
                <p class='content'>由于该系统只在 win10 系统环境下测试，未在其他环境下测试，不能保证可用性，现将已知的问题做一说明！

已知错误1：数据库引擎本系统采用 ACCESS 作为数据库，经测试（虚拟机测试），wi...</p>
                -->
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments blur">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-spinner fa-spin fa-fw"></i>
          </div>
        </section>
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true,
    tags: "ams",
    macros: {
      href: "{}"
    }
  },
  options: {
    ignoreHtmlClass: "tex2jax_ignore|dno",
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
};
</script>




  <script>
    window.subData = {
      title: '点云+PCL学习笔记',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger blur desktop">
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/avata.jpg'/>
      </div>
    
    
      <div class='text'>
        
          <h2>南  阳  向  北</h2>
        
        
          <p>Just  do  it!</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
        
          
            <a href="mailto:lhbmq@hnu.edu.cn"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://hbroad.github.io/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="tencent://message/?uin=1746469211&Site=&Menu=yes"
              class="social fab fa-qq flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/playlist?id=2455547327"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category blur desktop">
    
  <header>
    
      <a href='/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Commemorate/" href="/categories/Commemorate/"
            id="categoriesCommemorate"
            ><div class='name'>Commemorate</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/hexo/" href="/categories/hexo/"
            id="categorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%AF%95%E8%AE%BE/" href="/categories/%E6%AF%95%E8%AE%BE/"
            id="categoriesE6AF95E8AEBE"
            ><div class='name'>毕设</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%AC%94%E8%AE%B0/" href="/categories/%E7%AC%94%E8%AE%B0/"
            id="categoriesE7AC94E8AEB0"
            ><div class='name'>笔记</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud blur desktop mobile">
    
  <header>
    
      <a href='/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Commemorate/" style="font-size: 14px; color: #999">Commemorate</a> <a href="/tags/DIP/" style="font-size: 14px; color: #999">DIP</a> <a href="/tags/Interview/" style="font-size: 14px; color: #999">Interview</a> <a href="/tags/PCL/" style="font-size: 14px; color: #999">PCL</a> <a href="/tags/Point-Cloud/" style="font-size: 14px; color: #999">Point Cloud</a> <a href="/tags/git/" style="font-size: 14px; color: #999">git</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%80%83/" style="font-size: 14px; color: #999">华为机考</a> <a href="/tags/%E6%AF%95%E8%AE%BE/" style="font-size: 24px; color: #555">毕设</a> <a href="/tags/%E7%82%B9%E4%BA%91/" style="font-size: 14px; color: #999">点云</a>
    </div>
  </section>


  

  
    
    

<section class="widget qrcode blur desktop">
  
  <header>
    
      <i class="fab fa-weixin fa-fw fa-fw" aria-hidden="true"></i><span class='name'>微信公众号</span>
    
  </header>


  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/QR.jpg'
        ></div>
      
    
  </div>
</section>

  

  
    
    


  <section class="widget toc-wrapper blur desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#点云"><span class="toc-text">点云</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点云库"><span class="toc-text">点云库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PointT-类型"><span class="toc-text">PointT 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PointXYZ"><span class="toc-text">PointXYZ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-XYZI"><span class="toc-text">Point XYZI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PointXYZRGBA"><span class="toc-text">PointXYZRGBA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCD-文件"><span class="toc-text">PCD 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K-d-tree"><span class="toc-text">K-d tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理论"><span class="toc-text">理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种查询方式"><span class="toc-text">两种查询方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Octree-八叉树"><span class="toc-text">Octree(八叉树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点云连接"><span class="toc-text">点云连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#点连接"><span class="toc-text">点连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段连接"><span class="toc-text">字段连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点云滤波"><span class="toc-text">点云滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原因"><span class="toc-text">原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双边滤波"><span class="toc-text">双边滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直通滤波器"><span class="toc-text">直通滤波器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VoxelGrid（体素化网格）滤波器"><span class="toc-text">VoxelGrid（体素化网格）滤波器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数化模型投影点云"><span class="toc-text">参数化模型投影点云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从一个点云中提取一个子集"><span class="toc-text">从一个点云中提取一个子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RadiusOutlierRemoval-ConditionalRemoval-移除离群点"><span class="toc-text">RadiusOutlierRemoval &#x2F; ConditionalRemoval  移除离群点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RadiusOutlierRemoval"><span class="toc-text">RadiusOutlierRemoval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConditionalRemoval"><span class="toc-text">ConditionalRemoval</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CropHull-任意多边形内部点云提取"><span class="toc-text">CropHull 任意多边形内部点云提取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深度图像（Range-Depth-Images）"><span class="toc-text">深度图像（Range&#x2F;Depth Images）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从点云创建深度图像"><span class="toc-text">从点云创建深度图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从深度图像提取边界"><span class="toc-text">从深度图像提取边界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键点"><span class="toc-text">关键点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键概念及算法"><span class="toc-text">关键概念及算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NARF-关键点"><span class="toc-text">NARF 关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Harris关键点"><span class="toc-text">Harris关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCL-中的-keypoints"><span class="toc-text">PCL 中的 keypoints</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#深度图像提取-NARF-关键点"><span class="toc-text">深度图像提取 NARF 关键点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SIFT-关键点提取"><span class="toc-text">SIFT 关键点提取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Harris-关键点提取"><span class="toc-text">Harris 关键点提取</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特征描述与提取"><span class="toc-text">特征描述与提取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特征描述"><span class="toc-text">特征描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特征描述子"><span class="toc-text">特征描述子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理论-1"><span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#邻域的概念"><span class="toc-text">邻域的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特征提取"><span class="toc-text">特征提取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入点云的调用"><span class="toc-text">输入点云的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#估计点云的表面法线"><span class="toc-text">估计点云的表面法线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表面曲率"><span class="toc-text">表面曲率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#法线的定向问题"><span class="toc-text">法线的定向问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#点特征直方图（PFH）"><span class="toc-text">点特征直方图（PFH）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理论-2"><span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速点特征直方图（FPFH）"><span class="toc-text">快速点特征直方图（FPFH）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理论-3"><span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码-1"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点云配准"><span class="toc-text">点云配准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一对点云的配准（两两配准）"><span class="toc-text">一对点云的配准（两两配准）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对应估计"><span class="toc-text">对应估计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误对应关系的去除"><span class="toc-text">错误对应关系的去除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICP算法"><span class="toc-text">ICP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理论-4"><span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单ICP代码"><span class="toc-text">简单ICP代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#逐步匹配多幅点云"><span class="toc-text">逐步匹配多幅点云</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#交互式ICP"><span class="toc-text">交互式ICP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正态分布变换配准（NDT）"><span class="toc-text">正态分布变换配准（NDT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理论-5"><span class="toc-text">理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NDT-配准"><span class="toc-text">NDT 配准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码-2"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点云分割"><span class="toc-text">点云分割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#聚类分割算法"><span class="toc-text">聚类分割算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RANSAC"><span class="toc-text">RANSAC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#平面点云分割"><span class="toc-text">平面点云分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#圆柱体模型分割"><span class="toc-text">圆柱体模型分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧式聚类提取"><span class="toc-text">欧式聚类提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区域生长分割"><span class="toc-text">区域生长分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超体素点云分割（VCCS）"><span class="toc-text">超体素点云分割（VCCS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#论文：聚类与分割"><span class="toc-text">论文：聚类与分割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拟合简化的集合模型（平面模型）"><span class="toc-text">拟合简化的集合模型（平面模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本聚类技术"><span class="toc-text">基本聚类技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边缘查询"><span class="toc-text">边缘查询</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class='copyright'>
        <p>Copyright © 2018-2020  南阳向北</p>

        </div>
      
    

<script>setLoadingBarProgress(80);</script>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("04/02/2020 09:00:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

  </footer>



      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/HBRoad/imgonline/image/justin-lim-tloFnD-7EpI-unsplash.jpeg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/BBC19066-E176-47C2-9D22-48C81EE5DF6B.jpeg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/00E0F0ED-9F1C-407A-9AA6-545649D919F4.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('') {
          $('').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  








  
    
<script src="https://cdn.jsdelivr.net/gh/drew233/css/lvaline.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var guest_info = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var notify = 'true' == 'true';
  var verify = 'true' == 'true';
  var valine = new Valine();
  valine.init({
    el: '#valine_container',
    notify: notify,
    verify: verify,
    guest_info: guest_info,
    
    appId: "D08WOirJLYeYsVbBUOfdWPpf-gzGzoHsz",
    appKey: "fnC4nL5p8dhLXMMTpu8jXX8O",
    placeholder: "说点什么吧~",
    pageSize:'10',
    avatar:'identicon',
    lang:'zh-cn',
    visitor: 'true',
    highlight:'true'
  })
  </script>



  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>



<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = '复制成功';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = '复制失败';
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->

  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>






  <script>setLoadingBarProgress(100);</script>
</body>
</html>



<!--点击烟花爆炸效果-->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/fireworks.js"></script>


