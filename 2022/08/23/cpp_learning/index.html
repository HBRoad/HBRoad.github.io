<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>C++ 学习笔记 - 南阳向北</title>
  
    <meta name="keywords" content="Interview,Leetcode">
  
  
    <meta name="description" content="C++ 学习笔记上传（研）
原链接">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css">
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            南阳向北 <b><sup style='color:#3AA757'></sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  
                    <i class='fa fa-home fa-fw'></i>
                  
                  首页
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  
                    <i class='fas fa-folder-open fa-fw'></i>
                  
                  分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  
                    <i class='fas fa-tags fa-fw'></i>
                  
                  标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  
                    <i class='fas fa-archive fa-fw'></i>
                  
                  归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  
                    <i class='fas fa-link fa-fw'></i>
                  
                  友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  
                    <i class='fas fa-info-circle fa-fw'></i>
                  
                  关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="搜索" />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  
                    <i class='fa fa-home fa-fw'></i>
                  
                  首页
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  
                    <i class='fas fa-folder-open fa-fw'></i>
                  
                  分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  
                    <i class='fas fa-tags fa-fw'></i>
                  
                  标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  
                    <i class='fas fa-archive fa-fw'></i>
                  
                  归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  
                    <i class='fas fa-link fa-fw'></i>
                  
                  友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  
                    <i class='fas fa-info-circle fa-fw'></i>
                  
                  关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>




  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box blur article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2022/08/23/cpp_learning/">
        C++ 学习笔记
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
<div class='new-meta-item author'>
  <a href="https://hbroad.github.io/" rel="nofollow">
    <img src="https://s2.loli.net/2022/08/22/P8GFieU49zC3jRl.jpg">
    <p>南阳向北</p>
  </a>
</div>

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2022年8月23日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/cpp/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>cpp</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
          
            
  
    <div class="new-meta-item browse valine">
      <a class='notlink'>
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id="/2022/08/23/cpp_learning/" class="leancloud_visitors" data-flag-title="C++ 学习笔记">
        <p>
          <span class="leancloud-visitors-count">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
        </span>
      </a>
    </div>
  


          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <p>C++ 学习笔记上传（研）</p>
<p><a href="https://mqroad.notion.site/C-0fbc6625c13149f482d984f82a02b70e" target="_blank" rel="noopener">原链接</a></p>
<a id="more"></a>

<h1 id="小概念集锦"><a href="#小概念集锦" class="headerlink" title="小概念集锦"></a>小概念集锦</h1><ul>
<li>外存储器的容量大， 大部分可移动，便于在不同计算机之间进行信息交流。其只有被读入内存储器后才可被CPU读取，即CPU不能直接访问外存储器</li>
<li>进程是可以并发执行的程序的执行过程</li>
<li>循环队列是顺序存储结构</li>
<li>拷贝构造函数：<ul>
<li>程序中需要新建立一个对象，并用另一个对象去初始化</li>
<li>函数的参数为类的对象</li>
<li>函数的返回值是类的对象</li>
</ul>
</li>
<li>类外同名的变量赋值，不能改变类内的静态变量值</li>
<li>程序中的 typename 都可以替换为 class</li>
<li>NULL 与 nullptr<ul>
<li>NULL 在 C 中表示 void<em>，即指向任意类型的指针，C 中会完成隐式类型转换，但 C++ 中是强制类型转换，导致 void</em> 不能隐式转换为其他类型</li>
<li>起初 C++ 用 0 代替空指针，但其在函数重载时发生二义性，后续直接用 nullptr，而 NULL 表示 0</li>
</ul>
</li>
</ul>
<h1 id="CPP小概念"><a href="#CPP小概念" class="headerlink" title="CPP小概念"></a>CPP小概念</h1><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><h3 id="结构化程序设计框架"><a href="#结构化程序设计框架" class="headerlink" title="结构化程序设计框架"></a>结构化程序设计框架</h3><ul>
<li>函数是程序的基本单元</li>
</ul>
<h3 id="面向对象程序设计框架"><a href="#面向对象程序设计框架" class="headerlink" title="面向对象程序设计框架"></a>面向对象程序设计框架</h3><ul>
<li>类是程序的基本组成单元</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>单精度不能超过 7 位有效数字，双精度不能超过 15 位</li>
<li>一个字符串常量在存储时在给定的字符序列后再加一个空字符（‘\0’），而字符常量不加</li>
<li>任一种进制的整数，可添加后缀字母 U 或 L，表示无符号整型（usigned int）和长整型（long int），也可同时添加两者，无排序要求，如：55L，100LU</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>变量的存储类属性</p>
<ul>
<li>auto（自动变量）：默认存储类别，占用空间的分配和释放由系统自动完成</li>
<li>register（寄存器变量）：寄存器虽然快，但其数量有限，当其不够时，仍然按照 auto 处理</li>
<li>static（静态变量）：任何静态变量的生存期将延续到整个程序的终止；编译器为其分配的空间在整个程序运行期间不会释放；若未赋初值，系统自动赋值为 0</li>
<li>extern（外部变量）：声明为外部变量后，该变量可被其他文件引用，可避免为其重复分配内存</li>
</ul>
</li>
<li><p>typedef 类型</p>
<ul>
<li>给现有的数据类型起一个别名</li>
</ul>
</li>
<li><p>符号常量</p>
<ul>
<li><p>概念：用 const 修饰的标识符</p>
</li>
<li><p>原则：先声明，后使用</p>
</li>
<li><p>声明：const int i = 1；</p>
<p>用 const 声明的常量只能被读取，故在声明时需初始化，且其值在程序中无法改变</p>
</li>
<li><p>可用预处理命令 #define 定义符号常量：#define PI 3.14</p>
</li>
</ul>
</li>
</ul>
<h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>单目</li>
<li>双目</li>
<li>三目：?:（C++只此一个）</li>
</ul>
<h3 id="运算类型"><a href="#运算类型" class="headerlink" title="运算类型"></a>运算类型</h3><ul>
<li>赋值运算：可一次性给多变量赋值：x=y=z=1; 其从右往左依次赋值，即 z=1，接着将 z=1 赋给 y，得 y=z=1，最后得 x=y=z=1</li>
<li>自增运算<ul>
<li>a++：先参与运算，运算后再 +1</li>
<li>++a：先 +1，再参与到运算中</li>
</ul>
</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>！</li>
<li>&amp;&amp;</li>
<li>||</li>
</ul>
<p>优先级依次递减</p>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul>
<li><p>条件运算符：?:</p>
<p>  <code>a&gt;b ? 1:0；若a&gt;b，返回1 ，否则0</code></p>
</li>
<li><p>逗号运算符：返回最后表达式的值</p>
<p>  <code>(a = 3 * 5, a * 4), a + 5; // a = 15，表达式结果为 20</code></p>
</li>
<li><p>sizeof运算符：取得任何变量和类型在内存中占用的字节数</p>
<p>  <code>sizeof(int);  //4</code></p>
</li>
</ul>
<p><code>#include &lt;cmath&gt; // C++ 数学函数</code></p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针和地址"><a href="#指针和地址" class="headerlink" title="指针和地址"></a>指针和地址</h2><ul>
<li><p>指针：变量的地址就是该变量的指针</p>
</li>
<li><p>指针变量：存放地址的变量</p>
</li>
<li><p>指针运算</p>
<ul>
<li>指针变量和整型量加减 = 指向下一元素</li>
<li>相同的指针变量类型之间可以赋值</li>
<li>两个指向同一类型的指针变量进行逻辑运算，实质是地址的比较</li>
<li>两指向同一数组成员的指针变量可减运算，结果为两指针之间相差的元素个数</li>
</ul>
</li>
<li><p>指针和数组</p>
<ul>
<li><p>数组名即为该数组首元素的地址，即指针</p>
</li>
<li><p>数组名是常量指针，而指针是指针变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首元素的地址给指针</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line">p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取首元素</span></span><br><span class="line">a[<span class="number">0</span>];</span><br><span class="line">*p;</span><br><span class="line">*a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串常量可以赋给指针变量，会将前者第一个字符的指针给后者</p>
</li>
</ul>
</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>引用即为变量起别名</li>
<li>既然是起别名，在定义时就要初始化，即指定给谁起别名</li>
<li>既然是别名，那么对引用的操作就是对变量本身的操作</li>
<li>引用就是两个变量使用的是同一块内存单元</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;j = i; <span class="comment">// 给 i 起别名为 j</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&amp;只是标识符，非取地址符</li>
<li>一旦引用被初始化，不可更改为另一变量的引用</li>
</ul>
<h2 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h2><ul>
<li>静态存储分配是在编译阶段确定变量占据的空间，而部分程序只有在运行时才能确定，即为动态内存分配</li>
<li>new 申请，delete 释放</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对某种数据类型分配空间，赋初值10</span></span><br><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组</span></span><br><span class="line"><span class="keyword">int</span> *b;</span><br><span class="line">b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">// 元素个数可以是变量，这是与一般的数组声明最大的区别</span></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态内存分配是在堆内存或自由存储区，数量有限，当耗尽时再申请会返回空指针 NULL，故在分配空间后，可做判断如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//正常结束程序</span></span><br></pre></td></tr></table></figure>

<ul>
<li>动态分配后的内存需显式的释放，由 new 申请，则必须由 delete 释放</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数及声明"><a href="#函数及声明" class="headerlink" title="函数及声明"></a>函数及声明</h2><ul>
<li>函数不能嵌套，即函数内部不能定义其他函数</li>
<li>函数原型声明的两种形式（注意是声明不是定义）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//或省略形参变量名</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="参数的传递方式"><a href="#参数的传递方式" class="headerlink" title="参数的传递方式"></a>参数的传递方式</h3><ul>
<li>值传递<ul>
<li>实参不变，将实参复制一份给形参</li>
<li>虽不会改变实参的值，但当传递参数的大型的类对象时，空间和时间开销过大</li>
</ul>
</li>
<li>传地址<ul>
<li>传地址之后将改变实参的值</li>
</ul>
</li>
<li>引用传递<ul>
<li>隐式的传地址</li>
<li>参数声明为引用时，调用时编译器将自动传递实参的地址给被调用函数</li>
</ul>
</li>
</ul>
<p>一般情况下，当传递大型的数组或类对象时，采取传递指针的方式，因为任意类型的指针大小是一样的（32位下为 4 字节，64 位下为 8 字节），相比复制传递的方式，空间开销小很多。</p>
<p><em>建议传地址时使用引用代替指针</em></p>
<ul>
<li>指针和引用的区别<ul>
<li>定义和性质的不同<ul>
<li>指针是地址，引用只是变量的别名，与原变量共用一块地址</li>
</ul>
</li>
<li>函数传参时的区别<ul>
<li>指针传参可以直接操作实参的地址，对实参进行改变</li>
<li>引用传参是直接传递实参本身，节约时间空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li><p>默认参数</p>
<ul>
<li><p>缺省的实参只能用于替换函数调用中缺少的尾部实参，即函数调用是按位置依次赋值的，不是按照参数的类型匹配的，即实参的类型要和形参的顺序一致</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">default_n</span><span class="params">(<span class="keyword">int</span> a = <span class="number">1</span>, <span class="keyword">int</span> b = <span class="number">2</span>, <span class="keyword">char</span> c = <span class="string">' '</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">default_n(, , '&lt;&lt;');  // 该调用并不等价于 default_n(1, 2, '&lt;&lt;');</span><br><span class="line">defaulr_n('&lt;&lt;');      //同上</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>参数个数/参数类型不同</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul>
<li>为取代预处理宏函数</li>
<li>inline 关键字放在函数定义中的函数类型之前</li>
<li>内联函数和宏函数<ul>
<li>宏函数由预处理器进行替换，而内联函数由编译器实现，是真正的函数</li>
<li>但内联函数调用时像宏一样展开，执行效率更高</li>
</ul>
</li>
<li>内联函数和普通函数<ul>
<li>普通函数的调用将控制转移给被调用函数，从而调用有一定的时间和空间开销</li>
<li>内联函数直接将被调用函数复制一份到调用的地方，效率更高</li>
<li>但该优点也是缺点，即内联函数的函数体不能太大，结构也不能太复杂，否则编译器将放弃内联方式转而采用普通方式调用</li>
</ul>
</li>
</ul>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>数据成员：属性<ul>
<li>类中数据成员的类型任意，包括另一个类的对象</li>
<li>虽自身类的对象不能作为数据成员（因为类还没定义完成，该类型没法分配存储空间），但自身类的指针或引用可以（任意类型的指针大小是确定的）</li>
<li>类体内不能对数据初始化，初始化由构建函数完成</li>
</ul>
</li>
<li>成员函数：行为<ul>
<li>在类内定义的成员函数皆为内联函数</li>
<li>类外也可定义函数，通过<code>类名+作用域运算符::</code>来表明函数属于哪个类</li>
<li>成员函数可重载，参数可设置默认值</li>
</ul>
</li>
<li>类成员的访问控制<ul>
<li>私有成员只能被自己所属类中的成员函数及友元函数访问</li>
</ul>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li><p>对象的定义</p>
<ul>
<li><p>可定义一般类对象、对象数组、对象指针、对象引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c2</span>[10];</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> *<span class="title">c3</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> &amp;<span class="title">c4</span> = <span class="title">c1</span>;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对象的成员及其访问</p>
<ul>
<li><p><code>.</code> 运算符：访问一般对象的成员（数据成员或成员函数），也可访问对象引用或对象数组的成员，方法一致</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">			<span class="keyword">int</span> hour;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">settime</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Time T1;</span><br><span class="line">T1.hour;</span><br><span class="line">T1.settime();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-&gt;</code>运算符：访问一个指针变量所指向的对象成员，等价于 <code>(*对象指针名).成员</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time T1;</span><br><span class="line">Time* T2 = T1;</span><br><span class="line"><span class="comment">//对象指针变量 T2 的成员访问</span></span><br><span class="line">T2 -&gt; hour;</span><br><span class="line">T2 -&gt; settime();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">(*T2).hour;</span><br><span class="line">(*T2).settime;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><ul>
<li>构造函数的作用：用于新建对象的初始化工作</li>
<li>析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等</li>
</ul>
<p>每当创建对象，需要对该对象完成初始化时，则需要定义自己的构造函数；而对象撤销，需要自己添加清理工作代码时，则需要定义自己的析构函数</p>
<ul>
<li>共同特点：<ul>
<li>类体中说明的两种成员函数</li>
<li>没有返回值，void也不行</li>
<li>构造函数可带参数，可重载；析构函数都不能</li>
</ul>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>函数名与类名相同</li>
<li>函数体可在体内/体外</li>
<li>一般声明为公有函数</li>
<li>在定义对象时被系统直接调用，用户不能直接调用构造函数</li>
<li>构造函数初始化对象：<code>类名 对象名 (参数表)</code>，如：class c1 (1,2,3);</li>
<li>运算符 new + 构造函数： <code>class * c2 = new class ()</code></li>
<li>定义对象数组时只能调用没有参数或所有参数都有默认值的参数</li>
<li>定义对象指针时不会调用构造函数，因为指针变量还未实例化</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li>~ 类名</li>
<li>函数体可在体内/外</li>
<li>在对象生存期即将结束时由系统自动调用，之后对象消失，内存空间被释放</li>
<li>一个类只能定义一个析构函数</li>
<li>delete 运算符和析构函数一起使用</li>
</ul>
<h3 id="默认构造-析构函数"><a href="#默认构造-析构函数" class="headerlink" title="默认构造/析构函数"></a>默认构造/析构函数</h3><ul>
<li>不带参数</li>
<li>函数与类名相同</li>
<li>参数为空或所有参数带默认值</li>
<li>用户未定义时系统自动建立</li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul>
<li>只有一个参数，类型是本类对象的引用</li>
<li>每个类必须要有，若没有则编译系统自动生成一个公有的</li>
<li>被调用的 3 种情况：<ul>
<li>用类的已知的对象去初始化另一对象</li>
<li>对象作为函数的实参传递给函数形参</li>
<li>对象作为函数的返回值</li>
</ul>
</li>
<li>形式： <code>Copy_ConsFun_Name(const class_name &amp;obj_name)</code></li>
</ul>
<h2 id="自由存储对象"><a href="#自由存储对象" class="headerlink" title="自由存储对象"></a>自由存储对象</h2><ul>
<li>由堆运算符 new 和 delete 建立和删除</li>
<li>new 创建单个对象：根据参数调用构造函数</li>
<li>new 创建对象数组：调用默认构造函数</li>
<li>delete 删除对象：调用析构函数</li>
<li>new 或 delete 是显式的调用构造函数，调用的顺序取决于 new 和 delete 的顺序，析构的顺序不一定与构造的顺序相反，但对象数组中各个元素的构造和析构仍然是相反的</li>
<li>delete 删除对象和对象数组时各调用一次析构函数</li>
</ul>
<h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ul>
<li><p>对象创建后，对象的每个成员函数都含有一个系统自动生成的隐含指针，用于保存该对象的地址</p>
</li>
<li><p>“指向本对象的指针”</p>
</li>
<li><p>成员函数所属的对象指针，指向类对象的地址</p>
</li>
<li><p>成员函数可以通过该指针知道自己属于哪个类</p>
</li>
<li><p><code>this -&gt; 成员变量</code></p>
</li>
<li><p>可用于区分形参变量和对象成员变量（形参变量和成员变量标识符一致时更加明显）</p>
</li>
<li><p>一般不写，系统默认设置，但要注意：</p>
<ul>
<li><p>只能在类的成员函数中使用，指向该函数被调用的对象，一般用于返回当前对象本身</p>
</li>
<li><p>静态成员函数没有 this 指针</p>
<p>  编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p>
</li>
<li><p>友元函数没有 this 指针 （因为友元函数不属于任何类）</p>
</li>
</ul>
</li>
</ul>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>类中的非静态成员，每个类对象都有一个拷贝（副本），相互独立；而静态成员便是解决同一类的不同对象之间的数据和函数共享问题的，即不管该类拥有多少对象，其静态成员都只有一个副本，该副本被所有对象共享。</p>
<ul>
<li>表示整个类范围的信息，以 <code>static</code>声明</li>
</ul>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><ul>
<li><p>静态数据成员的值对所有对象都是一样的，但每个对象可以更新其值</p>
</li>
<li><p>必须初始化，格式为：<code>数据类型 类名 :: 静态数据成员名 = 值</code></p>
<ul>
<li>初始化在类体外进行，且前面不加 static，以免与一般静态变量或对象相混淆</li>
<li>初始化时使用作用域运算符来表明所属的类，因静态数据成员是类的成员</li>
<li>初始化时不加该成员的访问权限控制符</li>
</ul>
</li>
<li><p>若静态数据成员为 <code>public</code>，可在程序中引用该成员：<code>类名 :: 静态数据成员</code>，此时若未初始化，编译系统会自动赋值 0</p>
<p>  也即：静态成员变量既可以通过对象名引用（<code>obj.static_memb</code>），也可通过类名引用（<code>class_name::static_memb</code>）</p>
</li>
</ul>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul>
<li>用于访问类中保护或私有成员的公有接口</li>
<li>以 <code>static</code> 声明，属于类，由所有对象共享</li>
<li>可在类内/外定义，类外定义时不加 static</li>
<li>对对象的访问：<ul>
<li>可直接访问类中说明的静态成员，但不能是非静态成员</li>
<li>非静态成员需通过参数传递的方式得到对象后再通过对象访问</li>
</ul>
</li>
<li>main() 函数中对静态函数的调用：<code>类名 :: 静态成员函数名 (参数可选)</code>或 <code>对象名.静态成员函数名</code></li>
<li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）</li>
</ul>
<h2 id="常成员"><a href="#常成员" class="headerlink" title="常成员"></a>常成员</h2><p>对于既需要共享，又不希望其值被改变的数据，可定义为常成员进行保护，保证其在整个程序运行期间不可改变，用 <code>const</code>修饰符定义</p>
<h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><p>使用 const 关键字修饰的对象</p>
<ul>
<li><code>类名 const 对象名</code> 或 <code>const 类名 对象名</code></li>
<li>常对象必须有初值，且不能被更新</li>
<li>常对象只能调用类中的常成员函数</li>
</ul>
<h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p>使用 const 关键字说明的成员函数</p>
<ul>
<li><code>返回类型 成员函数名 (参数) const</code></li>
<li>函数实现部分也要带有 const 关键字：<code>type class_name :: memb_fun(argu) const</code></li>
<li>不能更新对象的数据成员，也不能调用类中没有用 const 修饰的函数</li>
<li>const 关键字可用于对重载函数的区分</li>
</ul>
<h3 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h3><p>使用 const 关键字修饰的数据成员</p>
<ul>
<li><p><code>const type name</code></p>
</li>
<li><p>定义必须出现在类体中</p>
</li>
<li><p>必须通过构造函数的成员初始化列表进行初始化（唯一的方法），且不能被更新，格式：</p>
<p>  <code>类名 :: 类名(形参) ：常数据成员 (赋值)</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须使用初始化列表来初始化 m_len</span></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul>
<li>解决类外访问类的私有和保护成员</li>
<li>友元机制允许一个类授权其他的函数访问其非公有成员，减小开销，提高程序运行效率</li>
<li>友元声明<ul>
<li>关键字： <code>friend</code></li>
<li>只能在类的声明中出现</li>
</ul>
</li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul>
<li>在类体中以 friend 声明，独立于当前类的外部函数</li>
<li>可以是不属于任何类的非成员函数，也可以是其他类的成员函数，可访问该类中的私有成员</li>
<li><code>friend 数据类型 友元函数名 (形参)</code></li>
<li>在类定义时声明，一般在类外定义友元函数（类中声明，类外定义）</li>
<li>普通友元函数（即类的非成员函数）引用类的私有成员时，需通过对象，即<code>对象名.</code>的形式，因普通友元函数不是类的成员函数</li>
<li>一个函数可被多个类声明为友元函数</li>
</ul>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>类B为A的友元类，则：</p>
<ul>
<li>B 中的所有成员函数都是 A 的友元函数，可访问 A 的所有成员</li>
<li><code>friend 类名</code><ul>
<li>友元类不具有对称性：B是A的友元类，但A不是B的</li>
<li>友元类不具有传递性：A是B的友元类，B是C的友元类，不代表A是C的友元类</li>
</ul>
</li>
</ul>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><ul>
<li><p>数组元素是对象，且每个元素是同一个类的对象</p>
</li>
<li><p>定义：<code>类名 数组名 (元素个数可选)</code></p>
</li>
<li><p>访问：<code>数组名[下标可选].成员名</code></p>
</li>
<li><p>创建类的对象数组的条件：</p>
<ul>
<li>没有给出构造函数，调用系统默认构造函数</li>
<li>有一个不带参数的构造函数</li>
<li>一个构造函数的参数全是默认参数</li>
</ul>
</li>
<li><p>对象数组的生命周期结束时，默认给每个元素调用一次析构函数，也可通过 delete 强制调用,，构造同理</p>
</li>
<li><p>若定义对象数组时没有使用初始化列表进行初始化，则会为每个对象调用默认构造函数</p>
<p>  若初始化项少于数组中的对象，则对剩余的对象调用默认构造函数</p>
</li>
</ul>
<h3 id="成员对象"><a href="#成员对象" class="headerlink" title="成员对象"></a>成员对象</h3><ul>
<li><p>一个类的成员是另一个类的对象</p>
</li>
<li><p><code>class c { c1 obj1; c2 obj2; };</code></p>
</li>
<li><p>类中有成员对象时，该类的构造函数要调用这些成员对象所在类的构造函数，并采用初始化列表进行初始化</p>
<p>  构造函数的调用顺序取决于类中的说明顺序，析构的调用相反</p>
</li>
<li><p>只能调用成员对象的公有函数或变量</p>
</li>
</ul>
<h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>继承：在现有类的基础上创建新类，新类得到已有类已经具备的特性</li>
<li>派生：从已有类（基类）产生一个子类（派生类）</li>
<li>单继承、多继承</li>
<li>基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样</li>
<li>派生类将基类的所有成员全部接收过来，除了构造和析构函数</li>
<li>派生类可对基类初始化</li>
</ul>
<h2 id="派生类对基类的访问"><a href="#派生类对基类的访问" class="headerlink" title="派生类对基类的访问"></a>派生类对基类的访问</h2><table>
<thead>
<tr>
<th>继承方式/基类成员</th>
<th>public成员</th>
<th>protected成员</th>
<th>private成员</th>
</tr>
</thead>
<tbody><tr>
<td>public继承</td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td>protected继承</td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td>private继承</td>
<td>private</td>
<td>private</td>
<td>不可见</td>
</tr>
<tr>
<td>- 基类中的私有成员在派生类中不可访问，只能在基类访问</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>- 派生类中可访问基类中中的公有和保护成员</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="派生类的析构和构造函数"><a href="#派生类的析构和构造函数" class="headerlink" title="派生类的析构和构造函数"></a>派生类的析构和构造函数</h2><p>基类的构造和析构不能被继承，故派生类的构造函数须调用基类的构造函数以初始化，同理，对派生对象的清理也需要新的析构函数</p>
<h3 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h3><ul>
<li><p>问题：</p>
<ul>
<li>考虑新增成员的初始化</li>
<li>考虑基类成员的初始化</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>执行派生类的构造函数时，调用基类的构造，注意是调用基类的构造函数，不是声明</li>
</ul>
</li>
<li><p>执行顺序：</p>
<ul>
<li><p>调用基类的构造函数：按照定义派生类时基类的声明顺序进行，而与派生类构造函数的成员初始化列表给出的顺序无关</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class son_class:public dad_class1(x), dad_class2(x1) &#123;&#125;</span><br><span class="line"><span class="comment">//调用构造函数时先调用基类 dad_class1 的构造，接着调用 dad_class2 的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用成员对象的构造函数：派生类中有多个成员对象时，按照派生类中声明成员对象的顺序进行，同样与初始化列表无关</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class son_class:public dad_class1(x), dad_class2(x1) </span><br><span class="line">&#123;</span><br><span class="line">		dad_class2 c2;</span><br><span class="line">		dad_class1 c1;</span><br><span class="line">		…</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用构造函数时先调用基类 dad_class2 的构造，接着调用 dad_class1 的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行派生类构造函数体中的内容，完成对派生类的初始化</p>
<p>  派生类中既有对基类的声明，又有成员对象时，先调用基类的构造函数，再调用成员对象所属类的构造函数，最后调用派生类自己的构造</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son_class</span>:</span><span class="function"><span class="keyword">public</span> <span class="title">dad_class1</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		dad_class2 c2;</span><br><span class="line">		son_class(……) &#123;……&#125;</span><br><span class="line">		…</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先调用基类 dad_class1 的构造，接着调用 dad_class2 的，最后调用自身的</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h3 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h3><p>调用过程与构造相反</p>
<ul>
<li>对派生类普通成员清理</li>
<li>调用成员对象的析构，对派生类新增的成员对象清理</li>
<li>调用基类析构，对基类清理</li>
</ul>
<h2 id="多继承与虚基类"><a href="#多继承与虚基类" class="headerlink" title="多继承与虚基类"></a>多继承与虚基类</h2><h3 id="多继承中的二义性"><a href="#多继承中的二义性" class="headerlink" title="多继承中的二义性"></a>多继承中的二义性</h3><ul>
<li><p>一个派生类有两个或多个基类</p>
</li>
<li><p>在派生类中对基类的访问应该是唯一的</p>
</li>
<li><p>在多继承情况下，派生类对基类中某个成员的访问出现不唯一的情况，即产生二义性</p>
</li>
<li><p>产生二义性问题的两种情况：</p>
<ul>
<li><p>多继承中，有两个或两个以上的基类存在同名成员，采用<code>对象名.函数名</code>直接调用时无法判断属于哪个类</p>
<p>  解决方法有二：</p>
<ul>
<li><p>通过作用域运算符进行限定，指定是哪个基类的函数</p>
<p>  <code>对象名.基类名 :: 成员函数名()</code></p>
</li>
<li><p>在派生类中定义同名成员以屏蔽基类中二义性的成员，但此时仍然可通过 :: 指定访问</p>
</li>
</ul>
</li>
<li><p>一个派生类从多个基类派生，且这些基类有一个共同的基类时，派生类访问该共同基类的成员时产生二义性</p>
<p>  解决方法同上，但更优的方法是虚基类</p>
</li>
</ul>
</li>
</ul>
<h3 id="虚基类（虚继承）"><a href="#虚基类（虚继承）" class="headerlink" title="虚基类（虚继承）"></a>虚基类（虚继承）</h3><p><a href="http://c.biancheng.net/view/2280.html" target="_blank" rel="noopener">http://c.biancheng.net/view/2280.html</a></p>
<p>解决二义性问题，将共同基类定义为虚基类，方式如下</p>
<ul>
<li><p>定义</p>
<ul>
<li><code>class c_name : virtual 继承方式 基类名</code></li>
<li><code>class c_name : 继承方式 virtual 基类名</code></li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li><p>虚基类是在声明派生类时，指定继承方式时声明的</p>
</li>
<li><p>虚基类派生的类，只产生一个虚基类子对象</p>
<p>   （可以理解为在派生类中只保留了一份共同基类的成员，这样就不会产生歧义了）</p>
</li>
<li><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</li>
</ul>
</li>
<li><p>虚基类的构造函数</p>
<ul>
<li><p>虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</p>
</li>
<li><p>虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。</p>
</li>
<li><p>直接或间接继承虚基类的派生类，其构造函数的成员初始化列表中，都列出了对虚基类构造函数的调用，而在最后的派生类中，除了对直接基类的初始化，还要对虚基类初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a): m_a(a)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b): A(a), m_b(b)&#123; &#125;    <span class="comment">// B 的直接继承中调用了A 的构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接派生类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::C(<span class="keyword">int</span> a, <span class="keyword">int</span> c): A(a), m_c(c)&#123; &#125; <span class="comment">// C 的直接继承中调用了A 的构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//间接派生类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// D 的间接继承中调用了直接继承 B、C 的构造，以及间接继承 A 的构造</span></span><br><span class="line">D::D(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d): A(a), B(<span class="number">90</span>, b), C(<span class="number">100</span>, c), m_d(d)&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_a="</span>&lt;&lt;m_a&lt;&lt;<span class="string">", m_b="</span>&lt;&lt;m_b&lt;&lt;<span class="string">", m_c="</span>&lt;&lt;m_c&lt;&lt;<span class="string">", m_d="</span>&lt;&lt;m_d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    b.display();</span><br><span class="line">   </span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    c.display();</span><br><span class="line"></span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>)</span></span>;</span><br><span class="line">    d.display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="子类型关系（向上转型）"><a href="#子类型关系（向上转型）" class="headerlink" title="子类型关系（向上转型）"></a>子类型关系（向上转型）</h2><p>类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。</p>
<h2 id="虚函数与多态性"><a href="#虚函数与多态性" class="headerlink" title="虚函数与多态性"></a>虚函数与多态性</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>同一接口为不同的对象服务</li>
<li>分类<ul>
<li>编译时的多态：通过函数重载和模板实现，在编译阶段确定调用哪个函数，实现机制称为“静态绑定”</li>
<li>运行时的多态：只有在运行时才知道是哪个函数，“动态绑定”</li>
</ul>
</li>
<li>多态是通过虚函数实现的</li>
</ul>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul>
<li>指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数</li>
<li>通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数</li>
<li>而虚函数允许在派生类中定义与基类同名的函数，且可用基类的指针或引用访问基/派生类中的同名函数</li>
<li>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong></li>
<li>C++中虚函数的唯一用处就是构成多态，有了多态，只需要一个指针变量就可以调用所有派生类的虚函数</li>
<li>虚函数可以是另一个类的友元函数，但不能是静态成员函数、内联函数、构造函数</li>
<li>派生类中可以重新定义从基类继承下来的虚函数，也可以不需要。但在派生类中重新定义虚函数时，函数名、形参表、返回值类型必须保持不变</li>
<li>换句话说，虚函数使得派生类可以更改（其实是覆盖）基类中的同名函数</li>
<li>若基类声明了虚函数，则在派生类中凡与该函数同名，同类型，同参数个数的均为虚函数</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul>
<li>一般情况下，清理派生类的对象时先调用派生类的析构，再调用基类的析构</li>
<li>但若用 new 建立了临时对象，如果基类中有析构，且定义了一个指向基类的指针变量，那么程序在用带指针参数的 delete 撤销对象时，系统只调用基类的析构</li>
<li>故若要调用派生类的析构函数，就要将其声明为虚函数，即虚析构函数</li>
</ul>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><ul>
<li>在基类中给派生类预留一个虚函数的名，但基类不知道拿这个函数干嘛，留给派生类补充函数体</li>
<li>即基类无法确定一个虚函数的具体操作方式或者内容，只能靠派生类提供该虚函数的具体实现方式，即为纯虚函数</li>
<li><code>virtual 类型 函数名 (参数表) = 0；</code><ul>
<li>纯虚函数没有函数体</li>
<li>“=0” 并不是返回值为 0，只是告诉编译系统这是纯虚函数</li>
<li>是声明语句，所以句尾要有分号</li>
<li>将一函数声明为纯虚函数，仍可以有函数体，即纯虚函数的标志是 “=0”，而不是有无函数体</li>
<li>纯虚函数不得声明为内联函数</li>
</ul>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li><p>拥有纯虚函数的类称为抽象类（一般为基类）</p>
</li>
<li><p>抽象类不能用来定义对象</p>
</li>
<li><p>若抽象类的派生类没有重新定义来自基类的纯虚函数，则该函数在派生类中亦是纯虚函数，派生类也为抽象类，而派生类可将重定义纯虚函数的任务转交给自己的派生类</p>
</li>
<li><p>几点说明：</p>
<ul>
<li><p>只要基类包含一个或多个纯虚函数，就是抽象类，抽象类不能用于定义对象</p>
</li>
<li><p>在类的层次结构中，顶层或上面几层皆可为抽象基类，抽象基类是各类的共性</p>
</li>
<li><p>抽象基类是本类族的公共接口</p>
</li>
<li><p>抽象类可以实现多态，道理同虚函数</p>
</li>
<li><p>只有类中的虚函数才能声明为纯虚函数，普通的函数不能</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶层函数不能被声明为纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//compile error</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//普通成员函数不能被声明为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//compile error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>运算符重载是多态的体现</p>
</li>
<li><p>C++ 把重载的运算符看做特殊的函数，称为运算符函数，故运算符重载就是函数重载的一种</p>
</li>
<li><p>运算符重载是对现有运算符的重载，不能利用重载创造新的运算符</p>
</li>
<li><p>不能重载的运算符：<code>.</code> 、<code>·*</code> 、<code>-&gt;*</code> 、<code>::</code> 、<code>?:</code></p>
</li>
<li><p>不得为运算符函数设置默认值，故在调用时不能省略实参</p>
</li>
<li><p>任何运算符在作为成员函数重载时不得重载为静态成员函数，new 和 delete 除外</p>
</li>
<li><p>只能作为成员函数重载：<code>=</code>、<code>[]</code>、<code>()</code>、<code>-&gt;</code>以及<code>所有的类型转换运算符</code></p>
</li>
<li><p>关键字：<code>operator</code></p>
<p>  <code>返回类型 operator 运算符 (参数表) {}</code> </p>
<p>  返回类型不能是 void</p>
</li>
<li><p>运算符重载函数也是函数，满足函数的一切性质</p>
</li>
</ul>
<h2 id="运算符重载的两种形式"><a href="#运算符重载的两种形式" class="headerlink" title="运算符重载的两种形式"></a>运算符重载的两种形式</h2><p>成员函数形式和友元函数形式，都可以访问类的私有成员</p>
<h3 id="成员函数形式"><a href="#成员函数形式" class="headerlink" title="成员函数形式"></a>成员函数形式</h3><ul>
<li><p>定义：<code>返回类型 operator 运算符 (参数表)</code></p>
<p>  可将 <code>operator 运算符</code>部分看做是一个函数名</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现运算符重载</span></span><br><span class="line"><span class="built_in">complex</span> <span class="built_in">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">complex</span> B;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="built_in">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.display();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果 6.7 + 9.5i</span></span><br></pre></td></tr></table></figure>

<p>  执行 <code>c3 = c1 + c2</code>时，编译器检测到 <code>+</code>左边是一个 complex 的对象，故会调用成员函数 <code>operator +()</code>，将该式转换为 <code>c3 = c1.operator(c2)</code>，即对象 c3 调用重载的成员函数，该函数的参数是 c2。</p>
<p>  所以说，重载为成员函数时，由于具有隐含的 this 指针，一般参数只有一个。对双目运算符如上述的 + 运算符，一般参数是第二个操作数；而对单目运算符，参数表为空。</p>
</li>
</ul>
<h3 id="友元函数形式"><a href="#友元函数形式" class="headerlink" title="友元函数形式"></a>友元函数形式</h3><ul>
<li><p>定义：<code>friend 返回类型 operator 运算符 (参数表)</code></p>
</li>
<li><p>注意：</p>
<p>  友元函数没有 this 指针，故对双目运算符，友元函数有两个参数；对单目运算符有一个参数</p>
</li>
</ul>
<h2 id="典型运算符的重载"><a href="#典型运算符的重载" class="headerlink" title="典型运算符的重载"></a>典型运算符的重载</h2><h3 id="重载负运算符-“-”"><a href="#重载负运算符-“-”" class="headerlink" title="重载负运算符 “-”"></a>重载负运算符 “-”</h3><ul>
<li>一元运算符，作为成员函数重载时，参数为空，存在默认的 this 指针；以友元函数重载时，参数为1个。</li>
</ul>
<h3 id="重载加运算符-“-”"><a href="#重载加运算符-“-”" class="headerlink" title="重载加运算符 “+”"></a>重载加运算符 “+”</h3><ul>
<li>同前例子</li>
</ul>
<h3 id="重载自增-减运算符-“-”"><a href="#重载自增-减运算符-“-”" class="headerlink" title="重载自增/减运算符 “++/- - ”"></a>重载自增/减运算符 “++/- - ”</h3><ul>
<li>作为类的成员函数重载<ul>
<li>前缀运算：<code>返回类型 operator ++ ()</code></li>
<li>后缀运算：<code>返回类型 operator ++ (int)</code></li>
</ul>
</li>
<li>作为类的友元函数重载<ul>
<li>前缀运算：<code>friend 返回类型 operator ++ (参数 1)</code></li>
<li>后缀运算：<code>friend 返回类型 operator ++ (参数 1，int)</code></li>
</ul>
</li>
<li>为了与前缀运算符区别，c++ 编译器设定在后缀运算符重载函数中增加一个实际并不使用的整形参数，以示区别</li>
<li>以自增为例，前缀自增是先增1，用增 1 后的值参与运算，故返回的是增1之后运算的值，内部也增 1；后缀自增是先参与运算，运算完毕之后再增 1，故返回的是对象本身，内部依然增 1</li>
</ul>
<h3 id="重载类型转换运算符-“long”"><a href="#重载类型转换运算符-“long”" class="headerlink" title="重载类型转换运算符 “long”"></a>重载类型转换运算符 “long”</h3><ul>
<li>必须作为成员函数重载</li>
<li>类型名就是返回值类型，故不需要声明返回值类型</li>
<li><code>operator long（参数表）</code></li>
</ul>
<h3 id="重载赋值运算符-“-”"><a href="#重载赋值运算符-“-”" class="headerlink" title="重载赋值运算符 “=”"></a>重载赋值运算符 “=”</h3><ul>
<li>必须作为成员函数重载</li>
<li>类中出现指向动态空间的指针时重载</li>
<li>注意：<ul>
<li>返回值应声明为引用，但在函数体中通常使用<code>return * this；</code>语句返回</li>
<li>若参数被声明为指针或引用，一般应加上 const 修饰</li>
<li>一般拷贝函数也会同时出现</li>
</ul>
</li>
</ul>
<h3 id="重载复合赋值运算符-“-”"><a href="#重载复合赋值运算符-“-”" class="headerlink" title="重载复合赋值运算符 “+/-/*=”"></a>重载复合赋值运算符 “+/-/*=”</h3><ul>
<li>两种重载形式均可</li>
<li>当重载为友元函数时，需要两个参数，且第一个参数应声明为引用</li>
</ul>
<h3 id="重载关系运算符-“-gt-、-lt-、-”"><a href="#重载关系运算符-“-gt-、-lt-、-”" class="headerlink" title="重载关系运算符 “&gt;、&lt;、==”"></a>重载关系运算符 “&gt;、&lt;、==”</h3><ul>
<li>返回逻辑值，即返回类型为 <code>bool</code></li>
</ul>
<h3 id="重载下标访问运算符-“-”"><a href="#重载下标访问运算符-“-”" class="headerlink" title="重载下标访问运算符 “[]”"></a>重载下标访问运算符 “[]”</h3><ul>
<li>只能重载为成员函数</li>
<li><code>返回类型 operator [] (下标形参，一般为整型)</code></li>
</ul>
<h3 id="重载-C-流运算符-“-gt-gt-lt-lt-”"><a href="#重载-C-流运算符-“-gt-gt-lt-lt-”" class="headerlink" title="重载 C++ 流运算符 “&gt;&gt; / &lt;&lt;”"></a>重载 C++ 流运算符 “&gt;&gt; / &lt;&lt;”</h3><ul>
<li>只能重载为非成员函数，一般为友元函数</li>
<li><code>friend istream&amp; operator &gt;&gt; (istream&amp;, 类名&amp;)</code></li>
<li><code>friend ostream&amp; operator &lt;&lt; (ostream&amp;, 类名&amp;)</code></li>
<li>之所以返回 i/ostream 类对象的引用，是为了能够连续读取/输出</li>
</ul>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>一系列相关函数的模型或样板，这些函数的源代码相同，只是针对不同的数据类型</p>
</li>
<li><p>对函数模板而言，数据类型是其参数，故是一种参数化 类型 的函数</p>
</li>
<li><p>格式：<code>template &lt;模板形参表声明&gt; 函数声明</code></p>
<ul>
<li><p>模板形参表声明可以是多个，中间用逗号隔开</p>
</li>
<li><p>模板形参的形式：</p>
<ul>
<li><p>typename 参数名</p>
</li>
<li><p>class 参数名</p>
</li>
<li><p>类型修饰 参数名</p>
<p><em>关键字 typename 与 class 完全等价，两者声明的参数为 虚拟类型参数，即指定这个参数名是一种类型，而这种类型只有实例化时才知道是什么类型，其即可做函数的返回值，也可做形参的类型，还可做函数体内变量的类型；而 类型修饰 声明的参数为常规参数，形式上与普通函数的声明相同。</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//此处可换行，但不能有分号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模板函数的实例化"><a href="#模板函数的实例化" class="headerlink" title="模板函数的实例化"></a>模板函数的实例化</h3><ul>
<li>函数模板中声明的函数称为 模板函数</li>
<li>编译系统生成函数模板的某个具体版本的过程称为函数模板的实例化</li>
</ul>
<h3 id="模板实参的省略"><a href="#模板实参的省略" class="headerlink" title="模板实参的省略"></a>模板实参的省略</h3><ul>
<li><p>模板函数的调用格式：<code>模板函数名 &lt;模板实参表&gt;（函数实参表）</code></p>
</li>
<li><p>调用一个模板函数时，编译系统需要足够的信息判断每个虚拟类型参数对应的实际参数，主要从 模板实参表 和 函数实参表 中获取信息，且后者优先于前者，如从后者获取的信息足够判断虚拟类型的具体参数，而它们恰好是参数表中最后的若干参数，则模板实参中的那几个参数可以省略，若都被省略，则 &lt;&gt; 为空，也可省略</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如上例，调用可分几种：</span></span><br><span class="line">Swap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&amp;a, &amp;b);</span><br><span class="line">Swap&lt;<span class="keyword">int</span>&gt;(&amp;a, &amp;b);</span><br><span class="line">Swap&lt;&gt;(&amp;a, &amp;b);</span><br><span class="line">Swap(&amp;a, &amp;b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能省略模板实参的情况：</p>
<ul>
<li><p>从模板实参表获得的信息有矛盾</p>
<p>  若一个函数实参中获得的是 int，另一个则是 float，显然 T 不能同时为 int 和 float，为此，可将其中一个显示的给出 T 的类型</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">1</span>;</span><br><span class="line">Swap&lt;<span class="keyword">int</span>&gt;(&amp;a, &amp;b);   <span class="comment">//将 float 强制转为 int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要获得特定的返回值，而不管参数的类型如何</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">1</span>;</span><br><span class="line">Swap&lt;<span class="keyword">double</span>&gt;(&amp;a, &amp;b);   <span class="comment">//将 int，float 强制转为 double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟参数类型没有出现在模板函数的形参表中</p>
</li>
<li><p>函数模板含有常规实参</p>
</li>
</ul>
</li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>类模板就一系列相关类的模板，只是类型不同</p>
</li>
<li><p>模板类的声明：<code>template &lt;模板参数表声明&gt; 类声明</code></p>
</li>
<li><p>类模板的成员函数可在类体内或类体外定义，在类外定义模板类（需要带上模板头）：</p>
<p>  <code>template&lt;typename 类型参数1 , typename 类型参数2 , …&gt;</code></p>
<p>  <code>返回值类型 类名&lt;类型参数1 , 类型参数2, ...&gt;::函数名(形参列表) {函数体}</code></p>
</li>
</ul>
<h3 id="类模板的实例化"><a href="#类模板的实例化" class="headerlink" title="类模板的实例化"></a>类模板的实例化</h3><ul>
<li><p>两种方式：</p>
<p>  <code>类名 &lt;模板实参表&gt; 对象名</code></p>
<p>  <code>类名 &lt;模板实参名&gt; 对象名(构造函数实参表)</code></p>
</li>
<li><p>注意：</p>
<ul>
<li><p>使用类模板定义对象时，实参不能省略，即类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;int, int&gt; p1(10, 20);</span><br><span class="line">Point&lt;int, float&gt; p2(10, 15.5);</span><br><span class="line">Point&lt;float, char*&gt; p3(12.4, "东经180度");</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了对象变量，我们也可以使用对象指针的方式来实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p1 = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt;(<span class="number">10.6</span>, <span class="number">109.3</span>);</span><br><span class="line">Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; *p = <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;(<span class="string">"东经180度"</span>, <span class="string">"北纬210度"</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，赋值号两边都要指明具体的数据类型，且要保持一致。下面的写法是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值号两边的数据类型不一致</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>, <span class="keyword">int</span>&gt;(<span class="number">10.6</span>, <span class="number">109</span>);</span><br><span class="line"><span class="comment">//赋值号右边没有指明数据类型</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">float</span>&gt; *p = <span class="keyword">new</span> Point(<span class="number">10.6</span>, <span class="number">109</span>);</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h1 id="C-流"><a href="#C-流" class="headerlink" title="C++流"></a>C++流</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1</span>;  <span class="comment">// 应在声明时初始化，否则变量的值不确定且无法修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt;<span class="comment">//指向常量的指针，即指针 *pt 是指向 const int 的，即 *pt 是 const的，不能修改</span></span><br></pre></td></tr></table></figure>
          
            <br>
            
  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://hbroad.github.io/2022/08/23/cpp_learning/>https://hbroad.github.io/2022/08/23/cpp_learning/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  


          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2022-08-23T15:51:07+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2022年8月23日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Interview/" rel="nofollow"><i class="fas fa-hashtag fas fa-tags" aria-hidden="true"></i><p>Interview</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Leetcode/" rel="nofollow"><i class="fas fa-hashtag fas fa-tags" aria-hidden="true"></i><p>Leetcode</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://hbroad.github.io/2022/08/23/cpp_learning/&title=C++ 学习笔记 - 南阳向北&summary=C++ 学习笔记上传（研）
原链接"
          
          >
          
            <img src="https://s2.loli.net/2022/08/02/HQ2vMiA6BOg8Vum.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://hbroad.github.io/2022/08/23/cpp_learning/&title=C++ 学习笔记 - 南阳向北&summary=C++ 学习笔记上传（研）
原链接"
          
          >
          
            <img src="https://s2.loli.net/2022/08/02/Jrfx7ZhuA6LmIOT.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://hbroad.github.io/2022/08/23/cpp_learning/&title=C++ 学习笔记 - 南阳向北&summary=C++ 学习笔记上传（研）
原链接"
          
          >
          
            <img src="https://s2.loli.net/2022/08/02/1bqKo4MSClXNeGY.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2022/09/08/null/'>
              <h6><i class="fas fa-chevron-left" aria-hidden="true"></i> 上一页</h6>
                <p class='title'>面试问题</p>
                <!--
                <p class='content'>
  738c9bd1e95cfc46d04fc0fe0d97f4378cdaa402e7d3c1dc37a22ccbba15c36e7412fbc5113ce4c62a626823664f9d...</p>
                -->
              </a>
            
            
              <a class='next' href='/2022/08/20/Leetcode_group/'>
               <h6>下一页 <i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                <p class='title'>力扣专题刷题</p>
                <!--
                <p class='content'>发现菜的不行，按专题来吧，学一点是一点
参考
参考




	
    
	




链表203. 移除链表元素
思路一：若头结点已经是要删除的值，直接让头结点指向下一个即为删除头结点；若头结点...</p>
                -->
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments blur">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-spinner fa-spin fa-fw"></i>
          </div>
        </section>
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'C++ 学习笔记',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  
    
    


  <section class="widget toc-wrapper blur desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本框架"><span class="toc-text">基本框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构化程序设计框架"><span class="toc-text">结构化程序设计框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象程序设计框架"><span class="toc-text">面向对象程序设计框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符和表达式"><span class="toc-text">运算符和表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算类型"><span class="toc-text">运算类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑运算符"><span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他运算符"><span class="toc-text">其他运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针和地址"><span class="toc-text">指针和地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态存储分配"><span class="toc-text">动态存储分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数及声明"><span class="toc-text">函数及声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数"><span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数的传递方式"><span class="toc-text">参数的传递方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认参数"><span class="toc-text">默认参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数重载"><span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内联函数"><span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归函数"><span class="toc-text">递归函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数和析构函数"><span class="toc-text">构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#析构函数"><span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认构造-析构函数"><span class="toc-text">默认构造&#x2F;析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拷贝构造函数"><span class="toc-text">拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自由存储对象"><span class="toc-text">自由存储对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-指针"><span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员"><span class="toc-text">静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态数据成员"><span class="toc-text">静态数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态成员函数"><span class="toc-text">静态成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常成员"><span class="toc-text">常成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常对象"><span class="toc-text">常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常成员函数"><span class="toc-text">常成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常数据成员"><span class="toc-text">常数据成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#友元"><span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#友元函数"><span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#友元类"><span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象数组"><span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员对象"><span class="toc-text">成员对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#派生类对基类的访问"><span class="toc-text">派生类对基类的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#派生类的析构和构造函数"><span class="toc-text">派生类的析构和构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#派生类的构造函数"><span class="toc-text">派生类的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#派生类的析构函数"><span class="toc-text">派生类的析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多继承与虚基类"><span class="toc-text">多继承与虚基类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多继承中的二义性"><span class="toc-text">多继承中的二义性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚基类（虚继承）"><span class="toc-text">虚基类（虚继承）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子类型关系（向上转型）"><span class="toc-text">子类型关系（向上转型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数与多态性"><span class="toc-text">虚函数与多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚函数"><span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚析构函数"><span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纯虚函数"><span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-text">抽象类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符重载的两种形式"><span class="toc-text">运算符重载的两种形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员函数形式"><span class="toc-text">成员函数形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#友元函数形式"><span class="toc-text">友元函数形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#典型运算符的重载"><span class="toc-text">典型运算符的重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重载负运算符-“-”"><span class="toc-text">重载负运算符 “-”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载加运算符-“-”"><span class="toc-text">重载加运算符 “+”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载自增-减运算符-“-”"><span class="toc-text">重载自增&#x2F;减运算符 “++&#x2F;- - ”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载类型转换运算符-“long”"><span class="toc-text">重载类型转换运算符 “long”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载赋值运算符-“-”"><span class="toc-text">重载赋值运算符 “&#x3D;”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载复合赋值运算符-“-”"><span class="toc-text">重载复合赋值运算符 “+&#x2F;-&#x2F;*&#x3D;”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载关系运算符-“-gt-、-lt-、-”"><span class="toc-text">重载关系运算符 “&gt;、&lt;、&#x3D;&#x3D;”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载下标访问运算符-“-”"><span class="toc-text">重载下标访问运算符 “[]”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载-C-流运算符-“-gt-gt-lt-lt-”"><span class="toc-text">重载 C++ 流运算符 “&gt;&gt; &#x2F; &lt;&lt;”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数模板"><span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-1"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板函数的实例化"><span class="toc-text">模板函数的实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板实参的省略"><span class="toc-text">模板实参的省略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类模板"><span class="toc-text">类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-2"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类模板的实例化"><span class="toc-text">类模板的实例化</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class='copyright'>
        <p>Copyright © 2018-2022  南阳向北</p>

        </div>
      
    

<script>setLoadingBarProgress(80);</script>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("04/02/2020 09:00:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

  </footer>



      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://s2.loli.net/2022/08/02/vifdEe4nStHyhgu.jpg", "https://s2.loli.net/2022/08/02/nEDS58psx7A3RcB.jpg", "https://s2.loli.net/2022/08/02/go8X2k4P5tjKqws.jpg", "https://s2.loli.net/2022/08/22/LBbUTqHAXFEZGjD.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('') {
          $('').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  








  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4.0/js/valine.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var guest_info = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var notify = 'true' == 'true';
  var verify = 'true' == 'true';
  var valine = new Valine();
  valine.init({
    el: '#valine_container',
    notify: notify,
    verify: verify,
    guest_info: guest_info,
    
    appId: "D08WOirJLYeYsVbBUOfdWPpf-gzGzoHsz",
    appKey: "fnC4nL5p8dhLXMMTpu8jXX8O",
    placeholder: "说点什么吧~",
    pageSize:'10',
    avatar:'identicon',
    lang:'zh-cn',
    visitor: 'true',
    highlight:'true'
  })
  </script>



  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>



<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-clipboard-check');
        let $span = $($btn.find('span'));
        $span[0].innerText = '复制成功';
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-exclamation-triangle');
        let $span = $($btn.find('span'));
        $span[0].innerText = '复制失败';
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->

  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>






  <script>setLoadingBarProgress(100);</script>
</body>
</html>



<!--点击烟花爆炸效果-->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/fireworks.js"></script>


